{"meta":{"version":1,"warehouse":"5.0.1"},"models":{"Asset":[{"_id":"source/img/avatar.jpg","path":"img/avatar.jpg","modified":0,"renderable":0},{"_id":"source/assets/0b6fcecfe53184140bb4005dd0eab836-20230127151311-0gha64i.png","path":"assets/0b6fcecfe53184140bb4005dd0eab836-20230127151311-0gha64i.png","modified":0,"renderable":0},{"_id":"source/assets/20200809110444386-20230127151311-z1qxdzv.png","path":"assets/20200809110444386-20230127151311-z1qxdzv.png","modified":0,"renderable":0},{"_id":"source/assets/20210417191156743-20230127151311-j5awou3.png","path":"assets/20210417191156743-20230127151311-j5awou3.png","modified":0,"renderable":0},{"_id":"source/assets/20210417191226786-20230127151312-304h995.png","path":"assets/20210417191226786-20230127151312-304h995.png","modified":0,"renderable":0},{"_id":"source/assets/20210417191245920-20230127151311-nf45pi0.png","path":"assets/20210417191245920-20230127151311-nf45pi0.png","modified":0,"renderable":0},{"_id":"source/assets/20210417191255980-20230127151311-y6imh9a.png","path":"assets/20210417191255980-20230127151311-y6imh9a.png","modified":0,"renderable":0},{"_id":"source/assets/20210417191320754-20230127151312-g8jrdjp.png","path":"assets/20210417191320754-20230127151312-g8jrdjp.png","modified":0,"renderable":0},{"_id":"source/assets/2d694736eb7778a548cdcb8189d6e226-20230127151312-riapszh.png","path":"assets/2d694736eb7778a548cdcb8189d6e226-20230127151312-riapszh.png","modified":0,"renderable":0},{"_id":"source/assets/327dcba48317d39b2cd0ee081d4e3fdc-20230127151312-4qigjlr.png","path":"assets/327dcba48317d39b2cd0ee081d4e3fdc-20230127151312-4qigjlr.png","modified":0,"renderable":0},{"_id":"source/assets/2edff9c3d5cb698abb0e62d720ad704b-20230127151311-dy2b8hg.png","path":"assets/2edff9c3d5cb698abb0e62d720ad704b-20230127151311-dy2b8hg.png","modified":0,"renderable":0},{"_id":"source/assets/39c6a500cefa6e29150c1295d3e152d1-20230127151312-5z7fqgr.png","path":"assets/39c6a500cefa6e29150c1295d3e152d1-20230127151312-5z7fqgr.png","modified":0,"renderable":0},{"_id":"source/assets/3fdc14e6be9f37b481abe633ac866a26-20230127151312-ko7ta8u.png","path":"assets/3fdc14e6be9f37b481abe633ac866a26-20230127151312-ko7ta8u.png","modified":0,"renderable":0},{"_id":"source/assets/640-20230404215050-p95bson.png","path":"assets/640-20230404215050-p95bson.png","modified":0,"renderable":0},{"_id":"source/assets/410360b70936d286a4df4ab2c11f28ad-20230127151311-j96gr8d.png","path":"assets/410360b70936d286a4df4ab2c11f28ad-20230127151311-j96gr8d.png","modified":0,"renderable":0},{"_id":"source/assets/640-20230404215050-qd8x4fd.png","path":"assets/640-20230404215050-qd8x4fd.png","modified":0,"renderable":0},{"_id":"source/assets/640-20230404215051-hnbb7ug.png","path":"assets/640-20230404215051-hnbb7ug.png","modified":0,"renderable":0},{"_id":"source/assets/640-20230404215051-lu967n5.png","path":"assets/640-20230404215051-lu967n5.png","modified":0,"renderable":0},{"_id":"source/assets/640-20230404215051-nrxnl0j.png","path":"assets/640-20230404215051-nrxnl0j.png","modified":0,"renderable":0},{"_id":"source/assets/640-20230404215051-pdghyi7.png","path":"assets/640-20230404215051-pdghyi7.png","modified":0,"renderable":0},{"_id":"source/assets/640-20230404215051-rx0ju25.png","path":"assets/640-20230404215051-rx0ju25.png","modified":0,"renderable":0},{"_id":"source/assets/6c916769e7f2450157bce49ea9438c10-20230127151312-x7ufhrj.png","path":"assets/6c916769e7f2450157bce49ea9438c10-20230127151312-x7ufhrj.png","modified":0,"renderable":0},{"_id":"source/assets/704e3015827edff48d6c84777aa28006-20230127151312-jonjh5w.png","path":"assets/704e3015827edff48d6c84777aa28006-20230127151312-jonjh5w.png","modified":0,"renderable":0},{"_id":"source/assets/83f121c9c340db46f955badf876220b2-20230127151311-j2wtijc.png","path":"assets/83f121c9c340db46f955badf876220b2-20230127151311-j2wtijc.png","modified":0,"renderable":0},{"_id":"source/assets/a0d8c504b2c17abbfb8eb40bc4d86d79-20230127151311-0azix9f.png","path":"assets/a0d8c504b2c17abbfb8eb40bc4d86d79-20230127151311-0azix9f.png","modified":0,"renderable":0},{"_id":"source/assets/b5e5ca9c35421192e7f02864c4fb30bb-20230127151311-iwgg2ln.png","path":"assets/b5e5ca9c35421192e7f02864c4fb30bb-20230127151311-iwgg2ln.png","modified":0,"renderable":0},{"_id":"source/assets/c2d8c43d5c018eb584586ad5857fbbf4-20230127151311-ml2ddae.png","path":"assets/c2d8c43d5c018eb584586ad5857fbbf4-20230127151311-ml2ddae.png","modified":0,"renderable":0},{"_id":"source/assets/da55da191ca558b60531e3a6b6ce5267-20230127151311-wiqzfgo.png","path":"assets/da55da191ca558b60531e3a6b6ce5267-20230127151311-wiqzfgo.png","modified":0,"renderable":0},{"_id":"source/assets/dubbo-export-20221214214601-bb3rzp9.jpg","path":"assets/dubbo-export-20221214214601-bb3rzp9.jpg","modified":0,"renderable":0},{"_id":"source/assets/dubbo-extension-20221214214601-56szafs.jpg","path":"assets/dubbo-extension-20221214214601-56szafs.jpg","modified":0,"renderable":0},{"_id":"source/assets/dubbo-framework-20221214214602-6xcgoty.jpg","path":"assets/dubbo-framework-20221214214602-6xcgoty.jpg","modified":0,"renderable":0},{"_id":"source/assets/dubbo-modules-20221214214601-dcxfz3a.jpg","path":"assets/dubbo-modules-20221214214601-dcxfz3a.jpg","modified":0,"renderable":0},{"_id":"source/assets/dubbo-refer-20221214214601-20gbi94.jpg","path":"assets/dubbo-refer-20221214214601-20gbi94.jpg","modified":0,"renderable":0},{"_id":"source/assets/dubbo-relation-20221214214601-7hb77fv.jpg","path":"assets/dubbo-relation-20221214214601-7hb77fv.jpg","modified":0,"renderable":0},{"_id":"source/assets/f0b471f40aa64279914a3acbd6e2913b-20230127151312-khh42zb.png","path":"assets/f0b471f40aa64279914a3acbd6e2913b-20230127151312-khh42zb.png","modified":0,"renderable":0},{"_id":"source/assets/ff614ca7c83414c712848a25b23e6a91-20230127151312-slrk125.png","path":"assets/ff614ca7c83414c712848a25b23e6a91-20230127151312-slrk125.png","modified":0,"renderable":0},{"_id":"source/assets/image-20221212232058-z1xl373.png","path":"assets/image-20221212232058-z1xl373.png","modified":0,"renderable":0},{"_id":"source/assets/image-20230218230318-0kn4aj5.png","path":"assets/image-20230218230318-0kn4aj5.png","modified":0,"renderable":0},{"_id":"source/assets/image-20230218230318-31t0a0v.png","path":"assets/image-20230218230318-31t0a0v.png","modified":0,"renderable":0},{"_id":"source/assets/image-20230218230318-cknlz85.png","path":"assets/image-20230218230318-cknlz85.png","modified":0,"renderable":0},{"_id":"source/assets/image-20230218230318-i0g5orx.png","path":"assets/image-20230218230318-i0g5orx.png","modified":0,"renderable":0},{"_id":"source/assets/image-20230218230318-nedvesv.png","path":"assets/image-20230218230318-nedvesv.png","modified":0,"renderable":0},{"_id":"source/assets/image-20230218230318-t4i4y3l.png","path":"assets/image-20230218230318-t4i4y3l.png","modified":0,"renderable":0},{"_id":"source/assets/image-20230218230318-t9tvsgp.png","path":"assets/image-20230218230318-t9tvsgp.png","modified":0,"renderable":0},{"_id":"source/assets/image-20230218230318-w95qpr6.png","path":"assets/image-20230218230318-w95qpr6.png","modified":0,"renderable":0},{"_id":"source/assets/image-20230218230318-ybffha3.png","path":"assets/image-20230218230318-ybffha3.png","modified":0,"renderable":0},{"_id":"source/assets/image-20230218230318-ye9g47h.png","path":"assets/image-20230218230318-ye9g47h.png","modified":0,"renderable":0},{"_id":"source/assets/image-20230218230318-ypt4n3t.png","path":"assets/image-20230218230318-ypt4n3t.png","modified":0,"renderable":0},{"_id":"source/assets/image-20230423172026-j99710c.png","path":"assets/image-20230423172026-j99710c.png","modified":0,"renderable":0},{"_id":"source/assets/image-20230424141422-t5zbclo.png","path":"assets/image-20230424141422-t5zbclo.png","modified":0,"renderable":0},{"_id":"source/assets/image-20230503214900-rmo1ydd.png","path":"assets/image-20230503214900-rmo1ydd.png","modified":0,"renderable":0},{"_id":"source/assets/image-20230505215709-q6pir67.png","path":"assets/image-20230505215709-q6pir67.png","modified":0,"renderable":0},{"_id":"source/assets/image-20230519215732-zz9jpqo.png","path":"assets/image-20230519215732-zz9jpqo.png","modified":0,"renderable":0},{"_id":"source/assets/image-20230527140729-waan312.png","path":"assets/image-20230527140729-waan312.png","modified":0,"renderable":0},{"_id":"source/assets/image-20230527154724-v674duu.png","path":"assets/image-20230527154724-v674duu.png","modified":0,"renderable":0},{"_id":"source/assets/image-20230619222624-l98xjgi.png","path":"assets/image-20230619222624-l98xjgi.png","modified":0,"renderable":0},{"_id":"source/assets/image-20230619222818-5btwdt3.png","path":"assets/image-20230619222818-5btwdt3.png","modified":0,"renderable":0},{"_id":"source/assets/image-20231117162020-0zic8ee.png","path":"assets/image-20231117162020-0zic8ee.png","modified":0,"renderable":0},{"_id":"source/assets/image-20231117162030-ue9pyz9.png","path":"assets/image-20231117162030-ue9pyz9.png","modified":0,"renderable":0},{"_id":"source/assets/image-20231117164621-qjdsktw.png","path":"assets/image-20231117164621-qjdsktw.png","modified":0,"renderable":0},{"_id":"source/assets/image-20231119124040-5kytmcz.png","path":"assets/image-20231119124040-5kytmcz.png","modified":0,"renderable":0},{"_id":"source/assets/image-20231119124137-6apottn.png","path":"assets/image-20231119124137-6apottn.png","modified":0,"renderable":0},{"_id":"source/assets/image-20231119124615-vxa33dm.png","path":"assets/image-20231119124615-vxa33dm.png","modified":0,"renderable":0},{"_id":"source/assets/image-20231119154230-3g5nidd.png","path":"assets/image-20231119154230-3g5nidd.png","modified":0,"renderable":0},{"_id":"source/assets/image-20231119154304-hwfdw8h.jpeg","path":"assets/image-20231119154304-hwfdw8h.jpeg","modified":0,"renderable":0},{"_id":"source/assets/image-20231126145713-0pou43f.png","path":"assets/image-20231126145713-0pou43f.png","modified":0,"renderable":0},{"_id":"source/assets/image-20231126155909-4zbslm1.png","path":"assets/image-20231126155909-4zbslm1.png","modified":0,"renderable":0},{"_id":"source/assets/image-20231126161709-b35di3t.png","path":"assets/image-20231126161709-b35di3t.png","modified":0,"renderable":0},{"_id":"source/assets/image-20231202123415-e2licnx.jpeg","path":"assets/image-20231202123415-e2licnx.jpeg","modified":0,"renderable":0},{"_id":"source/assets/net-img-0002-20230327194009-43b76u4.png","path":"assets/net-img-0002-20230327194009-43b76u4.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-0004-20230327194009-xusl7vj.png","path":"assets/net-img-0004-20230327194009-xusl7vj.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-0005-20230327194009-2m11zb7.png","path":"assets/net-img-0005-20230327194009-2m11zb7.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-0006-20230327194009-rdpidiy.png","path":"assets/net-img-0006-20230327194009-rdpidiy.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-0008-20230327194010-vj80p08.jpg","path":"assets/net-img-0008-20230327194010-vj80p08.jpg","modified":0,"renderable":0},{"_id":"source/assets/net-img-0009-20230327193706-lo1au43.jpg","path":"assets/net-img-0009-20230327193706-lo1au43.jpg","modified":0,"renderable":0},{"_id":"source/assets/net-img-0007-20230327194009-obwi5jv.png","path":"assets/net-img-0007-20230327194009-obwi5jv.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-0010-20230327194235-781jk47.png","path":"assets/net-img-0010-20230327194235-781jk47.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-0011-20230327194235-6us5fo3.png","path":"assets/net-img-0011-20230327194235-6us5fo3.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-0012-20230327194235-dpf6how.png","path":"assets/net-img-0012-20230327194235-dpf6how.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1582873055902-03de6700-dcb1-42a8-927e-af658b90b6b0-20230330213228-vjyh5tl.png","path":"assets/net-img-1582873055902-03de6700-dcb1-42a8-927e-af658b90b6b0-20230330213228-vjyh5tl.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1582873072467-a61dd6d9-f02a-4653-bcff-eeb592deaf68-20230330213234-ppelol3.png","path":"assets/net-img-1582873072467-a61dd6d9-f02a-4653-bcff-eeb592deaf68-20230330213234-ppelol3.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1582873090325-a7683e68-a46d-418f-bba5-0bd6c8c7575b-20230330213237-ldsjgn2.webp","path":"assets/net-img-1582873090325-a7683e68-a46d-418f-bba5-0bd6c8c7575b-20230330213237-ldsjgn2.webp","modified":0,"renderable":0},{"_id":"source/assets/net-img-1582873104499-77f0b1b3-a218-4cc7-9cd1-c5ab317f53ce-20230330213239-aq0b92g.png","path":"assets/net-img-1582873104499-77f0b1b3-a218-4cc7-9cd1-c5ab317f53ce-20230330213239-aq0b92g.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1582873144333-18753191-d8b2-47e1-a610-33c7c552fdaa-20230330213217-uigw9ix.png","path":"assets/net-img-1582873144333-18753191-d8b2-47e1-a610-33c7c552fdaa-20230330213217-uigw9ix.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1582873156123-9f655847-4b5d-4c84-8116-ede849af16e3-20230330213218-q1lh95h.png","path":"assets/net-img-1582873156123-9f655847-4b5d-4c84-8116-ede849af16e3-20230330213218-q1lh95h.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1582873335047-0818927f-77de-4ad8-aa95-fb7d537f6700-20230330213215-9u0gs7n.webp","path":"assets/net-img-1582873335047-0818927f-77de-4ad8-aa95-fb7d537f6700-20230330213215-9u0gs7n.webp","modified":0,"renderable":0},{"_id":"source/assets/net-img-1582873408415-b3e28487-6473-4fff-b4c9-b99b6b91a53a-20230330213216-4pmp0ac.webp","path":"assets/net-img-1582873408415-b3e28487-6473-4fff-b4c9-b99b6b91a53a-20230330213216-4pmp0ac.webp","modified":0,"renderable":0},{"_id":"source/assets/net-img-1582873416741-a71a0d28-b66d-49ca-8487-c0e0ceaa704c-20230330213216-jddkbfu.webp","path":"assets/net-img-1582873416741-a71a0d28-b66d-49ca-8487-c0e0ceaa704c-20230330213216-jddkbfu.webp","modified":0,"renderable":0},{"_id":"source/assets/net-img-1582873565810-556fde0f-9973-46d5-9e8e-4853e80b6ba3-20230330213302-b5p12uc.png","path":"assets/net-img-1582873565810-556fde0f-9973-46d5-9e8e-4853e80b6ba3-20230330213302-b5p12uc.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1582873583782-b5959bc6-9ff9-4ef1-95b3-9bc3fc1f83b9-20230330213307-m55wdql.png","path":"assets/net-img-1582873583782-b5959bc6-9ff9-4ef1-95b3-9bc3fc1f83b9-20230330213307-m55wdql.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1582873589321-1b21962d-3411-4d4f-af00-b2a82490e43c-20230330213311-i7hquya.png","path":"assets/net-img-1582873589321-1b21962d-3411-4d4f-af00-b2a82490e43c-20230330213311-i7hquya.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1582873594959-8501a655-dbe2-4983-9dcd-a33bde8f07f6-20230330213317-uu5k36v.png","path":"assets/net-img-1582873594959-8501a655-dbe2-4983-9dcd-a33bde8f07f6-20230330213317-uu5k36v.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1582873601269-c3ee8a62-7c38-4751-8cff-f60ddc262d41-20230330213313-8vw56oe.png","path":"assets/net-img-1582873601269-c3ee8a62-7c38-4751-8cff-f60ddc262d41-20230330213313-8vw56oe.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1582873690823-e85d7b31-4173-4adc-b4b4-92f314fd952b-20230330213322-ngp5u86.webp","path":"assets/net-img-1582873690823-e85d7b31-4173-4adc-b4b4-92f314fd952b-20230330213322-ngp5u86.webp","modified":0,"renderable":0},{"_id":"source/assets/net-img-1582873927778-b80fd046-98af-4768-bfc1-6d59761271e2-20230330213325-w0s4a7u.png","path":"assets/net-img-1582873927778-b80fd046-98af-4768-bfc1-6d59761271e2-20230330213325-w0s4a7u.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1582873928532-40dd13b8-87fb-4ecd-8e07-399dbc61eeb8-20230330213331-q75g2s7.png","path":"assets/net-img-1582873928532-40dd13b8-87fb-4ecd-8e07-399dbc61eeb8-20230330213331-q75g2s7.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1582873954652-cd9e9eab-021c-4792-9558-291d9ec5d743-20230330213333-aijfe0m.png","path":"assets/net-img-1582873954652-cd9e9eab-021c-4792-9558-291d9ec5d743-20230330213333-aijfe0m.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1582874001071-2fe5ab73-14e5-45aa-b07c-81ba0fecc256-20230330213404-cm5njiz.png","path":"assets/net-img-1582874001071-2fe5ab73-14e5-45aa-b07c-81ba0fecc256-20230330213404-cm5njiz.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1582874136797-a333d011-4325-4f7c-82f6-9792216b1a21-20230330213157-i9zy78v.webp","path":"assets/net-img-1582874136797-a333d011-4325-4f7c-82f6-9792216b1a21-20230330213157-i9zy78v.webp","modified":0,"renderable":0},{"_id":"source/assets/net-img-1582874168420-5865fe9a-fe6d-49b5-961a-2addc05fce6a-20230330213157-z8hfg9r.webp","path":"assets/net-img-1582874168420-5865fe9a-fe6d-49b5-961a-2addc05fce6a-20230330213157-z8hfg9r.webp","modified":0,"renderable":0},{"_id":"source/assets/net-img-1582874168964-bb84b249-5332-4a93-b161-842b2e6955ed-20230330213157-wrr6xqk.webp","path":"assets/net-img-1582874168964-bb84b249-5332-4a93-b161-842b2e6955ed-20230330213157-wrr6xqk.webp","modified":0,"renderable":0},{"_id":"source/assets/net-img-1582874243939-2eae4163-881d-47f6-b75d-18c057db48ef-20230330213158-setmh7t.webp","path":"assets/net-img-1582874243939-2eae4163-881d-47f6-b75d-18c057db48ef-20230330213158-setmh7t.webp","modified":0,"renderable":0},{"_id":"source/assets/net-img-1582874263210-a9e7bda6-4ed7-4d2d-8991-cdad8a2c292b-20230330213158-fukp6eb.png","path":"assets/net-img-1582874263210-a9e7bda6-4ed7-4d2d-8991-cdad8a2c292b-20230330213158-fukp6eb.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1582874272168-5169d4d6-17f9-493d-b99b-c9a678dd13da-20230330213159-jscv9ip.webp","path":"assets/net-img-1582874272168-5169d4d6-17f9-493d-b99b-c9a678dd13da-20230330213159-jscv9ip.webp","modified":0,"renderable":0},{"_id":"source/assets/net-img-1582874279332-65260fd7-5a39-4fd1-85b8-86729cc9982c-20230330213159-yohdmn5.webp","path":"assets/net-img-1582874279332-65260fd7-5a39-4fd1-85b8-86729cc9982c-20230330213159-yohdmn5.webp","modified":0,"renderable":0},{"_id":"source/assets/net-img-1582874334522-3936dfde-ef4a-4cf9-ab86-6001429fbb86-20230330213343-txdiivw.jpeg","path":"assets/net-img-1582874334522-3936dfde-ef4a-4cf9-ab86-6001429fbb86-20230330213343-txdiivw.jpeg","modified":0,"renderable":0},{"_id":"source/assets/net-img-1582874350036-1fb8d7cf-688f-4628-ae77-9a21de7c4d2e-20230330213346-aj91hqy.png","path":"assets/net-img-1582874350036-1fb8d7cf-688f-4628-ae77-9a21de7c4d2e-20230330213346-aj91hqy.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1582875290415-c052f229-8c31-4560-acef-300acae2409b-20221030135515-tme9bzx.png","path":"assets/net-img-1582875290415-c052f229-8c31-4560-acef-300acae2409b-20221030135515-tme9bzx.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1582875326094-cb5a96e7-e4c2-421d-83cf-216ca4f7f024-20221030135516-5igfhr6.png","path":"assets/net-img-1582875326094-cb5a96e7-e4c2-421d-83cf-216ca4f7f024-20221030135516-5igfhr6.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1582875326657-55738037-28bf-4de9-925a-f08034e0c722-20221030135516-j4ktjne.png","path":"assets/net-img-1582875326657-55738037-28bf-4de9-925a-f08034e0c722-20221030135516-j4ktjne.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1582875381841-0104c814-acd3-4ef3-a3bd-f5331d9a06bc-20221030135516-0716ftg.png","path":"assets/net-img-1582875381841-0104c814-acd3-4ef3-a3bd-f5331d9a06bc-20221030135516-0716ftg.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1582875390665-923c52b9-52ce-4e6f-9cee-763046546af3-20221030135517-j4zeqi7.png","path":"assets/net-img-1582875390665-923c52b9-52ce-4e6f-9cee-763046546af3-20221030135517-j4zeqi7.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1582875399701-d03e5b25-a1c9-498e-85d6-18f86f41e38f-20221030135517-a6hu6sv.png","path":"assets/net-img-1582875399701-d03e5b25-a1c9-498e-85d6-18f86f41e38f-20221030135517-a6hu6sv.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1582875452927-44c67a88-5cee-48b1-a764-a26d40a77538-20221030135540-f7dfpln.png","path":"assets/net-img-1582875452927-44c67a88-5cee-48b1-a764-a26d40a77538-20221030135540-f7dfpln.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1582875462202-61de3608-d606-44f6-b8d0-c82da3a7acd8-20221030135541-a1152vd.png","path":"assets/net-img-1582875462202-61de3608-d606-44f6-b8d0-c82da3a7acd8-20221030135541-a1152vd.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1582875470139-ea71ffbe-3cbd-44d8-8560-1e72b3a4bab4-20221030135541-hkuw6hs.png","path":"assets/net-img-1582875470139-ea71ffbe-3cbd-44d8-8560-1e72b3a4bab4-20221030135541-hkuw6hs.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1582875478351-18a69ed7-cb09-4a5a-a020-097490219718-20221030135517-0h9pq4n.png","path":"assets/net-img-1582875478351-18a69ed7-cb09-4a5a-a020-097490219718-20221030135517-0h9pq4n.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1582875574292-5a9c3846-0673-451f-8a69-409c0c8dff9c-20221030103933-qh2ia8u.png","path":"assets/net-img-1582875574292-5a9c3846-0673-451f-8a69-409c0c8dff9c-20221030103933-qh2ia8u.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1582875605484-a8880998-f9be-42d5-9997-a1c908ca05a9-20221030103933-jzsw591.webp","path":"assets/net-img-1582875605484-a8880998-f9be-42d5-9997-a1c908ca05a9-20221030103933-jzsw591.webp","modified":0,"renderable":0},{"_id":"source/assets/net-img-1591690708309-b6db1e95-1bbf-4140-b612-26fefc8d85b5-20221030132327-6s3ed7l.png","path":"assets/net-img-1591690708309-b6db1e95-1bbf-4140-b612-26fefc8d85b5-20221030132327-6s3ed7l.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1591690708399-bf1076aa-bdad-4e5f-ae30-261ccda91da5-20221030132327-4fweook.png","path":"assets/net-img-1591690708399-bf1076aa-bdad-4e5f-ae30-261ccda91da5-20221030132327-4fweook.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1591690708492-8b43720d-e8dc-4e22-9057-dcc4be2210de-20221030132325-ac88yvu.jpeg","path":"assets/net-img-1591690708492-8b43720d-e8dc-4e22-9057-dcc4be2210de-20221030132325-ac88yvu.jpeg","modified":0,"renderable":0},{"_id":"source/assets/net-img-1591690708909-03b304db-aa14-40fc-954b-2e5812e31b86-20221030132326-7iwfv9t.png","path":"assets/net-img-1591690708909-03b304db-aa14-40fc-954b-2e5812e31b86-20221030132326-7iwfv9t.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1591690908749-8d13658b-f28f-4a16-9787-5d802366b2bb-20221030132339-jhzqts2.png","path":"assets/net-img-1591690908749-8d13658b-f28f-4a16-9787-5d802366b2bb-20221030132339-jhzqts2.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1592902119376-b0ab487a-f7f3-454f-a784-aad737462ad4-20230330213502-h755rwl.png","path":"assets/net-img-1592902119376-b0ab487a-f7f3-454f-a784-aad737462ad4-20230330213502-h755rwl.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1592902119321-dda9e910-093f-47bf-890e-4719cb145075-20230527145229-565b500.png","path":"assets/net-img-1592902119321-dda9e910-093f-47bf-890e-4719cb145075-20230527145229-565b500.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1592902119376-b0ab487a-f7f3-454f-a784-aad737462ad4-20230527145229-vu7qxs4.png","path":"assets/net-img-1592902119376-b0ab487a-f7f3-454f-a784-aad737462ad4-20230527145229-vu7qxs4.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1592902120990-cffe2ea4-a4ed-4505-8bbd-c9b64730ae6e-20230527145229-4455z5v.png","path":"assets/net-img-1592902120990-cffe2ea4-a4ed-4505-8bbd-c9b64730ae6e-20230527145229-4455z5v.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1593008781064-94397bdb-4bd4-475a-b0de-25689df5598d-20230330213216-bqv0b3r.jpeg","path":"assets/net-img-1593008781064-94397bdb-4bd4-475a-b0de-25689df5598d-20230330213216-bqv0b3r.jpeg","modified":0,"renderable":0},{"_id":"source/assets/net-img-1593008911203-7a81af80-db8b-4843-a59a-755e226e2314-20230330213217-h350tsl.jpeg","path":"assets/net-img-1593008911203-7a81af80-db8b-4843-a59a-755e226e2314-20230330213217-h350tsl.jpeg","modified":0,"renderable":0},{"_id":"source/assets/net-img-1593009574123-1720bb9a-11ab-462c-9acc-83dfd40a63e3-20230330213217-8hneydr.jpeg","path":"assets/net-img-1593009574123-1720bb9a-11ab-462c-9acc-83dfd40a63e3-20230330213217-8hneydr.jpeg","modified":0,"renderable":0},{"_id":"source/assets/net-img-1593010056655-793ce18b-c4e9-4985-9ba7-ef5347134e12-20230330213219-q7hvhww.png","path":"assets/net-img-1593010056655-793ce18b-c4e9-4985-9ba7-ef5347134e12-20230330213219-q7hvhww.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1593010032163-e4fd6098-299b-4fac-adb3-b40e6ca3e534-20230330213218-jvzy0d2.png","path":"assets/net-img-1593010032163-e4fd6098-299b-4fac-adb3-b40e6ca3e534-20230330213218-jvzy0d2.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1593075294735-276336e9-41de-469d-a9e8-b4806bbdc0e9-20230330213341-wrzblbs.png","path":"assets/net-img-1593075294735-276336e9-41de-469d-a9e8-b4806bbdc0e9-20230330213341-wrzblbs.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1593075259316-cba6509a-9a9a-4282-8698-99fa1fcc0794-20230330213350-b5wkbl5.png","path":"assets/net-img-1593075259316-cba6509a-9a9a-4282-8698-99fa1fcc0794-20230330213350-b5wkbl5.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1593075298003-cebf8380-65e8-4a56-9a03-72d7f02ef65c-20230330213346-itjo56n.png","path":"assets/net-img-1593075298003-cebf8380-65e8-4a56-9a03-72d7f02ef65c-20230330213346-itjo56n.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1593075308254-c4ace563-ded0-42d8-8a4c-435a8bbe890f-20230330213356-yp75ww5.png","path":"assets/net-img-1593075308254-c4ace563-ded0-42d8-8a4c-435a8bbe890f-20230330213356-yp75ww5.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1593075466359-4fe25412-ad7b-4d12-ab59-556c6203aec3-20230330213411-owuofo8.png","path":"assets/net-img-1593075466359-4fe25412-ad7b-4d12-ab59-556c6203aec3-20230330213411-owuofo8.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1593075485480-eabde977-18f7-4a38-9f43-2a2792d14d5a-20230330213419-xbq6pfl.png","path":"assets/net-img-1593075485480-eabde977-18f7-4a38-9f43-2a2792d14d5a-20230330213419-xbq6pfl.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1593075510764-fa7e6f63-dbec-4789-a374-d8b319f98994-20230330213428-853fmb5.png","path":"assets/net-img-1593075510764-fa7e6f63-dbec-4789-a374-d8b319f98994-20230330213428-853fmb5.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1593076022539-0b41a928-a33d-4749-8e05-a629389f5b11-20230330213208-977tliz.png","path":"assets/net-img-1593076022539-0b41a928-a33d-4749-8e05-a629389f5b11-20230330213208-977tliz.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1593076049581-f084ed7e-111c-4a99-944b-bb4aadb0f33b-20230330213209-kp1deud.png","path":"assets/net-img-1593076049581-f084ed7e-111c-4a99-944b-bb4aadb0f33b-20230330213209-kp1deud.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1593076060148-a751342f-828e-49f2-a853-47b276d0fc68-20230330213209-k1w1si6.png","path":"assets/net-img-1593076060148-a751342f-828e-49f2-a853-47b276d0fc68-20230330213209-k1w1si6.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1593076076024-42ad7f21-eb2c-4c6b-8c34-802819b1fd8f-20230330213209-f5hjado.png","path":"assets/net-img-1593076076024-42ad7f21-eb2c-4c6b-8c34-802819b1fd8f-20230330213209-f5hjado.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1593076140792-4ab064fd-2370-4f64-a89e-6d7fc5bb9f39-20230330213209-drma95r.png","path":"assets/net-img-1593076140792-4ab064fd-2370-4f64-a89e-6d7fc5bb9f39-20230330213209-drma95r.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1593854466438-89baf576-0e30-4db7-934e-2781413c9510-20221030140124-w8acjeh.png","path":"assets/net-img-1593854466438-89baf576-0e30-4db7-934e-2781413c9510-20221030140124-w8acjeh.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1596005642573-853dc49e-7632-496d-9221-33e3b7879fea-20221030132325-84wdxkw.jpeg","path":"assets/net-img-1596005642573-853dc49e-7632-496d-9221-33e3b7879fea-20221030132325-84wdxkw.jpeg","modified":0,"renderable":0},{"_id":"source/assets/net-img-1596361953803-ed588642-562c-49e8-99dd-cdc0e81519b7-20230426150127-crjga75.png","path":"assets/net-img-1596361953803-ed588642-562c-49e8-99dd-cdc0e81519b7-20230426150127-crjga75.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1596249786159-92610d33-5cbb-4d46-b7a5-6f1c8d3d1d92-20221030135516-9i6hh1r.jpeg","path":"assets/net-img-1596249786159-92610d33-5cbb-4d46-b7a5-6f1c8d3d1d92-20221030135516-9i6hh1r.jpeg","modified":0,"renderable":0},{"_id":"source/assets/net-img-1596362023744-7f76e71b-8cd9-4797-87f7-bccdb93fbb3a-20221030140106-k1plvtd.jpeg","path":"assets/net-img-1596362023744-7f76e71b-8cd9-4797-87f7-bccdb93fbb3a-20221030140106-k1plvtd.jpeg","modified":0,"renderable":0},{"_id":"source/assets/net-img-1596783175795-a3a09f05-cdc6-4406-9b0a-0f3f6a28a5ff-20221030105031-64rpjno.jpeg","path":"assets/net-img-1596783175795-a3a09f05-cdc6-4406-9b0a-0f3f6a28a5ff-20221030105031-64rpjno.jpeg","modified":0,"renderable":0},{"_id":"source/assets/net-img-1596783496811-3a6ed88c-bb38-40b7-aaf3-ca98b12493f2-20221030105031-aijlekh.jpeg","path":"assets/net-img-1596783496811-3a6ed88c-bb38-40b7-aaf3-ca98b12493f2-20221030105031-aijlekh.jpeg","modified":0,"renderable":0},{"_id":"source/assets/net-img-1602123134723-ab15ac69-5397-4422-8dcf-3c43f4a10e06-20221030124512-4k4z367.png","path":"assets/net-img-1602123134723-ab15ac69-5397-4422-8dcf-3c43f4a10e06-20221030124512-4k4z367.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1602123013155-86ac51db-7d0a-4241-8094-f1fe2e16b43c-20221030124512-fqt8gu2.png","path":"assets/net-img-1602123013155-86ac51db-7d0a-4241-8094-f1fe2e16b43c-20221030124512-fqt8gu2.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1602404087657-9aa12bdc-ba61-429f-bf21-dcf0efc211fa-20221030124615-fz11c88.png","path":"assets/net-img-1602404087657-9aa12bdc-ba61-429f-bf21-dcf0efc211fa-20221030124615-fz11c88.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1602405124816-7ec65b09-2556-4ba3-b9ca-dabf0081929f-20230330213836-e0kef3p.png","path":"assets/net-img-1602405124816-7ec65b09-2556-4ba3-b9ca-dabf0081929f-20230330213836-e0kef3p.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1602510155856-cf2ddad6-d6bb-4ea0-bb8c-f9b1dc49cee8-20221030124433-3c4w0ya.png","path":"assets/net-img-1602510155856-cf2ddad6-d6bb-4ea0-bb8c-f9b1dc49cee8-20221030124433-3c4w0ya.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1602914807774-75634a6f-e238-498a-b0ce-e27f039a9646-20221030124604-ehzp01i.png","path":"assets/net-img-1602914807774-75634a6f-e238-498a-b0ce-e27f039a9646-20221030124604-ehzp01i.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1602920769113-5b1bf8b5-f2b3-4a36-948b-721849b796d7-20221030124537-xtsxn6h.png","path":"assets/net-img-1602920769113-5b1bf8b5-f2b3-4a36-948b-721849b796d7-20221030124537-xtsxn6h.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1602998399972-d63036ef-500b-49ae-a31a-84a558efb1ae-20221030124502-upt9d1p.png","path":"assets/net-img-1602998399972-d63036ef-500b-49ae-a31a-84a558efb1ae-20221030124502-upt9d1p.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1603004208800-d47ee0f7-24fa-4b06-ae5f-8ce7b97e1e34-20221030124351-wgmd1lo.png","path":"assets/net-img-1603004208800-d47ee0f7-24fa-4b06-ae5f-8ce7b97e1e34-20221030124351-wgmd1lo.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1603013197743-541a8456-5d1b-477d-9658-1b6d5c06780a-20230330213832-g2oqx3t.png","path":"assets/net-img-1603013197743-541a8456-5d1b-477d-9658-1b6d5c06780a-20230330213832-g2oqx3t.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1603013239640-a2f1a79b-35c2-4ca8-9355-5f37e9d680bb-20221030124448-sl4zele.png","path":"assets/net-img-1603013239640-a2f1a79b-35c2-4ca8-9355-5f37e9d680bb-20221030124448-sl4zele.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1603013275619-1a15e41e-436b-41ef-bce1-147db82e5a83-20221030124522-yeb4ilf.png","path":"assets/net-img-1603013275619-1a15e41e-436b-41ef-bce1-147db82e5a83-20221030124522-yeb4ilf.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1603013309762-3689744a-be23-4e8f-8487-d397b3cc7869-20221030124624-9buvwxc.png","path":"assets/net-img-1603013309762-3689744a-be23-4e8f-8487-d397b3cc7869-20221030124624-9buvwxc.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1615533992554-f7ecd3db-e7d5-4f29-b845-a22cb39dee76-20230426150127-m6xofsl.png","path":"assets/net-img-1615533992554-f7ecd3db-e7d5-4f29-b845-a22cb39dee76-20230426150127-m6xofsl.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1615535960262-7646f229-98d2-4474-be5c-3e5dd3c3e7ac-20221030140153-c14thj0.png","path":"assets/net-img-1615535960262-7646f229-98d2-4474-be5c-3e5dd3c3e7ac-20221030140153-c14thj0.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1615611389351-2cfaa4d5-b52c-4a2e-a170-c32ce97d17a6-20221030135532-u420fpk.png","path":"assets/net-img-1615611389351-2cfaa4d5-b52c-4a2e-a170-c32ce97d17a6-20221030135532-u420fpk.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1615611389351-2cfaa4d5-b52c-4a2e-a170-c32ce97d17a6-20230330213518-3fydrb9.png","path":"assets/net-img-1615611389351-2cfaa4d5-b52c-4a2e-a170-c32ce97d17a6-20230330213518-3fydrb9.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1615611419969-14ba7126-9f92-482c-a851-9898cece7e8f-20221030135532-6itdbiz.png","path":"assets/net-img-1615611419969-14ba7126-9f92-482c-a851-9898cece7e8f-20221030135532-6itdbiz.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1615611419969-14ba7126-9f92-482c-a851-9898cece7e8f-20230330213518-2ptpa3a.png","path":"assets/net-img-1615611419969-14ba7126-9f92-482c-a851-9898cece7e8f-20230330213518-2ptpa3a.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1615614053644-2e45ea92-d426-42ca-a609-91b095ff7e83-20221030135532-iwc3p25.png","path":"assets/net-img-1615614053644-2e45ea92-d426-42ca-a609-91b095ff7e83-20221030135532-iwc3p25.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1615614053644-2e45ea92-d426-42ca-a609-91b095ff7e83-20230330213519-1im5mrq.png","path":"assets/net-img-1615614053644-2e45ea92-d426-42ca-a609-91b095ff7e83-20230330213519-1im5mrq.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1615619423077-dea312ee-787e-4a28-b723-199f76a214f7-20221030135542-mx20k3e.png","path":"assets/net-img-1615619423077-dea312ee-787e-4a28-b723-199f76a214f7-20221030135542-mx20k3e.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1615619453470-bdab6e23-1385-4538-9c91-ceefcd05aa27-20221030135542-vyoxljv.png","path":"assets/net-img-1615619453470-bdab6e23-1385-4538-9c91-ceefcd05aa27-20221030135542-vyoxljv.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1623829860526-2438b2e1-de01-4c73-aa21-84e18c00d37c-20221031123408-wcse42k.png","path":"assets/net-img-1623829860526-2438b2e1-de01-4c73-aa21-84e18c00d37c-20221031123408-wcse42k.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1624106093230-4372b31c-0d0f-4640-8e80-62b7bdd258e4-20230122192859-kbq2rlz.png","path":"assets/net-img-1624106093230-4372b31c-0d0f-4640-8e80-62b7bdd258e4-20230122192859-kbq2rlz.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1624109586831-fa30fbaf-01b4-4243-bedf-eedfe9631e67-20230122192859-buewr2p.png","path":"assets/net-img-1624109586831-fa30fbaf-01b4-4243-bedf-eedfe9631e67-20230122192859-buewr2p.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1625277244322-1304b001-049b-467f-9207-4012228cca38-20221031123243-oqmq9cu.jpeg","path":"assets/net-img-1625277244322-1304b001-049b-467f-9207-4012228cca38-20221031123243-oqmq9cu.jpeg","modified":0,"renderable":0},{"_id":"source/assets/net-img-1626851086718-49fece61-64f3-4f2e-9b78-f97e17176373-20230101203426-dn382za.png","path":"assets/net-img-1626851086718-49fece61-64f3-4f2e-9b78-f97e17176373-20230101203426-dn382za.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1626851420391-9aa6cf8f-fa40-49c3-8a7a-941763583502-20230101203427-ybsosns.png","path":"assets/net-img-1626851420391-9aa6cf8f-fa40-49c3-8a7a-941763583502-20230101203427-ybsosns.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1626854477699-226d8221-ae45-44f5-b8fd-6003efd2531c-20230101203427-giho3sf.png","path":"assets/net-img-1626854477699-226d8221-ae45-44f5-b8fd-6003efd2531c-20230101203427-giho3sf.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1627291037100-eacf8101-ce28-4c56-9c4b-12e59e5a3b26-20221031123408-gsirdhu.jpeg","path":"assets/net-img-1627291037100-eacf8101-ce28-4c56-9c4b-12e59e5a3b26-20221031123408-gsirdhu.jpeg","modified":0,"renderable":0},{"_id":"source/assets/net-img-1627455003158-01c028a9-eb52-46e6-85ab-c811d640a84d-20221031123409-s3v35p9.jpeg","path":"assets/net-img-1627455003158-01c028a9-eb52-46e6-85ab-c811d640a84d-20221031123409-s3v35p9.jpeg","modified":0,"renderable":0},{"_id":"source/assets/net-img-1628324723790-e7e469c7-62d0-4076-aa53-5e937ae80bee-20230122192859-e7kchm7.jpeg","path":"assets/net-img-1628324723790-e7e469c7-62d0-4076-aa53-5e937ae80bee-20230122192859-e7kchm7.jpeg","modified":0,"renderable":0},{"_id":"source/assets/net-img-1628905841173-c32bdb25-8b61-4f16-b08e-96898d7aeefc-20221031123444-2pva1h4.png","path":"assets/net-img-1628905841173-c32bdb25-8b61-4f16-b08e-96898d7aeefc-20221031123444-2pva1h4.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1629558034184-e1fe6601-777e-4a34-afe5-df37e5a9b720-20230330213445-e5uive7.png","path":"assets/net-img-1629558034184-e1fe6601-777e-4a34-afe5-df37e5a9b720-20230330213445-e5uive7.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1629559055065-5ad8d49f-81b6-45f3-87f8-c98716f799ed-20230330213451-7nkjlzc.png","path":"assets/net-img-1629559055065-5ad8d49f-81b6-45f3-87f8-c98716f799ed-20230330213451-7nkjlzc.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1629559366006-0194df18-86f2-45fd-bd85-6f675b19bdb0-20230330213459-p7i5mm5.png","path":"assets/net-img-1629559366006-0194df18-86f2-45fd-bd85-6f675b19bdb0-20230330213459-p7i5mm5.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1629560137959-ab93eb78-c083-4c80-8283-4cfc470c8af0-20230330213504-cteixk9.png","path":"assets/net-img-1629560137959-ab93eb78-c083-4c80-8283-4cfc470c8af0-20230330213504-cteixk9.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1629870852837-ca139768-9f26-412a-8940-49ed6e38f57a-20230330213513-n1dmxgm.png","path":"assets/net-img-1629870852837-ca139768-9f26-412a-8940-49ed6e38f57a-20230330213513-n1dmxgm.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1631431982904-ce964c3b-4c64-4915-84a9-a3799dd2cf92-20230330213415-i9cgn1s.png","path":"assets/net-img-1631431982904-ce964c3b-4c64-4915-84a9-a3799dd2cf92-20230330213415-i9cgn1s.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1631436389678-e6910ed9-8e3c-4d73-93bf-362566a4ebb0-20230330213421-crfgpeh.png","path":"assets/net-img-1631436389678-e6910ed9-8e3c-4d73-93bf-362566a4ebb0-20230330213421-crfgpeh.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1639574230606-ee713d6a-1223-4275-bfaa-f60258aa6eea-20221030132914-2yfiwaf.jpeg","path":"assets/net-img-1639574230606-ee713d6a-1223-4275-bfaa-f60258aa6eea-20221030132914-2yfiwaf.jpeg","modified":0,"renderable":0},{"_id":"source/assets/net-img-1645242293838-01142675-6027-4b29-8f4d-1d872c2d6cea-20221030140106-8zicdb0.png","path":"assets/net-img-1645242293838-01142675-6027-4b29-8f4d-1d872c2d6cea-20221030140106-8zicdb0.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1646740660775-762fcaa3-26b5-4d95-ac43-5cca58540969-20230330213439-sxz1b5i.png","path":"assets/net-img-1646740660775-762fcaa3-26b5-4d95-ac43-5cca58540969-20230330213439-sxz1b5i.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1665073234010-c17ae82e-6da7-479a-ba1c-b1543abba0d5-20221111215525-80jshsc.png","path":"assets/net-img-1665073234010-c17ae82e-6da7-479a-ba1c-b1543abba0d5-20221111215525-80jshsc.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1646742883104-4eef3a95-3655-44f4-8887-2f5f1628732e-20230330213506-2xv20ln.png","path":"assets/net-img-1646742883104-4eef3a95-3655-44f4-8887-2f5f1628732e-20230330213506-2xv20ln.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1665073313636-93fb8cb7-e679-4c0f-8067-885d28f67ded-20221111215526-vcl9xfw.png","path":"assets/net-img-1665073313636-93fb8cb7-e679-4c0f-8067-885d28f67ded-20221111215526-vcl9xfw.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1665073347225-5388dfc6-3fc2-4492-902c-b7fcd02f3245-20221111215525-4h0vo0n.png","path":"assets/net-img-1665073347225-5388dfc6-3fc2-4492-902c-b7fcd02f3245-20221111215525-4h0vo0n.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1665073353104-76e6707d-af7c-4e84-97dd-7458adee7994-20221111215525-0zkzrc2.png","path":"assets/net-img-1665073353104-76e6707d-af7c-4e84-97dd-7458adee7994-20221111215525-0zkzrc2.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1665073358729-865ac7d0-89b5-4cc8-814e-a892038da58b-20221111215525-k257bcx.png","path":"assets/net-img-1665073358729-865ac7d0-89b5-4cc8-814e-a892038da58b-20221111215525-k257bcx.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1665073365265-002fd960-3cab-45d5-a547-968487191335-20221111215525-51j8yv0.png","path":"assets/net-img-1665073365265-002fd960-3cab-45d5-a547-968487191335-20221111215525-51j8yv0.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1665073370943-3b2e7f1c-7c9a-46a3-9e37-31742edea2f4-20221111215525-xb7w2cn.png","path":"assets/net-img-1665073370943-3b2e7f1c-7c9a-46a3-9e37-31742edea2f4-20221111215525-xb7w2cn.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1665073398713-d6f47c91-e7a2-407a-9cc0-de52b301cf26-20221111215526-gwi38jk.png","path":"assets/net-img-1665073398713-d6f47c91-e7a2-407a-9cc0-de52b301cf26-20221111215526-gwi38jk.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1665073405592-73518a43-9c02-4d55-baee-bafcff044efe-20221111215526-c9mhwt8.png","path":"assets/net-img-1665073405592-73518a43-9c02-4d55-baee-bafcff044efe-20221111215526-c9mhwt8.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1665073414310-928255a5-b8a0-4a7b-817f-dbabda18feef-20221111215526-c0gy94f.png","path":"assets/net-img-1665073414310-928255a5-b8a0-4a7b-817f-dbabda18feef-20221111215526-c0gy94f.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1665073424520-10dfe592-ea00-4ea5-b46e-992601919f1f-20221111215526-q1f6my9.png","path":"assets/net-img-1665073424520-10dfe592-ea00-4ea5-b46e-992601919f1f-20221111215526-q1f6my9.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1665073433573-ed1fdba5-d19f-40c2-a4f9-96a6ddbff0d2-20221111215526-5pgyp70.png","path":"assets/net-img-1665073433573-ed1fdba5-d19f-40c2-a4f9-96a6ddbff0d2-20221111215526-5pgyp70.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1665073440336-5f261660-b58b-4c06-9c1d-f21c0865e31c-20221111215526-0s6pvi9.png","path":"assets/net-img-1665073440336-5f261660-b58b-4c06-9c1d-f21c0865e31c-20221111215526-0s6pvi9.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1665073448391-a1d5eef7-134c-4b01-9c2e-2df8cc9ec893-20221111215526-gp8xqtg.png","path":"assets/net-img-1665073448391-a1d5eef7-134c-4b01-9c2e-2df8cc9ec893-20221111215526-gp8xqtg.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1665073460709-ab3783c9-f4f3-46ae-ab45-fe489a701313-20221111215526-4cnfbe6.png","path":"assets/net-img-1665073460709-ab3783c9-f4f3-46ae-ab45-fe489a701313-20221111215526-4cnfbe6.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1665073467540-2062cc90-042f-4ea8-8dbc-1afa0c8232c7-20221111215527-13hnynb.png","path":"assets/net-img-1665073467540-2062cc90-042f-4ea8-8dbc-1afa0c8232c7-20221111215527-13hnynb.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1665073473485-b4b83d79-2af4-4681-9d50-1c9096dc935c-20221111215527-zawp2eq.png","path":"assets/net-img-1665073473485-b4b83d79-2af4-4681-9d50-1c9096dc935c-20221111215527-zawp2eq.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1665073484287-631d0da3-1bb4-4881-b567-647d058f4f47-20221111215527-l67jrtu.png","path":"assets/net-img-1665073484287-631d0da3-1bb4-4881-b567-647d058f4f47-20221111215527-l67jrtu.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1665073567805-1c681335-41e9-40c3-a02a-0155e0383924-20221111215527-s7tudvn.png","path":"assets/net-img-1665073567805-1c681335-41e9-40c3-a02a-0155e0383924-20221111215527-s7tudvn.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1665073576092-3eea97da-b483-4acc-a6fd-eece98224cd0-20221111215527-fr7igf9.png","path":"assets/net-img-1665073576092-3eea97da-b483-4acc-a6fd-eece98224cd0-20221111215527-fr7igf9.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1665073584346-6bc72f6a-0e4a-412e-94bc-81d860d5b059-20221111215527-k046iu2.png","path":"assets/net-img-1665073584346-6bc72f6a-0e4a-412e-94bc-81d860d5b059-20221111215527-k046iu2.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1665073596487-2a45c98e-71a7-45e8-a0c2-ac4b06cd0cff-20221111215527-fzwff39.png","path":"assets/net-img-1665073596487-2a45c98e-71a7-45e8-a0c2-ac4b06cd0cff-20221111215527-fzwff39.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1665073607553-c63d8f6f-883c-4ce4-9acd-3861c0ffd7ff-20221111215527-e9urwmu.png","path":"assets/net-img-1665073607553-c63d8f6f-883c-4ce4-9acd-3861c0ffd7ff-20221111215527-e9urwmu.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1665073624592-674dd74d-86d2-4605-9955-7a16e09a1cb4-20221111215527-1blmix8.png","path":"assets/net-img-1665073624592-674dd74d-86d2-4605-9955-7a16e09a1cb4-20221111215527-1blmix8.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1665073630217-bd1f44be-c442-48c7-9478-62d7f8fc79ce-20221111215527-fmqia49.png","path":"assets/net-img-1665073630217-bd1f44be-c442-48c7-9478-62d7f8fc79ce-20221111215527-fmqia49.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1665073635044-265417f7-ec52-4a11-9a17-929aa008498c-20221111215527-s30ehyk.png","path":"assets/net-img-1665073635044-265417f7-ec52-4a11-9a17-929aa008498c-20221111215527-s30ehyk.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1665073657734-f1c3e079-3804-43d3-8e30-9b46530ad337-20221111215527-74wm25r.png","path":"assets/net-img-1665073657734-f1c3e079-3804-43d3-8e30-9b46530ad337-20221111215527-74wm25r.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1665073663657-eac74193-3f2d-4823-b1ce-076ee644f1ba-20221111215527-ce3yoc2.png","path":"assets/net-img-1665073663657-eac74193-3f2d-4823-b1ce-076ee644f1ba-20221111215527-ce3yoc2.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1665073671982-4bc2b9c6-228b-49a6-96ed-ab6555a1b26d-20221111215527-af0xz7y.png","path":"assets/net-img-1665073671982-4bc2b9c6-228b-49a6-96ed-ab6555a1b26d-20221111215527-af0xz7y.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1665073689906-f5db7615-5190-4e77-9d08-d177ad4026de-20221111215533-4736rjm.png","path":"assets/net-img-1665073689906-f5db7615-5190-4e77-9d08-d177ad4026de-20221111215533-4736rjm.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1665073701183-299298fc-39d3-49a7-80e3-7c1240dbf6bc-20221111215533-jaec6x0.png","path":"assets/net-img-1665073701183-299298fc-39d3-49a7-80e3-7c1240dbf6bc-20221111215533-jaec6x0.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1665073728272-8bc0096c-6425-4310-979a-28ad42d6e2c0-20221111215533-kvytuuy.png","path":"assets/net-img-1665073728272-8bc0096c-6425-4310-979a-28ad42d6e2c0-20221111215533-kvytuuy.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1665073733517-eb68002c-afc1-4746-96e4-0fa95b21bfad-20221111215533-jinki2i.png","path":"assets/net-img-1665073733517-eb68002c-afc1-4746-96e4-0fa95b21bfad-20221111215533-jinki2i.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1665073741703-3acb8484-f36b-4738-8769-c50625b23727-20221111215534-pwccic8.png","path":"assets/net-img-1665073741703-3acb8484-f36b-4738-8769-c50625b23727-20221111215534-pwccic8.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1665073776507-524d18b7-c84e-4311-a742-c02a67d7a63e-20221111215534-h1bzg7o.png","path":"assets/net-img-1665073776507-524d18b7-c84e-4311-a742-c02a67d7a63e-20221111215534-h1bzg7o.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1665887335160-92fef518-ebb8-4a80-8bba-39f60880a491-20221030140113-ritolt8.webp","path":"assets/net-img-1665887335160-92fef518-ebb8-4a80-8bba-39f60880a491-20221030140113-ritolt8.webp","modified":0,"renderable":0},{"_id":"source/assets/net-img-1665887374286-cdf6dee1-f1f2-4de2-8fdd-0652d9e2f667-20221030140113-kzrzbzq.webp","path":"assets/net-img-1665887374286-cdf6dee1-f1f2-4de2-8fdd-0652d9e2f667-20221030140113-kzrzbzq.webp","modified":0,"renderable":0},{"_id":"source/assets/net-img-1665887401184-ef95895d-d794-43e2-8d11-46c0b6186d3a-20221030140113-0svrost.webp","path":"assets/net-img-1665887401184-ef95895d-d794-43e2-8d11-46c0b6186d3a-20221030140113-0svrost.webp","modified":0,"renderable":0},{"_id":"source/assets/net-img-4122e8fc2d6e2995074ede61ff44aef4-20230330213516-hs7yexh.svg","path":"assets/net-img-4122e8fc2d6e2995074ede61ff44aef4-20230330213516-hs7yexh.svg","modified":0,"renderable":0},{"_id":"source/assets/net-img-4122e8fc2d6e2995074ede61ff44aef4-20230527145229-bw8f49a.svg","path":"assets/net-img-4122e8fc2d6e2995074ede61ff44aef4-20230527145229-bw8f49a.svg","modified":0,"renderable":0},{"_id":"source/assets/net-img-640-20221123123914-g18ng9z.png","path":"assets/net-img-640-20221123123914-g18ng9z.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-640-20221123124059-5desc25.png","path":"assets/net-img-640-20221123124059-5desc25.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-640-20230330194058-16epkoj.png","path":"assets/net-img-640-20230330194058-16epkoj.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-JDgR0O-20221030104726-xwobg2m.jpg","path":"assets/net-img-JDgR0O-20221030104726-xwobg2m.jpg","modified":0,"renderable":0},{"_id":"source/assets/net-img-640-20230330193532-4safylx.png","path":"assets/net-img-640-20230330193532-4safylx.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-Javb7R-20221030105018-f0nmumb.jpg","path":"assets/net-img-Javb7R-20221030105018-f0nmumb.jpg","modified":0,"renderable":0},{"_id":"source/assets/net-img-NHqeHS-20221030124555-egcayk2.png","path":"assets/net-img-NHqeHS-20221030124555-egcayk2.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-NIKEYn-20221030105009-qtc7vqs.jpg","path":"assets/net-img-NIKEYn-20221030105009-qtc7vqs.jpg","modified":0,"renderable":0},{"_id":"source/assets/net-img-NILhqg-20221030105009-gkjt4x4.jpg","path":"assets/net-img-NILhqg-20221030105009-gkjt4x4.jpg","modified":0,"renderable":0},{"_id":"source/assets/net-img-Nxg2RI-20221030140124-2j3rd9u.png","path":"assets/net-img-Nxg2RI-20221030140124-2j3rd9u.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-regexp-cn-20221030151436-zbahpvf.png","path":"assets/net-img-regexp-cn-20221030151436-zbahpvf.png","modified":0,"renderable":0},{"_id":"source/assets/recover1.jpg","path":"assets/recover1.jpg","modified":0,"renderable":0},{"_id":"source/assets/recover2.jpg","path":"assets/recover2.jpg","modified":0,"renderable":0},{"_id":"source/assets/微信图片_20221129215049-20221129215137-xy69pf5.jpg","path":"assets/微信图片_20221129215049-20221129215137-xy69pf5.jpg","modified":0,"renderable":0},{"_id":"source/img/svg/bilibili.svg","path":"img/svg/bilibili.svg","modified":0,"renderable":0},{"_id":"node_modules/hexo-theme-butterfly/source/css/index.styl","path":"css/index.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/css/var.styl","path":"css/var.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/img/404.jpg","path":"img/404.jpg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/img/butterfly-icon.png","path":"img/butterfly-icon.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/img/error-page.png","path":"img/error-page.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/img/favicon.ico","path":"img/favicon.ico","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/img/friend_404.gif","path":"img/friend_404.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/js/tw_cn.js","path":"js/tw_cn.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/js/search/algolia.js","path":"js/search/algolia.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/js/search/local-search.js","path":"js/search/local-search.js","modified":0,"renderable":1},{"_id":"source/assets/002bdbd0d71140c3834d44b93555237ftplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-ryqzvpj.awebp","path":"assets/002bdbd0d71140c3834d44b93555237ftplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-ryqzvpj.awebp","modified":0,"renderable":0},{"_id":"source/assets/0566fc7826064b12bb88082b39c10bd2tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-hkx67f6.awebp","path":"assets/0566fc7826064b12bb88082b39c10bd2tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-hkx67f6.awebp","modified":0,"renderable":0},{"_id":"source/assets/0dfa05911b3f4f448db0ce247eb0db91tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-oai6wan.awebp","path":"assets/0dfa05911b3f4f448db0ce247eb0db91tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-oai6wan.awebp","modified":0,"renderable":0},{"_id":"source/assets/13ba4ffef43045ba8ed42101aefd3d72tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-i9veirg.awebp","path":"assets/13ba4ffef43045ba8ed42101aefd3d72tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-i9veirg.awebp","modified":0,"renderable":0},{"_id":"source/assets/233f28fc503e4dcc9c1e1317a89b71d9tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-vqp6dd1.awebp","path":"assets/233f28fc503e4dcc9c1e1317a89b71d9tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-vqp6dd1.awebp","modified":0,"renderable":0},{"_id":"source/assets/29c7d6a21d76455d9bc5443394172a2btplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-jhifgqp.awebp","path":"assets/29c7d6a21d76455d9bc5443394172a2btplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-jhifgqp.awebp","modified":0,"renderable":0},{"_id":"source/assets/25a723e07ab64f0fa5fcdc4eeddf1e0dtplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-afj8oqs.awebp","path":"assets/25a723e07ab64f0fa5fcdc4eeddf1e0dtplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-afj8oqs.awebp","modified":0,"renderable":0},{"_id":"source/assets/34f2d54bc3724e51b0c8ad2695f7de95tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-2cym377.awebp","path":"assets/34f2d54bc3724e51b0c8ad2695f7de95tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-2cym377.awebp","modified":0,"renderable":0},{"_id":"source/assets/359cbfb6d68e450b8f611a9975099c6etplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-ol5zynd.awebp","path":"assets/359cbfb6d68e450b8f611a9975099c6etplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-ol5zynd.awebp","modified":0,"renderable":0},{"_id":"source/assets/523b778404c140a29621295d079be9f8tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-nuriy5k.awebp","path":"assets/523b778404c140a29621295d079be9f8tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-nuriy5k.awebp","modified":0,"renderable":0},{"_id":"source/assets/53b93ae1d4dc4adeaa4d6104cc9aa7b6tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-onec9un.awebp","path":"assets/53b93ae1d4dc4adeaa4d6104cc9aa7b6tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-onec9un.awebp","modified":0,"renderable":0},{"_id":"source/assets/53c6380455754787a12800dbf1e48a06tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-0takv3w.awebp","path":"assets/53c6380455754787a12800dbf1e48a06tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-0takv3w.awebp","modified":0,"renderable":0},{"_id":"source/assets/58038d8ee0344260875993d8636331d5tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-lhvub6f.awebp","path":"assets/58038d8ee0344260875993d8636331d5tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-lhvub6f.awebp","modified":0,"renderable":0},{"_id":"source/assets/594708f975664198bd523b79b8e1a73ftplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-0c9y8yc.awebp","path":"assets/594708f975664198bd523b79b8e1a73ftplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-0c9y8yc.awebp","modified":0,"renderable":0},{"_id":"source/assets/63f3b4b63fd14b7a84c33c0840bc41e2tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-7eix1tf.awebp","path":"assets/63f3b4b63fd14b7a84c33c0840bc41e2tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-7eix1tf.awebp","modified":0,"renderable":0},{"_id":"source/assets/6d2a0769269e405dac3519f9e45d14d7tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-hfn0g3i.awebp","path":"assets/6d2a0769269e405dac3519f9e45d14d7tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-hfn0g3i.awebp","modified":0,"renderable":0},{"_id":"source/assets/84c1132caafa47e1a56f670b0ac349aetplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-czmjytj.awebp","path":"assets/84c1132caafa47e1a56f670b0ac349aetplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-czmjytj.awebp","modified":0,"renderable":0},{"_id":"source/assets/908c9b12522247dfbd32bada7308cb27tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-r7sakmv.awebp","path":"assets/908c9b12522247dfbd32bada7308cb27tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-r7sakmv.awebp","modified":0,"renderable":0},{"_id":"source/assets/948ff8d7b81449269cbedf8928f28e59tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-2e3ivzs.awebp","path":"assets/948ff8d7b81449269cbedf8928f28e59tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-2e3ivzs.awebp","modified":0,"renderable":0},{"_id":"source/assets/ad0a175194af489d9c71f096ac430a03tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-4g64cdf.awebp","path":"assets/ad0a175194af489d9c71f096ac430a03tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-4g64cdf.awebp","modified":0,"renderable":0},{"_id":"source/assets/b704efb8f0784c89b520d5e990bcd670tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-zv6m9iy.awebp","path":"assets/b704efb8f0784c89b520d5e990bcd670tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-zv6m9iy.awebp","modified":0,"renderable":0},{"_id":"source/assets/c2b0e2f9f93449e7b86ef71e2bac35e9tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-8xtfk94.awebp","path":"assets/c2b0e2f9f93449e7b86ef71e2bac35e9tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-8xtfk94.awebp","modified":0,"renderable":0},{"_id":"source/assets/c7d327afbf054012bd98bb554bfd19a3tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-kxpsqug.awebp","path":"assets/c7d327afbf054012bd98bb554bfd19a3tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-kxpsqug.awebp","modified":0,"renderable":0},{"_id":"source/assets/d682866856c240b39d8dd674462b4072tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-ptt3047.awebp","path":"assets/d682866856c240b39d8dd674462b4072tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-ptt3047.awebp","modified":0,"renderable":0},{"_id":"source/assets/d4522ab88aca42a4b9c2d633301fcac5tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-idyvok3.awebp","path":"assets/d4522ab88aca42a4b9c2d633301fcac5tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-idyvok3.awebp","modified":0,"renderable":0},{"_id":"source/assets/d76e41420e1d44eb82e4b74dc7d4309btplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-e21hjq1.awebp","path":"assets/d76e41420e1d44eb82e4b74dc7d4309btplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-e21hjq1.awebp","modified":0,"renderable":0},{"_id":"source/assets/d9a984a0659546258734112ce5c687f7tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-qzq41qp.awebp","path":"assets/d9a984a0659546258734112ce5c687f7tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-qzq41qp.awebp","modified":0,"renderable":0},{"_id":"source/assets/d8bdbd9d79814646999637ffc46281cbtplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-5lz8huo.awebp","path":"assets/d8bdbd9d79814646999637ffc46281cbtplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-5lz8huo.awebp","modified":0,"renderable":0},{"_id":"source/assets/e87ee465af764c47866e1f69a22d065atplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-ms062uc.awebp","path":"assets/e87ee465af764c47866e1f69a22d065atplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-ms062uc.awebp","modified":0,"renderable":0},{"_id":"source/assets/ec623644e43b4c56bf1110c9cfc74bc8tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-1zakfmq.awebp","path":"assets/ec623644e43b4c56bf1110c9cfc74bc8tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-1zakfmq.awebp","modified":0,"renderable":0},{"_id":"source/assets/ec983e41a4b54a31a1f7f7c9ec511974tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-8ibqfew.awebp","path":"assets/ec983e41a4b54a31a1f7f7c9ec511974tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-8ibqfew.awebp","modified":0,"renderable":0},{"_id":"source/assets/f43dc00e2347458c876f15dae66f23d4tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-lapokvs.awebp","path":"assets/f43dc00e2347458c876f15dae66f23d4tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-lapokvs.awebp","modified":0,"renderable":0},{"_id":"source/assets/faa389f1359544b382bcaf1b9b5227bbtplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-woeeb5g.awebp","path":"assets/faa389f1359544b382bcaf1b9b5227bbtplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-woeeb5g.awebp","modified":0,"renderable":0},{"_id":"source/assets/f469c168d72b40c6b23accd8ab652a22tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-t5puo5k.awebp","path":"assets/f469c168d72b40c6b23accd8ab652a22tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-t5puo5k.awebp","modified":0,"renderable":0}],"Cache":[{"_id":"source/_data/styles.styl","hash":"9b172b1183effd328fbc67b2b0144ee248fbe538","modified":1745288519455},{"_id":"source/categories/index.md","hash":"1395184f0d2558fb5718d6dc0ccbbea5e4c60927","modified":1745107735838},{"_id":"source/img/avatar.jpg","hash":"c83e297b31b2980e9754293df5fa61b550befe3a","modified":1745288519639},{"_id":"source/tags/index.md","hash":"59375ce68c4ea9cab11669ca4d232dc0b17eefb4","modified":1745107735841},{"_id":"source/assets/0b6fcecfe53184140bb4005dd0eab836-20230127151311-0gha64i.png","hash":"bae9a3ae5487965c67494f6a8bcc29f3796a4616","modified":1745288519463},{"_id":"source/assets/20200809110444386-20230127151311-z1qxdzv.png","hash":"d1bcf5cc5016c65c1c8dfd7ef23b36e6c947b39f","modified":1745288519463},{"_id":"source/music/index.md","hash":"e3e6eca7c734cdfb963a50f09bfedc715aadb118","modified":1745107735841},{"_id":"source/assets/2d694736eb7778a548cdcb8189d6e226-20230127151312-riapszh.png","hash":"e7ad32cf02bb6f432b89c5893c6f5e185a8f95b7","modified":1745288519471},{"_id":"source/assets/327dcba48317d39b2cd0ee081d4e3fdc-20230127151312-4qigjlr.png","hash":"0f2c302d870b7f675cef1d23767307c1b18bbc14","modified":1745288519471},{"_id":"source/assets/2edff9c3d5cb698abb0e62d720ad704b-20230127151311-dy2b8hg.png","hash":"58008120a30cf8d8ca11a32bfbc8534868c780f8","modified":1745288519471},{"_id":"source/assets/39c6a500cefa6e29150c1295d3e152d1-20230127151312-5z7fqgr.png","hash":"5168db5245f5d7e11cf5c6f32608177c1562af98","modified":1745288519475},{"_id":"source/assets/640-20230404215051-pdghyi7.png","hash":"4dd1944316313ba8c5858ffd16a52eaaf9e0aac8","modified":1745288519479},{"_id":"source/assets/b5e5ca9c35421192e7f02864c4fb30bb-20230127151311-iwgg2ln.png","hash":"ee2d610a81cf1cd720b9a311c1608418049375b7","modified":1745288519479},{"_id":"source/assets/c2d8c43d5c018eb584586ad5857fbbf4-20230127151311-ml2ddae.png","hash":"e92f93c660a7069be52d2b186a4ee48e67fc611c","modified":1745288519483},{"_id":"source/assets/da55da191ca558b60531e3a6b6ce5267-20230127151311-wiqzfgo.png","hash":"89b4dcffe22aaeb612f8d8d44395dcefbf4027f9","modified":1745288519483},{"_id":"source/assets/dubbo-modules-20221214214601-dcxfz3a.jpg","hash":"a81339084c61e6e88a645df24a100f99252ee2d8","modified":1745288519483},{"_id":"source/assets/dubbo-relation-20221214214601-7hb77fv.jpg","hash":"b6d8258211efaf56f5b84c3535512ab87fd91581","modified":1745288519483},{"_id":"source/assets/ff614ca7c83414c712848a25b23e6a91-20230127151312-slrk125.png","hash":"573f477c483695ffff8716221ce4e05c028c21c3","modified":1745288519487},{"_id":"source/assets/image-20230218230318-0kn4aj5.png","hash":"961ffed68b045a0327c4de05ceba7ed9678b06c6","modified":1745288519487},{"_id":"source/assets/image-20230218230318-31t0a0v.png","hash":"eea7d51faef16c0743fda3184a5f109ab5f946f3","modified":1745288519487},{"_id":"source/assets/image-20230218230318-i0g5orx.png","hash":"7c81b3ba2f3c7031dce4944d49c26b4620fd16a3","modified":1745288519487},{"_id":"source/assets/image-20230218230318-cknlz85.png","hash":"5994bf3ba95ef539a5d93906cd954a8ad924fc84","modified":1745288519487},{"_id":"source/assets/image-20230218230318-t4i4y3l.png","hash":"61b376acb2adadd3bbaeb6d7377e7d83c1ec0c05","modified":1745288519487},{"_id":"source/assets/image-20230218230318-w95qpr6.png","hash":"0418c9a1496a70f2bc26baf91356e735f9ef538c","modified":1745288519487},{"_id":"source/assets/image-20230218230318-ybffha3.png","hash":"5e16e58c0db061654c14558b1a4c510bc6d72a4a","modified":1745288519491},{"_id":"source/assets/image-20230218230318-ye9g47h.png","hash":"168de4de61f89f23e67201c2de59b272f79b6926","modified":1745288519491},{"_id":"source/assets/image-20230218230318-ypt4n3t.png","hash":"87eb13cbc9b90a9f11dd92e7a1e3cda8fb7d4a95","modified":1745288519491},{"_id":"source/assets/image-20230218230318-nedvesv.png","hash":"45e270b26ea7b43d6e0984c300a539723416e67f","modified":1745288519487},{"_id":"source/assets/image-20230423172026-j99710c.png","hash":"883bd920611be893fe581cc2e2e53f4bd4a85525","modified":1745288519491},{"_id":"source/assets/image-20230505215709-q6pir67.png","hash":"33fd34987cb9c5c0dbf947046e6cc9a1ec9ecc9a","modified":1745288519491},{"_id":"source/assets/image-20230519215732-zz9jpqo.png","hash":"d63b938154b8b371dbcba26dea785815738dc533","modified":1745288519491},{"_id":"source/assets/image-20231119124040-5kytmcz.png","hash":"c92f258000b91edf24db4fa57248184aab5d7ff0","modified":1745288519499},{"_id":"source/assets/image-20231126161709-b35di3t.png","hash":"9af051afa303573bb95b4c559aa1b446360ef447","modified":1745288519527},{"_id":"source/assets/image-20230218230318-t9tvsgp.png","hash":"84f584278240b51e3ccc1208a8510d850714312b","modified":1745288519487},{"_id":"source/assets/net-img-1582873055902-03de6700-dcb1-42a8-927e-af658b90b6b0-20230330213228-vjyh5tl.png","hash":"02396f78d1be8b02ca4cf7efd37ec051c443be38","modified":1745288519559},{"_id":"source/assets/net-img-1582873072467-a61dd6d9-f02a-4653-bcff-eeb592deaf68-20230330213234-ppelol3.png","hash":"c4709d68ebe2880391ccb3b31edf93587b7ad822","modified":1745288519559},{"_id":"source/assets/net-img-1582873090325-a7683e68-a46d-418f-bba5-0bd6c8c7575b-20230330213237-ldsjgn2.webp","hash":"957194f1a9e698a629eff8be47cca675ee9b9082","modified":1745288519559},{"_id":"source/assets/net-img-1582873156123-9f655847-4b5d-4c84-8116-ede849af16e3-20230330213218-q1lh95h.png","hash":"c3d698b9bb8502b82b1677eeccdf1dc5179a1c12","modified":1745288519563},{"_id":"source/assets/net-img-1582873335047-0818927f-77de-4ad8-aa95-fb7d537f6700-20230330213215-9u0gs7n.webp","hash":"325753c050aeadeb41abb811db6932fcc9756cd0","modified":1745288519563},{"_id":"source/assets/net-img-1582873144333-18753191-d8b2-47e1-a610-33c7c552fdaa-20230330213217-uigw9ix.png","hash":"64e5d7a35a0fdd7b382ff036fa463edc29f1af45","modified":1745288519563},{"_id":"source/assets/net-img-1582873601269-c3ee8a62-7c38-4751-8cff-f60ddc262d41-20230330213313-8vw56oe.png","hash":"d4c6236d7806c168e159e57501764179442a6839","modified":1745288519567},{"_id":"source/assets/net-img-1582873416741-a71a0d28-b66d-49ca-8487-c0e0ceaa704c-20230330213216-jddkbfu.webp","hash":"607b6b8b44d4ebf8d11cda966f2c047942e62b47","modified":1745288519563},{"_id":"source/assets/net-img-1582873927778-b80fd046-98af-4768-bfc1-6d59761271e2-20230330213325-w0s4a7u.png","hash":"369ef2ab199332ff160f82fce185f96c7e408345","modified":1745288519567},{"_id":"source/assets/net-img-1582873954652-cd9e9eab-021c-4792-9558-291d9ec5d743-20230330213333-aijfe0m.png","hash":"a25433de852d27f730cd4abef66576122429b314","modified":1745288519567},{"_id":"source/assets/net-img-1582873104499-77f0b1b3-a218-4cc7-9cd1-c5ab317f53ce-20230330213239-aq0b92g.png","hash":"1ee2406b2b6ad8e8cdd96b301e76b353c8a9c229","modified":1745288519563},{"_id":"source/assets/net-img-1582873690823-e85d7b31-4173-4adc-b4b4-92f314fd952b-20230330213322-ngp5u86.webp","hash":"12465e7924ed4b09fe0192921b8337dae8db4b9a","modified":1745288519567},{"_id":"source/assets/net-img-1582874243939-2eae4163-881d-47f6-b75d-18c057db48ef-20230330213158-setmh7t.webp","hash":"96b5d70ff0bdab3d8180fb713dd6e8ba30d505ed","modified":1745288519571},{"_id":"source/assets/net-img-1582874168420-5865fe9a-fe6d-49b5-961a-2addc05fce6a-20230330213157-z8hfg9r.webp","hash":"cef07fcb1e58699024480d7b5c584d90aba0228b","modified":1745288519571},{"_id":"source/assets/net-img-1582874168964-bb84b249-5332-4a93-b161-842b2e6955ed-20230330213157-wrr6xqk.webp","hash":"a141b07c1984453e310c582226e442062e78ae56","modified":1745288519571},{"_id":"source/assets/net-img-1582874279332-65260fd7-5a39-4fd1-85b8-86729cc9982c-20230330213159-yohdmn5.webp","hash":"a6d62b42aebc0b63cb37a508191422a363e18ae9","modified":1745288519571},{"_id":"source/assets/net-img-1582874334522-3936dfde-ef4a-4cf9-ab86-6001429fbb86-20230330213343-txdiivw.jpeg","hash":"870924d44a9995a72ad2d1715ca8466e4f932b25","modified":1745288519571},{"_id":"source/assets/net-img-1582875290415-c052f229-8c31-4560-acef-300acae2409b-20221030135515-tme9bzx.png","hash":"8ef7b28179b9da9186474531f7739c3fff3cbd10","modified":1745288519571},{"_id":"source/assets/net-img-1582875326094-cb5a96e7-e4c2-421d-83cf-216ca4f7f024-20221030135516-5igfhr6.png","hash":"e0ff2aee5d376fb0101a542728f5909eede94315","modified":1745288519571},{"_id":"source/assets/net-img-1582875326657-55738037-28bf-4de9-925a-f08034e0c722-20221030135516-j4ktjne.png","hash":"96ee4e7065f5263abeb8d95a11ce0a18a84f494f","modified":1745288519571},{"_id":"source/assets/net-img-1582875381841-0104c814-acd3-4ef3-a3bd-f5331d9a06bc-20221030135516-0716ftg.png","hash":"80f1bf83e38d1461dc6910d6a30f79d6e2a1394b","modified":1745288519571},{"_id":"source/assets/net-img-1582874136797-a333d011-4325-4f7c-82f6-9792216b1a21-20230330213157-i9zy78v.webp","hash":"34290e221871996dca8c8375aa428da463082adb","modified":1745288519571},{"_id":"source/assets/net-img-1582874350036-1fb8d7cf-688f-4628-ae77-9a21de7c4d2e-20230330213346-aj91hqy.png","hash":"c7fad5d3499a6e0d8e4c4d560da5cddb7a36a55a","modified":1745288519571},{"_id":"source/assets/net-img-1582875452927-44c67a88-5cee-48b1-a764-a26d40a77538-20221030135540-f7dfpln.png","hash":"2daf9869605e16a37c4418c28e52afec9866c7db","modified":1745288519571},{"_id":"source/assets/net-img-1582875462202-61de3608-d606-44f6-b8d0-c82da3a7acd8-20221030135541-a1152vd.png","hash":"94df1ef507bac6d026fa641efdffa9bc09a61a13","modified":1745288519571},{"_id":"source/assets/net-img-1582875470139-ea71ffbe-3cbd-44d8-8560-1e72b3a4bab4-20221030135541-hkuw6hs.png","hash":"9d13278bb6ad5ab8a07fd25d0affc856348afbbc","modified":1745288519571},{"_id":"source/assets/net-img-1582875605484-a8880998-f9be-42d5-9997-a1c908ca05a9-20221030103933-jzsw591.webp","hash":"0dc72ecb95f0deb30a2fcd8b198821b605bd04ea","modified":1745288519575},{"_id":"source/assets/net-img-1591690708309-b6db1e95-1bbf-4140-b612-26fefc8d85b5-20221030132327-6s3ed7l.png","hash":"52f3bbca5eb07588c0f47b6cde9f9fa1745631a4","modified":1745288519575},{"_id":"source/assets/net-img-1582874272168-5169d4d6-17f9-493d-b99b-c9a678dd13da-20230330213159-jscv9ip.webp","hash":"9989009c49220d7ad185cf7e1daecdb15af6d1da","modified":1745288519571},{"_id":"source/assets/net-img-1582875399701-d03e5b25-a1c9-498e-85d6-18f86f41e38f-20221030135517-a6hu6sv.png","hash":"926070ac7bf26f22aab50a0f1b4ad414a02a22fd","modified":1745288519571},{"_id":"source/assets/net-img-1582875478351-18a69ed7-cb09-4a5a-a020-097490219718-20221030135517-0h9pq4n.png","hash":"0828e1ca982af7beedadf87586333ed1cf72fa39","modified":1745288519571},{"_id":"source/assets/net-img-1593076049581-f084ed7e-111c-4a99-944b-bb4aadb0f33b-20230330213209-kp1deud.png","hash":"572c4ff3a54622992e4754d21dc167429bcd50ff","modified":1745288519591},{"_id":"source/assets/net-img-1593076060148-a751342f-828e-49f2-a853-47b276d0fc68-20230330213209-k1w1si6.png","hash":"6ac6a432217bf88a0f8a20b143a9614ea8f078ef","modified":1745288519591},{"_id":"source/assets/net-img-1593854466438-89baf576-0e30-4db7-934e-2781413c9510-20221030140124-w8acjeh.png","hash":"aa5311b240c042132db43fd8ad7c9fd5e2684e44","modified":1745288519591},{"_id":"source/assets/net-img-1596361953803-ed588642-562c-49e8-99dd-cdc0e81519b7-20230426150127-crjga75.png","hash":"412de8e9c61132120a513b6dc1f1346c4f318f5e","modified":1745288519591},{"_id":"source/assets/net-img-1596362023744-7f76e71b-8cd9-4797-87f7-bccdb93fbb3a-20221030140106-k1plvtd.jpeg","hash":"871111348a751329bfc43b7558b117ab0fb54781","modified":1745288519591},{"_id":"source/assets/net-img-1593076076024-42ad7f21-eb2c-4c6b-8c34-802819b1fd8f-20230330213209-f5hjado.png","hash":"485de0eed404f2cdfe10a922214864646c536df1","modified":1745288519591},{"_id":"source/assets/net-img-1596783496811-3a6ed88c-bb38-40b7-aaf3-ca98b12493f2-20221030105031-aijlekh.jpeg","hash":"5bfb117e03defcf9d738674cf866591401250d25","modified":1745288519595},{"_id":"source/assets/net-img-1602123134723-ab15ac69-5397-4422-8dcf-3c43f4a10e06-20221030124512-4k4z367.png","hash":"faf44e5bbb92043e8b5781e7319f87b546001ea5","modified":1745288519595},{"_id":"source/assets/net-img-1602123013155-86ac51db-7d0a-4241-8094-f1fe2e16b43c-20221030124512-fqt8gu2.png","hash":"39b5117e13e5ec7803b99c9d8c9bd63784d09f54","modified":1745288519595},{"_id":"source/assets/net-img-1593076140792-4ab064fd-2370-4f64-a89e-6d7fc5bb9f39-20230330213209-drma95r.png","hash":"f57af1b9c0bf6dcba32d0394fc6778030f4d8147","modified":1745288519591},{"_id":"source/assets/net-img-1615533992554-f7ecd3db-e7d5-4f29-b845-a22cb39dee76-20230426150127-m6xofsl.png","hash":"99b89d8e0dc371e00ad8ca4e57c31fd470372296","modified":1745288519599},{"_id":"source/assets/net-img-1615535960262-7646f229-98d2-4474-be5c-3e5dd3c3e7ac-20221030140153-c14thj0.png","hash":"413ce886d78c230e5721a2238e703cd686208aa9","modified":1745288519599},{"_id":"source/assets/net-img-1625277244322-1304b001-049b-467f-9207-4012228cca38-20221031123243-oqmq9cu.jpeg","hash":"b715ae4a307faa63a555fef73f50a7e67219f8d2","modified":1745288519615},{"_id":"source/assets/net-img-1602510155856-cf2ddad6-d6bb-4ea0-bb8c-f9b1dc49cee8-20221030124433-3c4w0ya.png","hash":"3cd3283688af621e14353a63ae12c976b3b96cd7","modified":1745288519595},{"_id":"source/assets/net-img-1628324723790-e7e469c7-62d0-4076-aa53-5e937ae80bee-20230122192859-e7kchm7.jpeg","hash":"c564a0797766a360cb3d700344659bcb1a63a5af","modified":1745288519619},{"_id":"source/assets/net-img-1631436389678-e6910ed9-8e3c-4d73-93bf-362566a4ebb0-20230330213421-crfgpeh.png","hash":"3a084424eb7936f0e84046f2ed80e94e5a82d243","modified":1745288519623},{"_id":"source/assets/net-img-1639574230606-ee713d6a-1223-4275-bfaa-f60258aa6eea-20221030132914-2yfiwaf.jpeg","hash":"da8ff67b12daf7bc3384b335f9baa0924bb7de74","modified":1745288519623},{"_id":"source/assets/net-img-1646740660775-762fcaa3-26b5-4d95-ac43-5cca58540969-20230330213439-sxz1b5i.png","hash":"c85a97f212680ea6313e5b59dc14a4fd660bf2d9","modified":1745288519623},{"_id":"source/assets/net-img-1665073234010-c17ae82e-6da7-479a-ba1c-b1543abba0d5-20221111215525-80jshsc.png","hash":"f021b7c6e560a155d4e76284566214ce181fe201","modified":1745288519623},{"_id":"source/assets/net-img-1665073313636-93fb8cb7-e679-4c0f-8067-885d28f67ded-20221111215526-vcl9xfw.png","hash":"17f4f5b751e089a0d76b52e471ec5c9a2ceff444","modified":1745288519623},{"_id":"source/assets/net-img-1645242293838-01142675-6027-4b29-8f4d-1d872c2d6cea-20221030140106-8zicdb0.png","hash":"be0a7ca296495c45aeefa6205ee972c27fc09d3f","modified":1745288519623},{"_id":"source/assets/net-img-1665073358729-865ac7d0-89b5-4cc8-814e-a892038da58b-20221111215525-k257bcx.png","hash":"0ca686dd92e384559cc5bd7ed4110b5589a489e8","modified":1745288519623},{"_id":"source/assets/net-img-1665073365265-002fd960-3cab-45d5-a547-968487191335-20221111215525-51j8yv0.png","hash":"f021b7c6e560a155d4e76284566214ce181fe201","modified":1745288519623},{"_id":"source/assets/net-img-1665073370943-3b2e7f1c-7c9a-46a3-9e37-31742edea2f4-20221111215525-xb7w2cn.png","hash":"3ef96c77a510a92610cca91745e6818fca50f32c","modified":1745288519623},{"_id":"source/assets/net-img-1665073398713-d6f47c91-e7a2-407a-9cc0-de52b301cf26-20221111215526-gwi38jk.png","hash":"7c6c6a376b2d11bea215fa3f0396944ee98a0bf2","modified":1745288519623},{"_id":"source/assets/net-img-1665073405592-73518a43-9c02-4d55-baee-bafcff044efe-20221111215526-c9mhwt8.png","hash":"db37da8537372287a3483ee2088adbf70c908b3e","modified":1745288519623},{"_id":"source/assets/net-img-1665073414310-928255a5-b8a0-4a7b-817f-dbabda18feef-20221111215526-c0gy94f.png","hash":"03eda78dbd90f3e27b35c07b6149ebb22f80c60a","modified":1745288519623},{"_id":"source/assets/net-img-1665073424520-10dfe592-ea00-4ea5-b46e-992601919f1f-20221111215526-q1f6my9.png","hash":"5732bdd2254fc2df9b32ed878191af5c9c203857","modified":1745288519623},{"_id":"source/assets/net-img-1665073433573-ed1fdba5-d19f-40c2-a4f9-96a6ddbff0d2-20221111215526-5pgyp70.png","hash":"cd07f2413a92f7bfbc47ed997015527862cd2d26","modified":1745288519623},{"_id":"source/assets/net-img-1665073347225-5388dfc6-3fc2-4492-902c-b7fcd02f3245-20221111215525-4h0vo0n.png","hash":"11c3c24fada168360225f3da625dbf1940d1ebae","modified":1745288519623},{"_id":"source/assets/net-img-1665073353104-76e6707d-af7c-4e84-97dd-7458adee7994-20221111215525-0zkzrc2.png","hash":"3ef868230856bca16fb92c66fad7d37199561848","modified":1745288519623},{"_id":"source/assets/net-img-1665073440336-5f261660-b58b-4c06-9c1d-f21c0865e31c-20221111215526-0s6pvi9.png","hash":"fba77817166eca4d0a2606451c136c09ce22b0c0","modified":1745288519623},{"_id":"source/assets/net-img-1665073460709-ab3783c9-f4f3-46ae-ab45-fe489a701313-20221111215526-4cnfbe6.png","hash":"20ef0c0783a74dd7d0bc460949462b9502e2c060","modified":1745288519623},{"_id":"source/assets/net-img-1665073467540-2062cc90-042f-4ea8-8dbc-1afa0c8232c7-20221111215527-13hnynb.png","hash":"c84aeb21cb1986b15d68ecc274e8e73d2422e3c3","modified":1745288519623},{"_id":"source/assets/net-img-1665073484287-631d0da3-1bb4-4881-b567-647d058f4f47-20221111215527-l67jrtu.png","hash":"948d0c45ed7ffa9b202a60d247a0d1f961ecf147","modified":1745288519623},{"_id":"source/assets/net-img-1665073567805-1c681335-41e9-40c3-a02a-0155e0383924-20221111215527-s7tudvn.png","hash":"1aa5dc9f6b8ac8ab605ae58386281637ea30e2c7","modified":1745288519623},{"_id":"source/assets/net-img-1665073576092-3eea97da-b483-4acc-a6fd-eece98224cd0-20221111215527-fr7igf9.png","hash":"1dccaa650671139a972c29df9bab164cc9bd41d8","modified":1745288519623},{"_id":"source/assets/net-img-1665073596487-2a45c98e-71a7-45e8-a0c2-ac4b06cd0cff-20221111215527-fzwff39.png","hash":"4ea4eb5389253148560fe2f84be9949baf4ea1e2","modified":1745288519627},{"_id":"source/assets/net-img-1665073473485-b4b83d79-2af4-4681-9d50-1c9096dc935c-20221111215527-zawp2eq.png","hash":"f07245405e0b6c65db1543d51618afc03188b6c9","modified":1745288519623},{"_id":"source/assets/net-img-1665073448391-a1d5eef7-134c-4b01-9c2e-2df8cc9ec893-20221111215526-gp8xqtg.png","hash":"459a880bf0f7383a95471dd2fb8557743f84f7f5","modified":1745288519623},{"_id":"source/assets/net-img-1665073635044-265417f7-ec52-4a11-9a17-929aa008498c-20221111215527-s30ehyk.png","hash":"6111298420b3d37a2abdfbb525ca7a462a6eec42","modified":1745288519627},{"_id":"source/assets/net-img-1665073657734-f1c3e079-3804-43d3-8e30-9b46530ad337-20221111215527-74wm25r.png","hash":"fc0fcbcaa2176b4165d445deff78632786aba535","modified":1745288519627},{"_id":"source/assets/net-img-1665073663657-eac74193-3f2d-4823-b1ce-076ee644f1ba-20221111215527-ce3yoc2.png","hash":"c32e7b43243a7c3bba6e278596a971fcfe4c5626","modified":1745288519627},{"_id":"source/assets/net-img-1665073671982-4bc2b9c6-228b-49a6-96ed-ab6555a1b26d-20221111215527-af0xz7y.png","hash":"b5c7a29925623db00334fc81da68e7d67e9b8c30","modified":1745288519627},{"_id":"source/assets/net-img-1665073733517-eb68002c-afc1-4746-96e4-0fa95b21bfad-20221111215533-jinki2i.png","hash":"d9b4a0218a7653d5650c5820ddf7f6cb939b9255","modified":1745288519627},{"_id":"source/assets/net-img-1665073630217-bd1f44be-c442-48c7-9478-62d7f8fc79ce-20221111215527-fmqia49.png","hash":"30b83f99717332339d4fc99ad3d24b6b09fa1195","modified":1745288519627},{"_id":"source/assets/net-img-1665073624592-674dd74d-86d2-4605-9955-7a16e09a1cb4-20221111215527-1blmix8.png","hash":"476ee418d2e2e1df657a5e4c52fc46fafb7e6aeb","modified":1745288519627},{"_id":"source/assets/net-img-1665073607553-c63d8f6f-883c-4ce4-9acd-3861c0ffd7ff-20221111215527-e9urwmu.png","hash":"58792d335b56d61df03a0c719534b9ebe175ca06","modified":1745288519627},{"_id":"source/assets/net-img-1665887374286-cdf6dee1-f1f2-4de2-8fdd-0652d9e2f667-20221030140113-kzrzbzq.webp","hash":"e81b945e532f9bf366758c468c3770749ad5f729","modified":1745288519631},{"_id":"source/assets/net-img-1665887401184-ef95895d-d794-43e2-8d11-46c0b6186d3a-20221030140113-0svrost.webp","hash":"b9cc68508d12b2d5167602efd3e447eed2852a99","modified":1745288519631},{"_id":"source/assets/net-img-4122e8fc2d6e2995074ede61ff44aef4-20230330213516-hs7yexh.svg","hash":"de008cd5d533e2399ea43a9e0ac40f01d45ccf75","modified":1745107735823},{"_id":"source/assets/net-img-1665073776507-524d18b7-c84e-4311-a742-c02a67d7a63e-20221111215534-h1bzg7o.png","hash":"70ce12adde5768aa3d7f75fcd23c01bba60a1481","modified":1745288519631},{"_id":"source/assets/net-img-1665887335160-92fef518-ebb8-4a80-8bba-39f60880a491-20221030140113-ritolt8.webp","hash":"13169ab8c1647fc0aed80b0917e77d124ae2e772","modified":1745288519631},{"_id":"source/assets/net-img-4122e8fc2d6e2995074ede61ff44aef4-20230527145229-bw8f49a.svg","hash":"de008cd5d533e2399ea43a9e0ac40f01d45ccf75","modified":1745107735823},{"_id":"source/assets/net-img-640-20221123123914-g18ng9z.png","hash":"fed1d8bb65255b53f32f1dad99c958516440db00","modified":1745288519635},{"_id":"source/assets/net-img-Javb7R-20221030105018-f0nmumb.jpg","hash":"6643e83588989e0b9c562ecb62522511134180da","modified":1745288519635},{"_id":"source/assets/net-img-NIKEYn-20221030105009-qtc7vqs.jpg","hash":"96d4d9622ab94e815195a267ebd748deeca387d5","modified":1745288519635},{"_id":"source/assets/net-img-NILhqg-20221030105009-gkjt4x4.jpg","hash":"cf376bbe8f2ca07f66dba0bd27632de1d5a917b3","modified":1745288519635},{"_id":"source/assets/net-img-Nxg2RI-20221030140124-2j3rd9u.png","hash":"aae52ae2b5b8dd06bf02d43ee65d3dea3fbe1507","modified":1745288519635},{"_id":"source/assets/net-img-regexp-cn-20221030151436-zbahpvf.png","hash":"11e9763df7885e5f0102411d0d3097baac0be549","modified":1745288519639},{"_id":"source/assets/recover1.jpg","hash":"c3bed5eede5543317b5b1d1e6131510f12713d9d","modified":1745288519639},{"_id":"source/assets/recover2.jpg","hash":"6c25fad45107d0e81cfc93f6e72c8797d42fd120","modified":1745288519639},{"_id":"source/assets/net-img-NHqeHS-20221030124555-egcayk2.png","hash":"579571e4e43197309ab62b28f5b8d0298e7914b1","modified":1745288519635},{"_id":"source/_posts/java/Base.md","hash":"a2b306964de8955c0391c9019321b32d87a16570","modified":1745107735544},{"_id":"source/_posts/java/Collection.md","hash":"d37302730014f1617293ff7e00d8959733944b6a","modified":1745829708386},{"_id":"source/_posts/java/JVM.md","hash":"dcd32f95a6e022051ec3b5dd050dfb50923b2df2","modified":1745829708389},{"_id":"source/_posts/java/JavaWeb.md","hash":"518e78131fe061450ca36a4c1af821ef18a8b48b","modified":1745107735553},{"_id":"source/_posts/java/thread.md","hash":"43b40f3044194f891d2be8d79624f59e0fc3600b","modified":1745829708394},{"_id":"source/img/svg/bilibili.svg","hash":"e6c75b45007399f850ad762f6360297215dc4144","modified":1745107735840},{"_id":"source/_posts/Effective-Java/01. 考虑使用静态工厂方法替代构造方法.md","hash":"bf82552d626cfeabf87e726cb2c6675ae4bd25a0","modified":1745288519455},{"_id":"source/_posts/Effective-Java/02. 当构造方法参数过多时使用builder模式.md","hash":"8120c558078a9340f4149b6b3314268a99828cde","modified":1745288519455},{"_id":"source/_posts/Effective-Java/03. 使用私有构造方法或枚类实现Singleton属性.md","hash":"f411ca4722f126d8415af856d953c0c7767a1293","modified":1745288519455},{"_id":"source/_posts/Effective-Java/04. 使用私有构造方法执行非实例化.md","hash":"0339c29d7d45b2a5302fc337fad93b8fc78a6e35","modified":1745288519455},{"_id":"source/_posts/Effective-Java/05. 依赖注入优于硬连接资源(hardwiring resources).md","hash":"85efac1482bc39b1941e556204c4a61c445340f1","modified":1745288519455},{"_id":"source/_posts/Effective-Java/06. 避免创建不必要的对象.md","hash":"6746fbd853989b4492732c7a9b88feacfa00ba0d","modified":1745288519455},{"_id":"source/_posts/Effective-Java/07. 消除过期的对象引用.md","hash":"6fc4d34463713d1668bdcec350e5ddcfa3f97226","modified":1745288519455},{"_id":"source/_posts/Effective-Java/08. 避免使用Finalizer和Cleaner机制.md","hash":"28401601e39153e760eb000c74093052d757d5bb","modified":1745288519455},{"_id":"source/_posts/Effective-Java/09. 使用try-with-resources语句替代try-finally语句.md","hash":"fad5dc2c872ad2a7f66aa033019e757658af25b1","modified":1745288519455},{"_id":"source/_posts/java/ByteBuddy.md","hash":"3146810f87d7459bfd72e10a5c5cd8a3e2041a72","modified":1745829708385},{"_id":"source/_posts/Effective-Java/10. 重写equals方法时遵守通用约定.md","hash":"cbfc0ef2445c206b6092630d7774abedd9be4ece","modified":1745288519455},{"_id":"source/assets/net-img-640-20230330193532-4safylx.png","hash":"fef4a36094e1d2d446dcd6db1bd08bde2a33afd8","modified":1745288519635},{"_id":"source/_posts/Effective-Java/13. 谨慎地重写 clone 方法.md","hash":"6ee8a68a1b242614801f25646f0c08dbdfaa94ce","modified":1745288519455},{"_id":"source/_posts/Effective-Java/14. 考虑实现Comparable接口.md","hash":"812d3cf33fe2ba9961ad6a284c7efb5dde0a1ffa","modified":1745288519455},{"_id":"source/_posts/Effective-Java/15. 使类和成员的可访问性最小化.md","hash":"aced087d4fc9f05613cacb8d7856922fa9bcd06b","modified":1745288519455},{"_id":"source/_posts/Effective-Java/16. 在公共类中使用访问方法而不是公共属性.md","hash":"9338fdff29af02f3a7560e396d754bd96f0d2f79","modified":1745288519455},{"_id":"source/_posts/Effective-Java/17. 最小化可变性.md","hash":"4af808fedf1de24405a3a8fc1d979af573f9c3e1","modified":1745288519455},{"_id":"source/_posts/Effective-Java/18. 组合优于继承.md","hash":"e2e9ab02336ae7bb850af8dfe5b6e1f96f1d5060","modified":1745288519455},{"_id":"source/_posts/Effective-Java/19. 要么设计继承并提供文档说明，要么禁用继承.md","hash":"d81c11513f2e403920bb1c2baf2f220e82b744a0","modified":1745288519455},{"_id":"source/_posts/Effective-Java/20. 接口优于抽象类.md","hash":"65d5faf545a58d67d22774561246b4ade6348d36","modified":1745288519455},{"_id":"source/_posts/Effective-Java/21. 为后代设计接口.md","hash":"3b43b9a0f2f25c3d42aa2080af8bee5b8b815ca8","modified":1745288519455},{"_id":"source/_posts/Effective-Java/22. 接口仅用来定义类型.md","hash":"90db2cbffb13ccb82a578a0adace90ff8d94594c","modified":1745288519455},{"_id":"source/_posts/Effective-Java/23. 类层次结构优于标签类.md","hash":"479947cee3105310e77a35fb0f569b6d7bb92071","modified":1745288519455},{"_id":"source/_posts/Effective-Java/24. 支持使用静态成员类而不是非静态类.md","hash":"1149464abeb6caa0723359bbc002836bde2de78a","modified":1745288519455},{"_id":"source/_posts/Effective-Java/25. 将源文件限制为单个顶级类.md","hash":"59c223128d423ea1cec024038a026870aad1676d","modified":1745288519455},{"_id":"source/_posts/Effective-Java/26. 不要使用原始类型.md","hash":"0d38f2acd1a496d5a5885aa8c7e8aa43ec3f67d3","modified":1745288519455},{"_id":"source/_posts/Effective-Java/12. 始终重写 toString 方法.md","hash":"3680b5a8dd288695c81e4a0bbf67de9056a7a6ae","modified":1745288519455},{"_id":"source/_posts/Effective-Java/28. 列表优于数组.md","hash":"a3bd075dd95392e8141a642e3cf8b080f46c3fc4","modified":1745288519455},{"_id":"source/_posts/Effective-Java/29. 优先考虑泛型.md","hash":"5a39f728e738890b83e83b20422560bd9e7c835d","modified":1745288519455},{"_id":"source/_posts/Effective-Java/30. 优先使用泛型方法.md","hash":"a47797d88179519b19f602559936e3f8e70a813f","modified":1745288519455},{"_id":"source/_posts/Effective-Java/27. 消除非检查警告.md","hash":"85735e3582edb0dd46445bd2a2e2f727f3bd2c39","modified":1745288519455},{"_id":"source/_posts/Effective-Java/31. 使用限定通配符来增加API的灵活性.md","hash":"888cde29cd1335fa1b581bf4954cc2afa0a83bd7","modified":1745288519455},{"_id":"source/_posts/Effective-Java/33. 优先考虑类型安全的异构容器.md","hash":"4d920ebf9ecec110e0fbd68e087675e273ff6617","modified":1745288519455},{"_id":"source/_posts/Effective-Java/34. 使用枚举类型替代整型常量.md","hash":"5c6eec649d269dede8fb3a09d7067207c56e6359","modified":1745288519459},{"_id":"source/_posts/Effective-Java/35. 使用实例属性替代序数.md","hash":"b44cf12f22129e65ed7396f31ac8ea05198b4d9c","modified":1745288519459},{"_id":"source/_posts/Effective-Java/36. 使用EnumSet替代位属性.md","hash":"99e60cf43ae97615138e001a09b6e8802f52ee70","modified":1745288519459},{"_id":"source/_posts/Effective-Java/37. 使用EnumMap替代序数索引.md","hash":"4990936c24b785b1e5165b5acbcb4f17c53a3b2a","modified":1745288519459},{"_id":"source/_posts/Effective-Java/38. 使用接口模拟可扩展的枚举.md","hash":"1d75b857acbd0fcaea3bd38b5bb4110d7bc1238e","modified":1745288519459},{"_id":"source/_posts/Effective-Java/39. 注解优于命名模式.md","hash":"5fb9f1404d26a22007410ccda5a6b180e0a7b6f9","modified":1745288519459},{"_id":"source/_posts/Effective-Java/40. 始终使用Override注解.md","hash":"02d80972d51ffc9084643718549f2e5ef4a4021c","modified":1745288519459},{"_id":"source/_posts/Effective-Java/41. 使用标记接口定义类型.md","hash":"8f55d00706ac87c619c0d077613f011e50a1c83d","modified":1745288519459},{"_id":"source/_posts/Effective-Java/42. lambda表达式优于匿名类.md","hash":"1b3dfed0e9711c1a4bb87491761eb20f692321ea","modified":1745288519459},{"_id":"source/_posts/Effective-Java/43. 方法引用优于lambda表达式.md","hash":"54bb636380e25042ceb3d85816035d1626a4a38a","modified":1745288519459},{"_id":"source/_posts/Effective-Java/11. 重写equals方法时同时也要重写hashcode方法.md","hash":"cdb7a1a8d9d672e57d15a166681b90a66088710f","modified":1745288519455},{"_id":"source/_posts/Effective-Java/44. 优先使用标准的函数式接口.md","hash":"82fffdc414aaeb40925ee6fc3a104fcad2e18eb5","modified":1745288519459},{"_id":"source/_posts/Effective-Java/32. 合理地结合泛型和可变参数.md","hash":"c7c775db271304c87f7eceb81885ea80a1b70675","modified":1745288519455},{"_id":"source/_posts/Effective-Java/49. 检查参数有效性.md","hash":"7de98ffc44195560e2b8970f57e8ecf03d964a62","modified":1745288519459},{"_id":"source/_posts/Effective-Java/47. 优先使用Collection而不是Stream来作为方法的返回类型.md","hash":"bc70de6759da3d920e473c55090aa8eef04b79eb","modified":1745288519459},{"_id":"source/_posts/Effective-Java/50. 必要时进行防御性拷贝.md","hash":"38aaed60f94ecd5dbd7bbfe31d7bdd0d7be7f739","modified":1745288519459},{"_id":"source/_posts/Effective-Java/51. 仔细设计方法签名.md","hash":"8916171efa5c08766b1bacd1a09781e7b1d75f90","modified":1745288519459},{"_id":"source/_posts/Effective-Java/52. 明智审慎地使用重载.md","hash":"daf4a5d3aa484325f1c449671337489cbce8666e","modified":1745288519459},{"_id":"source/_posts/Effective-Java/53. 明智审慎地使用可变参数.md","hash":"ca0dac0ae97bab0e37f0b3a3a4d22dab5a18bff0","modified":1745288519459},{"_id":"source/_posts/Effective-Java/54. 返回空的数组或集合，不要返回 null.md","hash":"cdb723fec7959808ace54a73dbfe3d3c1e26ff8e","modified":1745288519459},{"_id":"source/_posts/Effective-Java/55. 明智审慎地返回 Optional.md","hash":"729d8c069eebef73b1afc518a7320ca40c903f13","modified":1745288519459},{"_id":"source/_posts/Effective-Java/56. 为所有已公开的 API 元素编写文档注释.md","hash":"87c48400c0cb3f44a9ed4aa1cb4326bcf524a0b7","modified":1745288519459},{"_id":"source/_posts/Effective-Java/45. 明智审慎地使用Stream.md","hash":"de9b89b42eb5463311d4ddf963739abeb4f1895b","modified":1745288519459},{"_id":"source/_posts/Effective-Java/57. 最小化局部变量的作用域.md","hash":"093c42a74d1900bfe724d06081c9907e7b2df92d","modified":1745288519459},{"_id":"source/_posts/Effective-Java/59. 了解并使用库.md","hash":"068aecbebfb3142f849901cdd278300576551919","modified":1745288519459},{"_id":"source/_posts/Effective-Java/48. 谨慎使用流并行.md","hash":"f8037ba7e8fb5679abdc82b65b33e421a517a288","modified":1745288519459},{"_id":"source/_posts/Effective-Java/58. for-each 循环优于传统 for 循环.md","hash":"43a387159242012195bced6da086c9a7b566eb93","modified":1745288519459},{"_id":"source/_posts/Effective-Java/60. 若需要精确答案就应避免使用 float 和 double 类型.md","hash":"387858bb3f93fa140a729876d1c61b81c0d65175","modified":1745288519459},{"_id":"source/_posts/Effective-Java/46. 优先考虑流中无副作用的函数.md","hash":"d5d493109045592dbe6902e59b1bcc41d72a3b6a","modified":1745288519459},{"_id":"source/_posts/Effective-Java/61. 基本数据类型优于包装类.md","hash":"0629f49ca9b26ccef39746df2ef64fa234fe78c3","modified":1745288519459},{"_id":"source/_posts/Effective-Java/63. 当心字符串连接引起的性能问题.md","hash":"84d2b5361146b45c690c28654414ab97b4770bf1","modified":1745288519459},{"_id":"source/_posts/Effective-Java/62. 当使用其他类型更合适时应避免使用字符串.md","hash":"d0519186405bf5c90086f9bb998390d01d393a6c","modified":1745288519459},{"_id":"source/_posts/Effective-Java/64. 通过接口引用对象.md","hash":"aebfc8b1f213741059800b4bcc2e1947dad90d36","modified":1745288519459},{"_id":"source/_posts/Effective-Java/65. 接口优于反射.md","hash":"5244b9242369e1335e4f014dcd764fd4d82d7add","modified":1745288519459},{"_id":"source/_posts/Effective-Java/66. 明智审慎地本地方法.md","hash":"ce70eb18f625b7caf759439a62445da1360a66e6","modified":1745288519459},{"_id":"source/_posts/Effective-Java/68. 遵守被广泛认可的命名约定.md","hash":"e057a695373948ec7976995db1d50d04d723fd77","modified":1745288519459},{"_id":"source/_posts/Effective-Java/69. 只针对异常的情况下才使用异常.md","hash":"eb3731eb2bd75cce2b9a5270f8f200ba6cc02de9","modified":1745288519459},{"_id":"source/_posts/Effective-Java/67. 明智审慎地进行优化.md","hash":"d4b35b657379fab42a9cdfde2f8420fccff3b587","modified":1745288519459},{"_id":"source/_posts/Effective-Java/70. 对可恢复的情况使用受检异常，对编程错误使用运行时异常.md","hash":"1d3ca76f5ea397d7ad9595de51bdbb6a9aad89b1","modified":1745288519459},{"_id":"source/_posts/Effective-Java/71. 避免不必要的使用受检异常.md","hash":"469b2092d08d7bf47cc70ca6e496184797adae72","modified":1745288519459},{"_id":"source/_posts/Effective-Java/72. 优先使用标准的异常.md","hash":"672eb2ce27165fb007da0c8430e07ce2256481b5","modified":1745288519459},{"_id":"source/_posts/Effective-Java/73. 抛出与抽象对应的异常.md","hash":"95a1f3ff9a83a77f7a4fb449dbadd389643c2273","modified":1745288519459},{"_id":"source/_posts/Effective-Java/74. 每个方法抛出的异常都需要创建文档.md","hash":"8eb6f3c815e4b7f2b41b949c2df7485946bad057","modified":1745288519459},{"_id":"source/_posts/Effective-Java/76. 保持失败原子性.md","hash":"65d6765471e16ba4e17ef34ceaa471afc7fc0fc4","modified":1745288519459},{"_id":"source/_posts/Effective-Java/75. 在细节消息中包含失败一捕获信息.md","hash":"e663f3502b06e080f661ccdaf344768456bd0a89","modified":1745288519459},{"_id":"source/_posts/Effective-Java/77. 不要忽略异常.md","hash":"e4ec2077f4c00cf1efc363a590ef16c25fa2eb7e","modified":1745288519459},{"_id":"source/_posts/Effective-Java/78. 同步访问共享的可变数据.md","hash":"96e65c1571023b5bcca872739e918f0b3e68ed5d","modified":1745288519459},{"_id":"source/_posts/Effective-Java/79. 避免过度同步.md","hash":"0a5bf93933a4374fd2086d1360f138737fac82b3","modified":1745288519459},{"_id":"source/_posts/Effective-Java/80. executor 、task 和 stream 优先于线程.md","hash":"69ed86a33ac7eeffe52e3a0f7809c70a704110db","modified":1745288519459},{"_id":"source/_posts/Effective-Java/81. 并发工具优于 wait 和 notify.md","hash":"8a0f32cc5e543b9dd50b87c2404e6558ff818cbd","modified":1745288519459},{"_id":"source/_posts/Effective-Java/82. 文档应包含线程安全属性.md","hash":"85f2b2bf0041b445b951d90ad042d3b1919099f8","modified":1745288519459},{"_id":"source/_posts/Effective-Java/83. 明智审慎的使用延迟初始化.md","hash":"79d8ea5a4b801922034b94fd176af1b468401bec","modified":1745288519459},{"_id":"source/_posts/Effective-Java/84. 不要依赖线程调度器.md","hash":"28d253636031ebd980c88737a349c5899af7455f","modified":1745288519459},{"_id":"source/_posts/Effective-Java/85. 优先选择 Java 序列化的替代方案.md","hash":"96fa8449dd71797bf1a4fbebfebe10963b175acd","modified":1745288519463},{"_id":"source/_posts/Effective-Java/86. 非常谨慎地实现 Serializable.md","hash":"5d0844b8b7ae1abdbd37a107c0108a934e16a92d","modified":1745288519463},{"_id":"source/_posts/Effective-Java/87. 考虑使用自定义的序列化形式.md","hash":"e83efee8de2f39fbdd4735f33df8a1713dbdc962","modified":1745288519463},{"_id":"source/_posts/Effective-Java/89. 对于实例控制，枚举类型优于 readResolve.md","hash":"7c6601b666c3cbb5d3f14f62b3b841f942d072cb","modified":1745288519463},{"_id":"source/_posts/Effective-Java/88. 保护性的编写 readObject 方法.md","hash":"5bce9a33fb6ad4e6c0972cba60b62c9c70c5a016","modified":1745288519463},{"_id":"source/_posts/Effective-Java/90. 考虑用序列化代理代替序列化实例.md","hash":"43bb4d78e805b1bfdfec8f60354c92cdbfc42c01","modified":1745288519463},{"_id":"source/_posts/java/Base/JavaStream.md","hash":"f97925e0bc003d76a587f51d4f054629367c60f6","modified":1745107735544},{"_id":"source/_posts/java/Base/ThreadLocal.md","hash":"c02a59a723e192f30c61e683bae0bd79d7884a15","modified":1745107735546},{"_id":"source/_posts/java/Base/Volatile.md","hash":"9b6118e7faf5bbb03d795f94ff421453fd76c421","modified":1745829708383},{"_id":"source/_posts/java/Collection/List.md","hash":"31fe0e881c1f4e9331ac464066a0c8e38503d69f","modified":1745107735548},{"_id":"source/_posts/java/Collection/Map.md","hash":"d3dcf0f60791924d4d7954e31848e96683b1a9bd","modified":1745829708387},{"_id":"source/_posts/java/Collection/Queue.md","hash":"63d8d89d4e7e38fcd0ad135cae0575c60803af76","modified":1745829708388},{"_id":"source/_posts/java/Collection/Set.md","hash":"3fdb5a9b32a3cfb4ef70461dd7581ed50ffe757b","modified":1745107735549},{"_id":"source/_posts/java/JVM/Java虚拟机栈栈帧.md","hash":"304facf3598dc4156564262b3e55dbac84a4b5b0","modified":1745829708390},{"_id":"source/_posts/java/JVM/垃圾回收和内存分配.md","hash":"062046151eb98db2e593a1e86b618dabf7a3eb5c","modified":1745829708391},{"_id":"source/_posts/java/JVM/虚拟机中的对象.md","hash":"a97790ddbfcc4e48e2602696e41767aa85e77289","modified":1745829708391},{"_id":"source/_posts/java/JVM/虚拟机运行时数据区域.md","hash":"151918cf15588c074eaa27397dafda6c39f02968","modified":1745829708393},{"_id":"source/_posts/java/JavaWeb/Filter拦截器.md","hash":"21a5931ec808e010a76b47a8dad1e3a09c5ae061","modified":1745107735554},{"_id":"source/_posts/java/thread/并发处理.md","hash":"cf31bcd923bca9b58d14ec7c829fec9529f5987a","modified":1745829708395},{"_id":"source/_posts/java/thread/并发锁.md","hash":"93a82aefc39ba1bdde9540152edf4de83b09fae3","modified":1745829708396},{"_id":"source/_posts/java/thread/线程池.md","hash":"5b2a25189cf1ce1703dc45f54a9a84a5ddbf61d0","modified":1745829708396},{"_id":"source/_posts/java/thread/线程间通讯.md","hash":"a1f71f31ea021c850b065ea198bca3f512877ccd","modified":1745829708397},{"_id":"source/assets/640-20230404215050-p95bson.png","hash":"0478df316349a076dfd91794b6ec861f95a5bada","modified":1745288519475},{"_id":"source/assets/net-img-1665073689906-f5db7615-5190-4e77-9d08-d177ad4026de-20221111215533-4736rjm.png","hash":"ecde750c44c0479a23f40c533748b829956a355b","modified":1745288519627},{"_id":"source/assets/640-20230404215050-qd8x4fd.png","hash":"daf1e3d27b80ee965c951c8f20b739f53215ee37","modified":1745288519475},{"_id":"source/assets/640-20230404215051-hnbb7ug.png","hash":"ecf312e7d0993fac1e8e595a5f4fa15a18e55732","modified":1745288519475},{"_id":"source/assets/640-20230404215051-lu967n5.png","hash":"befacad3f7005229202acebb0eb99f8d6185f7f9","modified":1745288519479},{"_id":"source/assets/640-20230404215051-nrxnl0j.png","hash":"4c94e2699cc8d1d8d5dd12a501c6df744d2e33a9","modified":1745288519479},{"_id":"source/assets/640-20230404215051-rx0ju25.png","hash":"98475a34df76ba664ef881b7e96101e3175650c5","modified":1745288519479},{"_id":"source/assets/6c916769e7f2450157bce49ea9438c10-20230127151312-x7ufhrj.png","hash":"bc1d3688bb55b74d18fb3bb5312e04e13ed5cb5e","modified":1745288519479},{"_id":"source/assets/704e3015827edff48d6c84777aa28006-20230127151312-jonjh5w.png","hash":"78a1c568a73ffdbd297c6f90c52738aa4427d6cd","modified":1745288519479},{"_id":"source/assets/83f121c9c340db46f955badf876220b2-20230127151311-j2wtijc.png","hash":"8c893b97511365f9a8a3cd6f142289cd4ebe5404","modified":1745288519479},{"_id":"source/assets/a0d8c504b2c17abbfb8eb40bc4d86d79-20230127151311-0azix9f.png","hash":"8d9910c06f73d0a0598f8267875b27772113da46","modified":1745288519479},{"_id":"source/assets/dubbo-export-20221214214601-bb3rzp9.jpg","hash":"1b3b5ef646a2870f664342904d7885fb7a69e493","modified":1745288519483},{"_id":"source/assets/dubbo-extension-20221214214601-56szafs.jpg","hash":"ae81b670b3781e6cecc373196218c63bebe89dad","modified":1745288519483},{"_id":"source/assets/dubbo-refer-20221214214601-20gbi94.jpg","hash":"e5c54853878b2f2e74dc1cf081808fd35c8afaab","modified":1745288519483},{"_id":"source/assets/f0b471f40aa64279914a3acbd6e2913b-20230127151312-khh42zb.png","hash":"e9a77caa9da51d1dd93a650495edd99a745ffccf","modified":1745288519487},{"_id":"source/assets/net-img-1665073701183-299298fc-39d3-49a7-80e3-7c1240dbf6bc-20221111215533-jaec6x0.png","hash":"19880cddc5c6a0b4b0bf82eec65beca6a37aee51","modified":1745288519627},{"_id":"source/assets/410360b70936d286a4df4ab2c11f28ad-20230127151311-j96gr8d.png","hash":"9716aecb984c1aa96693f8d1add945965eca9dcc","modified":1745288519475},{"_id":"source/assets/net-img-1665073728272-8bc0096c-6425-4310-979a-28ad42d6e2c0-20221111215533-kvytuuy.png","hash":"fc3ffdbd4ac7bac30b237de89866a8da823d0653","modified":1745288519627},{"_id":"source/assets/image-20230527140729-waan312.png","hash":"7eb8148e69f0cb3a939c5b3dd660545c3555e13f","modified":1745288519495},{"_id":"source/assets/image-20230527154724-v674duu.png","hash":"e57f382e17e0010d0e3684effe9260c649f9aeb1","modified":1745288519495},{"_id":"source/assets/image-20231119124615-vxa33dm.png","hash":"b2c0b04d99f9054312296f671a202c38d21f3702","modified":1745288519503},{"_id":"source/assets/net-img-0010-20230327194235-781jk47.png","hash":"d890a9ab327c0065b186eda3665a77555f66b202","modified":1745288519559},{"_id":"source/assets/net-img-1582873408415-b3e28487-6473-4fff-b4c9-b99b6b91a53a-20230330213216-4pmp0ac.webp","hash":"b22a07c71bb19493649e357ebe8ac92c1c9b80f4","modified":1745288519563},{"_id":"source/assets/net-img-1582873928532-40dd13b8-87fb-4ecd-8e07-399dbc61eeb8-20230330213331-q75g2s7.png","hash":"113b354cea75d36907ed70440faf49fdd397885b","modified":1745288519567},{"_id":"source/assets/net-img-1582874001071-2fe5ab73-14e5-45aa-b07c-81ba0fecc256-20230330213404-cm5njiz.png","hash":"211d2f540d3f18a1a692ba20c674d8cd3fb82a8a","modified":1745288519567},{"_id":"source/assets/net-img-1582874263210-a9e7bda6-4ed7-4d2d-8991-cdad8a2c292b-20230330213158-fukp6eb.png","hash":"3173c36ea570d35dd72ac5faa1a66803ad40812f","modified":1745288519571},{"_id":"source/assets/net-img-1582875390665-923c52b9-52ce-4e6f-9cee-763046546af3-20221030135517-j4zeqi7.png","hash":"112e4849845efefe49ce92bae1b850d6bc40a2d5","modified":1745288519571},{"_id":"source/assets/net-img-1591690708492-8b43720d-e8dc-4e22-9057-dcc4be2210de-20221030132325-ac88yvu.jpeg","hash":"db64f36546b2ae95739190e0994072eaa85dfb1f","modified":1745288519575},{"_id":"source/assets/net-img-1592902119376-b0ab487a-f7f3-454f-a784-aad737462ad4-20230330213502-h755rwl.png","hash":"dda2bfe438c8055100d16d9d7a132b43706e605d","modified":1745288519579},{"_id":"source/assets/net-img-1592902120990-cffe2ea4-a4ed-4505-8bbd-c9b64730ae6e-20230527145229-4455z5v.png","hash":"ad04409d1de7cdbb01b3fc6a8b7368ef80f5d80b","modified":1745288519579},{"_id":"source/assets/net-img-1593008781064-94397bdb-4bd4-475a-b0de-25689df5598d-20230330213216-bqv0b3r.jpeg","hash":"5cf37908a60979b8c0936e2d2ef0a91278f06c5a","modified":1745288519579},{"_id":"source/assets/net-img-1593008911203-7a81af80-db8b-4843-a59a-755e226e2314-20230330213217-h350tsl.jpeg","hash":"24ef0af2cd8bf480c01b58355b9d770de004b8a8","modified":1745288519583},{"_id":"source/assets/net-img-1593009574123-1720bb9a-11ab-462c-9acc-83dfd40a63e3-20230330213217-8hneydr.jpeg","hash":"7450dae97f4e6b2b24b12a60f50c88de1f3f8d99","modified":1745288519583},{"_id":"source/assets/net-img-1593010056655-793ce18b-c4e9-4985-9ba7-ef5347134e12-20230330213219-q7hvhww.png","hash":"f2af6f8b3a6ad39d3064a8c5f9cdbdedb6bf134e","modified":1745288519583},{"_id":"source/assets/net-img-1591690908749-8d13658b-f28f-4a16-9787-5d802366b2bb-20221030132339-jhzqts2.png","hash":"512a93f3e2cca50690d50a270235eabf87b47f2e","modified":1745288519579},{"_id":"source/assets/net-img-1593075259316-cba6509a-9a9a-4282-8698-99fa1fcc0794-20230330213350-b5wkbl5.png","hash":"77ef5f5fc2606eb5cf053d3987ca74886e24df95","modified":1745288519583},{"_id":"source/assets/net-img-1593075298003-cebf8380-65e8-4a56-9a03-72d7f02ef65c-20230330213346-itjo56n.png","hash":"316fdaa407fbf34ab761e6efc3597b56ee6100b7","modified":1745288519587},{"_id":"source/assets/net-img-1593075308254-c4ace563-ded0-42d8-8a4c-435a8bbe890f-20230330213356-yp75ww5.png","hash":"316fdaa407fbf34ab761e6efc3597b56ee6100b7","modified":1745288519587},{"_id":"source/assets/net-img-1593075466359-4fe25412-ad7b-4d12-ab59-556c6203aec3-20230330213411-owuofo8.png","hash":"2befb400a71425c989d9549b0e04b65214e9a716","modified":1745288519587},{"_id":"source/assets/net-img-1593075485480-eabde977-18f7-4a38-9f43-2a2792d14d5a-20230330213419-xbq6pfl.png","hash":"33763d8634927c0ea2ae44579eea5dfb9ae470e8","modified":1745288519587},{"_id":"source/assets/net-img-1593075294735-276336e9-41de-469d-a9e8-b4806bbdc0e9-20230330213341-wrzblbs.png","hash":"316fdaa407fbf34ab761e6efc3597b56ee6100b7","modified":1745288519587},{"_id":"source/assets/net-img-1592902119376-b0ab487a-f7f3-454f-a784-aad737462ad4-20230527145229-vu7qxs4.png","hash":"dda2bfe438c8055100d16d9d7a132b43706e605d","modified":1745288519579},{"_id":"source/assets/net-img-1593076022539-0b41a928-a33d-4749-8e05-a629389f5b11-20230330213208-977tliz.png","hash":"5beb1517d61fedd3981fdb6b992211c8e3e38bc0","modified":1745288519591},{"_id":"source/assets/net-img-1593075510764-fa7e6f63-dbec-4789-a374-d8b319f98994-20230330213428-853fmb5.png","hash":"f1cf27550f04d5863ee0f043848094cab3ba02fc","modified":1745288519587},{"_id":"source/assets/net-img-1596249786159-92610d33-5cbb-4d46-b7a5-6f1c8d3d1d92-20221030135516-9i6hh1r.jpeg","hash":"167542888a2ac22d16444dfffc6c7f3490afa4c5","modified":1745288519591},{"_id":"source/assets/net-img-1592902119321-dda9e910-093f-47bf-890e-4719cb145075-20230527145229-565b500.png","hash":"5339b6e9d1ca86874e2e278dd6576f48f7bca50f","modified":1745288519579},{"_id":"source/assets/net-img-1596783175795-a3a09f05-cdc6-4406-9b0a-0f3f6a28a5ff-20221030105031-64rpjno.jpeg","hash":"abdac5a591401ba625f9906a82d0151d6db649ff","modified":1745288519591},{"_id":"source/assets/net-img-1602914807774-75634a6f-e238-498a-b0ce-e27f039a9646-20221030124604-ehzp01i.png","hash":"c2fbab203e042d7575b5299d478924a0ab8e05d3","modified":1745288519595},{"_id":"source/assets/net-img-1602404087657-9aa12bdc-ba61-429f-bf21-dcf0efc211fa-20221030124615-fz11c88.png","hash":"6a5c2117715720f8a65bdaf2ae575d74a6af7f9a","modified":1745288519595},{"_id":"source/assets/net-img-1602998399972-d63036ef-500b-49ae-a31a-84a558efb1ae-20221030124502-upt9d1p.png","hash":"a4f9f093069a13bd7a44feee16f58851d8c74542","modified":1745288519595},{"_id":"source/assets/net-img-1603004208800-d47ee0f7-24fa-4b06-ae5f-8ce7b97e1e34-20221030124351-wgmd1lo.png","hash":"a869bf0b72f7dff0f0561b8c6f88fe846df28ed7","modified":1745288519599},{"_id":"source/assets/net-img-1602405124816-7ec65b09-2556-4ba3-b9ca-dabf0081929f-20230330213836-e0kef3p.png","hash":"38bf1df28a8794f922982beab6f83a5d86f728bb","modified":1745288519595},{"_id":"source/assets/net-img-1602920769113-5b1bf8b5-f2b3-4a36-948b-721849b796d7-20221030124537-xtsxn6h.png","hash":"e52d3c0fc15cfad4385dfe78e5d863b68ab4ad25","modified":1745288519595},{"_id":"source/assets/net-img-1603013275619-1a15e41e-436b-41ef-bce1-147db82e5a83-20221030124522-yeb4ilf.png","hash":"b4ea1c39bdc1604b038d114feed52f2e628f9665","modified":1745288519599},{"_id":"source/assets/net-img-1603013309762-3689744a-be23-4e8f-8487-d397b3cc7869-20221030124624-9buvwxc.png","hash":"a1bbc1affcf31dfe1308e483e928b285209e921a","modified":1745288519599},{"_id":"source/assets/net-img-1603013197743-541a8456-5d1b-477d-9658-1b6d5c06780a-20230330213832-g2oqx3t.png","hash":"4a4f123a2e54af955404aa1be763bdb3a398ffbd","modified":1745288519599},{"_id":"source/assets/net-img-1615611389351-2cfaa4d5-b52c-4a2e-a170-c32ce97d17a6-20221030135532-u420fpk.png","hash":"0ba2d08b26c612f6a89b5726f64087b5c9c84787","modified":1745288519599},{"_id":"source/assets/net-img-1615611389351-2cfaa4d5-b52c-4a2e-a170-c32ce97d17a6-20230330213518-3fydrb9.png","hash":"0ba2d08b26c612f6a89b5726f64087b5c9c84787","modified":1745288519599},{"_id":"source/assets/net-img-1615611419969-14ba7126-9f92-482c-a851-9898cece7e8f-20230330213518-2ptpa3a.png","hash":"cfc78b0e47b891d1fca9dc54d1ddd78afe90550a","modified":1745288519603},{"_id":"source/assets/net-img-1603013239640-a2f1a79b-35c2-4ca8-9355-5f37e9d680bb-20221030124448-sl4zele.png","hash":"5927bb1371fb10e84599ffcea6c902ddfd9b8439","modified":1745288519599},{"_id":"source/assets/net-img-1615611419969-14ba7126-9f92-482c-a851-9898cece7e8f-20221030135532-6itdbiz.png","hash":"cfc78b0e47b891d1fca9dc54d1ddd78afe90550a","modified":1745288519603},{"_id":"source/assets/net-img-1626851086718-49fece61-64f3-4f2e-9b78-f97e17176373-20230101203426-dn382za.png","hash":"46c374ebe93e60a9a4d8bb90d95a77021b45cb7c","modified":1745288519615},{"_id":"source/assets/net-img-1627291037100-eacf8101-ce28-4c56-9c4b-12e59e5a3b26-20221031123408-gsirdhu.jpeg","hash":"1c5326f40d22eab0e2a610f8ccc224b6b9501b76","modified":1745288519615},{"_id":"source/assets/net-img-1627455003158-01c028a9-eb52-46e6-85ab-c811d640a84d-20221031123409-s3v35p9.jpeg","hash":"56c8bddb1d453c3a47d11f847678b667770ff797","modified":1745288519619},{"_id":"source/assets/net-img-1629558034184-e1fe6601-777e-4a34-afe5-df37e5a9b720-20230330213445-e5uive7.png","hash":"550f368c0231a7e2f3021034569cc665d57a6787","modified":1745288519619},{"_id":"source/assets/net-img-1629559055065-5ad8d49f-81b6-45f3-87f8-c98716f799ed-20230330213451-7nkjlzc.png","hash":"3110a1357dfb77908084b87a5f8f8f745e16c988","modified":1745288519619},{"_id":"source/assets/net-img-1629870852837-ca139768-9f26-412a-8940-49ed6e38f57a-20230330213513-n1dmxgm.png","hash":"f5a30dac1d0f59a46c2637d318ce03b66f3121fa","modified":1745288519619},{"_id":"source/assets/net-img-1629559366006-0194df18-86f2-45fd-bd85-6f675b19bdb0-20230330213459-p7i5mm5.png","hash":"8f1be2292fcd61ed11916df32996d0c842f5868c","modified":1745288519619},{"_id":"source/assets/net-img-1631431982904-ce964c3b-4c64-4915-84a9-a3799dd2cf92-20230330213415-i9cgn1s.png","hash":"b770ae567fc87b114ec3116386d0e37edfc9a2be","modified":1745288519619},{"_id":"source/assets/net-img-1629560137959-ab93eb78-c083-4c80-8283-4cfc470c8af0-20230330213504-cteixk9.png","hash":"8a0f3c4fa62305900746a569186fe8839998f8ed","modified":1745288519619},{"_id":"source/assets/net-img-1646742883104-4eef3a95-3655-44f4-8887-2f5f1628732e-20230330213506-2xv20ln.png","hash":"1d55719d69d55b681aebfcccafda70e697684387","modified":1745288519623},{"_id":"source/assets/net-img-1626854477699-226d8221-ae45-44f5-b8fd-6003efd2531c-20230101203427-giho3sf.png","hash":"0f80ac0b2a2e4830fe7920af14fe54f5fe460552","modified":1745288519615},{"_id":"source/assets/net-img-640-20221123124059-5desc25.png","hash":"a0672bd10f97851a80294820734c8fdb8a83f76b","modified":1745288519635},{"_id":"source/assets/net-img-640-20230330194058-16epkoj.png","hash":"48e84cd029773e8adf0980b45354c56ec2e3df71","modified":1745288519635},{"_id":"source/assets/20210417191156743-20230127151311-j5awou3.png","hash":"660496d40debc115e3ecb4090bde67e518a9c6cd","modified":1745288519467},{"_id":"source/assets/20210417191245920-20230127151311-nf45pi0.png","hash":"59a93eaf67fc22a0ee5e55946fbe512406428c74","modified":1745288519467},{"_id":"source/assets/image-20221212232058-z1xl373.png","hash":"18ca78dfb60a0cf777cae7740f1c1299ea350062","modified":1745288519487},{"_id":"source/assets/image-20231117162020-0zic8ee.png","hash":"dd464a6d6f989f1ed302272194b29de04a038e68","modified":1745288519495},{"_id":"source/assets/image-20231126145713-0pou43f.png","hash":"427762194e416a4ed7a0a2cdc5ad9739a45ed666","modified":1745288519527},{"_id":"source/assets/net-img-1582873589321-1b21962d-3411-4d4f-af00-b2a82490e43c-20230330213311-i7hquya.png","hash":"fdfd6b2907a88b48a698e9051e943247d301de4e","modified":1745288519567},{"_id":"source/assets/net-img-1593010032163-e4fd6098-299b-4fac-adb3-b40e6ca3e534-20230330213218-jvzy0d2.png","hash":"69211aafe949bffe6da5649c54a6412496e2ddbe","modified":1745288519583},{"_id":"source/assets/net-img-1596005642573-853dc49e-7632-496d-9221-33e3b7879fea-20221030132325-84wdxkw.jpeg","hash":"88284c1eecce4f4b1bfc5382f8d4e08da4fccaf9","modified":1745288519591},{"_id":"source/assets/net-img-1624106093230-4372b31c-0d0f-4640-8e80-62b7bdd258e4-20230122192859-kbq2rlz.png","hash":"cb34bc60f583ed3d34b50574782211e0bab66919","modified":1745288519611},{"_id":"source/assets/net-img-1628905841173-c32bdb25-8b61-4f16-b08e-96898d7aeefc-20221031123444-2pva1h4.png","hash":"df9133d35fbddc693f913c6408a877dd58c9cd34","modified":1745288519619},{"_id":"source/assets/net-img-JDgR0O-20221030104726-xwobg2m.jpg","hash":"fa78b0c2612032e75f6b98f6509907b82332f666","modified":1745288519635},{"_id":"source/assets/20210417191226786-20230127151312-304h995.png","hash":"65b978ef856e5df70bbdc66c70b1d30e8b7b4ca4","modified":1745288519467},{"_id":"source/assets/20210417191255980-20230127151311-y6imh9a.png","hash":"69c83af75684b8f312f1255172bb7ad86f1de3b3","modified":1745288519471},{"_id":"source/assets/dubbo-framework-20221214214602-6xcgoty.jpg","hash":"956b54b92bc5c11635909a706fedde850930b89c","modified":1745288519483},{"_id":"source/assets/image-20230424141422-t5zbclo.png","hash":"83d623939686dc82dc41dca9e4815a4525816258","modified":1745288519491},{"_id":"source/assets/image-20231119124137-6apottn.png","hash":"eba7b1aeeea6dc0ee781cc54a0bfb8775bafd568","modified":1745288519499},{"_id":"source/assets/image-20230503214900-rmo1ydd.png","hash":"63d8124aaaf884e4c986b5aae4ae5db51aac6991","modified":1745288519491},{"_id":"source/assets/net-img-1582873583782-b5959bc6-9ff9-4ef1-95b3-9bc3fc1f83b9-20230330213307-m55wdql.png","hash":"e912d62b4c896916fb1eb15eb98b289666bc69b0","modified":1745288519563},{"_id":"source/assets/net-img-1582873594959-8501a655-dbe2-4983-9dcd-a33bde8f07f6-20230330213317-uu5k36v.png","hash":"a3c98651944a4bd158b0c2f5ec65dfb41b81a10c","modified":1745288519567},{"_id":"source/assets/net-img-1582875574292-5a9c3846-0673-451f-8a69-409c0c8dff9c-20221030103933-qh2ia8u.png","hash":"68c2624cfa788b453075a0902037673fffb432aa","modified":1745288519575},{"_id":"source/assets/net-img-1591690708399-bf1076aa-bdad-4e5f-ae30-261ccda91da5-20221030132327-4fweook.png","hash":"7a3f29db0804640a4084eed5e235dd6dea3ce1b6","modified":1745288519575},{"_id":"source/assets/net-img-1591690708909-03b304db-aa14-40fc-954b-2e5812e31b86-20221030132326-7iwfv9t.png","hash":"f30f62e8044d03122bcb10c1ecd936875c7864b2","modified":1745288519579},{"_id":"source/assets/net-img-1615614053644-2e45ea92-d426-42ca-a609-91b095ff7e83-20221030135532-iwc3p25.png","hash":"c593a666fb33cded85ae00413ade1c031882e5e6","modified":1745288519603},{"_id":"source/assets/net-img-1615619453470-bdab6e23-1385-4538-9c91-ceefcd05aa27-20221030135542-vyoxljv.png","hash":"30dfe5dcbbf79426f99197afbbfc3aa083e57836","modified":1745288519607},{"_id":"source/assets/net-img-1615614053644-2e45ea92-d426-42ca-a609-91b095ff7e83-20230330213519-1im5mrq.png","hash":"c593a666fb33cded85ae00413ade1c031882e5e6","modified":1745288519603},{"_id":"source/assets/net-img-1626851420391-9aa6cf8f-fa40-49c3-8a7a-941763583502-20230101203427-ybsosns.png","hash":"6c668b516ac102fc9727189230944b007d90baaf","modified":1745288519615},{"_id":"source/assets/net-img-1665073584346-6bc72f6a-0e4a-412e-94bc-81d860d5b059-20221111215527-k046iu2.png","hash":"8519cb1ad23cd866b3ba9254ad90fc4b7573732c","modified":1745288519627},{"_id":"source/assets/image-20230619222624-l98xjgi.png","hash":"cc14f495702df91cabd340194168ec55a3e3b060","modified":1745288519495},{"_id":"source/assets/image-20231117164621-qjdsktw.png","hash":"2b6cd4f708d015427be913cc191aef6258dda2dd","modified":1745288519499},{"_id":"source/assets/image-20231126155909-4zbslm1.png","hash":"0b7402beed24ffef50fb48547963e9c61644e8df","modified":1745288519527},{"_id":"source/assets/net-img-0011-20230327194235-6us5fo3.png","hash":"89253aaf65febdd684c337f9e7c82ab551a6fa73","modified":1745288519559},{"_id":"source/assets/net-img-0012-20230327194235-dpf6how.png","hash":"2176e4249b48413bbcbce7d6b9d27a34cf32a265","modified":1745288519559},{"_id":"source/assets/net-img-1582873565810-556fde0f-9973-46d5-9e8e-4853e80b6ba3-20230330213302-b5p12uc.png","hash":"52803510a8272e7507289a0acbaa5967d16c9a5f","modified":1745288519563},{"_id":"node_modules/hexo-theme-kratos-rebirth/.prettierignore","hash":"ae49ab74482bf0157ba7d30c21f5941a754ace36","modified":1745301264564},{"_id":"node_modules/hexo-theme-kratos-rebirth/.prettierrc","hash":"5f36b2ea290645ee34d943220a14b54ee5ea5be5","modified":1740119171853},{"_id":"node_modules/hexo-theme-kratos-rebirth/LICENSE","hash":"3dbbc837c7fd9be599f14a285e5fb5d48b4d8870","modified":1745301264580},{"_id":"node_modules/hexo-theme-kratos-rebirth/_config.yml","hash":"e846ad285f81a1b0af1ad76784d7b030f31249ea","modified":1745301264616},{"_id":"node_modules/hexo-theme-kratos-rebirth/ReadMe.md","hash":"8837b333650681cd3b84dc2880b7106e1beac8bf","modified":1745301264612},{"_id":"node_modules/hexo-theme-kratos-rebirth/package.json","hash":"83c1684e5162b62eb0b6869a7e5aa94f19ac772b","modified":1745301264608},{"_id":"node_modules/hexo-theme-kratos-rebirth/.husky/pre-commit","hash":"d93c558f564ea45c405fb08da13309ad3642aecb","modified":1745301264596},{"_id":"node_modules/hexo-theme-kratos-rebirth/devtools/build-once.js","hash":"60d86d0bdd3807ce33c544e2bacd8968b228e8e9","modified":1745301264604},{"_id":"node_modules/hexo-theme-kratos-rebirth/devtools/build-options.js","hash":"a433c50501cbb60b21d3e38632e59d8a2fa5276a","modified":1745301264604},{"_id":"node_modules/hexo-theme-kratos-rebirth/devtools/build-watch.js","hash":"d657fcec297bf6240f41ee442937b57d3869e18e","modified":1745301264604},{"_id":"node_modules/hexo-theme-kratos-rebirth/languages/zh-CN.yml","hash":"b77108a02d38755aedcb31a6bd900b054540c9ba","modified":1745301264616},{"_id":"node_modules/hexo-theme-kratos-rebirth/layout/archive.ejs","hash":"623ff5552eed30c929173a94495cc0408e716635","modified":1745301264600},{"_id":"node_modules/hexo-theme-kratos-rebirth/layout/category.ejs","hash":"5677b70953e6a33038a0e03eaa06e45c10ec7d73","modified":1745301264600},{"_id":"node_modules/hexo-theme-kratos-rebirth/layout/index.ejs","hash":"a8726925ebdf84617b508bf1a018a2b89ae1d4e6","modified":1745301264600},{"_id":"node_modules/hexo-theme-kratos-rebirth/layout/layout.ejs","hash":"a092091234ed2934f5eb00c1bc286a1129afcad1","modified":1745301264600},{"_id":"node_modules/hexo-theme-kratos-rebirth/layout/page.ejs","hash":"57c2d595e2dce3e4d9a6153c4a0f4c9f34bc2e44","modified":1745301264600},{"_id":"node_modules/hexo-theme-kratos-rebirth/layout/post.ejs","hash":"0e7ecca733e658f4c6c9524fdd3084f9026d16ad","modified":1745301264600},{"_id":"node_modules/hexo-theme-kratos-rebirth/layout/tag.ejs","hash":"5677b70953e6a33038a0e03eaa06e45c10ec7d73","modified":1745301264600},{"_id":"node_modules/hexo-theme-kratos-rebirth/scripts/additional-pages.js","hash":"61dcde531a4fd414fbc8c9c2b6ae92eac478db12","modified":1745301264604},{"_id":"node_modules/hexo-theme-kratos-rebirth/scripts/cdn-optimize-helpers.js","hash":"317191b128b031c3ba885c9a4dff68f28e070bfb","modified":1745301264604},{"_id":"node_modules/hexo-theme-kratos-rebirth/scripts/check-update.js","hash":"8272cd8c8dd22837f6f262c8e05b26099fdfaa87","modified":1745301264604},{"_id":"node_modules/hexo-theme-kratos-rebirth/scripts/gen-jsconfig.js","hash":"6e1aa475e99d5eac47d593ee46bf5e23543bbc3f","modified":1745301264604},{"_id":"node_modules/hexo-theme-kratos-rebirth/scripts/icon-to-html.js","hash":"d73e554f974fa8cfe702d986269e2ba46ea3a8d8","modified":1745301264604},{"_id":"node_modules/hexo-theme-kratos-rebirth/scripts/process-template.js","hash":"a0ba35be0a9b392c6f13b36c2bc127fac7ffe16d","modified":1745301264608},{"_id":"node_modules/hexo-theme-kratos-rebirth/scripts/search.js","hash":"7ca740b0f8dd084516eeda9c52b77ab04bed3a5e","modified":1745301264608},{"_id":"node_modules/hexo-theme-kratos-rebirth/scripts/tag-widgets.js","hash":"db83b945bc7c0710e085cac6f5f4985f92b411ba","modified":1745301264608},{"_id":"node_modules/hexo-theme-kratos-rebirth/.github/ISSUE_TEMPLATE/bug_report.yml","hash":"b07412f7926bd6bc9a2d327ce9c7ae67e548ba66","modified":1745301264616},{"_id":"node_modules/hexo-theme-kratos-rebirth/.github/ISSUE_TEMPLATE/feature_request.yml","hash":"7200fed1dfaaaa4d54f9c61fe1239f0ee040a6c0","modified":1745301264616},{"_id":"node_modules/hexo-theme-kratos-rebirth/.github/workflows/auto-release.yml","hash":"4fbe5b7c5aa47ea6c1116bd84de3088007ffc21b","modified":1745301264616},{"_id":"node_modules/hexo-theme-kratos-rebirth/.github/workflows/build-demo.yml","hash":"02bc61088feb85bebd4871006319c04d432b74cf","modified":1745301264616},{"_id":"node_modules/hexo-theme-kratos-rebirth/.github/workflows/build-test.yml","hash":"7ebd5e1f844b1c6cb67737566d7ff98eb843a0bd","modified":1745301264616},{"_id":"node_modules/hexo-theme-kratos-rebirth/layout/_index_style/card.ejs","hash":"ecb8a3368dadc0cf5df3c9305514f2313297f3fb","modified":1745301264600},{"_id":"node_modules/hexo-theme-kratos-rebirth/layout/_index_style/half.ejs","hash":"6ae5385151b0a9c94822087f8e316d1eb147bda4","modified":1745301264600},{"_id":"node_modules/hexo-theme-kratos-rebirth/layout/_index_style/status.ejs","hash":"5923b8dc74b161248db1f91db191c61b674c3430","modified":1745301264600},{"_id":"node_modules/hexo-theme-kratos-rebirth/layout/_modals/donate.ejs","hash":"9f4bbd3a03419c1da4a6157fc574b88846af8083","modified":1745301264600},{"_id":"node_modules/hexo-theme-kratos-rebirth/layout/_modals/share.ejs","hash":"7cea1da7c4579f6829b2f832e7d18fd730b7c258","modified":1745301264600},{"_id":"node_modules/hexo-theme-kratos-rebirth/layout/_pages/404.ejs","hash":"08babbe40015929680457cfd521832aad807dbdd","modified":1745301264596},{"_id":"node_modules/hexo-theme-kratos-rebirth/layout/_pages/categories.ejs","hash":"dd6c136ae3a28c6992500996d151a6083056797c","modified":1745301264600},{"_id":"node_modules/hexo-theme-kratos-rebirth/layout/_pages/search.ejs","hash":"dd050df8ce5a1bd3d4ac3091bacc4a24a993b7a8","modified":1745301264600},{"_id":"node_modules/hexo-theme-kratos-rebirth/layout/_partial/after-footer.ejs","hash":"7b1947b1454f106a72acc63197509141a9a5b6c0","modified":1745301264600},{"_id":"node_modules/hexo-theme-kratos-rebirth/layout/_pages/tags.ejs","hash":"6464e6a80cec58a7c517496a11e483d691f7abb0","modified":1745301264600},{"_id":"node_modules/hexo-theme-kratos-rebirth/layout/_partial/breadcrumb.ejs","hash":"deeaa93ca7513bc33a65797d7d5a66c9de6b16b4","modified":1745301264600},{"_id":"node_modules/hexo-theme-kratos-rebirth/layout/_partial/footer.ejs","hash":"676189d9fcaea6eb05c2dfa78c55205acd899302","modified":1745301264600},{"_id":"node_modules/hexo-theme-kratos-rebirth/layout/_partial/head.ejs","hash":"f25f3267b4f2caf6e66371b5a5527f97af7c9805","modified":1745301264600},{"_id":"node_modules/hexo-theme-kratos-rebirth/layout/_partial/header.ejs","hash":"9548a96fb6c1e3f37258ad3ef0817a4d9c13476d","modified":1745301264600},{"_id":"node_modules/hexo-theme-kratos-rebirth/layout/_partial/sidebar.ejs","hash":"ed0f28964cf73a8d90ba4dcaa992a66d42b13a35","modified":1745301264600},{"_id":"node_modules/hexo-theme-kratos-rebirth/layout/_widget/about.ejs","hash":"f970ca289ab43e715181cbbbe6c824d7880bf495","modified":1745301264596},{"_id":"node_modules/hexo-theme-kratos-rebirth/layout/_widget/category.ejs","hash":"b5494d86c54731125eeb93e5f93c2c978dbcc385","modified":1745301264600},{"_id":"node_modules/hexo-theme-kratos-rebirth/layout/_widget/posts.ejs","hash":"e48374fc0ca4e9ce5fe63483aa8f8504a92aa5c2","modified":1745301264600},{"_id":"node_modules/hexo-theme-kratos-rebirth/layout/_widget/tagcloud.ejs","hash":"d0f6a1f768c0145f7e76fcae9715d575a7e2c37d","modified":1745301264600},{"_id":"node_modules/hexo-theme-kratos-rebirth/layout/_widget/toc.ejs","hash":"10e8b0ca50309e9a7220edee38faa0b7321cab02","modified":1745301264604},{"_id":"node_modules/hexo-theme-kratos-rebirth/scripts/lib/cdn.js","hash":"d5ed17a54dbb710805090ca27b3bea102872da94","modified":1745301264604},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/css/kr-core.min.css","hash":"d72a0b5e296f5e1f5a09bb28cd6ca6246d50a32b","modified":1745301264596},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/404.webp","hash":"e07a240ab6ddeb77ee28a9531e0bc94077206248","modified":1745301264612},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/default.webp","hash":"6046fa3912d7001afea7e3634fc093ec7da3e7cc","modified":1745301264612},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/user.svg","hash":"9875dc6c4d296886d642a8ee3049db8aad406184","modified":1745301264612},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/js/kr-core.min.js","hash":"09d85de8fabc5d9d355c25b44adf8b32b3a42694","modified":1745301264604},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/js/kr-pjax.min.js","hash":"33842dc1a48f91ce3731baa6adf1969cf1443175","modified":1745301264608},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/js/kr-search.min.js","hash":"f21b03b0515aed07efa86f7103b5262bf20793f1","modified":1745301264608},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/js/kr-theme.min.js","hash":"b951ed9d6d15cc9424a49012672276543fdb935c","modified":1745301264608},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/css/kr-theme/dark.min.css","hash":"90c00f4c65f93ff5151d98d7722302944e4e3389","modified":1745301264596},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/css/kr-theme/light.min.css","hash":"3cfcb3ac03bc1349febe5cc8012fe1c67939b3fb","modified":1745301264596},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/js/kr-modal/donate.min.js","hash":"899cf6376b6a4d2d0075f81ef25c684f40a85727","modified":1745301264604},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/js/kr-modal/share.min.js","hash":"b8ce793233299bfaf6290d238ac531d328b6c4f8","modified":1745301264608},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/nprogress@0.2.0/History.md","hash":"38f837f30c75bed4b8990b36fdf540fe3c63ccd3","modified":1745301264608},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/nprogress@0.2.0/License.md","hash":"bc3e61d337e51c177534c644c20f190148d7905e","modified":1745301264612},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/nprogress@0.2.0/Notes.md","hash":"e7b5de6240b6918cbdccc708a06e4b20555966c1","modified":1745301264612},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/nprogress@0.2.0/Readme.md","hash":"63959b38ef0747eadd6f731b48d7aded7edc227b","modified":1745301264612},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/nprogress@0.2.0/bower.json","hash":"55980d38b6f24ec91f44579bcd38c667986368c5","modified":1745301264608},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/nprogress@0.2.0/component.json","hash":"ecbc4792d8583f73050dd4d918fea8073a7ded60","modified":1745301264608},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/nprogress@0.2.0/nprogress.css","hash":"17ca817a091da9dcf5fe0f2f1e1f2eea60a33149","modified":1745301264596},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/nprogress@0.2.0/nprogress.js","hash":"a7e1146d2021c42e68b599dc8bcc69d44fc31df3","modified":1745301264608},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/nprogress@0.2.0/package.json","hash":"574122118ffc8d4705e58806a13612553bc41588","modified":1745301264608},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/css/highlight/highlight.js/light.min.css","hash":"630129eab75776f1cf68122efd511a41d1ba2f71","modified":1745301264596},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/css/highlight/highlight.js/night-bright.min.css","hash":"824090a9fcbd60dbd79711c739c83c1a49d014d1","modified":1745301264596},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/css/highlight/highlight.js/night-blue.min.css","hash":"d2b9c867d6d07e2068e85229f65bcf647b0337a7","modified":1745301264596},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/css/highlight/highlight.js/night-eighties.min.css","hash":"48af974844df43711328280d72d9659a55407cac","modified":1745301264596},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/css/highlight/highlight.js/night.min.css","hash":"b62bd2c95fb37281235d2d6fa874605560cdb252","modified":1745301264596},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/css/highlight/prismjs/atom-dark.min.css","hash":"b99f782c938ebb1931ed3c7ea0aa2b16fc25ed16","modified":1745301264596},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1745301264596},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1745301264608},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1745301264596},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/nprogress@0.2.0/test/component.html","hash":"5965cc7f9bb812ada1ffcd6abec39124c20a4ef8","modified":1745301264604},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/nprogress@0.2.0/test/test.js","hash":"5c795debb89ec7d35ba1ec1e8ccbab0a7a353d78","modified":1745301264608},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/qr-code-styling@1.6.0-rc.1/lib/qr-code-styling.js","hash":"ea4d54224b3a1737c90bc1bba2d5742b75a60ee9","modified":1745301264608},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/viewerjs@1.11.6/dist/viewer.css","hash":"8cc334ada7b80acd5a4abba27eafa401955fe579","modified":1745301264596},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/viewerjs@1.11.6/dist/viewer.min.css","hash":"2e91a988d09aa17b3ee69463ec65a8b4447ae40c","modified":1745301264596},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/viewerjs@1.11.6/dist/viewer.min.js","hash":"8078b489658d7230e04069cefc84b99e1037f768","modified":1745301264608},{"_id":"source/assets/20210417191320754-20230127151312-g8jrdjp.png","hash":"dd1d3cb238af5550eef55056b50966793c34a226","modified":1745288519471},{"_id":"source/assets/image-20231117162030-ue9pyz9.png","hash":"6e9f29720c323a223db23d759b2a8c181b083ec3","modified":1745288519499},{"_id":"source/assets/image-20231119154230-3g5nidd.png","hash":"d6d544370fb3424614200bc4e507736e1232b51b","modified":1745288519503},{"_id":"source/assets/net-img-0002-20230327194009-43b76u4.png","hash":"fc814defbecf370c56170ac0d15f3e0b93b51696","modified":1745288519543},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1745301264616},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1745301264616},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/viewerjs@1.11.6/dist/viewer.common.js","hash":"d86e95961369ec9383f89341dbe31e8d20db5033","modified":1745301264608},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/viewerjs@1.11.6/dist/viewer.esm.js","hash":"1a76a6022b5c390eb786d7b3250a7e3c91d27389","modified":1745301264608},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/viewerjs@1.11.6/dist/viewer.js","hash":"471c93ce111abf02029a06661df79a4105f88408","modified":1745301264608},{"_id":"source/assets/net-img-1615619423077-dea312ee-787e-4a28-b723-199f76a214f7-20221030135542-mx20k3e.png","hash":"b4a5bed105f3d44c025b27c1b0f747b200b1fa27","modified":1745288519607},{"_id":"source/assets/微信图片_20221129215049-20221129215137-xy69pf5.jpg","hash":"49e75019313beb7dd36c03005938a4ab6dfed887","modified":1745288519639},{"_id":"source/assets/3fdc14e6be9f37b481abe633ac866a26-20230127151312-ko7ta8u.png","hash":"38a30a877028e896cb01f9ce849c88f4899a0c9e","modified":1745288519475},{"_id":"source/assets/net-img-0004-20230327194009-xusl7vj.png","hash":"4a31fef67d5662833fe069a5965459f3ad532818","modified":1745288519543},{"_id":"source/assets/net-img-0005-20230327194009-2m11zb7.png","hash":"45ecb280911ffd95feee86b4e637a127b22603ce","modified":1745288519547},{"_id":"source/assets/net-img-0007-20230327194009-obwi5jv.png","hash":"476b8a60e579a08ef8157ccece03e7a4ae3a3303","modified":1745288519551},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1745301264612},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1745301264604},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1745301264612},{"_id":"source/assets/net-img-1624109586831-fa30fbaf-01b4-4243-bedf-eedfe9631e67-20230122192859-buewr2p.png","hash":"e01f630b8f5bfefca0023ed64d4dcd7312b63643","modified":1745288519615},{"_id":"source/assets/net-img-0006-20230327194009-rdpidiy.png","hash":"90897c9c0c5369590efb4a3cb707f196222708d4","modified":1745288519547},{"_id":"source/assets/net-img-0009-20230327193706-lo1au43.jpg","hash":"b93578b5b9afce553dc98288e61d622408b19084","modified":1745288519555},{"_id":"source/assets/net-img-1623829860526-2438b2e1-de01-4c73-aa21-84e18c00d37c-20221031123408-wcse42k.png","hash":"0399712737ef6427d49e48d5d63dfbd23bf40e4d","modified":1745288519611},{"_id":"source/assets/image-20230619222818-5btwdt3.png","hash":"93d229df154b33632dc0fd6321f7d5d3348f7e08","modified":1745288519495},{"_id":"source/assets/net-img-0008-20230327194010-vj80p08.jpg","hash":"23b7ee822c099a0ba6d0236bbf138c14802582cc","modified":1745288519555},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1745301264612},{"_id":"source/assets/net-img-1665073741703-3acb8484-f36b-4738-8769-c50625b23727-20221111215534-pwccic8.png","hash":"6a5abcd2924620571b61900f720e35f9771a1147","modified":1745288519631},{"_id":"source/assets/image-20231202123415-e2licnx.jpeg","hash":"e36fcb08b0e84f5f0ee2669fdeed9debbe0dda49","modified":1745288519539},{"_id":"source/assets/image-20231119154304-hwfdw8h.jpeg","hash":"a4f9157154e31ff5efa456ba1cda9e9dbc676bf2","modified":1745288519523},{"_id":"node_modules/hexo-theme-butterfly/LICENSE","hash":"c8bc7df08db9dd3b39c2c2259a163a36cf2f6808","modified":1745301884931},{"_id":"node_modules/hexo-theme-butterfly/README.md","hash":"e1b9096ae0c4e5ef0a911aec05dbad4a3aae3173","modified":1745301884943},{"_id":"node_modules/hexo-theme-butterfly/README_CN.md","hash":"92e45255b8725f0a00450c88fcfd51ec61e1db67","modified":1745301884943},{"_id":"node_modules/hexo-theme-butterfly/package.json","hash":"0f469650107841dc1dc716aa94b3ca2bb0721762","modified":1745301884943},{"_id":"node_modules/hexo-theme-butterfly/_config.yml","hash":"7166aff350fcf84cbc01835fad5731eb855cecd7","modified":1745301884971},{"_id":"node_modules/hexo-theme-butterfly/plugins.yml","hash":"a2704f0406484fdae3410e9992cf996f9859356e","modified":1745301884971},{"_id":"node_modules/hexo-theme-butterfly/.github/FUNDING.yml","hash":"da5e77f5e0cdb7e11b36546fb6796d10e3dfbe5d","modified":1745301884971},{"_id":"node_modules/hexo-theme-butterfly/languages/default.yml","hash":"a2c938b1ef69195aec10c90dc7d1871953548e01","modified":1745301884971},{"_id":"node_modules/hexo-theme-butterfly/languages/en.yml","hash":"a2c938b1ef69195aec10c90dc7d1871953548e01","modified":1745301884971},{"_id":"node_modules/hexo-theme-butterfly/languages/ja.yml","hash":"a281d3cc3e117e90597b783dc5569dba3976d2eb","modified":1745301884971},{"_id":"node_modules/hexo-theme-butterfly/languages/ko.yml","hash":"c7d861c58f204f47a5b4d6e118e1f1e8fb8a852f","modified":1745301884971},{"_id":"node_modules/hexo-theme-butterfly/languages/zh-CN.yml","hash":"e0bf36edf18cf3380b900be7528b536252990c26","modified":1745301884971},{"_id":"node_modules/hexo-theme-butterfly/languages/zh-HK.yml","hash":"bac3063ad2892be232f7d91361c28585a3cc7eb5","modified":1745301884971},{"_id":"node_modules/hexo-theme-butterfly/languages/zh-TW.yml","hash":"bd7ee35aa30964493d2729ef105bb86331b096c3","modified":1745301884971},{"_id":"node_modules/hexo-theme-butterfly/layout/archive.pug","hash":"bc77220dfc269b8faad0930e1a4142ebf68165e5","modified":1745301884947},{"_id":"node_modules/hexo-theme-butterfly/layout/category.pug","hash":"a7e9805a781e34e38d27462e6ce2a5821c34bb9f","modified":1745301884951},{"_id":"node_modules/hexo-theme-butterfly/layout/index.pug","hash":"a93004cc8ec8050df603d32a6e6e02cd96fd9875","modified":1745301884959},{"_id":"node_modules/hexo-theme-butterfly/layout/page.pug","hash":"7ce2a49c6c41847de4ccea377ade116339984434","modified":1745301884959},{"_id":"node_modules/hexo-theme-butterfly/layout/post.pug","hash":"65c4a49c65c3fc4d9dc88b9791a75710c698c3a1","modified":1745301884963},{"_id":"node_modules/hexo-theme-butterfly/layout/tag.pug","hash":"ca5333bd262cb58c195c844b593a0eed0c721766","modified":1745301884963},{"_id":"node_modules/hexo-theme-butterfly/.github/ISSUE_TEMPLATE/bug_report.yml","hash":"10ce05c8dbde09f53bdabe40b5388de9ccc71a31","modified":1745301884971},{"_id":"node_modules/hexo-theme-butterfly/.github/ISSUE_TEMPLATE/config.yml","hash":"63ad2249ad09fb3fe21bd5ff9adefb304a7ab24a","modified":1745301884971},{"_id":"node_modules/hexo-theme-butterfly/.github/ISSUE_TEMPLATE/feature_request.yml","hash":"6e0f9470b18bd37d4891282ac73d61676b040e8c","modified":1745301884971},{"_id":"node_modules/hexo-theme-butterfly/.github/workflows/publish.yml","hash":"e320b40c051bae1549156cd5ea4a51383cf78598","modified":1745301884971},{"_id":"node_modules/hexo-theme-butterfly/.github/workflows/stale.yml","hash":"4040c76547e270aaf184e9b219a44ca41bbb1b9f","modified":1745301884971},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/additional-js.pug","hash":"f9b02aac0dbbb2b71c037dd215e70c8b7ec7741c","modified":1745301884947},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/footer.pug","hash":"6bd41add3a45e55d5e51eab5285a2d1a909d37f3","modified":1745301884955},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head.pug","hash":"1d11e334b22dbbedcb0f751f9ee9789d4416605e","modified":1745301884955},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/layout.pug","hash":"e5e6c05a621483b3542f2884e8ba45e84b1e973a","modified":1745301884959},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/pagination.pug","hash":"bd45e6fa935ace9cb54499b0491dacfb78ccc354","modified":1745301884963},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/rightside.pug","hash":"43f951b639038f3bc01deea03368d8dcf492cbb0","modified":1745301884963},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/sidebar.pug","hash":"3e65b7bf6bccccbba7e15349f0a44f15c64c5b5e","modified":1745301884963},{"_id":"node_modules/hexo-theme-butterfly/scripts/common/postDesc.js","hash":"272613a71d16f0de6dac883be4839259f774be76","modified":1745301884943},{"_id":"node_modules/hexo-theme-butterfly/scripts/events/404.js","hash":"039fc75f363d79669b0b2177d929cdff6f2ef7a4","modified":1745301884935},{"_id":"node_modules/hexo-theme-butterfly/scripts/events/cdn.js","hash":"7864ba45716c51aef8d8b04fd4bc212e0008ce3b","modified":1745301884935},{"_id":"node_modules/hexo-theme-butterfly/scripts/events/comment.js","hash":"7b1b16e1e8e08245a345764616956be50487eb53","modified":1745301884939},{"_id":"node_modules/hexo-theme-butterfly/scripts/events/init.js","hash":"ce68e84a9ccfcf91100befbaa9afc392a0cd93bb","modified":1745301884939},{"_id":"node_modules/hexo-theme-butterfly/scripts/events/merge_config.js","hash":"10ffed853a935498f1f5da2c5b57200c957874a7","modified":1745301884939},{"_id":"node_modules/hexo-theme-butterfly/scripts/events/stylus.js","hash":"bac639c404588ea62e601ef0bcd368c3bd0119af","modified":1745301884943},{"_id":"node_modules/hexo-theme-butterfly/scripts/events/welcome.js","hash":"f59e10305fef59ea3e62a7395106c0927582879d","modified":1745301884943},{"_id":"node_modules/hexo-theme-butterfly/scripts/filters/post_lazyload.js","hash":"b23108d29fff3e32384d8689c8bcd2ab306a1ae7","modified":1745301884943},{"_id":"node_modules/hexo-theme-butterfly/scripts/filters/random_cover.js","hash":"20a6ebf63439501a4b3fc81e7a2a2ea5d103bace","modified":1745301884943},{"_id":"node_modules/hexo-theme-butterfly/scripts/helpers/aside_archives.js","hash":"3eb0bbb1288dc7b0ff82cc46ceb53bd666893416","modified":1745301884935},{"_id":"node_modules/hexo-theme-butterfly/scripts/helpers/aside_categories.js","hash":"0cdf781a8c14d7b50d309e69f282ec7b178804bb","modified":1745301884935},{"_id":"node_modules/hexo-theme-butterfly/scripts/helpers/getArchiveLength.js","hash":"bf77635e920eaf52bceebc95f87c7c87a7ca8038","modified":1745301884939},{"_id":"node_modules/hexo-theme-butterfly/scripts/helpers/inject_head_js.js","hash":"00c5742ad1c75b3c5684d02ffc6a1921399e5376","modified":1745301884939},{"_id":"node_modules/hexo-theme-butterfly/scripts/helpers/related_post.js","hash":"950b7d0966429bf0f9e6c5e1161e50e545e320b4","modified":1745301884943},{"_id":"node_modules/hexo-theme-butterfly/scripts/helpers/series.js","hash":"45367c4ce827329867dbcc750ec125da9ccb2cfd","modified":1745301884943},{"_id":"node_modules/hexo-theme-butterfly/scripts/helpers/page.js","hash":"a07b586b510aa2df953102d998e84207acc34f9b","modified":1745301884939},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/button.js","hash":"2f44e1b3ccd170b256eae178299d6fa933a8d490","modified":1745301884935},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/chartjs.js","hash":"195ba802d7e8406c155124a9c939a2318f82938b","modified":1745301884935},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/flink.js","hash":"25eefe10189caf3910a0e5d5b2f2043ae9255531","modified":1745301884939},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/gallery.js","hash":"fa3d0a64f7fce4aff7928d4ddd95548978ba001c","modified":1745301884939},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/hide.js","hash":"f02fb085a88a2c0c82aeffacc24e1b71c74bd7c0","modified":1745301884939},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/inlineImg.js","hash":"89c6c78d2db43b190055d5690741a79bab4f3e7e","modified":1745301884939},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/label.js","hash":"cf0bc17d0180231167cc6aa8a00fc64f198cb9f9","modified":1745301884939},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/mermaid.js","hash":"50d8d8fac5c5b6e26317028895d7d82a2cf46606","modified":1745301884939},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/note.js","hash":"e68d8d21f3a86e3646907a3685550ee20e8d4a9f","modified":1745301884939},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/score.js","hash":"f589fb6646bd17cf12d77a9b251dd614e1c8b899","modified":1745301884943},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/series.js","hash":"40bc9a065e3a1423e0e66f4911e00713ca9f5e9e","modified":1745301884943},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/tabs.js","hash":"3c486b149e28edd1a06843f05a5c355000991b82","modified":1745301884943},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/timeline.js","hash":"176804f07567aa80f1ed95897a968a996b155dec","modified":1745301884943},{"_id":"node_modules/hexo-theme-butterfly/source/css/index.styl","hash":"b13d96924a5534bff91d75566b196ac87b4fac22","modified":1745301884967},{"_id":"node_modules/hexo-theme-butterfly/source/css/var.styl","hash":"d1eec577074ab7b262182885576135bf1896e12c","modified":1745301884971},{"_id":"node_modules/hexo-theme-butterfly/source/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1745301884935},{"_id":"node_modules/hexo-theme-butterfly/source/img/error-page.png","hash":"d2519710498a871ca3e913c57e2ba20a805b6430","modified":1745301884947},{"_id":"node_modules/hexo-theme-butterfly/source/img/favicon.ico","hash":"455ac256580bf31a45813dbbdb87219bfc8bfb04","modified":1745301884935},{"_id":"node_modules/hexo-theme-butterfly/source/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1745301884935},{"_id":"node_modules/hexo-theme-butterfly/source/js/tw_cn.js","hash":"fdb5482d04a75bd79946ad1ed291d281d0e9362d","modified":1745301884943},{"_id":"node_modules/hexo-theme-butterfly/source/js/main.js","hash":"5a52047b8520f79864d5a4ee2379a29751aead23","modified":1745301884939},{"_id":"node_modules/hexo-theme-butterfly/source/js/utils.js","hash":"48637ad8e405306772b93837f33400bde1055819","modified":1745301884943},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/Open_Graph.pug","hash":"e93a36d3c29b5a02c7f26a23f96e1f84b063cbe8","modified":1745301884959},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/analytics.pug","hash":"e792a435afee1f9491095084a00dc77e3522c1fd","modified":1745301884947},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/config.pug","hash":"9ea75b06f19bf356f340f4a3fc1bdc0713cfe445","modified":1745301884951},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/google_adsense.pug","hash":"f29123e603cbbcc6ce277d4e8f600ba67498077c","modified":1745301884955},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/config_site.pug","hash":"56a3c32de1a15627ff38c67f1131cdd6ec5ac924","modified":1745301884951},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/preconnect.pug","hash":"1e1a69aa2cbda2e621c741b3802093244b3cc04e","modified":1745301884963},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/pwa.pug","hash":"83ed05ef1e39f2ee70c3fba2cf96e488d8ffec66","modified":1745301884963},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/site_verification.pug","hash":"5168caadc4cf541f5d6676a9c5e8ae47a948f9ad","modified":1745301884963},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/structured_data.pug","hash":"1b83ae33961528f128596753fd05067c672d6bff","modified":1745301884963},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/header/index.pug","hash":"44331c9db74b281b5c5c41439d3407a9076df1a1","modified":1745301884955},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/header/menu_item.pug","hash":"733184f88e3a586a5fcc9d193ad500556b6c8eed","modified":1745301884959},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/header/post-info.pug","hash":"7d799c4694adb6e265e3f4b975d7f7f6a7021a17","modified":1745301884963},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/header/social.pug","hash":"e2d31e0f450ad42c47f7ee96375799342bf2f19b","modified":1745301884963},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/header/nav.pug","hash":"18b984ce184ea53d2dff5a03cc2d0d39d2ec3406","modified":1745301884959},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/loading/fullpage-loading.pug","hash":"a2f7d69ca7ec58f24fe7d4e04ae21d5b62b01567","modified":1745301884955},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/loading/index.pug","hash":"d76ce71ba106e350670c021a3dcae57547d01830","modified":1745301884955},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/loading/pace.pug","hash":"9d2d539555bab495959b9df734ed5c43a9f9e5a9","modified":1745301884959},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/mixins/article-sort.pug","hash":"ef7afe0df7a3746744ac8185da7163b7406120ca","modified":1745301884947},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/mixins/indexPostUI.pug","hash":"f3389fa9ae4fa32e3c16573286583bc3023e57ad","modified":1745301884959},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/page/categories.pug","hash":"5276a8d2835e05bd535fedc9f593a0ce8c3e8437","modified":1745301884951},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/page/default-page.pug","hash":"efb40388e37cca0b5e7c3c66e811a42f8d32c910","modified":1745301884951},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/page/404.pug","hash":"15d32c511e4875066fcbe9cb84c3ada07b5a7c41","modified":1745301884947},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/page/flink.pug","hash":"6b0fa5f048aca8e9cbe56978301af918cf7ac34a","modified":1745301884955},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/page/shuoshuo.pug","hash":"b2423cfc57a5e3a0e1112ff7c18d5c5c720d89d5","modified":1745301884963},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/page/tags.pug","hash":"79ad31eb72a9e14007770b18a426406a25315b38","modified":1745301884963},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/post/outdate-notice.pug","hash":"b7ce9484bc5c97ea6154f0b78fb9b8951fafedbd","modified":1745301884959},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/post/post-copyright.pug","hash":"b96c232e5178d927987791d9ae386dd83679535a","modified":1745301884963},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/post/reward.pug","hash":"db92f25ff3fd061882f81bf74ca560ff66983a0c","modified":1745301884963},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/aplayer.pug","hash":"ed79fef5b5025415ea12eaed970f3fe7f6ef9596","modified":1745301884947},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/effect.pug","hash":"43014bfc63583d3ee8808d526dd165848c0ed52f","modified":1745301884955},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/pjax.pug","hash":"efe4f8019632b51c92c4f7628758538305e06e47","modified":1745301884963},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/subtitle.pug","hash":"236c3ce26dd76e80b04d457789475c42da5ac0c8","modified":1745301884963},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/prismjs.pug","hash":"88f979a0b1a19eeb0db229247833bf9c6865c3b9","modified":1745301884963},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/umami_analytics.pug","hash":"bc35a1552d26ecdeeadbf06300078dbb5128a6e5","modified":1745301884963},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_ad.pug","hash":"a8312b527493dabbadbb1280760168d3bc909a3b","modified":1745301884947},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_announcement.pug","hash":"21e019bdc3b1e796bb00976bb29af2d51f873624","modified":1745301884947},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_author.pug","hash":"1aba8aa7cd767dc96879d13a13b4c8ceb9023233","modified":1745301884947},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_bottom_self.pug","hash":"1dba77d250eeebfb6e293d504352c7e9ea31980b","modified":1745301884947},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_archives.pug","hash":"73d33b6930e7944187a4b3403daf25d27077a2dd","modified":1745301884947},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_categories.pug","hash":"66e383b4ef374951eb87dd1bf4cdb7a667193fb5","modified":1745301884947},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_newest_comment.pug","hash":"d8753772889b5d0f4d15639ed6af5e91e53b1d03","modified":1745301884947},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_post_series.pug","hash":"e0bb72fa0ce15964b11b8fe421cae3432394e35f","modified":1745301884947},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_post_toc.pug","hash":"1dd19a564320d248dbcee7f118a5b96c6466da65","modified":1745301884947},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_recent_post.pug","hash":"bb842d2aa6469d65bf06af1372f0a19a9e4ef44c","modified":1745301884947},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_tags.pug","hash":"842b772a387b576550fa127030e1c2e9bf65716d","modified":1745301884951},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_top_self.pug","hash":"7b5ae404a1205546b7de4be42291315cf918f2b3","modified":1745301884951},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_webinfo.pug","hash":"fcddd80cdeb6aa81f342cd9f0102302f6ba087a8","modified":1745301884951},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/index.pug","hash":"45f620cd87b9ef2aa9d1e024e697ed6b4eecff34","modified":1745301884959},{"_id":"node_modules/hexo-theme-butterfly/source/css/_global/function.styl","hash":"d12340a7df4601b9a23f070e16645861aeb3bb0a","modified":1745301884967},{"_id":"node_modules/hexo-theme-butterfly/source/css/_global/index.styl","hash":"4fcb8222b9548e22f7b76f12d33e3698240cbae0","modified":1745301884967},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/highlight.styl","hash":"67062d597408068e4a59e95851e98fed34b745da","modified":1745301884967},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/theme.styl","hash":"a51edfd3e499e7d38c32241c40e8e4d371efca73","modified":1745301884971},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/aside.styl","hash":"ba174889e770ae9f6683379b9eae9d8c94253080","modified":1745301884967},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/chat.styl","hash":"4cc02bcbaa4a1933a82a9ea57a603fe2d059fc77","modified":1745301884967},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/comments.styl","hash":"fbfce4d67cacd1df22fb73d89d008693f59d9d91","modified":1745301884967},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/footer.styl","hash":"d7b988d8588207086670f39aa49fce442c429f7a","modified":1745301884967},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/head.styl","hash":"094108f2a4e351a2fa496d6bd3e2388151416b3f","modified":1745301884967},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/loading.styl","hash":"f0b01bbf321c2c24fdccaee367dd9fd448031a72","modified":1745301884971},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/pagination.styl","hash":"7d7554573c005399bc8c2264a85896d2d51be1e1","modified":1745301884971},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/relatedposts.styl","hash":"ef8e8549fe7ad4b99793844a93b4a89f77f417d5","modified":1745301884971},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/reward.styl","hash":"d9cdf564a822a585e67fd5bac8573ba87eeb3743","modified":1745301884971},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/post.styl","hash":"543eaf9c7df7e0db841e5946ee5f9082c3c46290","modified":1745301884971},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/rightside.styl","hash":"a0f5835f04358122e8b1d38dd3e8da09a1b5b431","modified":1745301884971},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/sidebar.styl","hash":"084dc4dfb41f55e237a9d6cf8c2f5dba729b83be","modified":1745301884971},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/third-party.styl","hash":"0af7c8754f04bdd9a02a14d880774753bd2e35ee","modified":1745301884971},{"_id":"node_modules/hexo-theme-butterfly/source/css/_mode/darkmode.styl","hash":"4c9849df9c68d892c7df0ca28123aeb0dc9dc424","modified":1745301884967},{"_id":"node_modules/hexo-theme-butterfly/source/css/_mode/readmode.styl","hash":"ad66212554468b7067590308ed4cf40524fea662","modified":1745301884971},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/404.styl","hash":"205ccc7d0ec6ce1193b46bc0c9ce0385594581fb","modified":1745301884967},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/archives.styl","hash":"5abe5480d83ff8b452a780a484d50a44091475bf","modified":1745301884967},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/categories.styl","hash":"c4cda7b0c99015df29ce00fdfddd2f7679653754","modified":1745301884967},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/common.styl","hash":"dcff804c4c237e1e908481b44c1ac4e39ac0da34","modified":1745301884967},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/flink.styl","hash":"1f8d715faf3b91b53426e38195c0920afb3bfa1c","modified":1745301884967},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/homepage.styl","hash":"992d192db7d1c96e995b85ed11c20c571d33fbad","modified":1745301884967},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/shuoshuo.styl","hash":"79bb1d9a27822ed5675d1e52f5dbd0e2f5d5010a","modified":1745301884971},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/tags.styl","hash":"7543bb688876a946538d66b991c71b94b5216277","modified":1745301884971},{"_id":"node_modules/hexo-theme-butterfly/source/css/_search/algolia.styl","hash":"d8a8275a68a1421c4c09b604cf78bea16c1d0463","modified":1745301884967},{"_id":"node_modules/hexo-theme-butterfly/source/css/_search/index.styl","hash":"6c4cbdadd9a49029fe0c59e29808d873e5b6b6ee","modified":1745301884967},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/button.styl","hash":"de8437a058a315d14d7e7034066f095b7b3ed4b4","modified":1745301884967},{"_id":"node_modules/hexo-theme-butterfly/source/css/_search/local-search.styl","hash":"1f2b86df86df81c3a59377b29102314ffc73dfa6","modified":1745301884971},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/gallery.styl","hash":"30d1f809efd252ed0233d96d4374efd2b01d2292","modified":1745301884967},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/hexo.styl","hash":"985b183db7b7bfd8f9bdb60494549fb7f850348b","modified":1745301884967},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/hide.styl","hash":"d27dbccaf3de1c9158d19e4fd49a25953cb5778d","modified":1745301884967},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/inlineImg.styl","hash":"3be8d0a75e7cc96548667cae0cb6a474279bd0b5","modified":1745301884967},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/label.styl","hash":"216f52fefc2274b542b549d8470503e6f1a308fb","modified":1745301884967},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/note.styl","hash":"4929382bd60788d34752a66e2fe764ef797a72a0","modified":1745301884971},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/series.styl","hash":"0657169849bc4bf4d93b5492ade040c8f58c1901","modified":1745301884971},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/tabs.styl","hash":"3a88eedcb694da79e92581ce50cb1a430b1fb615","modified":1745301884971},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/timeline.styl","hash":"e846ddaef494d46cdfa2379deacfe74fa1cc5264","modified":1745301884971},{"_id":"node_modules/hexo-theme-butterfly/source/css/_third-party/normalize.min.css","hash":"8549829fb7d3c21cd9e119884962e8c463a4a267","modified":1745301884935},{"_id":"node_modules/hexo-theme-butterfly/source/js/search/algolia.js","hash":"7119f2f2943de71999d3dd6ba5c60cde846f114b","modified":1745301884935},{"_id":"node_modules/hexo-theme-butterfly/source/js/search/local-search.js","hash":"a2b783230a9143de69004cfc914d9f55e6fc1660","modified":1745301884939},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/abcjs/abcjs.pug","hash":"febff991595504d8e850ced0b9cc090f02ed97f0","modified":1745301884947},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/abcjs/index.pug","hash":"f0a90d8e39915a74b16ef22e851f179415cd7eaa","modified":1745301884959},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/artalk.pug","hash":"b03ee8625149191f9d5d057bbc9824b68d8dd0c4","modified":1745301884947},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/disqus.pug","hash":"d6fff5a7f84c8b09f282f9ddc0020a68a8aac9ea","modified":1745301884955},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/fb.pug","hash":"cbfbcf34a24d21ba2b21cf9eedb76f4c3c563c5a","modified":1745301884955},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/index.pug","hash":"846cabae287ae31b3bbfac3da022475713dd5ecc","modified":1745301884959},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/twikoo.pug","hash":"b5db4203a1392385838c73549ddeae0a4be67eba","modified":1745301884963},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/valine.pug","hash":"7884883ec15792f7e54daacb3c62b851dde2b66a","modified":1745301884963},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/waline.pug","hash":"fd2320ee25507bb8ef49f932c2d170586b44ea4d","modified":1745301884967},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/chat/chatra.pug","hash":"5b29badecbbe828112c001156023fc0566045cf6","modified":1745301884951},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/chat/crisp.pug","hash":"24d094fd917947c0ca7492fa094328b1a183b873","modified":1745301884951},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/chat/index.pug","hash":"e8438941085def0591a72fc9b0d705dbf107f54f","modified":1745301884959},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/chat/tidio.pug","hash":"62466b251052cae609b6369d4cb4b6a85320757d","modified":1745301884963},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/artalk.pug","hash":"89c63a5f0c0ab6314de7158fbc8fcbc84997fc55","modified":1745301884947},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/disqus.pug","hash":"f2ea5249b3e6670f6c8c77868f4f42c502e43830","modified":1745301884955},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/disqusjs.pug","hash":"c81fa7d8a5cb96d1ae07bfa8c46b84a58161add1","modified":1745301884955},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/facebook_comments.pug","hash":"8af585e6d6f73ee57114eefad574dc6e8ea9f570","modified":1745301884955},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/giscus.pug","hash":"592b2251db6c1abeb8b0eebe3b2e6d9aa0dec445","modified":1745301884955},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/gitalk.pug","hash":"58914c58a190e3bc0aa37cb581e77e442b563501","modified":1745301884955},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/index.pug","hash":"db6713d2b90eb8183f86ac92c26761a8501c0ddb","modified":1745301884959},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/js.pug","hash":"3abbaaa4ea575c45b3cebffd40bad1acc6ffce84","modified":1745301884959},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/livere.pug","hash":"7a80231fc71822e503879383a2d9611edf1d72dd","modified":1745301884959},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/remark42.pug","hash":"84f7cfde00f929fa3dc40349bcab060ec68f1b9f","modified":1745301884963},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/twikoo.pug","hash":"53d99831f29aeb2e336ed1407d79590041f77002","modified":1745301884963},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/valine.pug","hash":"24f18b0c67803210d53abbf9c1d454c000b06eee","modified":1745301884963},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/waline.pug","hash":"e2bf15357485cd502414b3b20f5b1f762a2fd014","modified":1745301884967},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/math/chartjs.pug","hash":"732eb1118ea1a73aa5c164d639097c614f8e9953","modified":1745301884951},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/math/index.pug","hash":"af66d13204030d47537b9e31a6173e63589ce7ff","modified":1745301884959},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/math/katex.pug","hash":"b83db9fa64d42a0bfd97efb660e09be3f166a144","modified":1745301884959},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/math/mathjax.pug","hash":"db2f4fff80a1166476ea76ae004aa186df11bad3","modified":1745301884959},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/math/mermaid.pug","hash":"ca2fc5928ca292f29fd8333c73733344994096fb","modified":1745301884959},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/artalk.pug","hash":"187302dbc916852ff2fdf47061e272c061611dda","modified":1745301884947},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/common.pug","hash":"27fa75affebc6e84a487c62bceff783bde595256","modified":1745301884951},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/disqus-comment.pug","hash":"fa4b4194749d05f7249f365f2b89c0281057ce54","modified":1745301884951},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/github-issues.pug","hash":"72e2970b23570e308f8af5d8ba8e5e3321d01bbf","modified":1745301884955},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/index.pug","hash":"a7c07dbc1e970a5b247091458e1ee9b144a3366d","modified":1745301884959},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/remark42.pug","hash":"34edfebf0cace0852806be774910ccb0e0914650","modified":1745301884963},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/twikoo-comment.pug","hash":"d2e12a9fc302a4efe52c90d44896fbd73e193a1f","modified":1745301884963},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/valine.pug","hash":"d376ec17fb19fcdcf0d2ad71330190146d3af879","modified":1745301884967},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/remark42.pug","hash":"716dc463fe4ef5112e7018ed60804125fdfa5cad","modified":1745301884963},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/waline.pug","hash":"ec6c685080634ac46ffbea1b8f10313388888f43","modified":1745301884967},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/search/algolia.pug","hash":"7f0ede1cd3fed2669c94a8e1b21bc0b183f310b8","modified":1745301884947},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/search/docsearch.pug","hash":"013756ff3363344987cc00fc9bd833baf193c341","modified":1745301884955},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/search/index.pug","hash":"f8557548d2ad8dd149c562193991c6c6cda02415","modified":1745301884959},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/search/local-search.pug","hash":"2622b4cf9189fa23e4a422aaf9ef272e4f2c6137","modified":1745301884959},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/share/addtoany.pug","hash":"f5ee1c9c8ffa4bca972d30f4de69268b8d47f052","modified":1745301884947},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/share/share-js.pug","hash":"efef352c1d122409575386bf3894dce8e87032e2","modified":1745301884963},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/share/index.pug","hash":"e51e896ccb13900de38dc81cf44dc789e2418a12","modified":1745301884959},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/highlight/diff.styl","hash":"9f02598b5e4296aec6470639d4bac4c9ac46392e","modified":1745301884967},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/highlight/index.styl","hash":"ef52ebf1e8e751a412f9456fdaeee7d88afd9a72","modified":1745301884967},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/prismjs/diff.styl","hash":"077ec530831be1d80e93da380406b9f5abd0918a","modified":1745301884967},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/prismjs/index.styl","hash":"1883c91d43bff10aae55122a21e0b064b6f5c9dd","modified":1745301884967},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/prismjs/line-number.styl","hash":"de4bb5fc2dfca368b35e4c1109c92f7abc9e2245","modified":1745301884971},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/utterances.pug","hash":"30a7d157890de69deab28baa47fb7bb28b040efd","modified":1745301884963},{"_id":"node_modules/hexo-theme-butterfly/source/img/butterfly-icon.png","hash":"f5dd732fed5c3bcd4aa76bac3441bac8485fb432","modified":1745301884943},{"_id":"source/about/index.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1745302527631},{"_id":"source/_posts/java/thread/assets/net-img-1582875399701-d03e5b25-a1c9-498e-85d6-18f86f41e38f-20221030135517-a6hu6sv.png","hash":"926070ac7bf26f22aab50a0f1b4ad414a02a22fd","modified":1745304424332},{"_id":"source/assets/002bdbd0d71140c3834d44b93555237ftplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-ryqzvpj.awebp","hash":"83eb3ebf7ea7ce9bd9851a972fef4700f2db6369","modified":1713355524000},{"_id":"source/assets/0566fc7826064b12bb88082b39c10bd2tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-hkx67f6.awebp","hash":"ecd824b83a9c389240d6fa7a4c5cc5c71472c296","modified":1713355524000},{"_id":"source/assets/0dfa05911b3f4f448db0ce247eb0db91tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-oai6wan.awebp","hash":"122acee91c37e100abaae4837f5ea6af9008060a","modified":1713355524000},{"_id":"source/assets/13ba4ffef43045ba8ed42101aefd3d72tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-i9veirg.awebp","hash":"898cb7719a29420b606db776c8831d88f7bea10d","modified":1713355524000},{"_id":"source/assets/233f28fc503e4dcc9c1e1317a89b71d9tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-vqp6dd1.awebp","hash":"d4f2127935c3866c1d4e7c9f25a29e5e593b5e10","modified":1713355524000},{"_id":"source/assets/359cbfb6d68e450b8f611a9975099c6etplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-ol5zynd.awebp","hash":"1e3b0d18c3334de8bedb5fc639de7ed5ce4f23cc","modified":1713355524000},{"_id":"source/assets/34f2d54bc3724e51b0c8ad2695f7de95tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-2cym377.awebp","hash":"de6e4e9ded053a1b3f1adb69875c10555a23bfb5","modified":1713355524000},{"_id":"source/assets/25a723e07ab64f0fa5fcdc4eeddf1e0dtplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-afj8oqs.awebp","hash":"5043b9963391e1541b6181cdb98a273c72c7eff7","modified":1713355524000},{"_id":"source/assets/523b778404c140a29621295d079be9f8tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-nuriy5k.awebp","hash":"d20c589e3e683da0bf713ee3e67738ec46331fc4","modified":1713355524000},{"_id":"source/assets/594708f975664198bd523b79b8e1a73ftplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-0c9y8yc.awebp","hash":"35f07093b3a2e2bfb4b22391a9dd375518efcfde","modified":1713355524000},{"_id":"source/assets/53c6380455754787a12800dbf1e48a06tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-0takv3w.awebp","hash":"943ec93733bcf26d21b25f6ad69436b08966c62d","modified":1713355524000},{"_id":"source/assets/53b93ae1d4dc4adeaa4d6104cc9aa7b6tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-onec9un.awebp","hash":"898cb7719a29420b606db776c8831d88f7bea10d","modified":1713355524000},{"_id":"source/assets/63f3b4b63fd14b7a84c33c0840bc41e2tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-7eix1tf.awebp","hash":"898cb7719a29420b606db776c8831d88f7bea10d","modified":1713355524000},{"_id":"source/assets/908c9b12522247dfbd32bada7308cb27tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-r7sakmv.awebp","hash":"ecd824b83a9c389240d6fa7a4c5cc5c71472c296","modified":1713355524000},{"_id":"source/assets/84c1132caafa47e1a56f670b0ac349aetplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-czmjytj.awebp","hash":"30818642518ac339c3b5dd7bbf72e90d627ee41b","modified":1713355524000},{"_id":"source/assets/b704efb8f0784c89b520d5e990bcd670tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-zv6m9iy.awebp","hash":"68d0160eff5b6dd02c390d7828a98ae39ab95c9b","modified":1713355524000},{"_id":"source/assets/6d2a0769269e405dac3519f9e45d14d7tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-hfn0g3i.awebp","hash":"bf15c40cd7d44c951bac934785bcb85f0ff10ebb","modified":1713355524000},{"_id":"source/assets/948ff8d7b81449269cbedf8928f28e59tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-2e3ivzs.awebp","hash":"8f5518faaeabb248d154a1d80d61e67fe89e446d","modified":1713355524000},{"_id":"source/assets/c2b0e2f9f93449e7b86ef71e2bac35e9tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-8xtfk94.awebp","hash":"a9c2d081f8d38c9b7f943033a43750daf6c65667","modified":1713355524000},{"_id":"source/assets/c7d327afbf054012bd98bb554bfd19a3tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-kxpsqug.awebp","hash":"9d77519d200e67b376ad07779f3ff7675642928f","modified":1713355524000},{"_id":"source/assets/d682866856c240b39d8dd674462b4072tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-ptt3047.awebp","hash":"8192644a7b9946015345797563487d651fc02c3f","modified":1713355524000},{"_id":"source/assets/d8bdbd9d79814646999637ffc46281cbtplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-5lz8huo.awebp","hash":"de85ddb99d387378061109fb98f78feb39ab90e8","modified":1713355524000},{"_id":"source/assets/d76e41420e1d44eb82e4b74dc7d4309btplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-e21hjq1.awebp","hash":"7b13c53c1cf9bb5791a9ad7cc65db3a09880e01a","modified":1713355524000},{"_id":"source/assets/d9a984a0659546258734112ce5c687f7tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-qzq41qp.awebp","hash":"8772d815415551014082f341890ef9c2aa284ffe","modified":1713355524000},{"_id":"source/assets/d4522ab88aca42a4b9c2d633301fcac5tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-idyvok3.awebp","hash":"d68b03f8fd4cc1993b01b2648e0141bb83930dc9","modified":1713355524000},{"_id":"source/assets/e87ee465af764c47866e1f69a22d065atplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-ms062uc.awebp","hash":"de85ddb99d387378061109fb98f78feb39ab90e8","modified":1713355524000},{"_id":"source/assets/f469c168d72b40c6b23accd8ab652a22tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-t5puo5k.awebp","hash":"0255f87efaa2f130b7732bc33e6fc5c2528cb4a8","modified":1713355524000},{"_id":"source/_posts/20250501/2.md","hash":"b90f54227f8314963ee0eb572a4fabb60bb6d3eb","modified":1746090734022},{"_id":"source/_posts/20250501/1.md","hash":"c25ca4f5b86687978b4880e37d597dff269994a3","modified":1746090127672},{"_id":"source/assets/faa389f1359544b382bcaf1b9b5227bbtplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-woeeb5g.awebp","hash":"7be54a28d7082bc9065eacb415babb8166f3f115","modified":1713355524000},{"_id":"source/_posts/20250501/3.md","hash":"5b3a3fb5f26e702cc5caa83fa4c2e81f68dce3ad","modified":1746091790778},{"_id":"source/_posts/20250501/5.md","hash":"09e92b766c840b53bb32bd920f320f4dca013bfa","modified":1746092336124},{"_id":"source/_posts/20250501/6.md","hash":"6845791ec05d96edbc9c4f76525046545e42b2ee","modified":1746092445205},{"_id":"source/_posts/20250501/4.md","hash":"e63bdc5669f647cfa7f297f8a5300de1078ff127","modified":1746091897986},{"_id":"source/assets/29c7d6a21d76455d9bc5443394172a2btplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-jhifgqp.awebp","hash":"b395029db2b2e45f3655da46aca7af51c90abc62","modified":1713355524000},{"_id":"source/assets/58038d8ee0344260875993d8636331d5tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-lhvub6f.awebp","hash":"f509457d8a1e1193ecddd6971b62f7d825ebe4f9","modified":1713355524000},{"_id":"source/assets/ad0a175194af489d9c71f096ac430a03tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-4g64cdf.awebp","hash":"1d09d6164fdb55996376417d60d49f690d60d408","modified":1713355524000},{"_id":"source/assets/ec983e41a4b54a31a1f7f7c9ec511974tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-8ibqfew.awebp","hash":"cbf01e2f2b6d17cdefec667d80932d331364c9ed","modified":1713355524000},{"_id":"source/assets/f43dc00e2347458c876f15dae66f23d4tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-lapokvs.awebp","hash":"f509457d8a1e1193ecddd6971b62f7d825ebe4f9","modified":1713355524000},{"_id":"source/assets/ec623644e43b4c56bf1110c9cfc74bc8tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-1zakfmq.awebp","hash":"f509457d8a1e1193ecddd6971b62f7d825ebe4f9","modified":1713355524000},{"_id":"source/_posts/20250501/7.md","hash":"b548033fd3fb904f01a538df56a3ddc83ac13d5b","modified":1746092565348},{"_id":"source/_posts/20250501/assets/002bdbd0d71140c3834d44b93555237ftplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-ryqzvpj.awebp","hash":"83eb3ebf7ea7ce9bd9851a972fef4700f2db6369","modified":1713355524000},{"_id":"source/_posts/20250501/assets/0566fc7826064b12bb88082b39c10bd2tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-hkx67f6.awebp","hash":"ecd824b83a9c389240d6fa7a4c5cc5c71472c296","modified":1713355524000},{"_id":"source/_posts/20250501/assets/0dfa05911b3f4f448db0ce247eb0db91tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-oai6wan.awebp","hash":"122acee91c37e100abaae4837f5ea6af9008060a","modified":1713355524000},{"_id":"source/_posts/20250501/assets/233f28fc503e4dcc9c1e1317a89b71d9tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-vqp6dd1.awebp","hash":"d4f2127935c3866c1d4e7c9f25a29e5e593b5e10","modified":1713355524000},{"_id":"source/_posts/20250501/assets/25a723e07ab64f0fa5fcdc4eeddf1e0dtplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-afj8oqs.awebp","hash":"5043b9963391e1541b6181cdb98a273c72c7eff7","modified":1713355524000},{"_id":"source/_posts/20250501/assets/13ba4ffef43045ba8ed42101aefd3d72tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-i9veirg.awebp","hash":"898cb7719a29420b606db776c8831d88f7bea10d","modified":1713355524000},{"_id":"source/_posts/20250501/assets/29c7d6a21d76455d9bc5443394172a2btplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-jhifgqp.awebp","hash":"b395029db2b2e45f3655da46aca7af51c90abc62","modified":1713355524000},{"_id":"source/_posts/20250501/assets/34f2d54bc3724e51b0c8ad2695f7de95tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-2cym377.awebp","hash":"de6e4e9ded053a1b3f1adb69875c10555a23bfb5","modified":1713355524000},{"_id":"source/_posts/20250501/assets/359cbfb6d68e450b8f611a9975099c6etplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-ol5zynd.awebp","hash":"1e3b0d18c3334de8bedb5fc639de7ed5ce4f23cc","modified":1713355524000},{"_id":"source/_posts/20250501/assets/523b778404c140a29621295d079be9f8tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-nuriy5k.awebp","hash":"d20c589e3e683da0bf713ee3e67738ec46331fc4","modified":1713355524000},{"_id":"source/_posts/20250501/assets/53b93ae1d4dc4adeaa4d6104cc9aa7b6tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-onec9un.awebp","hash":"898cb7719a29420b606db776c8831d88f7bea10d","modified":1713355524000},{"_id":"source/_posts/20250501/assets/53c6380455754787a12800dbf1e48a06tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-0takv3w.awebp","hash":"943ec93733bcf26d21b25f6ad69436b08966c62d","modified":1713355524000},{"_id":"source/_posts/20250501/assets/594708f975664198bd523b79b8e1a73ftplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-0c9y8yc.awebp","hash":"35f07093b3a2e2bfb4b22391a9dd375518efcfde","modified":1713355524000},{"_id":"source/_posts/20250501/assets/6d2a0769269e405dac3519f9e45d14d7tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-hfn0g3i.awebp","hash":"bf15c40cd7d44c951bac934785bcb85f0ff10ebb","modified":1713355524000},{"_id":"source/_posts/20250501/assets/63f3b4b63fd14b7a84c33c0840bc41e2tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-7eix1tf.awebp","hash":"898cb7719a29420b606db776c8831d88f7bea10d","modified":1713355524000},{"_id":"source/_posts/20250501/assets/84c1132caafa47e1a56f670b0ac349aetplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-czmjytj.awebp","hash":"30818642518ac339c3b5dd7bbf72e90d627ee41b","modified":1713355524000},{"_id":"source/_posts/20250501/assets/908c9b12522247dfbd32bada7308cb27tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-r7sakmv.awebp","hash":"ecd824b83a9c389240d6fa7a4c5cc5c71472c296","modified":1713355524000},{"_id":"source/_posts/20250501/assets/948ff8d7b81449269cbedf8928f28e59tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-2e3ivzs.awebp","hash":"8f5518faaeabb248d154a1d80d61e67fe89e446d","modified":1713355524000},{"_id":"source/_posts/20250501/assets/b704efb8f0784c89b520d5e990bcd670tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-zv6m9iy.awebp","hash":"68d0160eff5b6dd02c390d7828a98ae39ab95c9b","modified":1713355524000},{"_id":"source/_posts/20250501/assets/c2b0e2f9f93449e7b86ef71e2bac35e9tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-8xtfk94.awebp","hash":"a9c2d081f8d38c9b7f943033a43750daf6c65667","modified":1713355524000},{"_id":"source/_posts/20250501/assets/c7d327afbf054012bd98bb554bfd19a3tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-kxpsqug.awebp","hash":"9d77519d200e67b376ad07779f3ff7675642928f","modified":1713355524000},{"_id":"source/_posts/20250501/assets/d4522ab88aca42a4b9c2d633301fcac5tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-idyvok3.awebp","hash":"d68b03f8fd4cc1993b01b2648e0141bb83930dc9","modified":1713355524000},{"_id":"source/_posts/20250501/assets/d682866856c240b39d8dd674462b4072tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-ptt3047.awebp","hash":"8192644a7b9946015345797563487d651fc02c3f","modified":1713355524000},{"_id":"source/_posts/20250501/assets/d76e41420e1d44eb82e4b74dc7d4309btplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-e21hjq1.awebp","hash":"7b13c53c1cf9bb5791a9ad7cc65db3a09880e01a","modified":1713355524000},{"_id":"source/_posts/20250501/assets/d8bdbd9d79814646999637ffc46281cbtplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-5lz8huo.awebp","hash":"de85ddb99d387378061109fb98f78feb39ab90e8","modified":1713355524000},{"_id":"source/_posts/20250501/assets/d9a984a0659546258734112ce5c687f7tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-qzq41qp.awebp","hash":"8772d815415551014082f341890ef9c2aa284ffe","modified":1713355524000},{"_id":"source/_posts/20250501/assets/e87ee465af764c47866e1f69a22d065atplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-ms062uc.awebp","hash":"de85ddb99d387378061109fb98f78feb39ab90e8","modified":1713355524000},{"_id":"source/_posts/20250501/assets/f469c168d72b40c6b23accd8ab652a22tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-t5puo5k.awebp","hash":"0255f87efaa2f130b7732bc33e6fc5c2528cb4a8","modified":1713355524000},{"_id":"source/_posts/20250501/assets/faa389f1359544b382bcaf1b9b5227bbtplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-woeeb5g.awebp","hash":"7be54a28d7082bc9065eacb415babb8166f3f115","modified":1713355524000},{"_id":"source/_posts/20250501/assets/58038d8ee0344260875993d8636331d5tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-lhvub6f.awebp","hash":"f509457d8a1e1193ecddd6971b62f7d825ebe4f9","modified":1713355524000},{"_id":"source/_posts/20250501/assets/ad0a175194af489d9c71f096ac430a03tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-4g64cdf.awebp","hash":"1d09d6164fdb55996376417d60d49f690d60d408","modified":1713355524000},{"_id":"source/_posts/20250501/assets/ec623644e43b4c56bf1110c9cfc74bc8tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-1zakfmq.awebp","hash":"f509457d8a1e1193ecddd6971b62f7d825ebe4f9","modified":1713355524000},{"_id":"source/_posts/20250501/assets/ec983e41a4b54a31a1f7f7c9ec511974tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-8ibqfew.awebp","hash":"cbf01e2f2b6d17cdefec667d80932d331364c9ed","modified":1713355524000},{"_id":"source/_posts/20250501/assets/f43dc00e2347458c876f15dae66f23d4tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-lapokvs.awebp","hash":"f509457d8a1e1193ecddd6971b62f7d825ebe4f9","modified":1713355524000}],"Category":[{"name":"WSL","_id":"cma56nfvo0002isjj047r393u"},{"name":"Java","_id":"cma56nfvu0007isjjehho4osz"},{"name":"Redis","_id":"cma56nfvv000bisjj7bkx50ac"},{"name":"Javascript","_id":"cma56nfvx000gisjj2yvi3urh"},{"name":"K3S","_id":"cma56nfvy000kisjj25czg1g4"},{"name":"Consul","_id":"cma56nfvz000pisjj1sdd2g4z"},{"name":"Netty","_id":"cma56nfw0000sisjj95c85bq1"}],"Data":[],"Page":[{"title":"分类","date":"2023-03-26T06:56:21.000Z","updated":"2025-04-20T00:08:55.838Z","type":"categories","comments":1,"description":null,"keywords":null,"top_img":null,"mathjax":null,"katex":null,"aside":null,"aplayer":null,"highlight_shrink":null,"_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\ndate: 2023-03-26 14:56:21\nupdated:\ntype: \"categories\"\ncomments:\ndescription:\nkeywords:\ntop_img:\nmathjax:\nkatex:\naside:\naplayer:\nhighlight_shrink:\n---\n","path":"categories/index.html","_id":"cm9s3f3yk0000bfg4b9w86gjl","layout":"page","content":"","excerpt":"","more":""},{"title":"music","date":"2023-03-26T08:02:27.000Z","updated":"2025-04-20T00:08:55.841Z","type":null,"comments":1,"description":null,"keywords":null,"top_img":null,"mathjax":null,"katex":null,"aside":null,"aplayer":null,"highlight_shrink":null,"_content":"","source":"music/index.md","raw":"---\ntitle: music\ndate: 2023-03-26 16:02:27\nupdated:\ntype:\ncomments:\ndescription:\nkeywords:\ntop_img:\nmathjax:\nkatex:\naside:\naplayer:\nhighlight_shrink:\n---\n","path":"music/index.html","_id":"cm9s3f3ys0002bfg46amjefog","layout":"page","content":"","excerpt":"","more":""},{"title":"标签","date":"2023-03-26T06:54:25.000Z","updated":"2025-04-20T00:08:55.841Z","type":"tags","comments":1,"description":null,"keywords":null,"top_img":null,"mathjax":null,"katex":null,"aside":null,"aplayer":null,"highlight_shrink":null,"_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2023-03-26 14:54:25\nupdated:\ntype: \"tags\"\ncomments:\ndescription:\nkeywords:\ntop_img:\nmathjax:\nkatex:\naside:\naplayer:\nhighlight_shrink:\n---\n","path":"tags/index.html","_id":"cm9s3f3yu0004bfg411vb67bv","layout":"page","content":"","excerpt":"","more":""},{"_content":"","source":"about/index.md","raw":"","date":"2025-04-22T06:15:27.631Z","updated":"2025-04-22T06:15:27.631Z","path":"about/index.html","_id":"cm9s4299d0000rmg4gjo77wkg","title":"","comments":1,"layout":"page","content":"","excerpt":"","more":""}],"Post":[{"title":"Base","date":"2022-10-30T05:24:18.000Z","lastmod":"2022-10-30T05:24:18.000Z","_content":"\n# Base\n\n## String 类和常量池\n\n　　String 对象的两种创建方式：\n\n```java\nString str1 = \"abcd\";//先检查字符串常量池中有没有\"abcd\"，如果字符串常量池中没有，则创建一个，然后 str1 指向字符串常量池中的对象，如果有，则直接将 str1 指向\"abcd\"\"；\nString str2 = new String(\"abcd\");//堆中创建一个新的对象\nString str3 = new String(\"abcd\");//堆中创建一个新的对象\nSystem.out.println(str1==str2);//false\nSystem.out.println(str2==str3);//false\n```\n\n　　这两种不同的创建方法是有差别的。\n\n　　第一种方式是在常量池中拿对象,如果没有则在字符串常量池中创建一个；\n第二种方式是直接在堆内存空间创建一个新的对象。\n**注意**\n\n- 直接使用双引号声明出来的 String 对象会直接存储在常量池中\n- 如果不是用双引号声明的 String 对象，可以使用 String 提供的 intern 方法，JDK1.7之前（不包含1.7）的处理方式是在常量池中创建与此 String 内容相同的字符串，并返回常量池中创建的字符串的引用，JDK1.7以及之后的处理方式是在常量池中记录此字符串的引用，并返回该引用\n\n## StringBuffer 和 StrinBuilder 区别 ,String 为何不可变\n\n　　java8 中 String 类使用 final 关键字修饰**字符数组**来保存字符串`private final char value[]`\njava8 之后 java9 等 String 类使用 final 关键字修饰**字节数组**来保存字符串`private final byte[] value`\n\n　　`StringBuffer` 和 `StringBuilder` 继承 `AbstractStringBuilder` 而在`AbstractStringBuilder`中使用字符数组存储字符串`char[] value`并没有使用 final 关键字修饰\n\n- 从线程安全性考虑:\n  String 中对象不可变,可理解为常量,线程安全.`AbstractStringBuilder`是公共父类,定义了一些字符串基本操作.Stringbuffer 对方法添加了同步锁或对调用的方法加了同步锁,线程安全.Stringbuilder 并没有对方法加同步锁加同步锁,所以非线程安全\n- 从性能考虑:\n  每次改变 String 类型会新建一个 String 对象,让后指针指向新的 String 对象,StringBuffer 每次使用对 StringBuffer 对象本身操作,不会产生新的对象,而是改变对象的引用.而 StringBuilder 相比 StringBuffer 性能会提升一部分,但需要承担线程不安全的风险\n\n## 在 Java 中定义一个不做事且没有参数的构造方法的作用\n\n　　在执行子类构造方法时,若没有调用`super()`,则默认会调用父类的无参构造函数,若父类中没有无参构造函数,编译就会报错\n\n## 接口和抽象类的区别是什么？\n\n1. 接口的方法默认是 public，所有方法在接口中不能有实现(Java 8 开始接口方法可以有默认实现），而抽象类可以有非抽象的方法。\n2. 接口中除了 static、final 变量，不能有其他变量，而抽象类中则不一定。\n3. 一个类可以实现多个接口，但只能实现一个抽象类。接口自己本身可以通过 extends 关键字扩展多个接口。\n4. 接口方法默认修饰符是 public，抽象方法可以有 public、protected 和 default 这些修饰符（抽象方法就是为了被重写所以不能使用 private 关键字修饰！）。\n5. 从设计层面来说，抽象是对类的抽象，是一种模板设计，而接口是对行为的抽象，是一种行为的规范。\n6. 关于抽象类 JDK 1.8 以前，抽象类的方法默认访问权限为 protected JDK 1.8 时，抽象类的方法默认访问权限变为 default\n7. JDK 1.8 以前，接口中的方法必须是 public 的 JDK 1.8 时，接口中的方法可以是 public 的，也可以是 default 的\n\n## 成员变量与局部变量区别\n\n　　语法上:成员变量可以被`public``private``static`等修饰,局部变量不能被修饰.但都能被`final`所修饰\n内存中的存储方式:如果成员变量是使用`static`修饰的，那么这个成员变量是属于类的，如果没有使用`static`修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存\n生命周期:成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失\n成员变量如果没有被赋初值,则会自动以类型的默认值而赋值（一种情况例外:被 final 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。\n\n## 为什么重写 equals 时必须重写 hashCode 方法\n\n　　`==` : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不试同一个对象。\n\n　　`equals()` : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况(前面第 1 部分已详细介绍过)：\n情况 1，类没有覆盖`equals()`方法。则通过`equals()`比较该类的两个对象时，等价于通过“==”比较这两个对象。\n情况 2，类覆盖了`equals()`方法。一般，我们都覆盖`equals()`方法来两个对象的内容相等；若它们的内容相等，则返回 true(即，认为这两个对象相等)。\n分两种情况\n\n- 不会创建“类对应的散列表” 例如:不会创建该类的 HashSet 集合。\n\n　　在这种情况下`equals()`用来比较该类的两个对象是否相等。而 hashCode() 则根本没有任何作用，所以，不用理会 hashCode()。\n\n- 会创建“类对应的散列表” 例如，会创建该类的 HashSet 集合,且自定义对象为键值\n\n1. 如果两个对象相等，那么它们的 hashCode()值一定相同。这里的相等是指，通过 equals()比较两个对象时返回 true。\n2. 如果两个对象 hashCode()相等，它们并不一定相等。因为在散列表中，hashCode()相等，即两个键值对的哈希值相等。然而哈希值相等，并不一定能得出键值对相等。 **“两个不同的键值对，哈希值相等”，这就是哈希冲突。**\n\n　　散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）,如果不重写 hashcode 可能会导致相同含义的的不同对象被(hashcode 应该相等)pass 掉.而如果只重写 hashCode 不重写 equals 方法，那么 equals 只是判断两个对象是否是同一个对象\n\n## 值传递和引用传递(java 是值传递)\n\n　　值传递（pass by value）是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。\n引用传递（pass by reference）是指在调用函数时将实际参数的地址直接传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。\n\n## Java 中的异常处理\n\n　　**注意：异常和错误的区别：异常能被程序本身处理，错误是无法处理。**\n\n- try 块： 用于捕获异常。其后可接零个或多个 catch 块，如果没有 catch 块，则必须跟一个 finally 块。\n- catch 块： 用于处理 try 捕获到的异常。\n- finally 块： 无论是否捕获或处理异常，finally 块里的语句都会被执行。当在 try 块或 catch 块中遇到 return 语句时，finally 语句块将在方法返回之前被执行。\n  **在以下 4 种特殊情况下，finally 块不会被执行：**\n- 在 finally 语句块第一行发生了异常。 因为在其他行，finally 块还是会得到执行\n- 在前面的代码中用了 System.exit(int)已退出程序。 exit 是带参函数 ；若该语句在异常语句之后，finally 会执行\n- 程序所在的线程死亡。\n- 关闭 CPU。\n\n> 如果 try 语句里有 return，返回的是 try 语句块中变量值。\n> 详细执行过程如下：\n> a.如果有返回值，就把返回值保存到局部变量中；\n> b.执行 jsr 指令跳到 finally 语句里执行；\n> c.执行完 finally 语句后，返回之前保存在局部变量表里的值。\n> 如果 try，finally 语句里均有 return，忽略 try 的 return，而使用 finally 的 return.\n\n## Java 中 IO 流分为几种?\n\n　　按照流的流向分，可以分为输入流和输出流；\n按照操作单元划分，可以划分为字节流和字符流；\n按照流的角色划分为节点流和处理流。\n\n## java 异常处理\n\n- try 块： 用于捕获异常。其后可接零个或多个 catch 块，如果没有 catch 块，则必须跟一个 finally 块。\n- catch 块： 用于处理 try 捕获到的异常。\n- finally 块： 无论是否捕获或处理异常，finally 块里的语句都会被执行。当在 try 块或 catch 块中遇到 return 语句时，finally 语句块将在方法返回之前被执行。\n\n　　在以下 4 种特殊情况下，finally 块不会被执行：\n\n- 在 finally 语句块第一行发生了异常。 因为在其他行，finally 块还是会得到执行\n- 在前面的代码中用了 System.exit(int)已退出程序。 exit 是带参函数 ；若该语句在异常语句之后，finally 会执行\n- 程序所在的线程死亡。\n- 关闭 CPU。\n  **注意： 当 try 语句和 finally 语句中都有 return 语句时，在方法返回之前，finally 语句的内容将被执行，并且 finally 语句的返回值将会覆盖原始的返回值**\n\n## Java修饰符\n\n### 访问修饰符\n\n#### public\n\n#### protected\n\n#### private\n\n#### default\n\n### 非访问修饰符\n\n#### final 关键字\n\n- final 修饰的类不能被继承，final 类中的所有成员方法都会被隐式的指定为 final 方法；\n- final 修饰的方法不能被重写；\n- final 修饰的变量是常量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能让其指向另一个对象。\n\n#### static 关键字\n\n- 修饰成员变量和成员方法: 被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享，可以并且建议通过类名调用。被 static 声明的成员变量属于静态成员变量，静态变量 存放在 Java 内存区域的方法区。\n- 静态代码块: 静态代码块定义在类中方法外, 静态代码块在非静态代码块之前执行(静态代码块—>非静态代码块—>构造方法)。 该类不管创建多少对象，静态代码块只执行一次.\n- 静态内部类（static 修饰类的话只能修饰内部类）： 静态内部类与非静态内部类之间存在一个最大的区别: **非静态内部类**在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围类，但是**静态内部类**却没有。没有这个引用就意味着：1. 它的创建是不需要依赖外围类的创建。2. 它不能使用任何外围类的非 static 成员变量和方法。\n\n#### abstract\n\n#### synchronized\n\n## Object类\n\n### Object类所有方法详解\n\n　　Object中含有： registerNatives()、getClass()、hashCode()、equals()、clone()、toString()、notify()、notifyAll()、wait(long)、wait(long,int)、wait()、finalize()\n\n- registerNatives()\n  - **注册 native方法**\n- getClass()[(1)](#oJQGR)\n  - 获取类的`Class` 对象\n- hashCode()\n- equals()\n- clone()\n- toString()\n- wait()/ wait(long)/ wait(long,int)\n  - 作用是阻塞当前线程，等待其他线程调用 notify()/notifyAll()方法将其唤醒。\n  - 注意：\n    - 此方法只能在当前线程获取到对象的锁监视器之后才能调用，否则会抛出 IllegalMonitorStateException异常。\n    - 调用 wait方法，线程会将锁监视器进行释放；而 Thread.sleep，Thread.yield()并不会释放锁。\n    - wait方法会一直阻塞，直到其他线程调用当前对象的 notify()/notifyAll()方法将其唤醒；而 wait(long)是等待给定超时时间内（单位毫秒），如果还没有调用 notify()/nofiyAll()会自动唤醒； wait(long,int)如果第二个参数大于 0并且小于 999999，则第一个参数 +1作为超时时间\n- notify()/notifyAll()[(2)](#W03CQ)\n  - 调用 `wait`方法，将锁释放并阻塞；这时另一个线程获取到了此对象锁，并调用此对象的 `notify()/notifyAll()`方法将之前的线程唤醒。\n  - **注意：**\n    - 调用 notify()后，阻塞线程被唤醒，可以参与锁的竞争，但可能调用 notify()方法的线程还要继续做其他事，锁并未释放，所以我们看到的结果是，无论 notify()是在方法一开始调用，还是最后调用，阻塞线程都要等待当前线程结束才能开始。\n- finalize()\n  - 此方法是在垃圾回收之前，JVM会调用此方法来清理资源。此方法可能会将对象重新置为可达状态，导致JVM无法进行垃圾回收。\n  - finalize()方法具有如下4个特点：\n    - 永远不要主动调用某个对象的 finalize()方法，该方法由垃圾回收机制自己调用；\n    - finalize()何时被调用，是否被调用具有不确定性；\n    - 当 JVM执行可恢复对象的 finalize()可能会将此对象重新变为可达状态；\n    - 当 JVM执行 finalize()方法时出现异常，垃圾回收机制不会报告异常，程序继续执行。\n\n### \n\n## 类型转换规则\n\n### 自动类型转换\n\n- boolean类型不能与其他类型进行类型转换\n- 不相关的对象类型不能进行转换\n- 容量大的类型转换为容量小的类型必须强制进行转换\n- 浮点数转换为整数会舍弃小数部分\n- 容量小类型可自动转换为容量大的基础类型\n- char 类型\n\n　　**byte ，short ，char 进行运算会先类型提升为int**\n\n## 引用\n\n### 反射.class、class.forname() 和 getClass() 的区别\n\n- **相同：**\n  - 通过这几种方式，得到的都是java.lang.Class对象；都是类加载的产物\n  - 三种情况在生成 Class 对象的时候都会先判断内存中是否已经加载此类。\n- **不同：**\n  - 出现的时期不同：\n    - Class.forname()在运行时加载；\n    - Class.class和对象名.getClass()是在编译时加载\n  - class.forname() 会装入类并做类的静态初始化\n  - Class c = C.class；JVM将使用类C的类装载器将类C加载到内存中(前提是类C还未加载进内存)，不进行类的初始化工作，返回C的Class对象\n  - Class c = c.getClass()会对类进行静态初始化、非静态初始化，返回引用运行时真正所指的对象（因为子对象的引用可能会赋给父对象的引用变量中）所属的类的 Class 对象\n\n### 为什么 wait()/notify()方法要放到 Object中呢\n\n　　因为每个对象都可以成为锁监视器对象，所以放到 Object中，可以直接使用。\n\n###\n","source":"_posts/java/Base.md","raw":"---\ntitle: Base\ndate: 2022-10-30T13:24:18Z\nlastmod: 2022-10-30T13:24:18Z\n---\n\n# Base\n\n## String 类和常量池\n\n　　String 对象的两种创建方式：\n\n```java\nString str1 = \"abcd\";//先检查字符串常量池中有没有\"abcd\"，如果字符串常量池中没有，则创建一个，然后 str1 指向字符串常量池中的对象，如果有，则直接将 str1 指向\"abcd\"\"；\nString str2 = new String(\"abcd\");//堆中创建一个新的对象\nString str3 = new String(\"abcd\");//堆中创建一个新的对象\nSystem.out.println(str1==str2);//false\nSystem.out.println(str2==str3);//false\n```\n\n　　这两种不同的创建方法是有差别的。\n\n　　第一种方式是在常量池中拿对象,如果没有则在字符串常量池中创建一个；\n第二种方式是直接在堆内存空间创建一个新的对象。\n**注意**\n\n- 直接使用双引号声明出来的 String 对象会直接存储在常量池中\n- 如果不是用双引号声明的 String 对象，可以使用 String 提供的 intern 方法，JDK1.7之前（不包含1.7）的处理方式是在常量池中创建与此 String 内容相同的字符串，并返回常量池中创建的字符串的引用，JDK1.7以及之后的处理方式是在常量池中记录此字符串的引用，并返回该引用\n\n## StringBuffer 和 StrinBuilder 区别 ,String 为何不可变\n\n　　java8 中 String 类使用 final 关键字修饰**字符数组**来保存字符串`private final char value[]`\njava8 之后 java9 等 String 类使用 final 关键字修饰**字节数组**来保存字符串`private final byte[] value`\n\n　　`StringBuffer` 和 `StringBuilder` 继承 `AbstractStringBuilder` 而在`AbstractStringBuilder`中使用字符数组存储字符串`char[] value`并没有使用 final 关键字修饰\n\n- 从线程安全性考虑:\n  String 中对象不可变,可理解为常量,线程安全.`AbstractStringBuilder`是公共父类,定义了一些字符串基本操作.Stringbuffer 对方法添加了同步锁或对调用的方法加了同步锁,线程安全.Stringbuilder 并没有对方法加同步锁加同步锁,所以非线程安全\n- 从性能考虑:\n  每次改变 String 类型会新建一个 String 对象,让后指针指向新的 String 对象,StringBuffer 每次使用对 StringBuffer 对象本身操作,不会产生新的对象,而是改变对象的引用.而 StringBuilder 相比 StringBuffer 性能会提升一部分,但需要承担线程不安全的风险\n\n## 在 Java 中定义一个不做事且没有参数的构造方法的作用\n\n　　在执行子类构造方法时,若没有调用`super()`,则默认会调用父类的无参构造函数,若父类中没有无参构造函数,编译就会报错\n\n## 接口和抽象类的区别是什么？\n\n1. 接口的方法默认是 public，所有方法在接口中不能有实现(Java 8 开始接口方法可以有默认实现），而抽象类可以有非抽象的方法。\n2. 接口中除了 static、final 变量，不能有其他变量，而抽象类中则不一定。\n3. 一个类可以实现多个接口，但只能实现一个抽象类。接口自己本身可以通过 extends 关键字扩展多个接口。\n4. 接口方法默认修饰符是 public，抽象方法可以有 public、protected 和 default 这些修饰符（抽象方法就是为了被重写所以不能使用 private 关键字修饰！）。\n5. 从设计层面来说，抽象是对类的抽象，是一种模板设计，而接口是对行为的抽象，是一种行为的规范。\n6. 关于抽象类 JDK 1.8 以前，抽象类的方法默认访问权限为 protected JDK 1.8 时，抽象类的方法默认访问权限变为 default\n7. JDK 1.8 以前，接口中的方法必须是 public 的 JDK 1.8 时，接口中的方法可以是 public 的，也可以是 default 的\n\n## 成员变量与局部变量区别\n\n　　语法上:成员变量可以被`public``private``static`等修饰,局部变量不能被修饰.但都能被`final`所修饰\n内存中的存储方式:如果成员变量是使用`static`修饰的，那么这个成员变量是属于类的，如果没有使用`static`修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存\n生命周期:成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失\n成员变量如果没有被赋初值,则会自动以类型的默认值而赋值（一种情况例外:被 final 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。\n\n## 为什么重写 equals 时必须重写 hashCode 方法\n\n　　`==` : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不试同一个对象。\n\n　　`equals()` : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况(前面第 1 部分已详细介绍过)：\n情况 1，类没有覆盖`equals()`方法。则通过`equals()`比较该类的两个对象时，等价于通过“==”比较这两个对象。\n情况 2，类覆盖了`equals()`方法。一般，我们都覆盖`equals()`方法来两个对象的内容相等；若它们的内容相等，则返回 true(即，认为这两个对象相等)。\n分两种情况\n\n- 不会创建“类对应的散列表” 例如:不会创建该类的 HashSet 集合。\n\n　　在这种情况下`equals()`用来比较该类的两个对象是否相等。而 hashCode() 则根本没有任何作用，所以，不用理会 hashCode()。\n\n- 会创建“类对应的散列表” 例如，会创建该类的 HashSet 集合,且自定义对象为键值\n\n1. 如果两个对象相等，那么它们的 hashCode()值一定相同。这里的相等是指，通过 equals()比较两个对象时返回 true。\n2. 如果两个对象 hashCode()相等，它们并不一定相等。因为在散列表中，hashCode()相等，即两个键值对的哈希值相等。然而哈希值相等，并不一定能得出键值对相等。 **“两个不同的键值对，哈希值相等”，这就是哈希冲突。**\n\n　　散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）,如果不重写 hashcode 可能会导致相同含义的的不同对象被(hashcode 应该相等)pass 掉.而如果只重写 hashCode 不重写 equals 方法，那么 equals 只是判断两个对象是否是同一个对象\n\n## 值传递和引用传递(java 是值传递)\n\n　　值传递（pass by value）是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。\n引用传递（pass by reference）是指在调用函数时将实际参数的地址直接传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。\n\n## Java 中的异常处理\n\n　　**注意：异常和错误的区别：异常能被程序本身处理，错误是无法处理。**\n\n- try 块： 用于捕获异常。其后可接零个或多个 catch 块，如果没有 catch 块，则必须跟一个 finally 块。\n- catch 块： 用于处理 try 捕获到的异常。\n- finally 块： 无论是否捕获或处理异常，finally 块里的语句都会被执行。当在 try 块或 catch 块中遇到 return 语句时，finally 语句块将在方法返回之前被执行。\n  **在以下 4 种特殊情况下，finally 块不会被执行：**\n- 在 finally 语句块第一行发生了异常。 因为在其他行，finally 块还是会得到执行\n- 在前面的代码中用了 System.exit(int)已退出程序。 exit 是带参函数 ；若该语句在异常语句之后，finally 会执行\n- 程序所在的线程死亡。\n- 关闭 CPU。\n\n> 如果 try 语句里有 return，返回的是 try 语句块中变量值。\n> 详细执行过程如下：\n> a.如果有返回值，就把返回值保存到局部变量中；\n> b.执行 jsr 指令跳到 finally 语句里执行；\n> c.执行完 finally 语句后，返回之前保存在局部变量表里的值。\n> 如果 try，finally 语句里均有 return，忽略 try 的 return，而使用 finally 的 return.\n\n## Java 中 IO 流分为几种?\n\n　　按照流的流向分，可以分为输入流和输出流；\n按照操作单元划分，可以划分为字节流和字符流；\n按照流的角色划分为节点流和处理流。\n\n## java 异常处理\n\n- try 块： 用于捕获异常。其后可接零个或多个 catch 块，如果没有 catch 块，则必须跟一个 finally 块。\n- catch 块： 用于处理 try 捕获到的异常。\n- finally 块： 无论是否捕获或处理异常，finally 块里的语句都会被执行。当在 try 块或 catch 块中遇到 return 语句时，finally 语句块将在方法返回之前被执行。\n\n　　在以下 4 种特殊情况下，finally 块不会被执行：\n\n- 在 finally 语句块第一行发生了异常。 因为在其他行，finally 块还是会得到执行\n- 在前面的代码中用了 System.exit(int)已退出程序。 exit 是带参函数 ；若该语句在异常语句之后，finally 会执行\n- 程序所在的线程死亡。\n- 关闭 CPU。\n  **注意： 当 try 语句和 finally 语句中都有 return 语句时，在方法返回之前，finally 语句的内容将被执行，并且 finally 语句的返回值将会覆盖原始的返回值**\n\n## Java修饰符\n\n### 访问修饰符\n\n#### public\n\n#### protected\n\n#### private\n\n#### default\n\n### 非访问修饰符\n\n#### final 关键字\n\n- final 修饰的类不能被继承，final 类中的所有成员方法都会被隐式的指定为 final 方法；\n- final 修饰的方法不能被重写；\n- final 修饰的变量是常量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能让其指向另一个对象。\n\n#### static 关键字\n\n- 修饰成员变量和成员方法: 被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享，可以并且建议通过类名调用。被 static 声明的成员变量属于静态成员变量，静态变量 存放在 Java 内存区域的方法区。\n- 静态代码块: 静态代码块定义在类中方法外, 静态代码块在非静态代码块之前执行(静态代码块—>非静态代码块—>构造方法)。 该类不管创建多少对象，静态代码块只执行一次.\n- 静态内部类（static 修饰类的话只能修饰内部类）： 静态内部类与非静态内部类之间存在一个最大的区别: **非静态内部类**在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围类，但是**静态内部类**却没有。没有这个引用就意味着：1. 它的创建是不需要依赖外围类的创建。2. 它不能使用任何外围类的非 static 成员变量和方法。\n\n#### abstract\n\n#### synchronized\n\n## Object类\n\n### Object类所有方法详解\n\n　　Object中含有： registerNatives()、getClass()、hashCode()、equals()、clone()、toString()、notify()、notifyAll()、wait(long)、wait(long,int)、wait()、finalize()\n\n- registerNatives()\n  - **注册 native方法**\n- getClass()[(1)](#oJQGR)\n  - 获取类的`Class` 对象\n- hashCode()\n- equals()\n- clone()\n- toString()\n- wait()/ wait(long)/ wait(long,int)\n  - 作用是阻塞当前线程，等待其他线程调用 notify()/notifyAll()方法将其唤醒。\n  - 注意：\n    - 此方法只能在当前线程获取到对象的锁监视器之后才能调用，否则会抛出 IllegalMonitorStateException异常。\n    - 调用 wait方法，线程会将锁监视器进行释放；而 Thread.sleep，Thread.yield()并不会释放锁。\n    - wait方法会一直阻塞，直到其他线程调用当前对象的 notify()/notifyAll()方法将其唤醒；而 wait(long)是等待给定超时时间内（单位毫秒），如果还没有调用 notify()/nofiyAll()会自动唤醒； wait(long,int)如果第二个参数大于 0并且小于 999999，则第一个参数 +1作为超时时间\n- notify()/notifyAll()[(2)](#W03CQ)\n  - 调用 `wait`方法，将锁释放并阻塞；这时另一个线程获取到了此对象锁，并调用此对象的 `notify()/notifyAll()`方法将之前的线程唤醒。\n  - **注意：**\n    - 调用 notify()后，阻塞线程被唤醒，可以参与锁的竞争，但可能调用 notify()方法的线程还要继续做其他事，锁并未释放，所以我们看到的结果是，无论 notify()是在方法一开始调用，还是最后调用，阻塞线程都要等待当前线程结束才能开始。\n- finalize()\n  - 此方法是在垃圾回收之前，JVM会调用此方法来清理资源。此方法可能会将对象重新置为可达状态，导致JVM无法进行垃圾回收。\n  - finalize()方法具有如下4个特点：\n    - 永远不要主动调用某个对象的 finalize()方法，该方法由垃圾回收机制自己调用；\n    - finalize()何时被调用，是否被调用具有不确定性；\n    - 当 JVM执行可恢复对象的 finalize()可能会将此对象重新变为可达状态；\n    - 当 JVM执行 finalize()方法时出现异常，垃圾回收机制不会报告异常，程序继续执行。\n\n### \n\n## 类型转换规则\n\n### 自动类型转换\n\n- boolean类型不能与其他类型进行类型转换\n- 不相关的对象类型不能进行转换\n- 容量大的类型转换为容量小的类型必须强制进行转换\n- 浮点数转换为整数会舍弃小数部分\n- 容量小类型可自动转换为容量大的基础类型\n- char 类型\n\n　　**byte ，short ，char 进行运算会先类型提升为int**\n\n## 引用\n\n### 反射.class、class.forname() 和 getClass() 的区别\n\n- **相同：**\n  - 通过这几种方式，得到的都是java.lang.Class对象；都是类加载的产物\n  - 三种情况在生成 Class 对象的时候都会先判断内存中是否已经加载此类。\n- **不同：**\n  - 出现的时期不同：\n    - Class.forname()在运行时加载；\n    - Class.class和对象名.getClass()是在编译时加载\n  - class.forname() 会装入类并做类的静态初始化\n  - Class c = C.class；JVM将使用类C的类装载器将类C加载到内存中(前提是类C还未加载进内存)，不进行类的初始化工作，返回C的Class对象\n  - Class c = c.getClass()会对类进行静态初始化、非静态初始化，返回引用运行时真正所指的对象（因为子对象的引用可能会赋给父对象的引用变量中）所属的类的 Class 对象\n\n### 为什么 wait()/notify()方法要放到 Object中呢\n\n　　因为每个对象都可以成为锁监视器对象，所以放到 Object中，可以直接使用。\n\n###\n","slug":"java-Base","published":1,"updated":"2025-04-20T00:08:55.544Z","_id":"cm9s3f3yo0001bfg4gji44ji6","comments":1,"layout":"post","photos":[],"content":"<h1>Base</h1>\n<h2 id=\"String-类和常量池\">String 类和常量池</h2>\n<p>String 对象的两种创建方式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">str1</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;abcd&quot;</span>;<span class=\"comment\">//先检查字符串常量池中有没有&quot;abcd&quot;，如果字符串常量池中没有，则创建一个，然后 str1 指向字符串常量池中的对象，如果有，则直接将 str1 指向&quot;abcd&quot;&quot;；</span></span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">str2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(<span class=\"string\">&quot;abcd&quot;</span>);<span class=\"comment\">//堆中创建一个新的对象</span></span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">str3</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(<span class=\"string\">&quot;abcd&quot;</span>);<span class=\"comment\">//堆中创建一个新的对象</span></span><br><span class=\"line\">System.out.println(str1==str2);<span class=\"comment\">//false</span></span><br><span class=\"line\">System.out.println(str2==str3);<span class=\"comment\">//false</span></span><br></pre></td></tr></table></figure>\n<p>这两种不同的创建方法是有差别的。</p>\n<p>第一种方式是在常量池中拿对象,如果没有则在字符串常量池中创建一个；<br>\n第二种方式是直接在堆内存空间创建一个新的对象。<br>\n<strong>注意</strong></p>\n<ul>\n<li>直接使用双引号声明出来的 String 对象会直接存储在常量池中</li>\n<li>如果不是用双引号声明的 String 对象，可以使用 String 提供的 intern 方法，JDK1.7之前（不包含1.7）的处理方式是在常量池中创建与此 String 内容相同的字符串，并返回常量池中创建的字符串的引用，JDK1.7以及之后的处理方式是在常量池中记录此字符串的引用，并返回该引用</li>\n</ul>\n<h2 id=\"StringBuffer-和-StrinBuilder-区别-String-为何不可变\">StringBuffer 和 StrinBuilder 区别 ,String 为何不可变</h2>\n<p>java8 中 String 类使用 final 关键字修饰<strong>字符数组</strong>来保存字符串<code>private final char value[]</code><br>\njava8 之后 java9 等 String 类使用 final 关键字修饰<strong>字节数组</strong>来保存字符串<code>private final byte[] value</code></p>\n<p><code>StringBuffer</code> 和 <code>StringBuilder</code> 继承 <code>AbstractStringBuilder</code> 而在<code>AbstractStringBuilder</code>中使用字符数组存储字符串<code>char[] value</code>并没有使用 final 关键字修饰</p>\n<ul>\n<li>从线程安全性考虑:<br>\nString 中对象不可变,可理解为常量,线程安全.<code>AbstractStringBuilder</code>是公共父类,定义了一些字符串基本操作.Stringbuffer 对方法添加了同步锁或对调用的方法加了同步锁,线程安全.Stringbuilder 并没有对方法加同步锁加同步锁,所以非线程安全</li>\n<li>从性能考虑:<br>\n每次改变 String 类型会新建一个 String 对象,让后指针指向新的 String 对象,StringBuffer 每次使用对 StringBuffer 对象本身操作,不会产生新的对象,而是改变对象的引用.而 StringBuilder 相比 StringBuffer 性能会提升一部分,但需要承担线程不安全的风险</li>\n</ul>\n<h2 id=\"在-Java-中定义一个不做事且没有参数的构造方法的作用\">在 Java 中定义一个不做事且没有参数的构造方法的作用</h2>\n<p>在执行子类构造方法时,若没有调用<code>super()</code>,则默认会调用父类的无参构造函数,若父类中没有无参构造函数,编译就会报错</p>\n<h2 id=\"接口和抽象类的区别是什么？\">接口和抽象类的区别是什么？</h2>\n<ol>\n<li>接口的方法默认是 public，所有方法在接口中不能有实现(Java 8 开始接口方法可以有默认实现），而抽象类可以有非抽象的方法。</li>\n<li>接口中除了 static、final 变量，不能有其他变量，而抽象类中则不一定。</li>\n<li>一个类可以实现多个接口，但只能实现一个抽象类。接口自己本身可以通过 extends 关键字扩展多个接口。</li>\n<li>接口方法默认修饰符是 public，抽象方法可以有 public、protected 和 default 这些修饰符（抽象方法就是为了被重写所以不能使用 private 关键字修饰！）。</li>\n<li>从设计层面来说，抽象是对类的抽象，是一种模板设计，而接口是对行为的抽象，是一种行为的规范。</li>\n<li>关于抽象类 JDK 1.8 以前，抽象类的方法默认访问权限为 protected JDK 1.8 时，抽象类的方法默认访问权限变为 default</li>\n<li>JDK 1.8 以前，接口中的方法必须是 public 的 JDK 1.8 时，接口中的方法可以是 public 的，也可以是 default 的</li>\n</ol>\n<h2 id=\"成员变量与局部变量区别\">成员变量与局部变量区别</h2>\n<p>语法上:成员变量可以被<code>public``private``static</code>等修饰,局部变量不能被修饰.但都能被<code>final</code>所修饰<br>\n内存中的存储方式:如果成员变量是使用<code>static</code>修饰的，那么这个成员变量是属于类的，如果没有使用<code>static</code>修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存<br>\n生命周期:成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失<br>\n成员变量如果没有被赋初值,则会自动以类型的默认值而赋值（一种情况例外:被 final 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。</p>\n<h2 id=\"为什么重写-equals-时必须重写-hashCode-方法\">为什么重写 equals 时必须重写 hashCode 方法</h2>\n<p><code>==</code> : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不试同一个对象。</p>\n<p><code>equals()</code> : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况(前面第 1 部分已详细介绍过)：<br>\n情况 1，类没有覆盖<code>equals()</code>方法。则通过<code>equals()</code>比较该类的两个对象时，等价于通过“==”比较这两个对象。<br>\n情况 2，类覆盖了<code>equals()</code>方法。一般，我们都覆盖<code>equals()</code>方法来两个对象的内容相等；若它们的内容相等，则返回 true(即，认为这两个对象相等)。<br>\n分两种情况</p>\n<ul>\n<li>不会创建“类对应的散列表” 例如:不会创建该类的 HashSet 集合。</li>\n</ul>\n<p>在这种情况下<code>equals()</code>用来比较该类的两个对象是否相等。而 hashCode() 则根本没有任何作用，所以，不用理会 hashCode()。</p>\n<ul>\n<li>会创建“类对应的散列表” 例如，会创建该类的 HashSet 集合,且自定义对象为键值</li>\n</ul>\n<ol>\n<li>如果两个对象相等，那么它们的 hashCode()值一定相同。这里的相等是指，通过 equals()比较两个对象时返回 true。</li>\n<li>如果两个对象 hashCode()相等，它们并不一定相等。因为在散列表中，hashCode()相等，即两个键值对的哈希值相等。然而哈希值相等，并不一定能得出键值对相等。 <strong>“两个不同的键值对，哈希值相等”，这就是哈希冲突。</strong></li>\n</ol>\n<p>散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）,如果不重写 hashcode 可能会导致相同含义的的不同对象被(hashcode 应该相等)pass 掉.而如果只重写 hashCode 不重写 equals 方法，那么 equals 只是判断两个对象是否是同一个对象</p>\n<h2 id=\"值传递和引用传递-java-是值传递\">值传递和引用传递(java 是值传递)</h2>\n<p>值传递（pass by value）是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。<br>\n引用传递（pass by reference）是指在调用函数时将实际参数的地址直接传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。</p>\n<h2 id=\"Java-中的异常处理\">Java 中的异常处理</h2>\n<p><strong>注意：异常和错误的区别：异常能被程序本身处理，错误是无法处理。</strong></p>\n<ul>\n<li>try 块： 用于捕获异常。其后可接零个或多个 catch 块，如果没有 catch 块，则必须跟一个 finally 块。</li>\n<li>catch 块： 用于处理 try 捕获到的异常。</li>\n<li>finally 块： 无论是否捕获或处理异常，finally 块里的语句都会被执行。当在 try 块或 catch 块中遇到 return 语句时，finally 语句块将在方法返回之前被执行。<br>\n<strong>在以下 4 种特殊情况下，finally 块不会被执行：</strong></li>\n<li>在 finally 语句块第一行发生了异常。 因为在其他行，finally 块还是会得到执行</li>\n<li>在前面的代码中用了 System.exit(int)已退出程序。 exit 是带参函数 ；若该语句在异常语句之后，finally 会执行</li>\n<li>程序所在的线程死亡。</li>\n<li>关闭 CPU。</li>\n</ul>\n<blockquote>\n<p>如果 try 语句里有 return，返回的是 try 语句块中变量值。<br>\n详细执行过程如下：<br>\na.如果有返回值，就把返回值保存到局部变量中；<br>\nb.执行 jsr 指令跳到 finally 语句里执行；<br>\nc.执行完 finally 语句后，返回之前保存在局部变量表里的值。<br>\n如果 try，finally 语句里均有 return，忽略 try 的 return，而使用 finally 的 return.</p>\n</blockquote>\n<h2 id=\"Java-中-IO-流分为几种\">Java 中 IO 流分为几种?</h2>\n<p>按照流的流向分，可以分为输入流和输出流；<br>\n按照操作单元划分，可以划分为字节流和字符流；<br>\n按照流的角色划分为节点流和处理流。</p>\n<h2 id=\"java-异常处理\">java 异常处理</h2>\n<ul>\n<li>try 块： 用于捕获异常。其后可接零个或多个 catch 块，如果没有 catch 块，则必须跟一个 finally 块。</li>\n<li>catch 块： 用于处理 try 捕获到的异常。</li>\n<li>finally 块： 无论是否捕获或处理异常，finally 块里的语句都会被执行。当在 try 块或 catch 块中遇到 return 语句时，finally 语句块将在方法返回之前被执行。</li>\n</ul>\n<p>在以下 4 种特殊情况下，finally 块不会被执行：</p>\n<ul>\n<li>在 finally 语句块第一行发生了异常。 因为在其他行，finally 块还是会得到执行</li>\n<li>在前面的代码中用了 System.exit(int)已退出程序。 exit 是带参函数 ；若该语句在异常语句之后，finally 会执行</li>\n<li>程序所在的线程死亡。</li>\n<li>关闭 CPU。<br>\n<strong>注意： 当 try 语句和 finally 语句中都有 return 语句时，在方法返回之前，finally 语句的内容将被执行，并且 finally 语句的返回值将会覆盖原始的返回值</strong></li>\n</ul>\n<h2 id=\"Java修饰符\">Java修饰符</h2>\n<h3 id=\"访问修饰符\">访问修饰符</h3>\n<h4 id=\"public\">public</h4>\n<h4 id=\"protected\">protected</h4>\n<h4 id=\"private\">private</h4>\n<h4 id=\"default\">default</h4>\n<h3 id=\"非访问修饰符\">非访问修饰符</h3>\n<h4 id=\"final-关键字\">final 关键字</h4>\n<ul>\n<li>final 修饰的类不能被继承，final 类中的所有成员方法都会被隐式的指定为 final 方法；</li>\n<li>final 修饰的方法不能被重写；</li>\n<li>final 修饰的变量是常量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能让其指向另一个对象。</li>\n</ul>\n<h4 id=\"static-关键字\">static 关键字</h4>\n<ul>\n<li>修饰成员变量和成员方法: 被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享，可以并且建议通过类名调用。被 static 声明的成员变量属于静态成员变量，静态变量 存放在 Java 内存区域的方法区。</li>\n<li>静态代码块: 静态代码块定义在类中方法外, 静态代码块在非静态代码块之前执行(静态代码块—&gt;非静态代码块—&gt;构造方法)。 该类不管创建多少对象，静态代码块只执行一次.</li>\n<li>静态内部类（static 修饰类的话只能修饰内部类）： 静态内部类与非静态内部类之间存在一个最大的区别: <strong>非静态内部类</strong>在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围类，但是<strong>静态内部类</strong>却没有。没有这个引用就意味着：1. 它的创建是不需要依赖外围类的创建。2. 它不能使用任何外围类的非 static 成员变量和方法。</li>\n</ul>\n<h4 id=\"abstract\">abstract</h4>\n<h4 id=\"synchronized\">synchronized</h4>\n<h2 id=\"Object类\">Object类</h2>\n<h3 id=\"Object类所有方法详解\">Object类所有方法详解</h3>\n<p>Object中含有： registerNatives()、getClass()、hashCode()、equals()、clone()、toString()、notify()、notifyAll()、wait(long)、wait(long,int)、wait()、finalize()</p>\n<ul>\n<li>registerNatives()\n<ul>\n<li><strong>注册 native方法</strong></li>\n</ul>\n</li>\n<li>getClass()<a href=\"#oJQGR\">(1)</a>\n<ul>\n<li>获取类的<code>Class</code> 对象</li>\n</ul>\n</li>\n<li>hashCode()</li>\n<li>equals()</li>\n<li>clone()</li>\n<li>toString()</li>\n<li>wait()/ wait(long)/ wait(long,int)\n<ul>\n<li>作用是阻塞当前线程，等待其他线程调用 notify()/notifyAll()方法将其唤醒。</li>\n<li>注意：\n<ul>\n<li>此方法只能在当前线程获取到对象的锁监视器之后才能调用，否则会抛出 IllegalMonitorStateException异常。</li>\n<li>调用 wait方法，线程会将锁监视器进行释放；而 Thread.sleep，Thread.yield()并不会释放锁。</li>\n<li>wait方法会一直阻塞，直到其他线程调用当前对象的 notify()/notifyAll()方法将其唤醒；而 wait(long)是等待给定超时时间内（单位毫秒），如果还没有调用 notify()/nofiyAll()会自动唤醒； wait(long,int)如果第二个参数大于 0并且小于 999999，则第一个参数 +1作为超时时间</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>notify()/notifyAll()<a href=\"#W03CQ\">(2)</a>\n<ul>\n<li>调用 <code>wait</code>方法，将锁释放并阻塞；这时另一个线程获取到了此对象锁，并调用此对象的 <code>notify()/notifyAll()</code>方法将之前的线程唤醒。</li>\n<li><strong>注意：</strong>\n<ul>\n<li>调用 notify()后，阻塞线程被唤醒，可以参与锁的竞争，但可能调用 notify()方法的线程还要继续做其他事，锁并未释放，所以我们看到的结果是，无论 notify()是在方法一开始调用，还是最后调用，阻塞线程都要等待当前线程结束才能开始。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>finalize()\n<ul>\n<li>此方法是在垃圾回收之前，JVM会调用此方法来清理资源。此方法可能会将对象重新置为可达状态，导致JVM无法进行垃圾回收。</li>\n<li>finalize()方法具有如下4个特点：\n<ul>\n<li>永远不要主动调用某个对象的 finalize()方法，该方法由垃圾回收机制自己调用；</li>\n<li>finalize()何时被调用，是否被调用具有不确定性；</li>\n<li>当 JVM执行可恢复对象的 finalize()可能会将此对象重新变为可达状态；</li>\n<li>当 JVM执行 finalize()方法时出现异常，垃圾回收机制不会报告异常，程序继续执行。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"\"></h3>\n<h2 id=\"类型转换规则\">类型转换规则</h2>\n<h3 id=\"自动类型转换\">自动类型转换</h3>\n<ul>\n<li>boolean类型不能与其他类型进行类型转换</li>\n<li>不相关的对象类型不能进行转换</li>\n<li>容量大的类型转换为容量小的类型必须强制进行转换</li>\n<li>浮点数转换为整数会舍弃小数部分</li>\n<li>容量小类型可自动转换为容量大的基础类型</li>\n<li>char 类型</li>\n</ul>\n<p><strong>byte ，short ，char 进行运算会先类型提升为int</strong></p>\n<h2 id=\"引用\">引用</h2>\n<h3 id=\"反射-class、class-forname-和-getClass-的区别\">反射.class、class.forname() 和 getClass() 的区别</h3>\n<ul>\n<li><strong>相同：</strong>\n<ul>\n<li>通过这几种方式，得到的都是java.lang.Class对象；都是类加载的产物</li>\n<li>三种情况在生成 Class 对象的时候都会先判断内存中是否已经加载此类。</li>\n</ul>\n</li>\n<li><strong>不同：</strong>\n<ul>\n<li>出现的时期不同：\n<ul>\n<li>Class.forname()在运行时加载；</li>\n<li>Class.class和对象名.getClass()是在编译时加载</li>\n</ul>\n</li>\n<li>class.forname() 会装入类并做类的静态初始化</li>\n<li>Class c = C.class；JVM将使用类C的类装载器将类C加载到内存中(前提是类C还未加载进内存)，不进行类的初始化工作，返回C的Class对象</li>\n<li>Class c = c.getClass()会对类进行静态初始化、非静态初始化，返回引用运行时真正所指的对象（因为子对象的引用可能会赋给父对象的引用变量中）所属的类的 Class 对象</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"为什么-wait-notify-方法要放到-Object中呢\">为什么 wait()/notify()方法要放到 Object中呢</h3>\n<p>因为每个对象都可以成为锁监视器对象，所以放到 Object中，可以直接使用。</p>\n<h3 id=\"-2\"></h3>\n","excerpt":"","more":"<h1>Base</h1>\n<h2 id=\"String-类和常量池\">String 类和常量池</h2>\n<p>String 对象的两种创建方式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">str1</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;abcd&quot;</span>;<span class=\"comment\">//先检查字符串常量池中有没有&quot;abcd&quot;，如果字符串常量池中没有，则创建一个，然后 str1 指向字符串常量池中的对象，如果有，则直接将 str1 指向&quot;abcd&quot;&quot;；</span></span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">str2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(<span class=\"string\">&quot;abcd&quot;</span>);<span class=\"comment\">//堆中创建一个新的对象</span></span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">str3</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(<span class=\"string\">&quot;abcd&quot;</span>);<span class=\"comment\">//堆中创建一个新的对象</span></span><br><span class=\"line\">System.out.println(str1==str2);<span class=\"comment\">//false</span></span><br><span class=\"line\">System.out.println(str2==str3);<span class=\"comment\">//false</span></span><br></pre></td></tr></table></figure>\n<p>这两种不同的创建方法是有差别的。</p>\n<p>第一种方式是在常量池中拿对象,如果没有则在字符串常量池中创建一个；<br>\n第二种方式是直接在堆内存空间创建一个新的对象。<br>\n<strong>注意</strong></p>\n<ul>\n<li>直接使用双引号声明出来的 String 对象会直接存储在常量池中</li>\n<li>如果不是用双引号声明的 String 对象，可以使用 String 提供的 intern 方法，JDK1.7之前（不包含1.7）的处理方式是在常量池中创建与此 String 内容相同的字符串，并返回常量池中创建的字符串的引用，JDK1.7以及之后的处理方式是在常量池中记录此字符串的引用，并返回该引用</li>\n</ul>\n<h2 id=\"StringBuffer-和-StrinBuilder-区别-String-为何不可变\">StringBuffer 和 StrinBuilder 区别 ,String 为何不可变</h2>\n<p>java8 中 String 类使用 final 关键字修饰<strong>字符数组</strong>来保存字符串<code>private final char value[]</code><br>\njava8 之后 java9 等 String 类使用 final 关键字修饰<strong>字节数组</strong>来保存字符串<code>private final byte[] value</code></p>\n<p><code>StringBuffer</code> 和 <code>StringBuilder</code> 继承 <code>AbstractStringBuilder</code> 而在<code>AbstractStringBuilder</code>中使用字符数组存储字符串<code>char[] value</code>并没有使用 final 关键字修饰</p>\n<ul>\n<li>从线程安全性考虑:<br>\nString 中对象不可变,可理解为常量,线程安全.<code>AbstractStringBuilder</code>是公共父类,定义了一些字符串基本操作.Stringbuffer 对方法添加了同步锁或对调用的方法加了同步锁,线程安全.Stringbuilder 并没有对方法加同步锁加同步锁,所以非线程安全</li>\n<li>从性能考虑:<br>\n每次改变 String 类型会新建一个 String 对象,让后指针指向新的 String 对象,StringBuffer 每次使用对 StringBuffer 对象本身操作,不会产生新的对象,而是改变对象的引用.而 StringBuilder 相比 StringBuffer 性能会提升一部分,但需要承担线程不安全的风险</li>\n</ul>\n<h2 id=\"在-Java-中定义一个不做事且没有参数的构造方法的作用\">在 Java 中定义一个不做事且没有参数的构造方法的作用</h2>\n<p>在执行子类构造方法时,若没有调用<code>super()</code>,则默认会调用父类的无参构造函数,若父类中没有无参构造函数,编译就会报错</p>\n<h2 id=\"接口和抽象类的区别是什么？\">接口和抽象类的区别是什么？</h2>\n<ol>\n<li>接口的方法默认是 public，所有方法在接口中不能有实现(Java 8 开始接口方法可以有默认实现），而抽象类可以有非抽象的方法。</li>\n<li>接口中除了 static、final 变量，不能有其他变量，而抽象类中则不一定。</li>\n<li>一个类可以实现多个接口，但只能实现一个抽象类。接口自己本身可以通过 extends 关键字扩展多个接口。</li>\n<li>接口方法默认修饰符是 public，抽象方法可以有 public、protected 和 default 这些修饰符（抽象方法就是为了被重写所以不能使用 private 关键字修饰！）。</li>\n<li>从设计层面来说，抽象是对类的抽象，是一种模板设计，而接口是对行为的抽象，是一种行为的规范。</li>\n<li>关于抽象类 JDK 1.8 以前，抽象类的方法默认访问权限为 protected JDK 1.8 时，抽象类的方法默认访问权限变为 default</li>\n<li>JDK 1.8 以前，接口中的方法必须是 public 的 JDK 1.8 时，接口中的方法可以是 public 的，也可以是 default 的</li>\n</ol>\n<h2 id=\"成员变量与局部变量区别\">成员变量与局部变量区别</h2>\n<p>语法上:成员变量可以被<code>public``private``static</code>等修饰,局部变量不能被修饰.但都能被<code>final</code>所修饰<br>\n内存中的存储方式:如果成员变量是使用<code>static</code>修饰的，那么这个成员变量是属于类的，如果没有使用<code>static</code>修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存<br>\n生命周期:成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失<br>\n成员变量如果没有被赋初值,则会自动以类型的默认值而赋值（一种情况例外:被 final 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。</p>\n<h2 id=\"为什么重写-equals-时必须重写-hashCode-方法\">为什么重写 equals 时必须重写 hashCode 方法</h2>\n<p><code>==</code> : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不试同一个对象。</p>\n<p><code>equals()</code> : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况(前面第 1 部分已详细介绍过)：<br>\n情况 1，类没有覆盖<code>equals()</code>方法。则通过<code>equals()</code>比较该类的两个对象时，等价于通过“==”比较这两个对象。<br>\n情况 2，类覆盖了<code>equals()</code>方法。一般，我们都覆盖<code>equals()</code>方法来两个对象的内容相等；若它们的内容相等，则返回 true(即，认为这两个对象相等)。<br>\n分两种情况</p>\n<ul>\n<li>不会创建“类对应的散列表” 例如:不会创建该类的 HashSet 集合。</li>\n</ul>\n<p>在这种情况下<code>equals()</code>用来比较该类的两个对象是否相等。而 hashCode() 则根本没有任何作用，所以，不用理会 hashCode()。</p>\n<ul>\n<li>会创建“类对应的散列表” 例如，会创建该类的 HashSet 集合,且自定义对象为键值</li>\n</ul>\n<ol>\n<li>如果两个对象相等，那么它们的 hashCode()值一定相同。这里的相等是指，通过 equals()比较两个对象时返回 true。</li>\n<li>如果两个对象 hashCode()相等，它们并不一定相等。因为在散列表中，hashCode()相等，即两个键值对的哈希值相等。然而哈希值相等，并不一定能得出键值对相等。 <strong>“两个不同的键值对，哈希值相等”，这就是哈希冲突。</strong></li>\n</ol>\n<p>散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）,如果不重写 hashcode 可能会导致相同含义的的不同对象被(hashcode 应该相等)pass 掉.而如果只重写 hashCode 不重写 equals 方法，那么 equals 只是判断两个对象是否是同一个对象</p>\n<h2 id=\"值传递和引用传递-java-是值传递\">值传递和引用传递(java 是值传递)</h2>\n<p>值传递（pass by value）是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。<br>\n引用传递（pass by reference）是指在调用函数时将实际参数的地址直接传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。</p>\n<h2 id=\"Java-中的异常处理\">Java 中的异常处理</h2>\n<p><strong>注意：异常和错误的区别：异常能被程序本身处理，错误是无法处理。</strong></p>\n<ul>\n<li>try 块： 用于捕获异常。其后可接零个或多个 catch 块，如果没有 catch 块，则必须跟一个 finally 块。</li>\n<li>catch 块： 用于处理 try 捕获到的异常。</li>\n<li>finally 块： 无论是否捕获或处理异常，finally 块里的语句都会被执行。当在 try 块或 catch 块中遇到 return 语句时，finally 语句块将在方法返回之前被执行。<br>\n<strong>在以下 4 种特殊情况下，finally 块不会被执行：</strong></li>\n<li>在 finally 语句块第一行发生了异常。 因为在其他行，finally 块还是会得到执行</li>\n<li>在前面的代码中用了 System.exit(int)已退出程序。 exit 是带参函数 ；若该语句在异常语句之后，finally 会执行</li>\n<li>程序所在的线程死亡。</li>\n<li>关闭 CPU。</li>\n</ul>\n<blockquote>\n<p>如果 try 语句里有 return，返回的是 try 语句块中变量值。<br>\n详细执行过程如下：<br>\na.如果有返回值，就把返回值保存到局部变量中；<br>\nb.执行 jsr 指令跳到 finally 语句里执行；<br>\nc.执行完 finally 语句后，返回之前保存在局部变量表里的值。<br>\n如果 try，finally 语句里均有 return，忽略 try 的 return，而使用 finally 的 return.</p>\n</blockquote>\n<h2 id=\"Java-中-IO-流分为几种\">Java 中 IO 流分为几种?</h2>\n<p>按照流的流向分，可以分为输入流和输出流；<br>\n按照操作单元划分，可以划分为字节流和字符流；<br>\n按照流的角色划分为节点流和处理流。</p>\n<h2 id=\"java-异常处理\">java 异常处理</h2>\n<ul>\n<li>try 块： 用于捕获异常。其后可接零个或多个 catch 块，如果没有 catch 块，则必须跟一个 finally 块。</li>\n<li>catch 块： 用于处理 try 捕获到的异常。</li>\n<li>finally 块： 无论是否捕获或处理异常，finally 块里的语句都会被执行。当在 try 块或 catch 块中遇到 return 语句时，finally 语句块将在方法返回之前被执行。</li>\n</ul>\n<p>在以下 4 种特殊情况下，finally 块不会被执行：</p>\n<ul>\n<li>在 finally 语句块第一行发生了异常。 因为在其他行，finally 块还是会得到执行</li>\n<li>在前面的代码中用了 System.exit(int)已退出程序。 exit 是带参函数 ；若该语句在异常语句之后，finally 会执行</li>\n<li>程序所在的线程死亡。</li>\n<li>关闭 CPU。<br>\n<strong>注意： 当 try 语句和 finally 语句中都有 return 语句时，在方法返回之前，finally 语句的内容将被执行，并且 finally 语句的返回值将会覆盖原始的返回值</strong></li>\n</ul>\n<h2 id=\"Java修饰符\">Java修饰符</h2>\n<h3 id=\"访问修饰符\">访问修饰符</h3>\n<h4 id=\"public\">public</h4>\n<h4 id=\"protected\">protected</h4>\n<h4 id=\"private\">private</h4>\n<h4 id=\"default\">default</h4>\n<h3 id=\"非访问修饰符\">非访问修饰符</h3>\n<h4 id=\"final-关键字\">final 关键字</h4>\n<ul>\n<li>final 修饰的类不能被继承，final 类中的所有成员方法都会被隐式的指定为 final 方法；</li>\n<li>final 修饰的方法不能被重写；</li>\n<li>final 修饰的变量是常量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能让其指向另一个对象。</li>\n</ul>\n<h4 id=\"static-关键字\">static 关键字</h4>\n<ul>\n<li>修饰成员变量和成员方法: 被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享，可以并且建议通过类名调用。被 static 声明的成员变量属于静态成员变量，静态变量 存放在 Java 内存区域的方法区。</li>\n<li>静态代码块: 静态代码块定义在类中方法外, 静态代码块在非静态代码块之前执行(静态代码块—&gt;非静态代码块—&gt;构造方法)。 该类不管创建多少对象，静态代码块只执行一次.</li>\n<li>静态内部类（static 修饰类的话只能修饰内部类）： 静态内部类与非静态内部类之间存在一个最大的区别: <strong>非静态内部类</strong>在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围类，但是<strong>静态内部类</strong>却没有。没有这个引用就意味着：1. 它的创建是不需要依赖外围类的创建。2. 它不能使用任何外围类的非 static 成员变量和方法。</li>\n</ul>\n<h4 id=\"abstract\">abstract</h4>\n<h4 id=\"synchronized\">synchronized</h4>\n<h2 id=\"Object类\">Object类</h2>\n<h3 id=\"Object类所有方法详解\">Object类所有方法详解</h3>\n<p>Object中含有： registerNatives()、getClass()、hashCode()、equals()、clone()、toString()、notify()、notifyAll()、wait(long)、wait(long,int)、wait()、finalize()</p>\n<ul>\n<li>registerNatives()\n<ul>\n<li><strong>注册 native方法</strong></li>\n</ul>\n</li>\n<li>getClass()<a href=\"#oJQGR\">(1)</a>\n<ul>\n<li>获取类的<code>Class</code> 对象</li>\n</ul>\n</li>\n<li>hashCode()</li>\n<li>equals()</li>\n<li>clone()</li>\n<li>toString()</li>\n<li>wait()/ wait(long)/ wait(long,int)\n<ul>\n<li>作用是阻塞当前线程，等待其他线程调用 notify()/notifyAll()方法将其唤醒。</li>\n<li>注意：\n<ul>\n<li>此方法只能在当前线程获取到对象的锁监视器之后才能调用，否则会抛出 IllegalMonitorStateException异常。</li>\n<li>调用 wait方法，线程会将锁监视器进行释放；而 Thread.sleep，Thread.yield()并不会释放锁。</li>\n<li>wait方法会一直阻塞，直到其他线程调用当前对象的 notify()/notifyAll()方法将其唤醒；而 wait(long)是等待给定超时时间内（单位毫秒），如果还没有调用 notify()/nofiyAll()会自动唤醒； wait(long,int)如果第二个参数大于 0并且小于 999999，则第一个参数 +1作为超时时间</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>notify()/notifyAll()<a href=\"#W03CQ\">(2)</a>\n<ul>\n<li>调用 <code>wait</code>方法，将锁释放并阻塞；这时另一个线程获取到了此对象锁，并调用此对象的 <code>notify()/notifyAll()</code>方法将之前的线程唤醒。</li>\n<li><strong>注意：</strong>\n<ul>\n<li>调用 notify()后，阻塞线程被唤醒，可以参与锁的竞争，但可能调用 notify()方法的线程还要继续做其他事，锁并未释放，所以我们看到的结果是，无论 notify()是在方法一开始调用，还是最后调用，阻塞线程都要等待当前线程结束才能开始。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>finalize()\n<ul>\n<li>此方法是在垃圾回收之前，JVM会调用此方法来清理资源。此方法可能会将对象重新置为可达状态，导致JVM无法进行垃圾回收。</li>\n<li>finalize()方法具有如下4个特点：\n<ul>\n<li>永远不要主动调用某个对象的 finalize()方法，该方法由垃圾回收机制自己调用；</li>\n<li>finalize()何时被调用，是否被调用具有不确定性；</li>\n<li>当 JVM执行可恢复对象的 finalize()可能会将此对象重新变为可达状态；</li>\n<li>当 JVM执行 finalize()方法时出现异常，垃圾回收机制不会报告异常，程序继续执行。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"\"></h3>\n<h2 id=\"类型转换规则\">类型转换规则</h2>\n<h3 id=\"自动类型转换\">自动类型转换</h3>\n<ul>\n<li>boolean类型不能与其他类型进行类型转换</li>\n<li>不相关的对象类型不能进行转换</li>\n<li>容量大的类型转换为容量小的类型必须强制进行转换</li>\n<li>浮点数转换为整数会舍弃小数部分</li>\n<li>容量小类型可自动转换为容量大的基础类型</li>\n<li>char 类型</li>\n</ul>\n<p><strong>byte ，short ，char 进行运算会先类型提升为int</strong></p>\n<h2 id=\"引用\">引用</h2>\n<h3 id=\"反射-class、class-forname-和-getClass-的区别\">反射.class、class.forname() 和 getClass() 的区别</h3>\n<ul>\n<li><strong>相同：</strong>\n<ul>\n<li>通过这几种方式，得到的都是java.lang.Class对象；都是类加载的产物</li>\n<li>三种情况在生成 Class 对象的时候都会先判断内存中是否已经加载此类。</li>\n</ul>\n</li>\n<li><strong>不同：</strong>\n<ul>\n<li>出现的时期不同：\n<ul>\n<li>Class.forname()在运行时加载；</li>\n<li>Class.class和对象名.getClass()是在编译时加载</li>\n</ul>\n</li>\n<li>class.forname() 会装入类并做类的静态初始化</li>\n<li>Class c = C.class；JVM将使用类C的类装载器将类C加载到内存中(前提是类C还未加载进内存)，不进行类的初始化工作，返回C的Class对象</li>\n<li>Class c = c.getClass()会对类进行静态初始化、非静态初始化，返回引用运行时真正所指的对象（因为子对象的引用可能会赋给父对象的引用变量中）所属的类的 Class 对象</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"为什么-wait-notify-方法要放到-Object中呢\">为什么 wait()/notify()方法要放到 Object中呢</h3>\n<p>因为每个对象都可以成为锁监视器对象，所以放到 Object中，可以直接使用。</p>\n<h3 id=\"-2\"></h3>\n"},{"title":"ByteBuddy","date":"2023-06-19T14:23:00.000Z","lastmod":"2023-07-08T05:54:37.000Z","_content":"\n# ByteBuddy\n\n```\n      <dependency>\n            <groupId>net.bytebuddy</groupId>\n            <artifactId>byte-buddy</artifactId>\n            <version>1.11.12</version>\n        </dependency>\n```\n\n## Hello World\n\n```\nClass<?> dynamicType = new ByteBuddy()\n                .subclass(Object.class)\n                .method(ElementMatchers.named(\"toString\"))\n                .intercept(FixedValue.value(\"Hello World\"))\n                .make()\n                .load(HelloWorldBuddy.class.getClassLoader())\n                .getLoaded();\nObject instance = dynamicType.newInstance();\nString toString = instance.toString();\nSystem.out.println(toString);\nSystem.out.println(instance.getClass().getCanonicalName());\n```\n\n​![image](/assets/image-20230619222624-l98xjgi.png)​\n\n　　从例子可以看出，很简单就创建了一个动态类型。ByteBuddy提供了一套流式API，从ByteBuddy实例出发，可以流畅的完成所有的操作和数据定义。  \n上面的示例中\n\n* subclass 指定了新创建的类的父类\n* method 指定了 Object 的 toString 方法\n* intercept 拦截了 toString 方法并返回固定的 value\n* 最后 make 方法生产字节码，有类加载器加载到虚拟机中\n\n　　此外，Byte Buddy不仅限于创建子类和操作类，还可以转换现有代码。Byte Buddy 还提供了一个方便的 API，用于定义所谓的 Java 代理，该代理允许在任何 Java 应用程序的运行期间进行代码转换\n\n## 创建动态类\n\n```\nDynamicType.Unloaded<?> dynamicType = new ByteBuddy()\n  .subclass(Object.class)\n  .name(\"com.zlk.learning.bytebuddy.DynamicType\")\n  .make();\n```\n\n　　上面的示例代码会创建一个继承至 Object 类型的类。这个动态创建的类型与直接扩展 Object 并且没有实现任何方法、属性和构造函数的类型是等价的，如下：\n\n```\npublic class DynamicTYpe {\n\n}\n```\n\n　　在创建类的时候，还提供了更多API来支持对类的定义，包括定义字段、方法等\n\n```\n        DynamicType.Unloaded<?> dynamicType = new ByteBuddy()\n                .subclass(Object.class)\n                .name(\"com.zlk.learning.bytebuddy.DynamicType\")\n                .defineField(\"name\", String.class, 1)\n                .defineField(\"age\", Integer.class, 1)\n                .method(ElementMatchers.named(\"toString\"))\n                .intercept(FixedValue.value(\"Hello World!\"))\n                .make();\n```\n\n​![image](/assets/image-20230619222818-5btwdt3.png)​\n\n　　上面的示例代码中，我们增加了两个字段name和age，同时拦截了toString方法，使其输出固定值 “Hello World!”。\n\n　　保留父类实现的接口信息\n\n```java\n\n\n    @Override\n    public Object instantiate(BeanDefinition beanDefinition, String beanName, Constructor ctor, Object[] args) throws BeansException {\n        Class<?> beanClass = beanDefinition.getBeanClass();\n        ArrayList<TypeDescription.Generic> list = getGenerics(beanClass);\n        Class clazz = new ByteBuddy().subclass(beanClass).implement(list)\n                .make()\n                .load(getClass().getClassLoader())\n                .getLoaded();\n        try {\n            if (null == ctor) return clazz.getDeclaredConstructor().newInstance();\n            return clazz.getDeclaredConstructor(ctor.getParameterTypes()).newInstance(args);\n        } catch (NoSuchMethodException | InstantiationException | IllegalAccessException | InvocationTargetException e) {\n            throw new BeansException(\"Failed to instantiate [\" + clazz.getName() + \"]\", e);\n        }\n    }\n    //获取父类的接口信息\n    private static ArrayList<TypeDescription.Generic> getGenerics(Class<?> beanClass) {\n        ArrayList<TypeDescription.Generic> list = new ArrayList<>();\n        try {\n            Type[] genericInterfaces = beanClass.getGenericInterfaces();\n            for (Type type : genericInterfaces) {\n                Type[] typeArguments = ((ParameterizedType) type).getActualTypeArguments();\n                Class<?>[] classes = new Class[typeArguments.length];\n                for (int i = 0; i < typeArguments.length; i++) {\n                    classes[i] = Class.forName(typeArguments[i].getTypeName());\n                }\n                Class<?> aClass = Class.forName(((ParameterizedType) type).getRawType().getTypeName());\n                TypeDescription.Generic listType = TypeDescription.Generic.Builder.parameterizedType(aClass, classes).build();\n                list.add(listType);\n            }\n        } catch (ClassNotFoundException e) {\n            throw new BeansException(\"Failed to instantiate [\" + beanClass.getName() + \"]\", e);\n        }\n        return list;\n    }\n```\n\n　　‍\n\n## 加载类\n\n　　上节创建的 DynamicType.Unloaded，代表一个尚未加载的类，顾名思义，这些类型不会加载到 Java 虚拟机中，它仅仅表示创建好了类的字节码，通过 DynamicType.Unloaded 中的 getBytes 方法你可以获取到该字节码。\n\n　　在应用程序中，可能需要将该字节码保存到文件，或者注入的现在的 jar 文件中，因此该类型还提供了一个 saveIn(File) 方法，可以将类存储在给定的文件夹中； inject(File) 方法将类注入到现有的 Jar 文件中，另外你只需要将该字节码直接加载到虚拟机使用，你可以通过 ClassLoadingStrategy 来加载。\n\n　　如果不指定ClassLoadingStrategy，Byte Buffer根据你提供的ClassLoader来推导出一个策略，内置的策略定义在枚举ClassLoadingStrategy.Default中\n\n* WRAPPER：创建一个新的Wrapping类加载器\n* CHILD_FIRST：类似上面，但是子加载器优先负责加载目标类\n* INJECTION：利用反射机制注入动态类型\n\n```\n Class<?> dynamicClass = dynamicType\n                .load(Object.class.getClassLoader(), ClassLoadingStrategy.Default.WRAPPER)\n                .getLoaded();\n```\n\n　　我们使用 WRAPPER 策略来加载适合大多数情况的类，这样生产的动态类不会被ApplicationClassLoader加载到，不会影响到项目中已经存在的类  \n​`getLoaded 方法返回一个 Java Class 的实例，它就表示现在加载的动态类`​\n\n## 拦截方法\n\n　　在之前的例子中，我们拦截了toString方法，并使其输出固定值。不过在实际开发中很少会遇到如此简单的场景，我们可以通过指定拦截方法的形式来处理复杂的逻辑\n\n### 通过匹配模式拦截\n\n　　ByteBuddy 通过 net.bytebuddy.matcher.ElementMatcher 来定义配置策略，可以通过此接口实现自己定义的匹配策略\n\n```\nFoo dynamicFoo = new ByteBuddy()\n  .subclass(Foo.class)\n  // 匹配由Foo.class声明的方法\n  .method(isDeclaredBy(Foo.class)).intercept(FixedValue.value(\"One!\"))\n  // 匹配名为foo的方法\n  .method(named(\"foo\")).intercept(FixedValue.value(\"Two!\"))\n  // 匹配名为foo，入参数量为1的方法\n  .method(named(\"foo\").and(takesArguments(1))).intercept(FixedValue.value(\"Three!\"))\n  .make()\n  .load(getClass().getClassLoader())\n  .getLoaded()\n  .newInstance();\n```\n\n### 方法委托\n\n　　使用MethodDelegation可以将方法调用委托给任意POJO。Byte Buddy不要求Source（被委托类）、Target类的方法名一致\n\n```\nclass Source {\n  public String hello(String name) { return null; }\n}\n\nclass Target {\n\n  public static String hello(String name) {\n    return \"Hello \" + name + \"!\";\n  }\n}\n\nString helloWorld = new ByteBuddy()\n  .subclass(Source.class)\n  .method(named(\"hello\"))\n  // 此处委托 类只能委托静态方法  对象可使用非静态方法\n  .intercept(MethodDelegation.to(Target.class))\n  .make()\n  .load(getClass().getClassLoader())\n  .getLoaded()\n  .newInstance()\n  .hello(\"World\");\n```\n\n　　其中 Target 还可以如下实现：\n\n```\nclass Target {\n  public static String intercept(String name) { return \"Hello \" + name + \"!\"; }\n  public static String intercept(int i) { return Integer.toString(i); }\n  public static String intercept(Object o) { return o.toString(); }\n}\n```\n\n　　前一个实现因为只有一个方法，而且类型也匹配，很好理解，那么后一个呢，Byte Buddy到底会委托给哪个方法？Byte Buddy遵循一个最接近原则：\n\n* intercept(int)因为参数类型不匹配，直接Pass\n* 另外两个方法参数都匹配，但是 intercept(String)类型更加接近，因此会委托给它\n\n　　同时需要注意的是被拦截的方法需要声明为 public，否则没法进行拦截增强。除此之外，还可以使用 @RuntimeType 注解来标注方法\n\n```java\n    @RuntimeType\n    public  Object interceptor(@This Object proxy, @Origin Method method,\n                              @SuperMethod Method superMethod,\n                              @AllArguments Object[] args) throws Exception {\n        System.out.println(\"bytebuddy delegate proxy2 before sing \");\n        Object ret = superMethod.invoke(proxy, args);\n        System.out.println(\"bytebuddy delegate proxy2 after sing \");\n        return ret;\n    }\n```\n\n### 参数绑定\n\n　　可以在拦截器（Target）的拦截方法 intercept 中使用注解注入参数，ByteBuddy 会根据注解给我们注入对于的参数值。比如\n\n```\nvoid intercept(Object o1, Object o2)\n// 等同于\nvoid intercept(@Argument(0) Object o1, @Argument(1) Object o2)\n```\n\n　　常用注解有以下这些：\n\n* @Argument 绑定单个参数\n* @AllArguments 绑定所有参数的数组\n* @This 当前被拦截的、动态生成的那个对象\n* @DefaultCall 调用默认方法而非super的方法\n* @SuperCall 用于调用父类版本的方法\n* @Origin 被拦截的源方法\n* @RuntimeType 可以用在返回值、参数上，提示ByteBuddy禁用严格的类型检查\n* @Super 当前被拦截的、动态生成的那个对象的父类对象\n* @FieldValue 注入被拦截对象的一个字段的值\n\n## Agent\n\n　　Java 从 1.5 开始提供了 java.lang.instrument包，该包为检测 Java 程序提供 API，比如用于监控、收集性能信息、诊断问题。通过 java.lang.instrument 实现工具被称为 Java Agent。Java Agent 可以修改类文件的字节码，通常是，在字节码方法插入额外的字节码来完成检测\n\n　　和通过ByteBuddy实例创建动态类型一样，bytebuddy也提供了AgentBuilder类使我们在agent中更优雅地编写代码\n\n```\nclass ToStringAgent {\n  public static void premain(String arguments, Instrumentation instrumentation) {\n    new AgentBuilder.Default()\n        .type(isAnnotatedWith(ToString.class))\n        .transform(new AgentBuilder.Transformer() {\n      @Override\n      public DynamicType.Builder transform(DynamicType.Builder builder,\n                                              TypeDescription typeDescription,\n                                              ClassLoader classloader) {\n        return builder.method(named(\"toString\"))\n                      .intercept(FixedValue.value(\"transformed\"));\n      }\n    }).installOn(instrumentation);\n  }\n}\n```\n\n* type 通过ElementMatcher 来匹配我们加载的class，匹配到之后，将会使用\n* transform 指定的转换器来对匹配到的class进行操作\n\n## ElementMatcher\n\n　　ElementMatcher可以定义匹配class的规则，在bytebuddy中，ElementMatchers类提供了许多常规的匹配方式，可以按照class name、注解、类型等来进行匹配，上面的实例中就是使用注解匹配的方式\n\n　　Junction继承自ElementMatcher接口，定义了and 和 or 方法，可以使我们在定义Matcher时通过链式定义一连串的匹配规则\n\n```\n      new AgentBuilder.Default()\n                .type(ElementMatchers.isAnnotatedWith(ToString.class)).and(ElementMatchers.isSubTypeOf(DynamicClass.class)).or(ElementMatchers.named(\"DynamicClass\"))\n                .transform(new AgentBuilder.Transformer() {\n                    public DynamicType.Builder<?> transform(DynamicType.Builder<?> builder, TypeDescription typeDescription, ClassLoader classLoader, JavaModule javaModule) {\n                        return builder\n                                .method(ElementMatchers.named(\"hello\"))\n                                .intercept(MethodDelegation.to(MyServiceInterceptor.class))\n                                ;\n                    }\n                }).installOn(instrumentation);\n```\n\n## [Transformer](https://so.csdn.net/so/search?q=Transformer&spm=1001.2101.3001.7020)\n\n　　Transformer 接口定义了 transform方法，会传入DynamicType.Builder实例，通过该builder，就可以对匹配到的类进行操作，就和上面讲的 ByteBuddy创建动态类型时类似操作，可以定义字段以及对方法进行拦截操作等，上面的例子就是对匹配到的类的hello方法进行了方法委托，在调用hello方法时，将会委托给 MyServiceInterceptor类\n\n```\npublic class MyServiceInterceptor {\n\n    @RuntimeType\n    public static Object intercept(@Origin Method method, @SuperCall Callable<?> callable) throws Exception {\n        System.out.println(\"intercept：拦截了\" + method.getName());\n        return callable.call();\n    }\n  \n}\n\n```\n\n## \n\n　　‍\n\n## END\n\n　　**参考文章**  \n​`bytebuddy官方文档 https://bytebuddy.net/#/tutorial`\n\n　　`https://juejin.cn/post/6844903965553852423#heading-12`​​\n","source":"_posts/java/ByteBuddy.md","raw":"---\ntitle: ByteBuddy\ndate: 2023-06-19T22:23:00Z\nlastmod: 2023-07-08T13:54:37Z\n---\n\n# ByteBuddy\n\n```\n      <dependency>\n            <groupId>net.bytebuddy</groupId>\n            <artifactId>byte-buddy</artifactId>\n            <version>1.11.12</version>\n        </dependency>\n```\n\n## Hello World\n\n```\nClass<?> dynamicType = new ByteBuddy()\n                .subclass(Object.class)\n                .method(ElementMatchers.named(\"toString\"))\n                .intercept(FixedValue.value(\"Hello World\"))\n                .make()\n                .load(HelloWorldBuddy.class.getClassLoader())\n                .getLoaded();\nObject instance = dynamicType.newInstance();\nString toString = instance.toString();\nSystem.out.println(toString);\nSystem.out.println(instance.getClass().getCanonicalName());\n```\n\n​![image](/assets/image-20230619222624-l98xjgi.png)​\n\n　　从例子可以看出，很简单就创建了一个动态类型。ByteBuddy提供了一套流式API，从ByteBuddy实例出发，可以流畅的完成所有的操作和数据定义。  \n上面的示例中\n\n* subclass 指定了新创建的类的父类\n* method 指定了 Object 的 toString 方法\n* intercept 拦截了 toString 方法并返回固定的 value\n* 最后 make 方法生产字节码，有类加载器加载到虚拟机中\n\n　　此外，Byte Buddy不仅限于创建子类和操作类，还可以转换现有代码。Byte Buddy 还提供了一个方便的 API，用于定义所谓的 Java 代理，该代理允许在任何 Java 应用程序的运行期间进行代码转换\n\n## 创建动态类\n\n```\nDynamicType.Unloaded<?> dynamicType = new ByteBuddy()\n  .subclass(Object.class)\n  .name(\"com.zlk.learning.bytebuddy.DynamicType\")\n  .make();\n```\n\n　　上面的示例代码会创建一个继承至 Object 类型的类。这个动态创建的类型与直接扩展 Object 并且没有实现任何方法、属性和构造函数的类型是等价的，如下：\n\n```\npublic class DynamicTYpe {\n\n}\n```\n\n　　在创建类的时候，还提供了更多API来支持对类的定义，包括定义字段、方法等\n\n```\n        DynamicType.Unloaded<?> dynamicType = new ByteBuddy()\n                .subclass(Object.class)\n                .name(\"com.zlk.learning.bytebuddy.DynamicType\")\n                .defineField(\"name\", String.class, 1)\n                .defineField(\"age\", Integer.class, 1)\n                .method(ElementMatchers.named(\"toString\"))\n                .intercept(FixedValue.value(\"Hello World!\"))\n                .make();\n```\n\n​![image](/assets/image-20230619222818-5btwdt3.png)​\n\n　　上面的示例代码中，我们增加了两个字段name和age，同时拦截了toString方法，使其输出固定值 “Hello World!”。\n\n　　保留父类实现的接口信息\n\n```java\n\n\n    @Override\n    public Object instantiate(BeanDefinition beanDefinition, String beanName, Constructor ctor, Object[] args) throws BeansException {\n        Class<?> beanClass = beanDefinition.getBeanClass();\n        ArrayList<TypeDescription.Generic> list = getGenerics(beanClass);\n        Class clazz = new ByteBuddy().subclass(beanClass).implement(list)\n                .make()\n                .load(getClass().getClassLoader())\n                .getLoaded();\n        try {\n            if (null == ctor) return clazz.getDeclaredConstructor().newInstance();\n            return clazz.getDeclaredConstructor(ctor.getParameterTypes()).newInstance(args);\n        } catch (NoSuchMethodException | InstantiationException | IllegalAccessException | InvocationTargetException e) {\n            throw new BeansException(\"Failed to instantiate [\" + clazz.getName() + \"]\", e);\n        }\n    }\n    //获取父类的接口信息\n    private static ArrayList<TypeDescription.Generic> getGenerics(Class<?> beanClass) {\n        ArrayList<TypeDescription.Generic> list = new ArrayList<>();\n        try {\n            Type[] genericInterfaces = beanClass.getGenericInterfaces();\n            for (Type type : genericInterfaces) {\n                Type[] typeArguments = ((ParameterizedType) type).getActualTypeArguments();\n                Class<?>[] classes = new Class[typeArguments.length];\n                for (int i = 0; i < typeArguments.length; i++) {\n                    classes[i] = Class.forName(typeArguments[i].getTypeName());\n                }\n                Class<?> aClass = Class.forName(((ParameterizedType) type).getRawType().getTypeName());\n                TypeDescription.Generic listType = TypeDescription.Generic.Builder.parameterizedType(aClass, classes).build();\n                list.add(listType);\n            }\n        } catch (ClassNotFoundException e) {\n            throw new BeansException(\"Failed to instantiate [\" + beanClass.getName() + \"]\", e);\n        }\n        return list;\n    }\n```\n\n　　‍\n\n## 加载类\n\n　　上节创建的 DynamicType.Unloaded，代表一个尚未加载的类，顾名思义，这些类型不会加载到 Java 虚拟机中，它仅仅表示创建好了类的字节码，通过 DynamicType.Unloaded 中的 getBytes 方法你可以获取到该字节码。\n\n　　在应用程序中，可能需要将该字节码保存到文件，或者注入的现在的 jar 文件中，因此该类型还提供了一个 saveIn(File) 方法，可以将类存储在给定的文件夹中； inject(File) 方法将类注入到现有的 Jar 文件中，另外你只需要将该字节码直接加载到虚拟机使用，你可以通过 ClassLoadingStrategy 来加载。\n\n　　如果不指定ClassLoadingStrategy，Byte Buffer根据你提供的ClassLoader来推导出一个策略，内置的策略定义在枚举ClassLoadingStrategy.Default中\n\n* WRAPPER：创建一个新的Wrapping类加载器\n* CHILD_FIRST：类似上面，但是子加载器优先负责加载目标类\n* INJECTION：利用反射机制注入动态类型\n\n```\n Class<?> dynamicClass = dynamicType\n                .load(Object.class.getClassLoader(), ClassLoadingStrategy.Default.WRAPPER)\n                .getLoaded();\n```\n\n　　我们使用 WRAPPER 策略来加载适合大多数情况的类，这样生产的动态类不会被ApplicationClassLoader加载到，不会影响到项目中已经存在的类  \n​`getLoaded 方法返回一个 Java Class 的实例，它就表示现在加载的动态类`​\n\n## 拦截方法\n\n　　在之前的例子中，我们拦截了toString方法，并使其输出固定值。不过在实际开发中很少会遇到如此简单的场景，我们可以通过指定拦截方法的形式来处理复杂的逻辑\n\n### 通过匹配模式拦截\n\n　　ByteBuddy 通过 net.bytebuddy.matcher.ElementMatcher 来定义配置策略，可以通过此接口实现自己定义的匹配策略\n\n```\nFoo dynamicFoo = new ByteBuddy()\n  .subclass(Foo.class)\n  // 匹配由Foo.class声明的方法\n  .method(isDeclaredBy(Foo.class)).intercept(FixedValue.value(\"One!\"))\n  // 匹配名为foo的方法\n  .method(named(\"foo\")).intercept(FixedValue.value(\"Two!\"))\n  // 匹配名为foo，入参数量为1的方法\n  .method(named(\"foo\").and(takesArguments(1))).intercept(FixedValue.value(\"Three!\"))\n  .make()\n  .load(getClass().getClassLoader())\n  .getLoaded()\n  .newInstance();\n```\n\n### 方法委托\n\n　　使用MethodDelegation可以将方法调用委托给任意POJO。Byte Buddy不要求Source（被委托类）、Target类的方法名一致\n\n```\nclass Source {\n  public String hello(String name) { return null; }\n}\n\nclass Target {\n\n  public static String hello(String name) {\n    return \"Hello \" + name + \"!\";\n  }\n}\n\nString helloWorld = new ByteBuddy()\n  .subclass(Source.class)\n  .method(named(\"hello\"))\n  // 此处委托 类只能委托静态方法  对象可使用非静态方法\n  .intercept(MethodDelegation.to(Target.class))\n  .make()\n  .load(getClass().getClassLoader())\n  .getLoaded()\n  .newInstance()\n  .hello(\"World\");\n```\n\n　　其中 Target 还可以如下实现：\n\n```\nclass Target {\n  public static String intercept(String name) { return \"Hello \" + name + \"!\"; }\n  public static String intercept(int i) { return Integer.toString(i); }\n  public static String intercept(Object o) { return o.toString(); }\n}\n```\n\n　　前一个实现因为只有一个方法，而且类型也匹配，很好理解，那么后一个呢，Byte Buddy到底会委托给哪个方法？Byte Buddy遵循一个最接近原则：\n\n* intercept(int)因为参数类型不匹配，直接Pass\n* 另外两个方法参数都匹配，但是 intercept(String)类型更加接近，因此会委托给它\n\n　　同时需要注意的是被拦截的方法需要声明为 public，否则没法进行拦截增强。除此之外，还可以使用 @RuntimeType 注解来标注方法\n\n```java\n    @RuntimeType\n    public  Object interceptor(@This Object proxy, @Origin Method method,\n                              @SuperMethod Method superMethod,\n                              @AllArguments Object[] args) throws Exception {\n        System.out.println(\"bytebuddy delegate proxy2 before sing \");\n        Object ret = superMethod.invoke(proxy, args);\n        System.out.println(\"bytebuddy delegate proxy2 after sing \");\n        return ret;\n    }\n```\n\n### 参数绑定\n\n　　可以在拦截器（Target）的拦截方法 intercept 中使用注解注入参数，ByteBuddy 会根据注解给我们注入对于的参数值。比如\n\n```\nvoid intercept(Object o1, Object o2)\n// 等同于\nvoid intercept(@Argument(0) Object o1, @Argument(1) Object o2)\n```\n\n　　常用注解有以下这些：\n\n* @Argument 绑定单个参数\n* @AllArguments 绑定所有参数的数组\n* @This 当前被拦截的、动态生成的那个对象\n* @DefaultCall 调用默认方法而非super的方法\n* @SuperCall 用于调用父类版本的方法\n* @Origin 被拦截的源方法\n* @RuntimeType 可以用在返回值、参数上，提示ByteBuddy禁用严格的类型检查\n* @Super 当前被拦截的、动态生成的那个对象的父类对象\n* @FieldValue 注入被拦截对象的一个字段的值\n\n## Agent\n\n　　Java 从 1.5 开始提供了 java.lang.instrument包，该包为检测 Java 程序提供 API，比如用于监控、收集性能信息、诊断问题。通过 java.lang.instrument 实现工具被称为 Java Agent。Java Agent 可以修改类文件的字节码，通常是，在字节码方法插入额外的字节码来完成检测\n\n　　和通过ByteBuddy实例创建动态类型一样，bytebuddy也提供了AgentBuilder类使我们在agent中更优雅地编写代码\n\n```\nclass ToStringAgent {\n  public static void premain(String arguments, Instrumentation instrumentation) {\n    new AgentBuilder.Default()\n        .type(isAnnotatedWith(ToString.class))\n        .transform(new AgentBuilder.Transformer() {\n      @Override\n      public DynamicType.Builder transform(DynamicType.Builder builder,\n                                              TypeDescription typeDescription,\n                                              ClassLoader classloader) {\n        return builder.method(named(\"toString\"))\n                      .intercept(FixedValue.value(\"transformed\"));\n      }\n    }).installOn(instrumentation);\n  }\n}\n```\n\n* type 通过ElementMatcher 来匹配我们加载的class，匹配到之后，将会使用\n* transform 指定的转换器来对匹配到的class进行操作\n\n## ElementMatcher\n\n　　ElementMatcher可以定义匹配class的规则，在bytebuddy中，ElementMatchers类提供了许多常规的匹配方式，可以按照class name、注解、类型等来进行匹配，上面的实例中就是使用注解匹配的方式\n\n　　Junction继承自ElementMatcher接口，定义了and 和 or 方法，可以使我们在定义Matcher时通过链式定义一连串的匹配规则\n\n```\n      new AgentBuilder.Default()\n                .type(ElementMatchers.isAnnotatedWith(ToString.class)).and(ElementMatchers.isSubTypeOf(DynamicClass.class)).or(ElementMatchers.named(\"DynamicClass\"))\n                .transform(new AgentBuilder.Transformer() {\n                    public DynamicType.Builder<?> transform(DynamicType.Builder<?> builder, TypeDescription typeDescription, ClassLoader classLoader, JavaModule javaModule) {\n                        return builder\n                                .method(ElementMatchers.named(\"hello\"))\n                                .intercept(MethodDelegation.to(MyServiceInterceptor.class))\n                                ;\n                    }\n                }).installOn(instrumentation);\n```\n\n## [Transformer](https://so.csdn.net/so/search?q=Transformer&spm=1001.2101.3001.7020)\n\n　　Transformer 接口定义了 transform方法，会传入DynamicType.Builder实例，通过该builder，就可以对匹配到的类进行操作，就和上面讲的 ByteBuddy创建动态类型时类似操作，可以定义字段以及对方法进行拦截操作等，上面的例子就是对匹配到的类的hello方法进行了方法委托，在调用hello方法时，将会委托给 MyServiceInterceptor类\n\n```\npublic class MyServiceInterceptor {\n\n    @RuntimeType\n    public static Object intercept(@Origin Method method, @SuperCall Callable<?> callable) throws Exception {\n        System.out.println(\"intercept：拦截了\" + method.getName());\n        return callable.call();\n    }\n  \n}\n\n```\n\n## \n\n　　‍\n\n## END\n\n　　**参考文章**  \n​`bytebuddy官方文档 https://bytebuddy.net/#/tutorial`\n\n　　`https://juejin.cn/post/6844903965553852423#heading-12`​​\n","slug":"java-ByteBuddy","published":1,"updated":"2025-04-28T08:41:48.385Z","_id":"cm9s3f3ys0003bfg478vr1fbf","comments":1,"layout":"post","photos":[],"content":"<h1>ByteBuddy</h1>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">      &lt;groupId&gt;net.bytebuddy&lt;/groupId&gt;</span><br><span class=\"line\">      &lt;artifactId&gt;byte-buddy&lt;/artifactId&gt;</span><br><span class=\"line\">      &lt;version&gt;1.11.12&lt;/version&gt;</span><br><span class=\"line\">  &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Hello-World\">Hello World</h2>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class&lt;?&gt; dynamicType = new ByteBuddy()</span><br><span class=\"line\">                .subclass(Object.class)</span><br><span class=\"line\">                .method(ElementMatchers.named(&quot;toString&quot;))</span><br><span class=\"line\">                .intercept(FixedValue.value(&quot;Hello World&quot;))</span><br><span class=\"line\">                .make()</span><br><span class=\"line\">                .load(HelloWorldBuddy.class.getClassLoader())</span><br><span class=\"line\">                .getLoaded();</span><br><span class=\"line\">Object instance = dynamicType.newInstance();</span><br><span class=\"line\">String toString = instance.toString();</span><br><span class=\"line\">System.out.println(toString);</span><br><span class=\"line\">System.out.println(instance.getClass().getCanonicalName());</span><br></pre></td></tr></table></figure>\n<p>​<img src=\"/assets/image-20230619222624-l98xjgi.png\" alt=\"image\">​</p>\n<p>从例子可以看出，很简单就创建了一个动态类型。ByteBuddy提供了一套流式API，从ByteBuddy实例出发，可以流畅的完成所有的操作和数据定义。<br>\n上面的示例中</p>\n<ul>\n<li>subclass 指定了新创建的类的父类</li>\n<li>method 指定了 Object 的 toString 方法</li>\n<li>intercept 拦截了 toString 方法并返回固定的 value</li>\n<li>最后 make 方法生产字节码，有类加载器加载到虚拟机中</li>\n</ul>\n<p>此外，Byte Buddy不仅限于创建子类和操作类，还可以转换现有代码。Byte Buddy 还提供了一个方便的 API，用于定义所谓的 Java 代理，该代理允许在任何 Java 应用程序的运行期间进行代码转换</p>\n<h2 id=\"创建动态类\">创建动态类</h2>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DynamicType.Unloaded&lt;?&gt; dynamicType = new ByteBuddy()</span><br><span class=\"line\">  .subclass(Object.class)</span><br><span class=\"line\">  .name(&quot;com.zlk.learning.bytebuddy.DynamicType&quot;)</span><br><span class=\"line\">  .make();</span><br></pre></td></tr></table></figure>\n<p>上面的示例代码会创建一个继承至 Object 类型的类。这个动态创建的类型与直接扩展 Object 并且没有实现任何方法、属性和构造函数的类型是等价的，如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class DynamicTYpe &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在创建类的时候，还提供了更多API来支持对类的定义，包括定义字段、方法等</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DynamicType.Unloaded&lt;?&gt; dynamicType = new ByteBuddy()</span><br><span class=\"line\">        .subclass(Object.class)</span><br><span class=\"line\">        .name(&quot;com.zlk.learning.bytebuddy.DynamicType&quot;)</span><br><span class=\"line\">        .defineField(&quot;name&quot;, String.class, 1)</span><br><span class=\"line\">        .defineField(&quot;age&quot;, Integer.class, 1)</span><br><span class=\"line\">        .method(ElementMatchers.named(&quot;toString&quot;))</span><br><span class=\"line\">        .intercept(FixedValue.value(&quot;Hello World!&quot;))</span><br><span class=\"line\">        .make();</span><br></pre></td></tr></table></figure>\n<p>​<img src=\"/assets/image-20230619222818-5btwdt3.png\" alt=\"image\">​</p>\n<p>上面的示例代码中，我们增加了两个字段name和age，同时拦截了toString方法，使其输出固定值 “Hello World!”。</p>\n<p>保留父类实现的接口信息</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Object <span class=\"title function_\">instantiate</span><span class=\"params\">(BeanDefinition beanDefinition, String beanName, Constructor ctor, Object[] args)</span> <span class=\"keyword\">throws</span> BeansException &#123;</span><br><span class=\"line\">    Class&lt;?&gt; beanClass = beanDefinition.getBeanClass();</span><br><span class=\"line\">    ArrayList&lt;TypeDescription.Generic&gt; list = getGenerics(beanClass);</span><br><span class=\"line\">    <span class=\"type\">Class</span> <span class=\"variable\">clazz</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ByteBuddy</span>().subclass(beanClass).implement(list)</span><br><span class=\"line\">            .make()</span><br><span class=\"line\">            .load(getClass().getClassLoader())</span><br><span class=\"line\">            .getLoaded();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"literal\">null</span> == ctor) <span class=\"keyword\">return</span> clazz.getDeclaredConstructor().newInstance();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> clazz.getDeclaredConstructor(ctor.getParameterTypes()).newInstance(args);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (NoSuchMethodException | InstantiationException | IllegalAccessException | InvocationTargetException e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">BeansException</span>(<span class=\"string\">&quot;Failed to instantiate [&quot;</span> + clazz.getName() + <span class=\"string\">&quot;]&quot;</span>, e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//获取父类的接口信息</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> ArrayList&lt;TypeDescription.Generic&gt; getGenerics(Class&lt;?&gt; beanClass) &#123;</span><br><span class=\"line\">    ArrayList&lt;TypeDescription.Generic&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        Type[] genericInterfaces = beanClass.getGenericInterfaces();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Type type : genericInterfaces) &#123;</span><br><span class=\"line\">            Type[] typeArguments = ((ParameterizedType) type).getActualTypeArguments();</span><br><span class=\"line\">            Class&lt;?&gt;[] classes = <span class=\"keyword\">new</span> <span class=\"title class_\">Class</span>[typeArguments.length];</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; typeArguments.length; i++) &#123;</span><br><span class=\"line\">                classes[i] = Class.forName(typeArguments[i].getTypeName());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            Class&lt;?&gt; aClass = Class.forName(((ParameterizedType) type).getRawType().getTypeName());</span><br><span class=\"line\">            TypeDescription.<span class=\"type\">Generic</span> <span class=\"variable\">listType</span> <span class=\"operator\">=</span> TypeDescription.Generic.Builder.parameterizedType(aClass, classes).build();</span><br><span class=\"line\">            list.add(listType);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (ClassNotFoundException e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">BeansException</span>(<span class=\"string\">&quot;Failed to instantiate [&quot;</span> + beanClass.getName() + <span class=\"string\">&quot;]&quot;</span>, e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> list;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>‍</p>\n<h2 id=\"加载类\">加载类</h2>\n<p>上节创建的 DynamicType.Unloaded，代表一个尚未加载的类，顾名思义，这些类型不会加载到 Java 虚拟机中，它仅仅表示创建好了类的字节码，通过 DynamicType.Unloaded 中的 getBytes 方法你可以获取到该字节码。</p>\n<p>在应用程序中，可能需要将该字节码保存到文件，或者注入的现在的 jar 文件中，因此该类型还提供了一个 saveIn(File) 方法，可以将类存储在给定的文件夹中； inject(File) 方法将类注入到现有的 Jar 文件中，另外你只需要将该字节码直接加载到虚拟机使用，你可以通过 ClassLoadingStrategy 来加载。</p>\n<p>如果不指定ClassLoadingStrategy，Byte Buffer根据你提供的ClassLoader来推导出一个策略，内置的策略定义在枚举ClassLoadingStrategy.Default中</p>\n<ul>\n<li>WRAPPER：创建一个新的Wrapping类加载器</li>\n<li>CHILD_FIRST：类似上面，但是子加载器优先负责加载目标类</li>\n<li>INJECTION：利用反射机制注入动态类型</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class&lt;?&gt; dynamicClass = dynamicType</span><br><span class=\"line\">               .load(Object.class.getClassLoader(), ClassLoadingStrategy.Default.WRAPPER)</span><br><span class=\"line\">               .getLoaded();</span><br></pre></td></tr></table></figure>\n<p>我们使用 WRAPPER 策略来加载适合大多数情况的类，这样生产的动态类不会被ApplicationClassLoader加载到，不会影响到项目中已经存在的类<br>\n​<code>getLoaded 方法返回一个 Java Class 的实例，它就表示现在加载的动态类</code>​</p>\n<h2 id=\"拦截方法\">拦截方法</h2>\n<p>在之前的例子中，我们拦截了toString方法，并使其输出固定值。不过在实际开发中很少会遇到如此简单的场景，我们可以通过指定拦截方法的形式来处理复杂的逻辑</p>\n<h3 id=\"通过匹配模式拦截\">通过匹配模式拦截</h3>\n<p>ByteBuddy 通过 net.bytebuddy.matcher.ElementMatcher 来定义配置策略，可以通过此接口实现自己定义的匹配策略</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Foo dynamicFoo = new ByteBuddy()</span><br><span class=\"line\">  .subclass(Foo.class)</span><br><span class=\"line\">  // 匹配由Foo.class声明的方法</span><br><span class=\"line\">  .method(isDeclaredBy(Foo.class)).intercept(FixedValue.value(&quot;One!&quot;))</span><br><span class=\"line\">  // 匹配名为foo的方法</span><br><span class=\"line\">  .method(named(&quot;foo&quot;)).intercept(FixedValue.value(&quot;Two!&quot;))</span><br><span class=\"line\">  // 匹配名为foo，入参数量为1的方法</span><br><span class=\"line\">  .method(named(&quot;foo&quot;).and(takesArguments(1))).intercept(FixedValue.value(&quot;Three!&quot;))</span><br><span class=\"line\">  .make()</span><br><span class=\"line\">  .load(getClass().getClassLoader())</span><br><span class=\"line\">  .getLoaded()</span><br><span class=\"line\">  .newInstance();</span><br></pre></td></tr></table></figure>\n<h3 id=\"方法委托\">方法委托</h3>\n<p>使用MethodDelegation可以将方法调用委托给任意POJO。Byte Buddy不要求Source（被委托类）、Target类的方法名一致</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Source &#123;</span><br><span class=\"line\">  public String hello(String name) &#123; return null; &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class Target &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  public static String hello(String name) &#123;</span><br><span class=\"line\">    return &quot;Hello &quot; + name + &quot;!&quot;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">String helloWorld = new ByteBuddy()</span><br><span class=\"line\">  .subclass(Source.class)</span><br><span class=\"line\">  .method(named(&quot;hello&quot;))</span><br><span class=\"line\">  // 此处委托 类只能委托静态方法  对象可使用非静态方法</span><br><span class=\"line\">  .intercept(MethodDelegation.to(Target.class))</span><br><span class=\"line\">  .make()</span><br><span class=\"line\">  .load(getClass().getClassLoader())</span><br><span class=\"line\">  .getLoaded()</span><br><span class=\"line\">  .newInstance()</span><br><span class=\"line\">  .hello(&quot;World&quot;);</span><br></pre></td></tr></table></figure>\n<p>其中 Target 还可以如下实现：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Target &#123;</span><br><span class=\"line\">  public static String intercept(String name) &#123; return &quot;Hello &quot; + name + &quot;!&quot;; &#125;</span><br><span class=\"line\">  public static String intercept(int i) &#123; return Integer.toString(i); &#125;</span><br><span class=\"line\">  public static String intercept(Object o) &#123; return o.toString(); &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>前一个实现因为只有一个方法，而且类型也匹配，很好理解，那么后一个呢，Byte Buddy到底会委托给哪个方法？Byte Buddy遵循一个最接近原则：</p>\n<ul>\n<li>intercept(int)因为参数类型不匹配，直接Pass</li>\n<li>另外两个方法参数都匹配，但是 intercept(String)类型更加接近，因此会委托给它</li>\n</ul>\n<p>同时需要注意的是被拦截的方法需要声明为 public，否则没法进行拦截增强。除此之外，还可以使用 @RuntimeType 注解来标注方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RuntimeType</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>  Object <span class=\"title function_\">interceptor</span><span class=\"params\">(<span class=\"meta\">@This</span> Object proxy, <span class=\"meta\">@Origin</span> Method method,</span></span><br><span class=\"line\"><span class=\"params\">                          <span class=\"meta\">@SuperMethod</span> Method superMethod,</span></span><br><span class=\"line\"><span class=\"params\">                          <span class=\"meta\">@AllArguments</span> Object[] args)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;bytebuddy delegate proxy2 before sing &quot;</span>);</span><br><span class=\"line\">    <span class=\"type\">Object</span> <span class=\"variable\">ret</span> <span class=\"operator\">=</span> superMethod.invoke(proxy, args);</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;bytebuddy delegate proxy2 after sing &quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"参数绑定\">参数绑定</h3>\n<p>可以在拦截器（Target）的拦截方法 intercept 中使用注解注入参数，ByteBuddy 会根据注解给我们注入对于的参数值。比如</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void intercept(Object o1, Object o2)</span><br><span class=\"line\">// 等同于</span><br><span class=\"line\">void intercept(@Argument(0) Object o1, @Argument(1) Object o2)</span><br></pre></td></tr></table></figure>\n<p>常用注解有以下这些：</p>\n<ul>\n<li>@Argument 绑定单个参数</li>\n<li>@AllArguments 绑定所有参数的数组</li>\n<li>@This 当前被拦截的、动态生成的那个对象</li>\n<li>@DefaultCall 调用默认方法而非super的方法</li>\n<li>@SuperCall 用于调用父类版本的方法</li>\n<li>@Origin 被拦截的源方法</li>\n<li>@RuntimeType 可以用在返回值、参数上，提示ByteBuddy禁用严格的类型检查</li>\n<li>@Super 当前被拦截的、动态生成的那个对象的父类对象</li>\n<li>@FieldValue 注入被拦截对象的一个字段的值</li>\n</ul>\n<h2 id=\"Agent\">Agent</h2>\n<p>Java 从 1.5 开始提供了 java.lang.instrument包，该包为检测 Java 程序提供 API，比如用于监控、收集性能信息、诊断问题。通过 java.lang.instrument 实现工具被称为 Java Agent。Java Agent 可以修改类文件的字节码，通常是，在字节码方法插入额外的字节码来完成检测</p>\n<p>和通过ByteBuddy实例创建动态类型一样，bytebuddy也提供了AgentBuilder类使我们在agent中更优雅地编写代码</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class ToStringAgent &#123;</span><br><span class=\"line\">  public static void premain(String arguments, Instrumentation instrumentation) &#123;</span><br><span class=\"line\">    new AgentBuilder.Default()</span><br><span class=\"line\">        .type(isAnnotatedWith(ToString.class))</span><br><span class=\"line\">        .transform(new AgentBuilder.Transformer() &#123;</span><br><span class=\"line\">      @Override</span><br><span class=\"line\">      public DynamicType.Builder transform(DynamicType.Builder builder,</span><br><span class=\"line\">                                              TypeDescription typeDescription,</span><br><span class=\"line\">                                              ClassLoader classloader) &#123;</span><br><span class=\"line\">        return builder.method(named(&quot;toString&quot;))</span><br><span class=\"line\">                      .intercept(FixedValue.value(&quot;transformed&quot;));</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;).installOn(instrumentation);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>type 通过ElementMatcher 来匹配我们加载的class，匹配到之后，将会使用</li>\n<li>transform 指定的转换器来对匹配到的class进行操作</li>\n</ul>\n<h2 id=\"ElementMatcher\">ElementMatcher</h2>\n<p>ElementMatcher可以定义匹配class的规则，在bytebuddy中，ElementMatchers类提供了许多常规的匹配方式，可以按照class name、注解、类型等来进行匹配，上面的实例中就是使用注解匹配的方式</p>\n<p>Junction继承自ElementMatcher接口，定义了and 和 or 方法，可以使我们在定义Matcher时通过链式定义一连串的匹配规则</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new AgentBuilder.Default()</span><br><span class=\"line\">          .type(ElementMatchers.isAnnotatedWith(ToString.class)).and(ElementMatchers.isSubTypeOf(DynamicClass.class)).or(ElementMatchers.named(&quot;DynamicClass&quot;))</span><br><span class=\"line\">          .transform(new AgentBuilder.Transformer() &#123;</span><br><span class=\"line\">              public DynamicType.Builder&lt;?&gt; transform(DynamicType.Builder&lt;?&gt; builder, TypeDescription typeDescription, ClassLoader classLoader, JavaModule javaModule) &#123;</span><br><span class=\"line\">                  return builder</span><br><span class=\"line\">                          .method(ElementMatchers.named(&quot;hello&quot;))</span><br><span class=\"line\">                          .intercept(MethodDelegation.to(MyServiceInterceptor.class))</span><br><span class=\"line\">                          ;</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">          &#125;).installOn(instrumentation);</span><br></pre></td></tr></table></figure>\n<h2 id=\"Transformer\"><a href=\"https://so.csdn.net/so/search?q=Transformer&amp;spm=1001.2101.3001.7020\">Transformer</a></h2>\n<p>Transformer 接口定义了 transform方法，会传入DynamicType.Builder实例，通过该builder，就可以对匹配到的类进行操作，就和上面讲的 ByteBuddy创建动态类型时类似操作，可以定义字段以及对方法进行拦截操作等，上面的例子就是对匹配到的类的hello方法进行了方法委托，在调用hello方法时，将会委托给 MyServiceInterceptor类</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class MyServiceInterceptor &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @RuntimeType</span><br><span class=\"line\">    public static Object intercept(@Origin Method method, @SuperCall Callable&lt;?&gt; callable) throws Exception &#123;</span><br><span class=\"line\">        System.out.println(&quot;intercept：拦截了&quot; + method.getName());</span><br><span class=\"line\">        return callable.call();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"\"></h2>\n<p>‍</p>\n<h2 id=\"END\">END</h2>\n<p><strong>参考文章</strong><br>\n​<code>bytebuddy官方文档 https://bytebuddy.net/#/tutorial</code></p>\n<p><code>https://juejin.cn/post/6844903965553852423#heading-12</code>​​</p>\n","excerpt":"","more":"<h1>ByteBuddy</h1>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">      &lt;groupId&gt;net.bytebuddy&lt;/groupId&gt;</span><br><span class=\"line\">      &lt;artifactId&gt;byte-buddy&lt;/artifactId&gt;</span><br><span class=\"line\">      &lt;version&gt;1.11.12&lt;/version&gt;</span><br><span class=\"line\">  &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Hello-World\">Hello World</h2>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class&lt;?&gt; dynamicType = new ByteBuddy()</span><br><span class=\"line\">                .subclass(Object.class)</span><br><span class=\"line\">                .method(ElementMatchers.named(&quot;toString&quot;))</span><br><span class=\"line\">                .intercept(FixedValue.value(&quot;Hello World&quot;))</span><br><span class=\"line\">                .make()</span><br><span class=\"line\">                .load(HelloWorldBuddy.class.getClassLoader())</span><br><span class=\"line\">                .getLoaded();</span><br><span class=\"line\">Object instance = dynamicType.newInstance();</span><br><span class=\"line\">String toString = instance.toString();</span><br><span class=\"line\">System.out.println(toString);</span><br><span class=\"line\">System.out.println(instance.getClass().getCanonicalName());</span><br></pre></td></tr></table></figure>\n<p>​<img src=\"/assets/image-20230619222624-l98xjgi.png\" alt=\"image\">​</p>\n<p>从例子可以看出，很简单就创建了一个动态类型。ByteBuddy提供了一套流式API，从ByteBuddy实例出发，可以流畅的完成所有的操作和数据定义。<br>\n上面的示例中</p>\n<ul>\n<li>subclass 指定了新创建的类的父类</li>\n<li>method 指定了 Object 的 toString 方法</li>\n<li>intercept 拦截了 toString 方法并返回固定的 value</li>\n<li>最后 make 方法生产字节码，有类加载器加载到虚拟机中</li>\n</ul>\n<p>此外，Byte Buddy不仅限于创建子类和操作类，还可以转换现有代码。Byte Buddy 还提供了一个方便的 API，用于定义所谓的 Java 代理，该代理允许在任何 Java 应用程序的运行期间进行代码转换</p>\n<h2 id=\"创建动态类\">创建动态类</h2>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DynamicType.Unloaded&lt;?&gt; dynamicType = new ByteBuddy()</span><br><span class=\"line\">  .subclass(Object.class)</span><br><span class=\"line\">  .name(&quot;com.zlk.learning.bytebuddy.DynamicType&quot;)</span><br><span class=\"line\">  .make();</span><br></pre></td></tr></table></figure>\n<p>上面的示例代码会创建一个继承至 Object 类型的类。这个动态创建的类型与直接扩展 Object 并且没有实现任何方法、属性和构造函数的类型是等价的，如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class DynamicTYpe &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在创建类的时候，还提供了更多API来支持对类的定义，包括定义字段、方法等</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DynamicType.Unloaded&lt;?&gt; dynamicType = new ByteBuddy()</span><br><span class=\"line\">        .subclass(Object.class)</span><br><span class=\"line\">        .name(&quot;com.zlk.learning.bytebuddy.DynamicType&quot;)</span><br><span class=\"line\">        .defineField(&quot;name&quot;, String.class, 1)</span><br><span class=\"line\">        .defineField(&quot;age&quot;, Integer.class, 1)</span><br><span class=\"line\">        .method(ElementMatchers.named(&quot;toString&quot;))</span><br><span class=\"line\">        .intercept(FixedValue.value(&quot;Hello World!&quot;))</span><br><span class=\"line\">        .make();</span><br></pre></td></tr></table></figure>\n<p>​<img src=\"/assets/image-20230619222818-5btwdt3.png\" alt=\"image\">​</p>\n<p>上面的示例代码中，我们增加了两个字段name和age，同时拦截了toString方法，使其输出固定值 “Hello World!”。</p>\n<p>保留父类实现的接口信息</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Object <span class=\"title function_\">instantiate</span><span class=\"params\">(BeanDefinition beanDefinition, String beanName, Constructor ctor, Object[] args)</span> <span class=\"keyword\">throws</span> BeansException &#123;</span><br><span class=\"line\">    Class&lt;?&gt; beanClass = beanDefinition.getBeanClass();</span><br><span class=\"line\">    ArrayList&lt;TypeDescription.Generic&gt; list = getGenerics(beanClass);</span><br><span class=\"line\">    <span class=\"type\">Class</span> <span class=\"variable\">clazz</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ByteBuddy</span>().subclass(beanClass).implement(list)</span><br><span class=\"line\">            .make()</span><br><span class=\"line\">            .load(getClass().getClassLoader())</span><br><span class=\"line\">            .getLoaded();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"literal\">null</span> == ctor) <span class=\"keyword\">return</span> clazz.getDeclaredConstructor().newInstance();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> clazz.getDeclaredConstructor(ctor.getParameterTypes()).newInstance(args);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (NoSuchMethodException | InstantiationException | IllegalAccessException | InvocationTargetException e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">BeansException</span>(<span class=\"string\">&quot;Failed to instantiate [&quot;</span> + clazz.getName() + <span class=\"string\">&quot;]&quot;</span>, e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//获取父类的接口信息</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> ArrayList&lt;TypeDescription.Generic&gt; getGenerics(Class&lt;?&gt; beanClass) &#123;</span><br><span class=\"line\">    ArrayList&lt;TypeDescription.Generic&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        Type[] genericInterfaces = beanClass.getGenericInterfaces();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Type type : genericInterfaces) &#123;</span><br><span class=\"line\">            Type[] typeArguments = ((ParameterizedType) type).getActualTypeArguments();</span><br><span class=\"line\">            Class&lt;?&gt;[] classes = <span class=\"keyword\">new</span> <span class=\"title class_\">Class</span>[typeArguments.length];</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; typeArguments.length; i++) &#123;</span><br><span class=\"line\">                classes[i] = Class.forName(typeArguments[i].getTypeName());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            Class&lt;?&gt; aClass = Class.forName(((ParameterizedType) type).getRawType().getTypeName());</span><br><span class=\"line\">            TypeDescription.<span class=\"type\">Generic</span> <span class=\"variable\">listType</span> <span class=\"operator\">=</span> TypeDescription.Generic.Builder.parameterizedType(aClass, classes).build();</span><br><span class=\"line\">            list.add(listType);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (ClassNotFoundException e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">BeansException</span>(<span class=\"string\">&quot;Failed to instantiate [&quot;</span> + beanClass.getName() + <span class=\"string\">&quot;]&quot;</span>, e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> list;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>‍</p>\n<h2 id=\"加载类\">加载类</h2>\n<p>上节创建的 DynamicType.Unloaded，代表一个尚未加载的类，顾名思义，这些类型不会加载到 Java 虚拟机中，它仅仅表示创建好了类的字节码，通过 DynamicType.Unloaded 中的 getBytes 方法你可以获取到该字节码。</p>\n<p>在应用程序中，可能需要将该字节码保存到文件，或者注入的现在的 jar 文件中，因此该类型还提供了一个 saveIn(File) 方法，可以将类存储在给定的文件夹中； inject(File) 方法将类注入到现有的 Jar 文件中，另外你只需要将该字节码直接加载到虚拟机使用，你可以通过 ClassLoadingStrategy 来加载。</p>\n<p>如果不指定ClassLoadingStrategy，Byte Buffer根据你提供的ClassLoader来推导出一个策略，内置的策略定义在枚举ClassLoadingStrategy.Default中</p>\n<ul>\n<li>WRAPPER：创建一个新的Wrapping类加载器</li>\n<li>CHILD_FIRST：类似上面，但是子加载器优先负责加载目标类</li>\n<li>INJECTION：利用反射机制注入动态类型</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class&lt;?&gt; dynamicClass = dynamicType</span><br><span class=\"line\">               .load(Object.class.getClassLoader(), ClassLoadingStrategy.Default.WRAPPER)</span><br><span class=\"line\">               .getLoaded();</span><br></pre></td></tr></table></figure>\n<p>我们使用 WRAPPER 策略来加载适合大多数情况的类，这样生产的动态类不会被ApplicationClassLoader加载到，不会影响到项目中已经存在的类<br>\n​<code>getLoaded 方法返回一个 Java Class 的实例，它就表示现在加载的动态类</code>​</p>\n<h2 id=\"拦截方法\">拦截方法</h2>\n<p>在之前的例子中，我们拦截了toString方法，并使其输出固定值。不过在实际开发中很少会遇到如此简单的场景，我们可以通过指定拦截方法的形式来处理复杂的逻辑</p>\n<h3 id=\"通过匹配模式拦截\">通过匹配模式拦截</h3>\n<p>ByteBuddy 通过 net.bytebuddy.matcher.ElementMatcher 来定义配置策略，可以通过此接口实现自己定义的匹配策略</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Foo dynamicFoo = new ByteBuddy()</span><br><span class=\"line\">  .subclass(Foo.class)</span><br><span class=\"line\">  // 匹配由Foo.class声明的方法</span><br><span class=\"line\">  .method(isDeclaredBy(Foo.class)).intercept(FixedValue.value(&quot;One!&quot;))</span><br><span class=\"line\">  // 匹配名为foo的方法</span><br><span class=\"line\">  .method(named(&quot;foo&quot;)).intercept(FixedValue.value(&quot;Two!&quot;))</span><br><span class=\"line\">  // 匹配名为foo，入参数量为1的方法</span><br><span class=\"line\">  .method(named(&quot;foo&quot;).and(takesArguments(1))).intercept(FixedValue.value(&quot;Three!&quot;))</span><br><span class=\"line\">  .make()</span><br><span class=\"line\">  .load(getClass().getClassLoader())</span><br><span class=\"line\">  .getLoaded()</span><br><span class=\"line\">  .newInstance();</span><br></pre></td></tr></table></figure>\n<h3 id=\"方法委托\">方法委托</h3>\n<p>使用MethodDelegation可以将方法调用委托给任意POJO。Byte Buddy不要求Source（被委托类）、Target类的方法名一致</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Source &#123;</span><br><span class=\"line\">  public String hello(String name) &#123; return null; &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class Target &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  public static String hello(String name) &#123;</span><br><span class=\"line\">    return &quot;Hello &quot; + name + &quot;!&quot;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">String helloWorld = new ByteBuddy()</span><br><span class=\"line\">  .subclass(Source.class)</span><br><span class=\"line\">  .method(named(&quot;hello&quot;))</span><br><span class=\"line\">  // 此处委托 类只能委托静态方法  对象可使用非静态方法</span><br><span class=\"line\">  .intercept(MethodDelegation.to(Target.class))</span><br><span class=\"line\">  .make()</span><br><span class=\"line\">  .load(getClass().getClassLoader())</span><br><span class=\"line\">  .getLoaded()</span><br><span class=\"line\">  .newInstance()</span><br><span class=\"line\">  .hello(&quot;World&quot;);</span><br></pre></td></tr></table></figure>\n<p>其中 Target 还可以如下实现：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Target &#123;</span><br><span class=\"line\">  public static String intercept(String name) &#123; return &quot;Hello &quot; + name + &quot;!&quot;; &#125;</span><br><span class=\"line\">  public static String intercept(int i) &#123; return Integer.toString(i); &#125;</span><br><span class=\"line\">  public static String intercept(Object o) &#123; return o.toString(); &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>前一个实现因为只有一个方法，而且类型也匹配，很好理解，那么后一个呢，Byte Buddy到底会委托给哪个方法？Byte Buddy遵循一个最接近原则：</p>\n<ul>\n<li>intercept(int)因为参数类型不匹配，直接Pass</li>\n<li>另外两个方法参数都匹配，但是 intercept(String)类型更加接近，因此会委托给它</li>\n</ul>\n<p>同时需要注意的是被拦截的方法需要声明为 public，否则没法进行拦截增强。除此之外，还可以使用 @RuntimeType 注解来标注方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RuntimeType</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>  Object <span class=\"title function_\">interceptor</span><span class=\"params\">(<span class=\"meta\">@This</span> Object proxy, <span class=\"meta\">@Origin</span> Method method,</span></span><br><span class=\"line\"><span class=\"params\">                          <span class=\"meta\">@SuperMethod</span> Method superMethod,</span></span><br><span class=\"line\"><span class=\"params\">                          <span class=\"meta\">@AllArguments</span> Object[] args)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;bytebuddy delegate proxy2 before sing &quot;</span>);</span><br><span class=\"line\">    <span class=\"type\">Object</span> <span class=\"variable\">ret</span> <span class=\"operator\">=</span> superMethod.invoke(proxy, args);</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;bytebuddy delegate proxy2 after sing &quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"参数绑定\">参数绑定</h3>\n<p>可以在拦截器（Target）的拦截方法 intercept 中使用注解注入参数，ByteBuddy 会根据注解给我们注入对于的参数值。比如</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void intercept(Object o1, Object o2)</span><br><span class=\"line\">// 等同于</span><br><span class=\"line\">void intercept(@Argument(0) Object o1, @Argument(1) Object o2)</span><br></pre></td></tr></table></figure>\n<p>常用注解有以下这些：</p>\n<ul>\n<li>@Argument 绑定单个参数</li>\n<li>@AllArguments 绑定所有参数的数组</li>\n<li>@This 当前被拦截的、动态生成的那个对象</li>\n<li>@DefaultCall 调用默认方法而非super的方法</li>\n<li>@SuperCall 用于调用父类版本的方法</li>\n<li>@Origin 被拦截的源方法</li>\n<li>@RuntimeType 可以用在返回值、参数上，提示ByteBuddy禁用严格的类型检查</li>\n<li>@Super 当前被拦截的、动态生成的那个对象的父类对象</li>\n<li>@FieldValue 注入被拦截对象的一个字段的值</li>\n</ul>\n<h2 id=\"Agent\">Agent</h2>\n<p>Java 从 1.5 开始提供了 java.lang.instrument包，该包为检测 Java 程序提供 API，比如用于监控、收集性能信息、诊断问题。通过 java.lang.instrument 实现工具被称为 Java Agent。Java Agent 可以修改类文件的字节码，通常是，在字节码方法插入额外的字节码来完成检测</p>\n<p>和通过ByteBuddy实例创建动态类型一样，bytebuddy也提供了AgentBuilder类使我们在agent中更优雅地编写代码</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class ToStringAgent &#123;</span><br><span class=\"line\">  public static void premain(String arguments, Instrumentation instrumentation) &#123;</span><br><span class=\"line\">    new AgentBuilder.Default()</span><br><span class=\"line\">        .type(isAnnotatedWith(ToString.class))</span><br><span class=\"line\">        .transform(new AgentBuilder.Transformer() &#123;</span><br><span class=\"line\">      @Override</span><br><span class=\"line\">      public DynamicType.Builder transform(DynamicType.Builder builder,</span><br><span class=\"line\">                                              TypeDescription typeDescription,</span><br><span class=\"line\">                                              ClassLoader classloader) &#123;</span><br><span class=\"line\">        return builder.method(named(&quot;toString&quot;))</span><br><span class=\"line\">                      .intercept(FixedValue.value(&quot;transformed&quot;));</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;).installOn(instrumentation);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>type 通过ElementMatcher 来匹配我们加载的class，匹配到之后，将会使用</li>\n<li>transform 指定的转换器来对匹配到的class进行操作</li>\n</ul>\n<h2 id=\"ElementMatcher\">ElementMatcher</h2>\n<p>ElementMatcher可以定义匹配class的规则，在bytebuddy中，ElementMatchers类提供了许多常规的匹配方式，可以按照class name、注解、类型等来进行匹配，上面的实例中就是使用注解匹配的方式</p>\n<p>Junction继承自ElementMatcher接口，定义了and 和 or 方法，可以使我们在定义Matcher时通过链式定义一连串的匹配规则</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new AgentBuilder.Default()</span><br><span class=\"line\">          .type(ElementMatchers.isAnnotatedWith(ToString.class)).and(ElementMatchers.isSubTypeOf(DynamicClass.class)).or(ElementMatchers.named(&quot;DynamicClass&quot;))</span><br><span class=\"line\">          .transform(new AgentBuilder.Transformer() &#123;</span><br><span class=\"line\">              public DynamicType.Builder&lt;?&gt; transform(DynamicType.Builder&lt;?&gt; builder, TypeDescription typeDescription, ClassLoader classLoader, JavaModule javaModule) &#123;</span><br><span class=\"line\">                  return builder</span><br><span class=\"line\">                          .method(ElementMatchers.named(&quot;hello&quot;))</span><br><span class=\"line\">                          .intercept(MethodDelegation.to(MyServiceInterceptor.class))</span><br><span class=\"line\">                          ;</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">          &#125;).installOn(instrumentation);</span><br></pre></td></tr></table></figure>\n<h2 id=\"Transformer\"><a href=\"https://so.csdn.net/so/search?q=Transformer&amp;spm=1001.2101.3001.7020\">Transformer</a></h2>\n<p>Transformer 接口定义了 transform方法，会传入DynamicType.Builder实例，通过该builder，就可以对匹配到的类进行操作，就和上面讲的 ByteBuddy创建动态类型时类似操作，可以定义字段以及对方法进行拦截操作等，上面的例子就是对匹配到的类的hello方法进行了方法委托，在调用hello方法时，将会委托给 MyServiceInterceptor类</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class MyServiceInterceptor &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @RuntimeType</span><br><span class=\"line\">    public static Object intercept(@Origin Method method, @SuperCall Callable&lt;?&gt; callable) throws Exception &#123;</span><br><span class=\"line\">        System.out.println(&quot;intercept：拦截了&quot; + method.getName());</span><br><span class=\"line\">        return callable.call();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"\"></h2>\n<p>‍</p>\n<h2 id=\"END\">END</h2>\n<p><strong>参考文章</strong><br>\n​<code>bytebuddy官方文档 https://bytebuddy.net/#/tutorial</code></p>\n<p><code>https://juejin.cn/post/6844903965553852423#heading-12</code>​​</p>\n"},{"title":"Collection","date":"2022-10-30T05:21:31.000Z","lastmod":"2023-05-27T07:29:52.000Z","_content":"\n# Collection\n\n# Collection\n\n​![](/assets/net-img-1596005642573-853dc49e-7632-496d-9221-33e3b7879fea-20221030132325-84wdxkw.jpeg)​\n\n​![](/assets/net-img-1591690708492-8b43720d-e8dc-4e22-9057-dcc4be2210de-20221030132325-ac88yvu.jpeg)​\n\n- Collection 接口的接口 对象的集合\n  - List 子接口 按进入先后有序保存 可重复\n    - LinkedList(双向链表) 接口实现类 链表 插入删除 没有同步 线程不安全\n    - ArrayList(Object 数组) 接口实现类 数组 随机访问 没有同步 线程不安全\n    - Vector(Object 数组) 接口实现类 数组 同步 线程安全\n  - Set 子接口 不可重复\n    - HashSet(无序，唯一)\n    - LinkedHashSet(有序，唯一)\n      线程不安全\n    - TreeSet(有序，唯一)\n- Map 接口 键值对的集合\n  - Hashtable(链表+数组) 接口实现类 同步 线程安全\n  - HashMap(1.8 之前数组+链表，1.8 之后达到一定长度会转化为红黑树) 接口实现类 没有同步 线程不安全\n    - LinkedHashMap(在 HashMap 基础上添加一条双向链表)\n  - TreeMap(红黑树(自平衡排序二叉树))\n\n## Iterable\n\n　　**Iterator 也是一个接口，它只有三个方法：**\n\n- hasNext()\n- next()\n- remove()\n\n## ArrayList 与 LinkedList 区别\n\n- 都不保证线程安全\n- ArrayList 底层是数组，LinkedList 底层使用双向链表（1.6 之前为循环链表，1.7 之后取消循环）\n- ArrayList 采用数组存储，删除和插入的时间复杂度会受元素位置影响。LinkedList 采用链式存储，对于插入删除不受元素位置影响\n- LinkedList 不支持随机访问，ArrayList 支持元素序号访问\n- ArrayList 会在列表结尾预留一定空余空间，LinkedList 每个节点所消耗的空间比 ArrayList 大\n\n## HashMap 和 Hashtable 区别\n\n- HashMap 是非线程安全的，HashTable 是线程安全的 (如果你要保证线程安全的话就使用 ConcurrentHashMap 吧,效率比 hashtable 高)；\n- HashMap 中，null 可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为 null。。但是在 HashTable 中 put 进的键值只要有一个 null，直接抛出 NullPointerException。\n- 初始化\n  - ① 创建时如果不指定容量初始值： Hashtable 默认的**初始大小为 11**，之后每次扩充，容量变为原来的 2n+1。HashMap 默认的**初始化大小为 16**。之后每次扩充，容量变为原来的 2 倍。\n  - ② 创建时如果给定了容量初始值：Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为 2 的幂次方大小\n- JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（**将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树**）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。\n\n## ConcurrentHashMap 和 Hashtable 的区别\n\n　　ConcurrentHashMap 和 Hashtable 的区别主要体现在实现线程安全的方式上不同。\n\n- 底层数据结构： JDK1.7 的 ConcurrentHashMap 底层采用 **分段的数组+链表** 实现，JDK1.8 采用的数据结构跟 HashMap1.8 的结构一样，**数组+链表/红黑二叉树**。Hashtable 和 JDK1.8 之前的 HashMap 的底层数据结构类似都是采用 **数组+链表** 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；\n- 实现线程安全的方式（重要）：\n  - ① 在 JDK1.7 的时候，ConcurrentHashMap（分段锁） 对整个桶数组进行了分割分段(Segment)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。 到了 JDK1.8 的时候已经摒弃了 Segment 的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作。（JDK1.6 以后 对 synchronized 锁做了很多优化） 整个看起来就像是优化过且线程安全的 HashMap，虽然在 JDK1.8 中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本；\n  - ② Hashtable(同一把锁) :使用 synchronized 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。\n\n## HashTable：全表锁\n\n![](/assets/net-img-1591690708909-03b304db-aa14-40fc-954b-2e5812e31b86-20221030132326-7iwfv9t.png)\n\n## JDK7 的 ConcurrentHashMap：\n\n　　首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。\n\n　　一个 `ConcurrentHashMap` 里包含一个 `Segment(片段)` 数组。`Segment` 的结构和 `HashMap` 类似，是一种数组和链表结构，一个 `Segment` 包含一个 `HashEntry` 数组，每个 `HashEntry` 是一个链表结构的元素，每个 `Segment` 守护着一个 `HashEntry` 数组里的元素，当对 `HashEntry` 数组的数据进行修改时，必须首先获得对应的 `Segment` 的锁。\n\n　　![](/assets/net-img-1591690708399-bf1076aa-bdad-4e5f-ae30-261ccda91da5-20221030132327-4fweook.png)[https://imgchr.com/i/t2J5Kx](https://imgchr.com/i/t2J5Kx)\n\n## JDK1.8 的 ConcurrentHashMap（TreeBin: 红黑二叉树节点 Node: 链表节点）`\n\n　　​**​`1.8之前ConcurrentHashMap将hashmap数组分段，对于每个段加锁。而在1.8后几乎与hashmap类似，只是更改了put操作，在计算hash值和索引位置后会先判断数组是否正在扩容。若正在扩容则调用扩容辅助函数。没有则在判断是否为空，为空则采用csa方法放入数组，若不为空则使用synchronized锁住该节点，根据链表或红黑树选择插入方法。最后判断长度，为8则开始转换红黑树。`​** ​ `synchronized `​只锁定当前链表或红黑二叉树的首节点，这样只要 hash 不冲突，就不会产生并发，效率又提升 N 倍。\n\n​![](/assets/net-img-1591690708309-b6db1e95-1bbf-4140-b612-26fefc8d85b5-20221030132327-6s3ed7l.png)​\n\n## HashMap 和 HashSet 区别\n\n　　**HashSet 底层就是基于 HashMap 实现的**\n\n|HashMap|HashSet|\n| ----------------------------------| ------------------------------------------------------------------------|\n|实现了 Map 接口|实现 Set 接口|\n|存储键值对|仅存储对象|\n|调用 put()向 map 中添加元素|调用 add()方法向 Set 中添加元素|\n|HashMap 使用键（Key）计算 Hashcode|HashSet 使用成员对象来计算 hashcode 值，对于两个对象来说 hashcode 可能相|\n","source":"_posts/java/Collection.md","raw":"---\ntitle: Collection\ndate: 2022-10-30T13:21:31Z\nlastmod: 2023-05-27T15:29:52Z\n---\n\n# Collection\n\n# Collection\n\n​![](/assets/net-img-1596005642573-853dc49e-7632-496d-9221-33e3b7879fea-20221030132325-84wdxkw.jpeg)​\n\n​![](/assets/net-img-1591690708492-8b43720d-e8dc-4e22-9057-dcc4be2210de-20221030132325-ac88yvu.jpeg)​\n\n- Collection 接口的接口 对象的集合\n  - List 子接口 按进入先后有序保存 可重复\n    - LinkedList(双向链表) 接口实现类 链表 插入删除 没有同步 线程不安全\n    - ArrayList(Object 数组) 接口实现类 数组 随机访问 没有同步 线程不安全\n    - Vector(Object 数组) 接口实现类 数组 同步 线程安全\n  - Set 子接口 不可重复\n    - HashSet(无序，唯一)\n    - LinkedHashSet(有序，唯一)\n      线程不安全\n    - TreeSet(有序，唯一)\n- Map 接口 键值对的集合\n  - Hashtable(链表+数组) 接口实现类 同步 线程安全\n  - HashMap(1.8 之前数组+链表，1.8 之后达到一定长度会转化为红黑树) 接口实现类 没有同步 线程不安全\n    - LinkedHashMap(在 HashMap 基础上添加一条双向链表)\n  - TreeMap(红黑树(自平衡排序二叉树))\n\n## Iterable\n\n　　**Iterator 也是一个接口，它只有三个方法：**\n\n- hasNext()\n- next()\n- remove()\n\n## ArrayList 与 LinkedList 区别\n\n- 都不保证线程安全\n- ArrayList 底层是数组，LinkedList 底层使用双向链表（1.6 之前为循环链表，1.7 之后取消循环）\n- ArrayList 采用数组存储，删除和插入的时间复杂度会受元素位置影响。LinkedList 采用链式存储，对于插入删除不受元素位置影响\n- LinkedList 不支持随机访问，ArrayList 支持元素序号访问\n- ArrayList 会在列表结尾预留一定空余空间，LinkedList 每个节点所消耗的空间比 ArrayList 大\n\n## HashMap 和 Hashtable 区别\n\n- HashMap 是非线程安全的，HashTable 是线程安全的 (如果你要保证线程安全的话就使用 ConcurrentHashMap 吧,效率比 hashtable 高)；\n- HashMap 中，null 可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为 null。。但是在 HashTable 中 put 进的键值只要有一个 null，直接抛出 NullPointerException。\n- 初始化\n  - ① 创建时如果不指定容量初始值： Hashtable 默认的**初始大小为 11**，之后每次扩充，容量变为原来的 2n+1。HashMap 默认的**初始化大小为 16**。之后每次扩充，容量变为原来的 2 倍。\n  - ② 创建时如果给定了容量初始值：Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为 2 的幂次方大小\n- JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（**将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树**）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。\n\n## ConcurrentHashMap 和 Hashtable 的区别\n\n　　ConcurrentHashMap 和 Hashtable 的区别主要体现在实现线程安全的方式上不同。\n\n- 底层数据结构： JDK1.7 的 ConcurrentHashMap 底层采用 **分段的数组+链表** 实现，JDK1.8 采用的数据结构跟 HashMap1.8 的结构一样，**数组+链表/红黑二叉树**。Hashtable 和 JDK1.8 之前的 HashMap 的底层数据结构类似都是采用 **数组+链表** 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；\n- 实现线程安全的方式（重要）：\n  - ① 在 JDK1.7 的时候，ConcurrentHashMap（分段锁） 对整个桶数组进行了分割分段(Segment)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。 到了 JDK1.8 的时候已经摒弃了 Segment 的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作。（JDK1.6 以后 对 synchronized 锁做了很多优化） 整个看起来就像是优化过且线程安全的 HashMap，虽然在 JDK1.8 中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本；\n  - ② Hashtable(同一把锁) :使用 synchronized 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。\n\n## HashTable：全表锁\n\n![](/assets/net-img-1591690708909-03b304db-aa14-40fc-954b-2e5812e31b86-20221030132326-7iwfv9t.png)\n\n## JDK7 的 ConcurrentHashMap：\n\n　　首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。\n\n　　一个 `ConcurrentHashMap` 里包含一个 `Segment(片段)` 数组。`Segment` 的结构和 `HashMap` 类似，是一种数组和链表结构，一个 `Segment` 包含一个 `HashEntry` 数组，每个 `HashEntry` 是一个链表结构的元素，每个 `Segment` 守护着一个 `HashEntry` 数组里的元素，当对 `HashEntry` 数组的数据进行修改时，必须首先获得对应的 `Segment` 的锁。\n\n　　![](/assets/net-img-1591690708399-bf1076aa-bdad-4e5f-ae30-261ccda91da5-20221030132327-4fweook.png)[https://imgchr.com/i/t2J5Kx](https://imgchr.com/i/t2J5Kx)\n\n## JDK1.8 的 ConcurrentHashMap（TreeBin: 红黑二叉树节点 Node: 链表节点）`\n\n　　​**​`1.8之前ConcurrentHashMap将hashmap数组分段，对于每个段加锁。而在1.8后几乎与hashmap类似，只是更改了put操作，在计算hash值和索引位置后会先判断数组是否正在扩容。若正在扩容则调用扩容辅助函数。没有则在判断是否为空，为空则采用csa方法放入数组，若不为空则使用synchronized锁住该节点，根据链表或红黑树选择插入方法。最后判断长度，为8则开始转换红黑树。`​** ​ `synchronized `​只锁定当前链表或红黑二叉树的首节点，这样只要 hash 不冲突，就不会产生并发，效率又提升 N 倍。\n\n​![](/assets/net-img-1591690708309-b6db1e95-1bbf-4140-b612-26fefc8d85b5-20221030132327-6s3ed7l.png)​\n\n## HashMap 和 HashSet 区别\n\n　　**HashSet 底层就是基于 HashMap 实现的**\n\n|HashMap|HashSet|\n| ----------------------------------| ------------------------------------------------------------------------|\n|实现了 Map 接口|实现 Set 接口|\n|存储键值对|仅存储对象|\n|调用 put()向 map 中添加元素|调用 add()方法向 Set 中添加元素|\n|HashMap 使用键（Key）计算 Hashcode|HashSet 使用成员对象来计算 hashcode 值，对于两个对象来说 hashcode 可能相|\n","slug":"java-Collection","published":1,"updated":"2025-04-28T08:41:48.386Z","_id":"cm9s3f3yv0005bfg49hwx0b2y","comments":1,"layout":"post","photos":[],"content":"<h1>Collection</h1>\n<h1>Collection</h1>\n<p>​<img src=\"/assets/net-img-1596005642573-853dc49e-7632-496d-9221-33e3b7879fea-20221030132325-84wdxkw.jpeg\" alt=\"\">​</p>\n<p>​<img src=\"/assets/net-img-1591690708492-8b43720d-e8dc-4e22-9057-dcc4be2210de-20221030132325-ac88yvu.jpeg\" alt=\"\">​</p>\n<ul>\n<li>Collection 接口的接口 对象的集合\n<ul>\n<li>List 子接口 按进入先后有序保存 可重复\n<ul>\n<li>LinkedList(双向链表) 接口实现类 链表 插入删除 没有同步 线程不安全</li>\n<li>ArrayList(Object 数组) 接口实现类 数组 随机访问 没有同步 线程不安全</li>\n<li>Vector(Object 数组) 接口实现类 数组 同步 线程安全</li>\n</ul>\n</li>\n<li>Set 子接口 不可重复\n<ul>\n<li>HashSet(无序，唯一)</li>\n<li>LinkedHashSet(有序，唯一)<br>\n线程不安全</li>\n<li>TreeSet(有序，唯一)</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Map 接口 键值对的集合\n<ul>\n<li>Hashtable(链表+数组) 接口实现类 同步 线程安全</li>\n<li>HashMap(1.8 之前数组+链表，1.8 之后达到一定长度会转化为红黑树) 接口实现类 没有同步 线程不安全\n<ul>\n<li>LinkedHashMap(在 HashMap 基础上添加一条双向链表)</li>\n</ul>\n</li>\n<li>TreeMap(红黑树(自平衡排序二叉树))</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Iterable\">Iterable</h2>\n<p><strong>Iterator 也是一个接口，它只有三个方法：</strong></p>\n<ul>\n<li>hasNext()</li>\n<li>next()</li>\n<li>remove()</li>\n</ul>\n<h2 id=\"ArrayList-与-LinkedList-区别\">ArrayList 与 LinkedList 区别</h2>\n<ul>\n<li>都不保证线程安全</li>\n<li>ArrayList 底层是数组，LinkedList 底层使用双向链表（1.6 之前为循环链表，1.7 之后取消循环）</li>\n<li>ArrayList 采用数组存储，删除和插入的时间复杂度会受元素位置影响。LinkedList 采用链式存储，对于插入删除不受元素位置影响</li>\n<li>LinkedList 不支持随机访问，ArrayList 支持元素序号访问</li>\n<li>ArrayList 会在列表结尾预留一定空余空间，LinkedList 每个节点所消耗的空间比 ArrayList 大</li>\n</ul>\n<h2 id=\"HashMap-和-Hashtable-区别\">HashMap 和 Hashtable 区别</h2>\n<ul>\n<li>HashMap 是非线程安全的，HashTable 是线程安全的 (如果你要保证线程安全的话就使用 ConcurrentHashMap 吧,效率比 hashtable 高)；</li>\n<li>HashMap 中，null 可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为 null。。但是在 HashTable 中 put 进的键值只要有一个 null，直接抛出 NullPointerException。</li>\n<li>初始化\n<ul>\n<li>① 创建时如果不指定容量初始值： Hashtable 默认的<strong>初始大小为 11</strong>，之后每次扩充，容量变为原来的 2n+1。HashMap 默认的<strong>初始化大小为 16</strong>。之后每次扩充，容量变为原来的 2 倍。</li>\n<li>② 创建时如果给定了容量初始值：Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为 2 的幂次方大小</li>\n</ul>\n</li>\n<li>JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（<strong>将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树</strong>）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。</li>\n</ul>\n<h2 id=\"ConcurrentHashMap-和-Hashtable-的区别\">ConcurrentHashMap 和 Hashtable 的区别</h2>\n<p>ConcurrentHashMap 和 Hashtable 的区别主要体现在实现线程安全的方式上不同。</p>\n<ul>\n<li>底层数据结构： JDK1.7 的 ConcurrentHashMap 底层采用 <strong>分段的数组+链表</strong> 实现，JDK1.8 采用的数据结构跟 HashMap1.8 的结构一样，<strong>数组+链表/红黑二叉树</strong>。Hashtable 和 JDK1.8 之前的 HashMap 的底层数据结构类似都是采用 <strong>数组+链表</strong> 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；</li>\n<li>实现线程安全的方式（重要）：\n<ul>\n<li>① 在 JDK1.7 的时候，ConcurrentHashMap（分段锁） 对整个桶数组进行了分割分段(Segment)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。 到了 JDK1.8 的时候已经摒弃了 Segment 的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作。（JDK1.6 以后 对 synchronized 锁做了很多优化） 整个看起来就像是优化过且线程安全的 HashMap，虽然在 JDK1.8 中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本；</li>\n<li>② Hashtable(同一把锁) :使用 synchronized 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"HashTable：全表锁\">HashTable：全表锁</h2>\n<p><img src=\"/assets/net-img-1591690708909-03b304db-aa14-40fc-954b-2e5812e31b86-20221030132326-7iwfv9t.png\" alt=\"\"></p>\n<h2 id=\"JDK7-的-ConcurrentHashMap：\">JDK7 的 ConcurrentHashMap：</h2>\n<p>首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。</p>\n<p>一个 <code>ConcurrentHashMap</code> 里包含一个 <code>Segment(片段)</code> 数组。<code>Segment</code> 的结构和 <code>HashMap</code> 类似，是一种数组和链表结构，一个 <code>Segment</code> 包含一个 <code>HashEntry</code> 数组，每个 <code>HashEntry</code> 是一个链表结构的元素，每个 <code>Segment</code> 守护着一个 <code>HashEntry</code> 数组里的元素，当对 <code>HashEntry</code> 数组的数据进行修改时，必须首先获得对应的 <code>Segment</code> 的锁。</p>\n<p><img src=\"/assets/net-img-1591690708399-bf1076aa-bdad-4e5f-ae30-261ccda91da5-20221030132327-4fweook.png\" alt=\"\"><a href=\"https://imgchr.com/i/t2J5Kx\">https://imgchr.com/i/t2J5Kx</a></p>\n<h2 id=\"JDK1-8-的-ConcurrentHashMap（TreeBin-红黑二叉树节点-Node-链表节点）\">JDK1.8 的 ConcurrentHashMap（TreeBin: 红黑二叉树节点 Node: 链表节点）`</h2>\n<p>​<strong>​<code>1.8之前ConcurrentHashMap将hashmap数组分段，对于每个段加锁。而在1.8后几乎与hashmap类似，只是更改了put操作，在计算hash值和索引位置后会先判断数组是否正在扩容。若正在扩容则调用扩容辅助函数。没有则在判断是否为空，为空则采用csa方法放入数组，若不为空则使用synchronized锁住该节点，根据链表或红黑树选择插入方法。最后判断长度，为8则开始转换红黑树。</code>​</strong> ​ <code>synchronized </code>​只锁定当前链表或红黑二叉树的首节点，这样只要 hash 不冲突，就不会产生并发，效率又提升 N 倍。</p>\n<p>​<img src=\"/assets/net-img-1591690708309-b6db1e95-1bbf-4140-b612-26fefc8d85b5-20221030132327-6s3ed7l.png\" alt=\"\">​</p>\n<h2 id=\"HashMap-和-HashSet-区别\">HashMap 和 HashSet 区别</h2>\n<p><strong>HashSet 底层就是基于 HashMap 实现的</strong></p>\n<table>\n<thead>\n<tr>\n<th>HashMap</th>\n<th>HashSet</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>实现了 Map 接口</td>\n<td>实现 Set 接口</td>\n</tr>\n<tr>\n<td>存储键值对</td>\n<td>仅存储对象</td>\n</tr>\n<tr>\n<td>调用 put()向 map 中添加元素</td>\n<td>调用 add()方法向 Set 中添加元素</td>\n</tr>\n<tr>\n<td>HashMap 使用键（Key）计算 Hashcode</td>\n<td>HashSet 使用成员对象来计算 hashcode 值，对于两个对象来说 hashcode 可能相</td>\n</tr>\n</tbody>\n</table>\n","excerpt":"","more":"<h1>Collection</h1>\n<h1>Collection</h1>\n<p>​<img src=\"/assets/net-img-1596005642573-853dc49e-7632-496d-9221-33e3b7879fea-20221030132325-84wdxkw.jpeg\" alt=\"\">​</p>\n<p>​<img src=\"/assets/net-img-1591690708492-8b43720d-e8dc-4e22-9057-dcc4be2210de-20221030132325-ac88yvu.jpeg\" alt=\"\">​</p>\n<ul>\n<li>Collection 接口的接口 对象的集合\n<ul>\n<li>List 子接口 按进入先后有序保存 可重复\n<ul>\n<li>LinkedList(双向链表) 接口实现类 链表 插入删除 没有同步 线程不安全</li>\n<li>ArrayList(Object 数组) 接口实现类 数组 随机访问 没有同步 线程不安全</li>\n<li>Vector(Object 数组) 接口实现类 数组 同步 线程安全</li>\n</ul>\n</li>\n<li>Set 子接口 不可重复\n<ul>\n<li>HashSet(无序，唯一)</li>\n<li>LinkedHashSet(有序，唯一)<br>\n线程不安全</li>\n<li>TreeSet(有序，唯一)</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Map 接口 键值对的集合\n<ul>\n<li>Hashtable(链表+数组) 接口实现类 同步 线程安全</li>\n<li>HashMap(1.8 之前数组+链表，1.8 之后达到一定长度会转化为红黑树) 接口实现类 没有同步 线程不安全\n<ul>\n<li>LinkedHashMap(在 HashMap 基础上添加一条双向链表)</li>\n</ul>\n</li>\n<li>TreeMap(红黑树(自平衡排序二叉树))</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Iterable\">Iterable</h2>\n<p><strong>Iterator 也是一个接口，它只有三个方法：</strong></p>\n<ul>\n<li>hasNext()</li>\n<li>next()</li>\n<li>remove()</li>\n</ul>\n<h2 id=\"ArrayList-与-LinkedList-区别\">ArrayList 与 LinkedList 区别</h2>\n<ul>\n<li>都不保证线程安全</li>\n<li>ArrayList 底层是数组，LinkedList 底层使用双向链表（1.6 之前为循环链表，1.7 之后取消循环）</li>\n<li>ArrayList 采用数组存储，删除和插入的时间复杂度会受元素位置影响。LinkedList 采用链式存储，对于插入删除不受元素位置影响</li>\n<li>LinkedList 不支持随机访问，ArrayList 支持元素序号访问</li>\n<li>ArrayList 会在列表结尾预留一定空余空间，LinkedList 每个节点所消耗的空间比 ArrayList 大</li>\n</ul>\n<h2 id=\"HashMap-和-Hashtable-区别\">HashMap 和 Hashtable 区别</h2>\n<ul>\n<li>HashMap 是非线程安全的，HashTable 是线程安全的 (如果你要保证线程安全的话就使用 ConcurrentHashMap 吧,效率比 hashtable 高)；</li>\n<li>HashMap 中，null 可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为 null。。但是在 HashTable 中 put 进的键值只要有一个 null，直接抛出 NullPointerException。</li>\n<li>初始化\n<ul>\n<li>① 创建时如果不指定容量初始值： Hashtable 默认的<strong>初始大小为 11</strong>，之后每次扩充，容量变为原来的 2n+1。HashMap 默认的<strong>初始化大小为 16</strong>。之后每次扩充，容量变为原来的 2 倍。</li>\n<li>② 创建时如果给定了容量初始值：Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为 2 的幂次方大小</li>\n</ul>\n</li>\n<li>JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（<strong>将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树</strong>）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。</li>\n</ul>\n<h2 id=\"ConcurrentHashMap-和-Hashtable-的区别\">ConcurrentHashMap 和 Hashtable 的区别</h2>\n<p>ConcurrentHashMap 和 Hashtable 的区别主要体现在实现线程安全的方式上不同。</p>\n<ul>\n<li>底层数据结构： JDK1.7 的 ConcurrentHashMap 底层采用 <strong>分段的数组+链表</strong> 实现，JDK1.8 采用的数据结构跟 HashMap1.8 的结构一样，<strong>数组+链表/红黑二叉树</strong>。Hashtable 和 JDK1.8 之前的 HashMap 的底层数据结构类似都是采用 <strong>数组+链表</strong> 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；</li>\n<li>实现线程安全的方式（重要）：\n<ul>\n<li>① 在 JDK1.7 的时候，ConcurrentHashMap（分段锁） 对整个桶数组进行了分割分段(Segment)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。 到了 JDK1.8 的时候已经摒弃了 Segment 的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作。（JDK1.6 以后 对 synchronized 锁做了很多优化） 整个看起来就像是优化过且线程安全的 HashMap，虽然在 JDK1.8 中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本；</li>\n<li>② Hashtable(同一把锁) :使用 synchronized 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"HashTable：全表锁\">HashTable：全表锁</h2>\n<p><img src=\"/assets/net-img-1591690708909-03b304db-aa14-40fc-954b-2e5812e31b86-20221030132326-7iwfv9t.png\" alt=\"\"></p>\n<h2 id=\"JDK7-的-ConcurrentHashMap：\">JDK7 的 ConcurrentHashMap：</h2>\n<p>首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。</p>\n<p>一个 <code>ConcurrentHashMap</code> 里包含一个 <code>Segment(片段)</code> 数组。<code>Segment</code> 的结构和 <code>HashMap</code> 类似，是一种数组和链表结构，一个 <code>Segment</code> 包含一个 <code>HashEntry</code> 数组，每个 <code>HashEntry</code> 是一个链表结构的元素，每个 <code>Segment</code> 守护着一个 <code>HashEntry</code> 数组里的元素，当对 <code>HashEntry</code> 数组的数据进行修改时，必须首先获得对应的 <code>Segment</code> 的锁。</p>\n<p><img src=\"/assets/net-img-1591690708399-bf1076aa-bdad-4e5f-ae30-261ccda91da5-20221030132327-4fweook.png\" alt=\"\"><a href=\"https://imgchr.com/i/t2J5Kx\">https://imgchr.com/i/t2J5Kx</a></p>\n<h2 id=\"JDK1-8-的-ConcurrentHashMap（TreeBin-红黑二叉树节点-Node-链表节点）\">JDK1.8 的 ConcurrentHashMap（TreeBin: 红黑二叉树节点 Node: 链表节点）`</h2>\n<p>​<strong>​<code>1.8之前ConcurrentHashMap将hashmap数组分段，对于每个段加锁。而在1.8后几乎与hashmap类似，只是更改了put操作，在计算hash值和索引位置后会先判断数组是否正在扩容。若正在扩容则调用扩容辅助函数。没有则在判断是否为空，为空则采用csa方法放入数组，若不为空则使用synchronized锁住该节点，根据链表或红黑树选择插入方法。最后判断长度，为8则开始转换红黑树。</code>​</strong> ​ <code>synchronized </code>​只锁定当前链表或红黑二叉树的首节点，这样只要 hash 不冲突，就不会产生并发，效率又提升 N 倍。</p>\n<p>​<img src=\"/assets/net-img-1591690708309-b6db1e95-1bbf-4140-b612-26fefc8d85b5-20221030132327-6s3ed7l.png\" alt=\"\">​</p>\n<h2 id=\"HashMap-和-HashSet-区别\">HashMap 和 HashSet 区别</h2>\n<p><strong>HashSet 底层就是基于 HashMap 实现的</strong></p>\n<table>\n<thead>\n<tr>\n<th>HashMap</th>\n<th>HashSet</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>实现了 Map 接口</td>\n<td>实现 Set 接口</td>\n</tr>\n<tr>\n<td>存储键值对</td>\n<td>仅存储对象</td>\n</tr>\n<tr>\n<td>调用 put()向 map 中添加元素</td>\n<td>调用 add()方法向 Set 中添加元素</td>\n</tr>\n<tr>\n<td>HashMap 使用键（Key）计算 Hashcode</td>\n<td>HashSet 使用成员对象来计算 hashcode 值，对于两个对象来说 hashcode 可能相</td>\n</tr>\n</tbody>\n</table>\n"},{"title":"JVM","date":"2022-10-30T05:39:04.000Z","lastmod":"2023-11-26T06:54:43.000Z","_content":"\n# JVM\n\n## GC评估标准\n\n### 吞吐量\n\n> CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量 = 运行用户代码时间 /（运行用户代码时间 + 垃圾收集时间）。\n\n* 吞吐量就是比如：虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。\n\n* 这种情况下，应用程序能容忍较高的暂停时间。因此，高吞吐量的应用程序有更长的时间基准，快速响应是不必考虑的。\n\n* 吞吐量优先，意味着在单位时间内，STW的时间最短：0.2 + 0.2 = 0.4\n\n### 暂停时间\n\n> 指一个时间段内应用程序线程暂停，让GC线程执行的状态\n\n* GC期间100毫秒的暂停时间意味着在这100毫秒期间内没有应用程序线程是活动的。\n\n* 暂停时间优先，意味着尽可能让单次STW的时间最短\n\n## 为何永久代被元空间替代\n\n- 永久代有固定上限，无法进行调整，而元空间直接使用内存，受本机可用内存限制。\n- 元空间里存放的是类的元数据，加载多少类的元数据由系统的实际可用空间来控制，可以加载更多的类\n- JDK8 合并 HotSpot 和 JRockit 代码时，jrockit 不存在永久代，所以合并后没必要设置一个永生代位置\n\n## 双亲委托优点和缺点\n\n　　优点：\n\n* 避免类重复加载，确保全局唯一\n* 保护程序，防止核心api被修改\n\n　　缺点：\n\n* 检查类是否加载的委托过程是单向的，顶层的ClassLoader无法访问底层的ClassLoader所加载的类。\n\n## 双亲委派机制的破坏\n\n### 线程上下文类加载器\n\n> 通过java.lang.Thread类的setContextClassLoader()方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。\n\n​![image](/assets/image-20231117164621-qjdsktw.png)​\n\n### 热部署（热替换）\n\n> 服务不能中断，修改必须立即表现正在运行的系统之中\n\n## 类、类的加载器、类的实例之间的引用关系\n\n　　在类加载器的内部实现中，用一个Java集合来存放所加载类的引用。另一方面，一个Class对象总是会引用它的类加载器，调用Class对象的getClassLoader()方法，就能获得它的类加载器。由此可见，代表某个类的Class实例与其类的加载器之间为双向关联关系。\n\n　　一个类的实例总是引用代表这个类的Class对象。在Object类中定义了getClass()方法，这个方法返回代表对象所属类的Class对象的引用。此外，所有的Java类都有一个静态属性class，它引用代表这个类的Class对象。\n\n​![图像](/assets/image-20231119124615-vxa33dm.png)​\n\n## to区域被填满了，to区中的有的对象年龄还没被复制15次，也会被移动到年老代中吗？\n\n　　Minor GC会一直重复`from to`​的过程,直到“To”区被填满,“To”区被填满之后,会将所有对象移动到年老代中。默认情况下,如果对象年龄达到15岁,就会移动到老年代中。\n","source":"_posts/java/JVM.md","raw":"---\ntitle: JVM\ndate: 2022-10-30T13:39:04Z\nlastmod: 2023-11-26T14:54:43Z\n---\n\n# JVM\n\n## GC评估标准\n\n### 吞吐量\n\n> CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量 = 运行用户代码时间 /（运行用户代码时间 + 垃圾收集时间）。\n\n* 吞吐量就是比如：虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。\n\n* 这种情况下，应用程序能容忍较高的暂停时间。因此，高吞吐量的应用程序有更长的时间基准，快速响应是不必考虑的。\n\n* 吞吐量优先，意味着在单位时间内，STW的时间最短：0.2 + 0.2 = 0.4\n\n### 暂停时间\n\n> 指一个时间段内应用程序线程暂停，让GC线程执行的状态\n\n* GC期间100毫秒的暂停时间意味着在这100毫秒期间内没有应用程序线程是活动的。\n\n* 暂停时间优先，意味着尽可能让单次STW的时间最短\n\n## 为何永久代被元空间替代\n\n- 永久代有固定上限，无法进行调整，而元空间直接使用内存，受本机可用内存限制。\n- 元空间里存放的是类的元数据，加载多少类的元数据由系统的实际可用空间来控制，可以加载更多的类\n- JDK8 合并 HotSpot 和 JRockit 代码时，jrockit 不存在永久代，所以合并后没必要设置一个永生代位置\n\n## 双亲委托优点和缺点\n\n　　优点：\n\n* 避免类重复加载，确保全局唯一\n* 保护程序，防止核心api被修改\n\n　　缺点：\n\n* 检查类是否加载的委托过程是单向的，顶层的ClassLoader无法访问底层的ClassLoader所加载的类。\n\n## 双亲委派机制的破坏\n\n### 线程上下文类加载器\n\n> 通过java.lang.Thread类的setContextClassLoader()方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。\n\n​![image](/assets/image-20231117164621-qjdsktw.png)​\n\n### 热部署（热替换）\n\n> 服务不能中断，修改必须立即表现正在运行的系统之中\n\n## 类、类的加载器、类的实例之间的引用关系\n\n　　在类加载器的内部实现中，用一个Java集合来存放所加载类的引用。另一方面，一个Class对象总是会引用它的类加载器，调用Class对象的getClassLoader()方法，就能获得它的类加载器。由此可见，代表某个类的Class实例与其类的加载器之间为双向关联关系。\n\n　　一个类的实例总是引用代表这个类的Class对象。在Object类中定义了getClass()方法，这个方法返回代表对象所属类的Class对象的引用。此外，所有的Java类都有一个静态属性class，它引用代表这个类的Class对象。\n\n​![图像](/assets/image-20231119124615-vxa33dm.png)​\n\n## to区域被填满了，to区中的有的对象年龄还没被复制15次，也会被移动到年老代中吗？\n\n　　Minor GC会一直重复`from to`​的过程,直到“To”区被填满,“To”区被填满之后,会将所有对象移动到年老代中。默认情况下,如果对象年龄达到15岁,就会移动到老年代中。\n","slug":"java-JVM","published":1,"updated":"2025-04-28T08:41:48.389Z","_id":"cm9s3f3yv0006bfg45rn42dzz","comments":1,"layout":"post","photos":[],"content":"<h1>JVM</h1>\n<h2 id=\"GC评估标准\">GC评估标准</h2>\n<h3 id=\"吞吐量\">吞吐量</h3>\n<blockquote>\n<p>CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量 = 运行用户代码时间 /（运行用户代码时间 + 垃圾收集时间）。</p>\n</blockquote>\n<ul>\n<li>\n<p>吞吐量就是比如：虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。</p>\n</li>\n<li>\n<p>这种情况下，应用程序能容忍较高的暂停时间。因此，高吞吐量的应用程序有更长的时间基准，快速响应是不必考虑的。</p>\n</li>\n<li>\n<p>吞吐量优先，意味着在单位时间内，STW的时间最短：0.2 + 0.2 = 0.4</p>\n</li>\n</ul>\n<h3 id=\"暂停时间\">暂停时间</h3>\n<blockquote>\n<p>指一个时间段内应用程序线程暂停，让GC线程执行的状态</p>\n</blockquote>\n<ul>\n<li>\n<p>GC期间100毫秒的暂停时间意味着在这100毫秒期间内没有应用程序线程是活动的。</p>\n</li>\n<li>\n<p>暂停时间优先，意味着尽可能让单次STW的时间最短</p>\n</li>\n</ul>\n<h2 id=\"为何永久代被元空间替代\">为何永久代被元空间替代</h2>\n<ul>\n<li>永久代有固定上限，无法进行调整，而元空间直接使用内存，受本机可用内存限制。</li>\n<li>元空间里存放的是类的元数据，加载多少类的元数据由系统的实际可用空间来控制，可以加载更多的类</li>\n<li>JDK8 合并 HotSpot 和 JRockit 代码时，jrockit 不存在永久代，所以合并后没必要设置一个永生代位置</li>\n</ul>\n<h2 id=\"双亲委托优点和缺点\">双亲委托优点和缺点</h2>\n<p>优点：</p>\n<ul>\n<li>避免类重复加载，确保全局唯一</li>\n<li>保护程序，防止核心api被修改</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>检查类是否加载的委托过程是单向的，顶层的ClassLoader无法访问底层的ClassLoader所加载的类。</li>\n</ul>\n<h2 id=\"双亲委派机制的破坏\">双亲委派机制的破坏</h2>\n<h3 id=\"线程上下文类加载器\">线程上下文类加载器</h3>\n<blockquote>\n<p>通过java.lang.Thread类的setContextClassLoader()方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。</p>\n</blockquote>\n<p>​<img src=\"/assets/image-20231117164621-qjdsktw.png\" alt=\"image\">​</p>\n<h3 id=\"热部署（热替换）\">热部署（热替换）</h3>\n<blockquote>\n<p>服务不能中断，修改必须立即表现正在运行的系统之中</p>\n</blockquote>\n<h2 id=\"类、类的加载器、类的实例之间的引用关系\">类、类的加载器、类的实例之间的引用关系</h2>\n<p>在类加载器的内部实现中，用一个Java集合来存放所加载类的引用。另一方面，一个Class对象总是会引用它的类加载器，调用Class对象的getClassLoader()方法，就能获得它的类加载器。由此可见，代表某个类的Class实例与其类的加载器之间为双向关联关系。</p>\n<p>一个类的实例总是引用代表这个类的Class对象。在Object类中定义了getClass()方法，这个方法返回代表对象所属类的Class对象的引用。此外，所有的Java类都有一个静态属性class，它引用代表这个类的Class对象。</p>\n<p>​<img src=\"/assets/image-20231119124615-vxa33dm.png\" alt=\"图像\">​</p>\n<h2 id=\"to区域被填满了，to区中的有的对象年龄还没被复制15次，也会被移动到年老代中吗？\">to区域被填满了，to区中的有的对象年龄还没被复制15次，也会被移动到年老代中吗？</h2>\n<p>Minor GC会一直重复<code>from to</code>​的过程,直到“To”区被填满,“To”区被填满之后,会将所有对象移动到年老代中。默认情况下,如果对象年龄达到15岁,就会移动到老年代中。</p>\n","excerpt":"","more":"<h1>JVM</h1>\n<h2 id=\"GC评估标准\">GC评估标准</h2>\n<h3 id=\"吞吐量\">吞吐量</h3>\n<blockquote>\n<p>CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量 = 运行用户代码时间 /（运行用户代码时间 + 垃圾收集时间）。</p>\n</blockquote>\n<ul>\n<li>\n<p>吞吐量就是比如：虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。</p>\n</li>\n<li>\n<p>这种情况下，应用程序能容忍较高的暂停时间。因此，高吞吐量的应用程序有更长的时间基准，快速响应是不必考虑的。</p>\n</li>\n<li>\n<p>吞吐量优先，意味着在单位时间内，STW的时间最短：0.2 + 0.2 = 0.4</p>\n</li>\n</ul>\n<h3 id=\"暂停时间\">暂停时间</h3>\n<blockquote>\n<p>指一个时间段内应用程序线程暂停，让GC线程执行的状态</p>\n</blockquote>\n<ul>\n<li>\n<p>GC期间100毫秒的暂停时间意味着在这100毫秒期间内没有应用程序线程是活动的。</p>\n</li>\n<li>\n<p>暂停时间优先，意味着尽可能让单次STW的时间最短</p>\n</li>\n</ul>\n<h2 id=\"为何永久代被元空间替代\">为何永久代被元空间替代</h2>\n<ul>\n<li>永久代有固定上限，无法进行调整，而元空间直接使用内存，受本机可用内存限制。</li>\n<li>元空间里存放的是类的元数据，加载多少类的元数据由系统的实际可用空间来控制，可以加载更多的类</li>\n<li>JDK8 合并 HotSpot 和 JRockit 代码时，jrockit 不存在永久代，所以合并后没必要设置一个永生代位置</li>\n</ul>\n<h2 id=\"双亲委托优点和缺点\">双亲委托优点和缺点</h2>\n<p>优点：</p>\n<ul>\n<li>避免类重复加载，确保全局唯一</li>\n<li>保护程序，防止核心api被修改</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>检查类是否加载的委托过程是单向的，顶层的ClassLoader无法访问底层的ClassLoader所加载的类。</li>\n</ul>\n<h2 id=\"双亲委派机制的破坏\">双亲委派机制的破坏</h2>\n<h3 id=\"线程上下文类加载器\">线程上下文类加载器</h3>\n<blockquote>\n<p>通过java.lang.Thread类的setContextClassLoader()方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。</p>\n</blockquote>\n<p>​<img src=\"/assets/image-20231117164621-qjdsktw.png\" alt=\"image\">​</p>\n<h3 id=\"热部署（热替换）\">热部署（热替换）</h3>\n<blockquote>\n<p>服务不能中断，修改必须立即表现正在运行的系统之中</p>\n</blockquote>\n<h2 id=\"类、类的加载器、类的实例之间的引用关系\">类、类的加载器、类的实例之间的引用关系</h2>\n<p>在类加载器的内部实现中，用一个Java集合来存放所加载类的引用。另一方面，一个Class对象总是会引用它的类加载器，调用Class对象的getClassLoader()方法，就能获得它的类加载器。由此可见，代表某个类的Class实例与其类的加载器之间为双向关联关系。</p>\n<p>一个类的实例总是引用代表这个类的Class对象。在Object类中定义了getClass()方法，这个方法返回代表对象所属类的Class对象的引用。此外，所有的Java类都有一个静态属性class，它引用代表这个类的Class对象。</p>\n<p>​<img src=\"/assets/image-20231119124615-vxa33dm.png\" alt=\"图像\">​</p>\n<h2 id=\"to区域被填满了，to区中的有的对象年龄还没被复制15次，也会被移动到年老代中吗？\">to区域被填满了，to区中的有的对象年龄还没被复制15次，也会被移动到年老代中吗？</h2>\n<p>Minor GC会一直重复<code>from to</code>​的过程,直到“To”区被填满,“To”区被填满之后,会将所有对象移动到年老代中。默认情况下,如果对象年龄达到15岁,就会移动到老年代中。</p>\n"},{"title":"JavaWeb","date":"2022-10-30T05:27:30.000Z","lastmod":"2022-10-30T05:27:36.000Z","_content":"\n# JavaWeb\n\n　　‍\n\n　　‍\n","source":"_posts/java/JavaWeb.md","raw":"---\ntitle: JavaWeb\ndate: 2022-10-30T13:27:30Z\nlastmod: 2022-10-30T13:27:36Z\n---\n\n# JavaWeb\n\n　　‍\n\n　　‍\n","slug":"java-JavaWeb","published":1,"updated":"2025-04-20T00:08:55.553Z","_id":"cm9s3f3yx0007bfg47uroaeyi","comments":1,"layout":"post","photos":[],"content":"<h1>JavaWeb</h1>\n<p>‍</p>\n<p>‍</p>\n","excerpt":"","more":"<h1>JavaWeb</h1>\n<p>‍</p>\n<p>‍</p>\n"},{"title":"thread","date":"2023-05-14T14:53:28.000Z","lastmod":"2023-08-25T08:32:48.000Z","_content":"\n# thread\n\n## 概述\n\n### 并发与并行\n\n　　并行：指两个或多个事件在同一时刻发生（同时发生）。  \n并发：指两个或多个事件在同一个时间段内发生。  \n​![1-1.png](/assets/net-img-1582875290415-c052f229-8c31-4560-acef-300acae2409b-20221030135515-tme9bzx.png)​\n\n### 进程、线程\n\n> 进程是正在运行的程序的实例。  \n> 进程是线程的容器，即一个进程中可以开启多个线程。\n\n> 线程是进程内部的一个独立执行单元；  \n> 一个进程可以同时并发运行多个线程；\n\n## 线程生命周期\n\n　　​![](/assets/net-img-1596249786159-92610d33-5cbb-4d46-b7a5-6f1c8d3d1d92-20221030135516-9i6hh1r.jpeg)  1. 新建\n\n* new 关键字创建了一个线程之后，该线程就处于新建状态\n* JVM 为线程分配内存，初始化成员变量值\n\n2. 就绪\n\n    * 当线程对象调用了 start()方法之后，该线程处于就绪状态\n    * JVM 为线程创建方法栈和程序计数器，等待线程调度器调度\n3. 运行\n\n    * 就绪状态的线程获得 CPU 资源，开始运行 run()方法，该线程进入运行状态\n4. 阻塞\n\n    * 线程在等待进入临界区\n5. 无限期等待\n\n    * 处于这种状态的线程不会被分配CPU执行时间，它们要等待被显式地唤醒，否则会处于无限期等待的状态。\n6. 限期等待\n\n    * 处于这种状态的线程不会被分配CPU执行时间，不过无须无限期等待被其他线程显示地唤醒，在达到一定时间后它们会自动唤醒。\n7. 死亡\n\n    * 线程会以如下 3 种方式结束，结束后就处于死亡状态：\n    * run()或 call()方法执行完成，线程正常结束。\n    * 线程抛出一个未捕获的 Exception 或 Error。>调用该线程 stop()方法来结束该线程，该方法容易导致死锁，不推荐使用。\n\n## 死锁\n\n　　多个线程因竞争资源而造成的一种僵局(互相等待)\n\n### 死锁产生必要条件\n\n1. 互斥条件  \n    在一段时间内某资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待\n2. 不可剥夺条件  \n    进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放（只能是主动释放)。\n3. 请求与保持  \n    进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。\n4. 循环等待条件  \n    存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被 链中下一个进程所请求。即存在一个处于等待状态的进程集合{Pl, P2, …, pn}，其中 Pi 等 待的资源被 P(i+1)占有（i=0, 1, …, n-1)，Pn 等待的资源被 P0 占有，如图所示\n\n​![1-5.png](/assets/net-img-1582875326094-cb5a96e7-e4c2-421d-83cf-216ca4f7f024-20221030135516-5igfhr6.png)![1-4.png](/assets/net-img-1582875326657-55738037-28bf-4de9-925a-f08034e0c722-20221030135516-j4ktjne.png)​\n\n### 死锁处理\n\n### 死锁预防\n\n1. 破坏“互斥”条件  \n    ​`互斥`​条件是无法破坏的。因此，在死锁预防里主要是破坏其他几个必要条件，而不去涉及破坏`互斥`​条件。\n2. 破坏“占有并等待”条件  \n    系统中不允许进程在已获得某种资源的情况下，申请其他资源。即要想出一个办法，阻止进程在持有资源的同时申请其他资源\n\n    * 方法一：一次性分配资源，即创建进程时，要求它申请所需的全部资源，系统或满足其所有要求，或什么也不给它。\n    * 方法二：要求每个进程提出新的资源申请前，释放它所占有的资源。这样，一个进程在需要资源 S 时，须先把它先前占有的资源 R 释放掉，然后才能提出对 S 的申请，即使它可能很快又要用到资源 R。\n3. 破坏“不可抢占”条件  \n    破坏“不可抢占”条件就是允许对资源实行抢夺。\n\n    * 方法一：如果占有某些资源的一个进程进行进一步资源请求被拒绝，则该进程必须释放它最初占有的资源，如果有必要，可再次请求这些资源和另外的资源。\n    * 方法二：如果一个进程请求当前被另一个进程占有的一个资源，则操作系统可以抢占另一个进程，要求它释放资源。只有在任意两个进程的优先级都不相同的条件下，方法二才能预防死锁。\n4. 破坏“循环等待”条件  \n    破坏“循环等待”条件的一种方法，是将系统中的所有资源统一编号，进程可在任何时刻提出资源申请，但所有申请必须按照资源的编号顺序（升序）提出。这样做就能保证系统不出现死锁。\n\n### 死锁避免\n\n1. 有序资源分配法  \n    算法\n\n```\n必须为所有资源统一编号，\n同类资源必须一次申请完，\n不同类资源必须按顺序申请\n```\n\n2. 银行家算法  \n    银行家算法的基本思想是分配资源之前，判断系统是否是安全的；若是，才分配。它是最具有代表性的避免死锁的算法。  \n    设进程 i 提出请求 REQUEST [i]，则银行家算法按如下规则进行判断。![1-6.png](/assets/net-img-1582875381841-0104c814-acd3-4ef3-a3bd-f5331d9a06bc-20221030135516-0716ftg.png)​\n\n```\n1. 如果REQUEST [i]<= NEED[i，j]，则转（2)；否则，出错。\n2 .如果REQUEST [i]<= AVAILABLE[i]，则转（3)；否则，等待。\n3 .系统试探分配资源，修改相关数据：\n   AVAILABLE[i]-=REQUEST[i];//可用资源数-请求资源数\n   ALLOCATION[i]+=REQUEST[i];//已分配资源数+请求资源数\n   NEED[i]-=REQUEST[i];//需要资源数-请求资源数\n系统执行安全性检查，如安全，则分配成立；否则试探险性分配作废，系统恢复原状，进程等待\n```\n\n3. 顺序加锁  \n    如果能确保所有的线程都是按照相同的顺序获得锁，那么死锁就不会发生,但是，这种方式需要事先知道所有可能会用到的锁，但总有些时候是无法预知的，所以该种方式只适合特定场景\n4. 限时加锁  \n    限时加锁是线程在尝试获取锁的时候加一个超时时间，若超过这个时间则放弃对该锁请求，并回退并释放所有已经获得的锁，然后等待一段随机的时间再重试  \n    这种方式有两个缺点：\n\n```\n1) 当线程数量少时，该种方式可避免死锁，但当线程数量过多，这些线程的加锁时限相同的概率就高很多，可能会导致超时后重试的死循环。\n2) Java中不能对synchronized同步块设置超时时间。你需要创建一个自定义锁，或使用Java5中java.util.concurrent包下的工具\n```\n\n### 死锁检测\n\n　　**死锁检测算法**  \n​![1-7.png](/assets/net-img-1582875390665-923c52b9-52ce-4e6f-9cee-763046546af3-20221030135517-j4zeqi7.png)​\n\n```\nE 是现有资源向量（existing resource vector），代码每种已存在资源的总数\nA 是可用资源向量（available resource vector），那么Ai表示当前可供使用的资源数（即没有被分配的资源）\nC 是当前分配矩阵（current allocation matrix），C的第i行代表Pi当前所持有的每一种类型资源的资源数\nR 是请求矩阵（request matrix），R的每一行代表P所需要的资源的数量\n```\n\n　　**死锁检测步骤：**\n\n```\n寻找一个没有结束标记的进程Pi，对于它而言R矩阵的第i行向量小于或等于A。\n如果找到了这样一个进程，执行该进程，然后将C矩阵的第i行向量加到A中，标记该进程，并转到第1步\n如果没有这样的进程，那么算法终止\n算法结束时，所有没有标记过的进程都是死锁进程\n```\n\n### 死锁恢复\n\n* 资源剥夺法  \n  剥夺陷于死锁的进程所占用的资源，但并不撤销此进程，直至死锁解除。\n* 进程回退法  \n  根据系统保存的检查点让所有的进程回退，直到足以解除死锁，这种措施要求系统建立保存检查点、回退及重启机制。\n* 进程撤销法\n\n  * 撤销陷入死锁的所有进程，解除死锁，继续运行。\n  * 逐个撤销陷入死锁的进程，回收其资源并重新分配，直至死锁解除。\n\n## Java创建线程\n\n* 继承 Thread 类 extends Thread\n* 实现 Runnable 接口 implements Runnable\n* 实现 Callable 接口 implements Callable\n\n  * 实现 Callable 接口。 相较于实现 Runnable 接口的方式，方法可以有返回值，并且可以抛出异常。\n  * 执行 Callable 方式，需要 FutureTask 实现类的支持，用于接收运算结果。 FutureTask 是 Future 接口的实现类，线程启动 `new Thread(objectFutureTask1).start()`​\n\n> Future\n\n* cancel()方法用来取消任务，如果取消任务成功则返回true，如果取消任务失败则返回false。\n\n  * 参数mayInterruptIfRunning表示是否允许取消正在执行却没有执行完毕的任务，如果设置true，则表示可以取消正在执行过程中的任务。\n  * 如果任务已经完成，则无论mayInterruptIfRunning为true还是false，此方法肯定返回false，即如果取消已经完成的任务会返回false\n  * 如果任务正在执行，若mayInterruptIfRunning设置为true，则返回true，若mayInterruptIfRunning设置为false，则返回false；如果任务还没有执行，则无论mayInterruptIfRunning为true还是false，肯定返回true。\n* isCancelled()方法表示任务是否被取消成功，如果在任务正常完成前被取消成功，则返回 true。\n* isDone()方法表示任务是否已经完成，若任务完成，则返回true；\n* get()方法用来获取执行结果，这个方法会产生阻塞，会一直等到任务执行完毕才返回；\n* get(long timeout, TimeUnit unit)用来获取执行结果，如果在指定时间内，还没获取到结果，就直接返回null。\n\n> FutureTask\n>\n> 实现了RunnableFuture接口，而RunnableFuture接口继承了Runnable与Future接口，所以它既可以作为Runnable被线程中执行，又可以作为callable获得返回值。\n\n* 适合应用场景\n\n  * 执行多任务计算\n  * 在高并发环境下确保任务只执行一次\n\n### 小结\n\n* 实现接口和继承 Thread 类比较\n\n> 接口更适合多个相同的程序代码的线程去共享同一个资源。  \n> 接口可以避免 java 中的单继承的局限性。  \n> 接口代码可以被多个线程共享，代码和线程独立。  \n> 线程池只能放入实现 Runable 或 Callable 接口的线程，不能直接放入继承 Thread 的类。  \n> 扩充：在 java 中，每次程序运行至少启动 2 个线程。一个是 main 线程，一个是垃圾收集线程。\n\n* Runnable 和 Callable 接口比较\n\n  * 相同点：\n\n> 两者都是接口；  \n> 两者都可用来编写多线程程序；  \n> 两者都需要调用 Thread.start()启动线程；\n\n* 不同点：\n\n> 实现 Callable 接口的线程能返回执行结果；而实现 Runnable 接口的线程不能返回结果；  \n> Callable 接口的 call()方法允许抛出异常；而 Runnable 接口的 run()方法的不允许抛异常；  \n> 实现 Callable 接口的线程可以调用 Future.cancel 取消执行  ，而实现 Runnable 接口的线程不能\n\n* 注意点：\n\n> Callable 接口支持返回执行结果，此时需要调用 FutureTask.get()方法实现，此方法会阻塞主线程直到获取‘将来’结果；当不调用此方法时，主线程不会阻塞！\n>\n> 实现Runnable接口,在某些情况下可以提高性能，使用继承 Thread 类方式，每次执行一次任务，都需要新建一个独立的线程，执行完任务后线程走到生命周期的尽头被销毁，如果还想执行这个任务，就必须再新建一个继承了 Thread 类的类，如果此时执行的内容比较少，比如只是在 run() 方法里简单打印一行文字，那么它所带来的开销并不大，相比于整个线程从开始创建到执行完毕被销毁，这一系列的操作比 run() 方法打印文字本身带来的开销要大得多，相当于捡了芝麻丢了西瓜，得不偿失。如果我们使用实现 Runnable 接口的方式，就可以把任务直接传入线程池，使用一些固定的线程来完成任务，不需要每次新建销毁线程，大大降低了性能开销。\n","source":"_posts/java/thread.md","raw":"---\ntitle: thread\ndate: 2023-05-14T22:53:28Z\nlastmod: 2023-08-25T16:32:48Z\n---\n\n# thread\n\n## 概述\n\n### 并发与并行\n\n　　并行：指两个或多个事件在同一时刻发生（同时发生）。  \n并发：指两个或多个事件在同一个时间段内发生。  \n​![1-1.png](/assets/net-img-1582875290415-c052f229-8c31-4560-acef-300acae2409b-20221030135515-tme9bzx.png)​\n\n### 进程、线程\n\n> 进程是正在运行的程序的实例。  \n> 进程是线程的容器，即一个进程中可以开启多个线程。\n\n> 线程是进程内部的一个独立执行单元；  \n> 一个进程可以同时并发运行多个线程；\n\n## 线程生命周期\n\n　　​![](/assets/net-img-1596249786159-92610d33-5cbb-4d46-b7a5-6f1c8d3d1d92-20221030135516-9i6hh1r.jpeg)  1. 新建\n\n* new 关键字创建了一个线程之后，该线程就处于新建状态\n* JVM 为线程分配内存，初始化成员变量值\n\n2. 就绪\n\n    * 当线程对象调用了 start()方法之后，该线程处于就绪状态\n    * JVM 为线程创建方法栈和程序计数器，等待线程调度器调度\n3. 运行\n\n    * 就绪状态的线程获得 CPU 资源，开始运行 run()方法，该线程进入运行状态\n4. 阻塞\n\n    * 线程在等待进入临界区\n5. 无限期等待\n\n    * 处于这种状态的线程不会被分配CPU执行时间，它们要等待被显式地唤醒，否则会处于无限期等待的状态。\n6. 限期等待\n\n    * 处于这种状态的线程不会被分配CPU执行时间，不过无须无限期等待被其他线程显示地唤醒，在达到一定时间后它们会自动唤醒。\n7. 死亡\n\n    * 线程会以如下 3 种方式结束，结束后就处于死亡状态：\n    * run()或 call()方法执行完成，线程正常结束。\n    * 线程抛出一个未捕获的 Exception 或 Error。>调用该线程 stop()方法来结束该线程，该方法容易导致死锁，不推荐使用。\n\n## 死锁\n\n　　多个线程因竞争资源而造成的一种僵局(互相等待)\n\n### 死锁产生必要条件\n\n1. 互斥条件  \n    在一段时间内某资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待\n2. 不可剥夺条件  \n    进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放（只能是主动释放)。\n3. 请求与保持  \n    进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。\n4. 循环等待条件  \n    存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被 链中下一个进程所请求。即存在一个处于等待状态的进程集合{Pl, P2, …, pn}，其中 Pi 等 待的资源被 P(i+1)占有（i=0, 1, …, n-1)，Pn 等待的资源被 P0 占有，如图所示\n\n​![1-5.png](/assets/net-img-1582875326094-cb5a96e7-e4c2-421d-83cf-216ca4f7f024-20221030135516-5igfhr6.png)![1-4.png](/assets/net-img-1582875326657-55738037-28bf-4de9-925a-f08034e0c722-20221030135516-j4ktjne.png)​\n\n### 死锁处理\n\n### 死锁预防\n\n1. 破坏“互斥”条件  \n    ​`互斥`​条件是无法破坏的。因此，在死锁预防里主要是破坏其他几个必要条件，而不去涉及破坏`互斥`​条件。\n2. 破坏“占有并等待”条件  \n    系统中不允许进程在已获得某种资源的情况下，申请其他资源。即要想出一个办法，阻止进程在持有资源的同时申请其他资源\n\n    * 方法一：一次性分配资源，即创建进程时，要求它申请所需的全部资源，系统或满足其所有要求，或什么也不给它。\n    * 方法二：要求每个进程提出新的资源申请前，释放它所占有的资源。这样，一个进程在需要资源 S 时，须先把它先前占有的资源 R 释放掉，然后才能提出对 S 的申请，即使它可能很快又要用到资源 R。\n3. 破坏“不可抢占”条件  \n    破坏“不可抢占”条件就是允许对资源实行抢夺。\n\n    * 方法一：如果占有某些资源的一个进程进行进一步资源请求被拒绝，则该进程必须释放它最初占有的资源，如果有必要，可再次请求这些资源和另外的资源。\n    * 方法二：如果一个进程请求当前被另一个进程占有的一个资源，则操作系统可以抢占另一个进程，要求它释放资源。只有在任意两个进程的优先级都不相同的条件下，方法二才能预防死锁。\n4. 破坏“循环等待”条件  \n    破坏“循环等待”条件的一种方法，是将系统中的所有资源统一编号，进程可在任何时刻提出资源申请，但所有申请必须按照资源的编号顺序（升序）提出。这样做就能保证系统不出现死锁。\n\n### 死锁避免\n\n1. 有序资源分配法  \n    算法\n\n```\n必须为所有资源统一编号，\n同类资源必须一次申请完，\n不同类资源必须按顺序申请\n```\n\n2. 银行家算法  \n    银行家算法的基本思想是分配资源之前，判断系统是否是安全的；若是，才分配。它是最具有代表性的避免死锁的算法。  \n    设进程 i 提出请求 REQUEST [i]，则银行家算法按如下规则进行判断。![1-6.png](/assets/net-img-1582875381841-0104c814-acd3-4ef3-a3bd-f5331d9a06bc-20221030135516-0716ftg.png)​\n\n```\n1. 如果REQUEST [i]<= NEED[i，j]，则转（2)；否则，出错。\n2 .如果REQUEST [i]<= AVAILABLE[i]，则转（3)；否则，等待。\n3 .系统试探分配资源，修改相关数据：\n   AVAILABLE[i]-=REQUEST[i];//可用资源数-请求资源数\n   ALLOCATION[i]+=REQUEST[i];//已分配资源数+请求资源数\n   NEED[i]-=REQUEST[i];//需要资源数-请求资源数\n系统执行安全性检查，如安全，则分配成立；否则试探险性分配作废，系统恢复原状，进程等待\n```\n\n3. 顺序加锁  \n    如果能确保所有的线程都是按照相同的顺序获得锁，那么死锁就不会发生,但是，这种方式需要事先知道所有可能会用到的锁，但总有些时候是无法预知的，所以该种方式只适合特定场景\n4. 限时加锁  \n    限时加锁是线程在尝试获取锁的时候加一个超时时间，若超过这个时间则放弃对该锁请求，并回退并释放所有已经获得的锁，然后等待一段随机的时间再重试  \n    这种方式有两个缺点：\n\n```\n1) 当线程数量少时，该种方式可避免死锁，但当线程数量过多，这些线程的加锁时限相同的概率就高很多，可能会导致超时后重试的死循环。\n2) Java中不能对synchronized同步块设置超时时间。你需要创建一个自定义锁，或使用Java5中java.util.concurrent包下的工具\n```\n\n### 死锁检测\n\n　　**死锁检测算法**  \n​![1-7.png](/assets/net-img-1582875390665-923c52b9-52ce-4e6f-9cee-763046546af3-20221030135517-j4zeqi7.png)​\n\n```\nE 是现有资源向量（existing resource vector），代码每种已存在资源的总数\nA 是可用资源向量（available resource vector），那么Ai表示当前可供使用的资源数（即没有被分配的资源）\nC 是当前分配矩阵（current allocation matrix），C的第i行代表Pi当前所持有的每一种类型资源的资源数\nR 是请求矩阵（request matrix），R的每一行代表P所需要的资源的数量\n```\n\n　　**死锁检测步骤：**\n\n```\n寻找一个没有结束标记的进程Pi，对于它而言R矩阵的第i行向量小于或等于A。\n如果找到了这样一个进程，执行该进程，然后将C矩阵的第i行向量加到A中，标记该进程，并转到第1步\n如果没有这样的进程，那么算法终止\n算法结束时，所有没有标记过的进程都是死锁进程\n```\n\n### 死锁恢复\n\n* 资源剥夺法  \n  剥夺陷于死锁的进程所占用的资源，但并不撤销此进程，直至死锁解除。\n* 进程回退法  \n  根据系统保存的检查点让所有的进程回退，直到足以解除死锁，这种措施要求系统建立保存检查点、回退及重启机制。\n* 进程撤销法\n\n  * 撤销陷入死锁的所有进程，解除死锁，继续运行。\n  * 逐个撤销陷入死锁的进程，回收其资源并重新分配，直至死锁解除。\n\n## Java创建线程\n\n* 继承 Thread 类 extends Thread\n* 实现 Runnable 接口 implements Runnable\n* 实现 Callable 接口 implements Callable\n\n  * 实现 Callable 接口。 相较于实现 Runnable 接口的方式，方法可以有返回值，并且可以抛出异常。\n  * 执行 Callable 方式，需要 FutureTask 实现类的支持，用于接收运算结果。 FutureTask 是 Future 接口的实现类，线程启动 `new Thread(objectFutureTask1).start()`​\n\n> Future\n\n* cancel()方法用来取消任务，如果取消任务成功则返回true，如果取消任务失败则返回false。\n\n  * 参数mayInterruptIfRunning表示是否允许取消正在执行却没有执行完毕的任务，如果设置true，则表示可以取消正在执行过程中的任务。\n  * 如果任务已经完成，则无论mayInterruptIfRunning为true还是false，此方法肯定返回false，即如果取消已经完成的任务会返回false\n  * 如果任务正在执行，若mayInterruptIfRunning设置为true，则返回true，若mayInterruptIfRunning设置为false，则返回false；如果任务还没有执行，则无论mayInterruptIfRunning为true还是false，肯定返回true。\n* isCancelled()方法表示任务是否被取消成功，如果在任务正常完成前被取消成功，则返回 true。\n* isDone()方法表示任务是否已经完成，若任务完成，则返回true；\n* get()方法用来获取执行结果，这个方法会产生阻塞，会一直等到任务执行完毕才返回；\n* get(long timeout, TimeUnit unit)用来获取执行结果，如果在指定时间内，还没获取到结果，就直接返回null。\n\n> FutureTask\n>\n> 实现了RunnableFuture接口，而RunnableFuture接口继承了Runnable与Future接口，所以它既可以作为Runnable被线程中执行，又可以作为callable获得返回值。\n\n* 适合应用场景\n\n  * 执行多任务计算\n  * 在高并发环境下确保任务只执行一次\n\n### 小结\n\n* 实现接口和继承 Thread 类比较\n\n> 接口更适合多个相同的程序代码的线程去共享同一个资源。  \n> 接口可以避免 java 中的单继承的局限性。  \n> 接口代码可以被多个线程共享，代码和线程独立。  \n> 线程池只能放入实现 Runable 或 Callable 接口的线程，不能直接放入继承 Thread 的类。  \n> 扩充：在 java 中，每次程序运行至少启动 2 个线程。一个是 main 线程，一个是垃圾收集线程。\n\n* Runnable 和 Callable 接口比较\n\n  * 相同点：\n\n> 两者都是接口；  \n> 两者都可用来编写多线程程序；  \n> 两者都需要调用 Thread.start()启动线程；\n\n* 不同点：\n\n> 实现 Callable 接口的线程能返回执行结果；而实现 Runnable 接口的线程不能返回结果；  \n> Callable 接口的 call()方法允许抛出异常；而 Runnable 接口的 run()方法的不允许抛异常；  \n> 实现 Callable 接口的线程可以调用 Future.cancel 取消执行  ，而实现 Runnable 接口的线程不能\n\n* 注意点：\n\n> Callable 接口支持返回执行结果，此时需要调用 FutureTask.get()方法实现，此方法会阻塞主线程直到获取‘将来’结果；当不调用此方法时，主线程不会阻塞！\n>\n> 实现Runnable接口,在某些情况下可以提高性能，使用继承 Thread 类方式，每次执行一次任务，都需要新建一个独立的线程，执行完任务后线程走到生命周期的尽头被销毁，如果还想执行这个任务，就必须再新建一个继承了 Thread 类的类，如果此时执行的内容比较少，比如只是在 run() 方法里简单打印一行文字，那么它所带来的开销并不大，相比于整个线程从开始创建到执行完毕被销毁，这一系列的操作比 run() 方法打印文字本身带来的开销要大得多，相当于捡了芝麻丢了西瓜，得不偿失。如果我们使用实现 Runnable 接口的方式，就可以把任务直接传入线程池，使用一些固定的线程来完成任务，不需要每次新建销毁线程，大大降低了性能开销。\n","slug":"java-thread","published":1,"updated":"2025-04-28T08:41:48.394Z","_id":"cm9s3f3yx0008bfg4d2n5e8hf","comments":1,"layout":"post","photos":[],"content":"<h1>thread</h1>\n<h2 id=\"概述\">概述</h2>\n<h3 id=\"并发与并行\">并发与并行</h3>\n<p>并行：指两个或多个事件在同一时刻发生（同时发生）。<br>\n并发：指两个或多个事件在同一个时间段内发生。<br>\n​<img src=\"/assets/net-img-1582875290415-c052f229-8c31-4560-acef-300acae2409b-20221030135515-tme9bzx.png\" alt=\"1-1.png\">​</p>\n<h3 id=\"进程、线程\">进程、线程</h3>\n<blockquote>\n<p>进程是正在运行的程序的实例。<br>\n进程是线程的容器，即一个进程中可以开启多个线程。</p>\n</blockquote>\n<blockquote>\n<p>线程是进程内部的一个独立执行单元；<br>\n一个进程可以同时并发运行多个线程；</p>\n</blockquote>\n<h2 id=\"线程生命周期\">线程生命周期</h2>\n<p>​<img src=\"/assets/net-img-1596249786159-92610d33-5cbb-4d46-b7a5-6f1c8d3d1d92-20221030135516-9i6hh1r.jpeg\" alt=\"\">  1. 新建</p>\n<ul>\n<li>new 关键字创建了一个线程之后，该线程就处于新建状态</li>\n<li>JVM 为线程分配内存，初始化成员变量值</li>\n</ul>\n<ol start=\"2\">\n<li>\n<p>就绪</p>\n<ul>\n<li>当线程对象调用了 start()方法之后，该线程处于就绪状态</li>\n<li>JVM 为线程创建方法栈和程序计数器，等待线程调度器调度</li>\n</ul>\n</li>\n<li>\n<p>运行</p>\n<ul>\n<li>就绪状态的线程获得 CPU 资源，开始运行 run()方法，该线程进入运行状态</li>\n</ul>\n</li>\n<li>\n<p>阻塞</p>\n<ul>\n<li>线程在等待进入临界区</li>\n</ul>\n</li>\n<li>\n<p>无限期等待</p>\n<ul>\n<li>处于这种状态的线程不会被分配CPU执行时间，它们要等待被显式地唤醒，否则会处于无限期等待的状态。</li>\n</ul>\n</li>\n<li>\n<p>限期等待</p>\n<ul>\n<li>处于这种状态的线程不会被分配CPU执行时间，不过无须无限期等待被其他线程显示地唤醒，在达到一定时间后它们会自动唤醒。</li>\n</ul>\n</li>\n<li>\n<p>死亡</p>\n<ul>\n<li>线程会以如下 3 种方式结束，结束后就处于死亡状态：</li>\n<li>run()或 call()方法执行完成，线程正常结束。</li>\n<li>线程抛出一个未捕获的 Exception 或 Error。&gt;调用该线程 stop()方法来结束该线程，该方法容易导致死锁，不推荐使用。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"死锁\">死锁</h2>\n<p>多个线程因竞争资源而造成的一种僵局(互相等待)</p>\n<h3 id=\"死锁产生必要条件\">死锁产生必要条件</h3>\n<ol>\n<li>互斥条件<br>\n在一段时间内某资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待</li>\n<li>不可剥夺条件<br>\n进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放（只能是主动释放)。</li>\n<li>请求与保持<br>\n进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。</li>\n<li>循环等待条件<br>\n存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被 链中下一个进程所请求。即存在一个处于等待状态的进程集合{Pl, P2, …, pn}，其中 Pi 等 待的资源被 P(i+1)占有（i=0, 1, …, n-1)，Pn 等待的资源被 P0 占有，如图所示</li>\n</ol>\n<p>​<img src=\"/assets/net-img-1582875326094-cb5a96e7-e4c2-421d-83cf-216ca4f7f024-20221030135516-5igfhr6.png\" alt=\"1-5.png\"><img src=\"/assets/net-img-1582875326657-55738037-28bf-4de9-925a-f08034e0c722-20221030135516-j4ktjne.png\" alt=\"1-4.png\">​</p>\n<h3 id=\"死锁处理\">死锁处理</h3>\n<h3 id=\"死锁预防\">死锁预防</h3>\n<ol>\n<li>\n<p>破坏“互斥”条件<br>\n​<code>互斥</code>​条件是无法破坏的。因此，在死锁预防里主要是破坏其他几个必要条件，而不去涉及破坏<code>互斥</code>​条件。</p>\n</li>\n<li>\n<p>破坏“占有并等待”条件<br>\n系统中不允许进程在已获得某种资源的情况下，申请其他资源。即要想出一个办法，阻止进程在持有资源的同时申请其他资源</p>\n<ul>\n<li>方法一：一次性分配资源，即创建进程时，要求它申请所需的全部资源，系统或满足其所有要求，或什么也不给它。</li>\n<li>方法二：要求每个进程提出新的资源申请前，释放它所占有的资源。这样，一个进程在需要资源 S 时，须先把它先前占有的资源 R 释放掉，然后才能提出对 S 的申请，即使它可能很快又要用到资源 R。</li>\n</ul>\n</li>\n<li>\n<p>破坏“不可抢占”条件<br>\n破坏“不可抢占”条件就是允许对资源实行抢夺。</p>\n<ul>\n<li>方法一：如果占有某些资源的一个进程进行进一步资源请求被拒绝，则该进程必须释放它最初占有的资源，如果有必要，可再次请求这些资源和另外的资源。</li>\n<li>方法二：如果一个进程请求当前被另一个进程占有的一个资源，则操作系统可以抢占另一个进程，要求它释放资源。只有在任意两个进程的优先级都不相同的条件下，方法二才能预防死锁。</li>\n</ul>\n</li>\n<li>\n<p>破坏“循环等待”条件<br>\n破坏“循环等待”条件的一种方法，是将系统中的所有资源统一编号，进程可在任何时刻提出资源申请，但所有申请必须按照资源的编号顺序（升序）提出。这样做就能保证系统不出现死锁。</p>\n</li>\n</ol>\n<h3 id=\"死锁避免\">死锁避免</h3>\n<ol>\n<li>有序资源分配法<br>\n算法</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">必须为所有资源统一编号，</span><br><span class=\"line\">同类资源必须一次申请完，</span><br><span class=\"line\">不同类资源必须按顺序申请</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>银行家算法<br>\n银行家算法的基本思想是分配资源之前，判断系统是否是安全的；若是，才分配。它是最具有代表性的避免死锁的算法。<br>\n设进程 i 提出请求 REQUEST [i]，则银行家算法按如下规则进行判断。<img src=\"/assets/net-img-1582875381841-0104c814-acd3-4ef3-a3bd-f5331d9a06bc-20221030135516-0716ftg.png\" alt=\"1-6.png\">​</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 如果REQUEST [i]&lt;= NEED[i，j]，则转（2)；否则，出错。</span><br><span class=\"line\">2 .如果REQUEST [i]&lt;= AVAILABLE[i]，则转（3)；否则，等待。</span><br><span class=\"line\">3 .系统试探分配资源，修改相关数据：</span><br><span class=\"line\">   AVAILABLE[i]-=REQUEST[i];//可用资源数-请求资源数</span><br><span class=\"line\">   ALLOCATION[i]+=REQUEST[i];//已分配资源数+请求资源数</span><br><span class=\"line\">   NEED[i]-=REQUEST[i];//需要资源数-请求资源数</span><br><span class=\"line\">系统执行安全性检查，如安全，则分配成立；否则试探险性分配作废，系统恢复原状，进程等待</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>顺序加锁<br>\n如果能确保所有的线程都是按照相同的顺序获得锁，那么死锁就不会发生,但是，这种方式需要事先知道所有可能会用到的锁，但总有些时候是无法预知的，所以该种方式只适合特定场景</li>\n<li>限时加锁<br>\n限时加锁是线程在尝试获取锁的时候加一个超时时间，若超过这个时间则放弃对该锁请求，并回退并释放所有已经获得的锁，然后等待一段随机的时间再重试<br>\n这种方式有两个缺点：</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1) 当线程数量少时，该种方式可避免死锁，但当线程数量过多，这些线程的加锁时限相同的概率就高很多，可能会导致超时后重试的死循环。</span><br><span class=\"line\">2) Java中不能对synchronized同步块设置超时时间。你需要创建一个自定义锁，或使用Java5中java.util.concurrent包下的工具</span><br></pre></td></tr></table></figure>\n<h3 id=\"死锁检测\">死锁检测</h3>\n<p><strong>死锁检测算法</strong><br>\n​<img src=\"/assets/net-img-1582875390665-923c52b9-52ce-4e6f-9cee-763046546af3-20221030135517-j4zeqi7.png\" alt=\"1-7.png\">​</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">E 是现有资源向量（existing resource vector），代码每种已存在资源的总数</span><br><span class=\"line\">A 是可用资源向量（available resource vector），那么Ai表示当前可供使用的资源数（即没有被分配的资源）</span><br><span class=\"line\">C 是当前分配矩阵（current allocation matrix），C的第i行代表Pi当前所持有的每一种类型资源的资源数</span><br><span class=\"line\">R 是请求矩阵（request matrix），R的每一行代表P所需要的资源的数量</span><br></pre></td></tr></table></figure>\n<p><strong>死锁检测步骤：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">寻找一个没有结束标记的进程Pi，对于它而言R矩阵的第i行向量小于或等于A。</span><br><span class=\"line\">如果找到了这样一个进程，执行该进程，然后将C矩阵的第i行向量加到A中，标记该进程，并转到第1步</span><br><span class=\"line\">如果没有这样的进程，那么算法终止</span><br><span class=\"line\">算法结束时，所有没有标记过的进程都是死锁进程</span><br></pre></td></tr></table></figure>\n<h3 id=\"死锁恢复\">死锁恢复</h3>\n<ul>\n<li>\n<p>资源剥夺法<br>\n剥夺陷于死锁的进程所占用的资源，但并不撤销此进程，直至死锁解除。</p>\n</li>\n<li>\n<p>进程回退法<br>\n根据系统保存的检查点让所有的进程回退，直到足以解除死锁，这种措施要求系统建立保存检查点、回退及重启机制。</p>\n</li>\n<li>\n<p>进程撤销法</p>\n<ul>\n<li>撤销陷入死锁的所有进程，解除死锁，继续运行。</li>\n<li>逐个撤销陷入死锁的进程，回收其资源并重新分配，直至死锁解除。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Java创建线程\">Java创建线程</h2>\n<ul>\n<li>\n<p>继承 Thread 类 extends Thread</p>\n</li>\n<li>\n<p>实现 Runnable 接口 implements Runnable</p>\n</li>\n<li>\n<p>实现 Callable 接口 implements Callable</p>\n<ul>\n<li>实现 Callable 接口。 相较于实现 Runnable 接口的方式，方法可以有返回值，并且可以抛出异常。</li>\n<li>执行 Callable 方式，需要 FutureTask 实现类的支持，用于接收运算结果。 FutureTask 是 Future 接口的实现类，线程启动 <code>new Thread(objectFutureTask1).start()</code>​</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>Future</p>\n</blockquote>\n<ul>\n<li>\n<p>cancel()方法用来取消任务，如果取消任务成功则返回true，如果取消任务失败则返回false。</p>\n<ul>\n<li>参数mayInterruptIfRunning表示是否允许取消正在执行却没有执行完毕的任务，如果设置true，则表示可以取消正在执行过程中的任务。</li>\n<li>如果任务已经完成，则无论mayInterruptIfRunning为true还是false，此方法肯定返回false，即如果取消已经完成的任务会返回false</li>\n<li>如果任务正在执行，若mayInterruptIfRunning设置为true，则返回true，若mayInterruptIfRunning设置为false，则返回false；如果任务还没有执行，则无论mayInterruptIfRunning为true还是false，肯定返回true。</li>\n</ul>\n</li>\n<li>\n<p>isCancelled()方法表示任务是否被取消成功，如果在任务正常完成前被取消成功，则返回 true。</p>\n</li>\n<li>\n<p>isDone()方法表示任务是否已经完成，若任务完成，则返回true；</p>\n</li>\n<li>\n<p>get()方法用来获取执行结果，这个方法会产生阻塞，会一直等到任务执行完毕才返回；</p>\n</li>\n<li>\n<p>get(long timeout, TimeUnit unit)用来获取执行结果，如果在指定时间内，还没获取到结果，就直接返回null。</p>\n</li>\n</ul>\n<blockquote>\n<p>FutureTask</p>\n<p>实现了RunnableFuture接口，而RunnableFuture接口继承了Runnable与Future接口，所以它既可以作为Runnable被线程中执行，又可以作为callable获得返回值。</p>\n</blockquote>\n<ul>\n<li>\n<p>适合应用场景</p>\n<ul>\n<li>执行多任务计算</li>\n<li>在高并发环境下确保任务只执行一次</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"小结\">小结</h3>\n<ul>\n<li>实现接口和继承 Thread 类比较</li>\n</ul>\n<blockquote>\n<p>接口更适合多个相同的程序代码的线程去共享同一个资源。<br>\n接口可以避免 java 中的单继承的局限性。<br>\n接口代码可以被多个线程共享，代码和线程独立。<br>\n线程池只能放入实现 Runable 或 Callable 接口的线程，不能直接放入继承 Thread 的类。<br>\n扩充：在 java 中，每次程序运行至少启动 2 个线程。一个是 main 线程，一个是垃圾收集线程。</p>\n</blockquote>\n<ul>\n<li>\n<p>Runnable 和 Callable 接口比较</p>\n<ul>\n<li>相同点：</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>两者都是接口；<br>\n两者都可用来编写多线程程序；<br>\n两者都需要调用 Thread.start()启动线程；</p>\n</blockquote>\n<ul>\n<li>不同点：</li>\n</ul>\n<blockquote>\n<p>实现 Callable 接口的线程能返回执行结果；而实现 Runnable 接口的线程不能返回结果；<br>\nCallable 接口的 call()方法允许抛出异常；而 Runnable 接口的 run()方法的不允许抛异常；<br>\n实现 Callable 接口的线程可以调用 Future.cancel 取消执行  ，而实现 Runnable 接口的线程不能</p>\n</blockquote>\n<ul>\n<li>注意点：</li>\n</ul>\n<blockquote>\n<p>Callable 接口支持返回执行结果，此时需要调用 FutureTask.get()方法实现，此方法会阻塞主线程直到获取‘将来’结果；当不调用此方法时，主线程不会阻塞！</p>\n<p>实现Runnable接口,在某些情况下可以提高性能，使用继承 Thread 类方式，每次执行一次任务，都需要新建一个独立的线程，执行完任务后线程走到生命周期的尽头被销毁，如果还想执行这个任务，就必须再新建一个继承了 Thread 类的类，如果此时执行的内容比较少，比如只是在 run() 方法里简单打印一行文字，那么它所带来的开销并不大，相比于整个线程从开始创建到执行完毕被销毁，这一系列的操作比 run() 方法打印文字本身带来的开销要大得多，相当于捡了芝麻丢了西瓜，得不偿失。如果我们使用实现 Runnable 接口的方式，就可以把任务直接传入线程池，使用一些固定的线程来完成任务，不需要每次新建销毁线程，大大降低了性能开销。</p>\n</blockquote>\n","excerpt":"","more":"<h1>thread</h1>\n<h2 id=\"概述\">概述</h2>\n<h3 id=\"并发与并行\">并发与并行</h3>\n<p>并行：指两个或多个事件在同一时刻发生（同时发生）。<br>\n并发：指两个或多个事件在同一个时间段内发生。<br>\n​<img src=\"/assets/net-img-1582875290415-c052f229-8c31-4560-acef-300acae2409b-20221030135515-tme9bzx.png\" alt=\"1-1.png\">​</p>\n<h3 id=\"进程、线程\">进程、线程</h3>\n<blockquote>\n<p>进程是正在运行的程序的实例。<br>\n进程是线程的容器，即一个进程中可以开启多个线程。</p>\n</blockquote>\n<blockquote>\n<p>线程是进程内部的一个独立执行单元；<br>\n一个进程可以同时并发运行多个线程；</p>\n</blockquote>\n<h2 id=\"线程生命周期\">线程生命周期</h2>\n<p>​<img src=\"/assets/net-img-1596249786159-92610d33-5cbb-4d46-b7a5-6f1c8d3d1d92-20221030135516-9i6hh1r.jpeg\" alt=\"\">  1. 新建</p>\n<ul>\n<li>new 关键字创建了一个线程之后，该线程就处于新建状态</li>\n<li>JVM 为线程分配内存，初始化成员变量值</li>\n</ul>\n<ol start=\"2\">\n<li>\n<p>就绪</p>\n<ul>\n<li>当线程对象调用了 start()方法之后，该线程处于就绪状态</li>\n<li>JVM 为线程创建方法栈和程序计数器，等待线程调度器调度</li>\n</ul>\n</li>\n<li>\n<p>运行</p>\n<ul>\n<li>就绪状态的线程获得 CPU 资源，开始运行 run()方法，该线程进入运行状态</li>\n</ul>\n</li>\n<li>\n<p>阻塞</p>\n<ul>\n<li>线程在等待进入临界区</li>\n</ul>\n</li>\n<li>\n<p>无限期等待</p>\n<ul>\n<li>处于这种状态的线程不会被分配CPU执行时间，它们要等待被显式地唤醒，否则会处于无限期等待的状态。</li>\n</ul>\n</li>\n<li>\n<p>限期等待</p>\n<ul>\n<li>处于这种状态的线程不会被分配CPU执行时间，不过无须无限期等待被其他线程显示地唤醒，在达到一定时间后它们会自动唤醒。</li>\n</ul>\n</li>\n<li>\n<p>死亡</p>\n<ul>\n<li>线程会以如下 3 种方式结束，结束后就处于死亡状态：</li>\n<li>run()或 call()方法执行完成，线程正常结束。</li>\n<li>线程抛出一个未捕获的 Exception 或 Error。&gt;调用该线程 stop()方法来结束该线程，该方法容易导致死锁，不推荐使用。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"死锁\">死锁</h2>\n<p>多个线程因竞争资源而造成的一种僵局(互相等待)</p>\n<h3 id=\"死锁产生必要条件\">死锁产生必要条件</h3>\n<ol>\n<li>互斥条件<br>\n在一段时间内某资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待</li>\n<li>不可剥夺条件<br>\n进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放（只能是主动释放)。</li>\n<li>请求与保持<br>\n进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。</li>\n<li>循环等待条件<br>\n存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被 链中下一个进程所请求。即存在一个处于等待状态的进程集合{Pl, P2, …, pn}，其中 Pi 等 待的资源被 P(i+1)占有（i=0, 1, …, n-1)，Pn 等待的资源被 P0 占有，如图所示</li>\n</ol>\n<p>​<img src=\"/assets/net-img-1582875326094-cb5a96e7-e4c2-421d-83cf-216ca4f7f024-20221030135516-5igfhr6.png\" alt=\"1-5.png\"><img src=\"/assets/net-img-1582875326657-55738037-28bf-4de9-925a-f08034e0c722-20221030135516-j4ktjne.png\" alt=\"1-4.png\">​</p>\n<h3 id=\"死锁处理\">死锁处理</h3>\n<h3 id=\"死锁预防\">死锁预防</h3>\n<ol>\n<li>\n<p>破坏“互斥”条件<br>\n​<code>互斥</code>​条件是无法破坏的。因此，在死锁预防里主要是破坏其他几个必要条件，而不去涉及破坏<code>互斥</code>​条件。</p>\n</li>\n<li>\n<p>破坏“占有并等待”条件<br>\n系统中不允许进程在已获得某种资源的情况下，申请其他资源。即要想出一个办法，阻止进程在持有资源的同时申请其他资源</p>\n<ul>\n<li>方法一：一次性分配资源，即创建进程时，要求它申请所需的全部资源，系统或满足其所有要求，或什么也不给它。</li>\n<li>方法二：要求每个进程提出新的资源申请前，释放它所占有的资源。这样，一个进程在需要资源 S 时，须先把它先前占有的资源 R 释放掉，然后才能提出对 S 的申请，即使它可能很快又要用到资源 R。</li>\n</ul>\n</li>\n<li>\n<p>破坏“不可抢占”条件<br>\n破坏“不可抢占”条件就是允许对资源实行抢夺。</p>\n<ul>\n<li>方法一：如果占有某些资源的一个进程进行进一步资源请求被拒绝，则该进程必须释放它最初占有的资源，如果有必要，可再次请求这些资源和另外的资源。</li>\n<li>方法二：如果一个进程请求当前被另一个进程占有的一个资源，则操作系统可以抢占另一个进程，要求它释放资源。只有在任意两个进程的优先级都不相同的条件下，方法二才能预防死锁。</li>\n</ul>\n</li>\n<li>\n<p>破坏“循环等待”条件<br>\n破坏“循环等待”条件的一种方法，是将系统中的所有资源统一编号，进程可在任何时刻提出资源申请，但所有申请必须按照资源的编号顺序（升序）提出。这样做就能保证系统不出现死锁。</p>\n</li>\n</ol>\n<h3 id=\"死锁避免\">死锁避免</h3>\n<ol>\n<li>有序资源分配法<br>\n算法</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">必须为所有资源统一编号，</span><br><span class=\"line\">同类资源必须一次申请完，</span><br><span class=\"line\">不同类资源必须按顺序申请</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>银行家算法<br>\n银行家算法的基本思想是分配资源之前，判断系统是否是安全的；若是，才分配。它是最具有代表性的避免死锁的算法。<br>\n设进程 i 提出请求 REQUEST [i]，则银行家算法按如下规则进行判断。<img src=\"/assets/net-img-1582875381841-0104c814-acd3-4ef3-a3bd-f5331d9a06bc-20221030135516-0716ftg.png\" alt=\"1-6.png\">​</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 如果REQUEST [i]&lt;= NEED[i，j]，则转（2)；否则，出错。</span><br><span class=\"line\">2 .如果REQUEST [i]&lt;= AVAILABLE[i]，则转（3)；否则，等待。</span><br><span class=\"line\">3 .系统试探分配资源，修改相关数据：</span><br><span class=\"line\">   AVAILABLE[i]-=REQUEST[i];//可用资源数-请求资源数</span><br><span class=\"line\">   ALLOCATION[i]+=REQUEST[i];//已分配资源数+请求资源数</span><br><span class=\"line\">   NEED[i]-=REQUEST[i];//需要资源数-请求资源数</span><br><span class=\"line\">系统执行安全性检查，如安全，则分配成立；否则试探险性分配作废，系统恢复原状，进程等待</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>顺序加锁<br>\n如果能确保所有的线程都是按照相同的顺序获得锁，那么死锁就不会发生,但是，这种方式需要事先知道所有可能会用到的锁，但总有些时候是无法预知的，所以该种方式只适合特定场景</li>\n<li>限时加锁<br>\n限时加锁是线程在尝试获取锁的时候加一个超时时间，若超过这个时间则放弃对该锁请求，并回退并释放所有已经获得的锁，然后等待一段随机的时间再重试<br>\n这种方式有两个缺点：</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1) 当线程数量少时，该种方式可避免死锁，但当线程数量过多，这些线程的加锁时限相同的概率就高很多，可能会导致超时后重试的死循环。</span><br><span class=\"line\">2) Java中不能对synchronized同步块设置超时时间。你需要创建一个自定义锁，或使用Java5中java.util.concurrent包下的工具</span><br></pre></td></tr></table></figure>\n<h3 id=\"死锁检测\">死锁检测</h3>\n<p><strong>死锁检测算法</strong><br>\n​<img src=\"/assets/net-img-1582875390665-923c52b9-52ce-4e6f-9cee-763046546af3-20221030135517-j4zeqi7.png\" alt=\"1-7.png\">​</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">E 是现有资源向量（existing resource vector），代码每种已存在资源的总数</span><br><span class=\"line\">A 是可用资源向量（available resource vector），那么Ai表示当前可供使用的资源数（即没有被分配的资源）</span><br><span class=\"line\">C 是当前分配矩阵（current allocation matrix），C的第i行代表Pi当前所持有的每一种类型资源的资源数</span><br><span class=\"line\">R 是请求矩阵（request matrix），R的每一行代表P所需要的资源的数量</span><br></pre></td></tr></table></figure>\n<p><strong>死锁检测步骤：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">寻找一个没有结束标记的进程Pi，对于它而言R矩阵的第i行向量小于或等于A。</span><br><span class=\"line\">如果找到了这样一个进程，执行该进程，然后将C矩阵的第i行向量加到A中，标记该进程，并转到第1步</span><br><span class=\"line\">如果没有这样的进程，那么算法终止</span><br><span class=\"line\">算法结束时，所有没有标记过的进程都是死锁进程</span><br></pre></td></tr></table></figure>\n<h3 id=\"死锁恢复\">死锁恢复</h3>\n<ul>\n<li>\n<p>资源剥夺法<br>\n剥夺陷于死锁的进程所占用的资源，但并不撤销此进程，直至死锁解除。</p>\n</li>\n<li>\n<p>进程回退法<br>\n根据系统保存的检查点让所有的进程回退，直到足以解除死锁，这种措施要求系统建立保存检查点、回退及重启机制。</p>\n</li>\n<li>\n<p>进程撤销法</p>\n<ul>\n<li>撤销陷入死锁的所有进程，解除死锁，继续运行。</li>\n<li>逐个撤销陷入死锁的进程，回收其资源并重新分配，直至死锁解除。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Java创建线程\">Java创建线程</h2>\n<ul>\n<li>\n<p>继承 Thread 类 extends Thread</p>\n</li>\n<li>\n<p>实现 Runnable 接口 implements Runnable</p>\n</li>\n<li>\n<p>实现 Callable 接口 implements Callable</p>\n<ul>\n<li>实现 Callable 接口。 相较于实现 Runnable 接口的方式，方法可以有返回值，并且可以抛出异常。</li>\n<li>执行 Callable 方式，需要 FutureTask 实现类的支持，用于接收运算结果。 FutureTask 是 Future 接口的实现类，线程启动 <code>new Thread(objectFutureTask1).start()</code>​</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>Future</p>\n</blockquote>\n<ul>\n<li>\n<p>cancel()方法用来取消任务，如果取消任务成功则返回true，如果取消任务失败则返回false。</p>\n<ul>\n<li>参数mayInterruptIfRunning表示是否允许取消正在执行却没有执行完毕的任务，如果设置true，则表示可以取消正在执行过程中的任务。</li>\n<li>如果任务已经完成，则无论mayInterruptIfRunning为true还是false，此方法肯定返回false，即如果取消已经完成的任务会返回false</li>\n<li>如果任务正在执行，若mayInterruptIfRunning设置为true，则返回true，若mayInterruptIfRunning设置为false，则返回false；如果任务还没有执行，则无论mayInterruptIfRunning为true还是false，肯定返回true。</li>\n</ul>\n</li>\n<li>\n<p>isCancelled()方法表示任务是否被取消成功，如果在任务正常完成前被取消成功，则返回 true。</p>\n</li>\n<li>\n<p>isDone()方法表示任务是否已经完成，若任务完成，则返回true；</p>\n</li>\n<li>\n<p>get()方法用来获取执行结果，这个方法会产生阻塞，会一直等到任务执行完毕才返回；</p>\n</li>\n<li>\n<p>get(long timeout, TimeUnit unit)用来获取执行结果，如果在指定时间内，还没获取到结果，就直接返回null。</p>\n</li>\n</ul>\n<blockquote>\n<p>FutureTask</p>\n<p>实现了RunnableFuture接口，而RunnableFuture接口继承了Runnable与Future接口，所以它既可以作为Runnable被线程中执行，又可以作为callable获得返回值。</p>\n</blockquote>\n<ul>\n<li>\n<p>适合应用场景</p>\n<ul>\n<li>执行多任务计算</li>\n<li>在高并发环境下确保任务只执行一次</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"小结\">小结</h3>\n<ul>\n<li>实现接口和继承 Thread 类比较</li>\n</ul>\n<blockquote>\n<p>接口更适合多个相同的程序代码的线程去共享同一个资源。<br>\n接口可以避免 java 中的单继承的局限性。<br>\n接口代码可以被多个线程共享，代码和线程独立。<br>\n线程池只能放入实现 Runable 或 Callable 接口的线程，不能直接放入继承 Thread 的类。<br>\n扩充：在 java 中，每次程序运行至少启动 2 个线程。一个是 main 线程，一个是垃圾收集线程。</p>\n</blockquote>\n<ul>\n<li>\n<p>Runnable 和 Callable 接口比较</p>\n<ul>\n<li>相同点：</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>两者都是接口；<br>\n两者都可用来编写多线程程序；<br>\n两者都需要调用 Thread.start()启动线程；</p>\n</blockquote>\n<ul>\n<li>不同点：</li>\n</ul>\n<blockquote>\n<p>实现 Callable 接口的线程能返回执行结果；而实现 Runnable 接口的线程不能返回结果；<br>\nCallable 接口的 call()方法允许抛出异常；而 Runnable 接口的 run()方法的不允许抛异常；<br>\n实现 Callable 接口的线程可以调用 Future.cancel 取消执行  ，而实现 Runnable 接口的线程不能</p>\n</blockquote>\n<ul>\n<li>注意点：</li>\n</ul>\n<blockquote>\n<p>Callable 接口支持返回执行结果，此时需要调用 FutureTask.get()方法实现，此方法会阻塞主线程直到获取‘将来’结果；当不调用此方法时，主线程不会阻塞！</p>\n<p>实现Runnable接口,在某些情况下可以提高性能，使用继承 Thread 类方式，每次执行一次任务，都需要新建一个独立的线程，执行完任务后线程走到生命周期的尽头被销毁，如果还想执行这个任务，就必须再新建一个继承了 Thread 类的类，如果此时执行的内容比较少，比如只是在 run() 方法里简单打印一行文字，那么它所带来的开销并不大，相比于整个线程从开始创建到执行完毕被销毁，这一系列的操作比 run() 方法打印文字本身带来的开销要大得多，相当于捡了芝麻丢了西瓜，得不偿失。如果我们使用实现 Runnable 接口的方式，就可以把任务直接传入线程池，使用一些固定的线程来完成任务，不需要每次新建销毁线程，大大降低了性能开销。</p>\n</blockquote>\n"},{"title":"JavaStream","date":"2022-10-30T05:27:17.000Z","lastmod":"2023-08-25T12:01:12.000Z","_content":"\n# JavaStream\n\n### Stream\n\n> Stream（流）是一个来自数据源的元素队列并支持聚合操作\n\n- 元素是特定类型的对象，形成一个队列。 Java中的Stream并不会存储元素，而是按需计算。\n- **数据源** 流的来源。 可以是集合，数组，I/O channel， 产生器generator 等。\n- **聚合操作** 类似SQL语句一样的操作， 比如filter, map, reduce, find, match, sorted等。\n\n　　Stream还有两个特征\n\n- **Pipelining**: 中间操作都会返回流对象本身。 这样多个操作可以串联成一个管道， 如同流式风格（fluent style）。 这样做可以对操作进行优化， 比如延迟执行(laziness)和短路( short-circuiting)。\n- **内部迭代**： 以前对集合遍历都是通过Iterator或者For-Each的方式, 显式的在集合外部进行迭代， 这叫做外部迭代。 Stream提供了内部迭代的方式， 通过访问者模式(Visitor)实现。\n\n### 生成流\n\n- stream() -为集合创建串行流。\n- parallelStream() − 为集合创建并行流。\n- `Stream.of()` 从一堆对象中创建 Stream 流\n\n### 数据处理\n\n#### map\n\n> 用于映射每个元素到对应的结果，可对当前元素进行数据处理\n\n#### flatmap\n\n> 将流的每个元素, 转换为其他对象的流,入参接受一个返回对象流的函数\n\n#### filter（lamda表达式）\n\n> 用于通过设置的条件过滤出元素(过滤条件对应的是留下的元素)\n\n#### limit\n\n> 用于获取指定数量的流\n\n#### sorted\n\n> 用于对流进行排序，可以传入**Comparator**参数控制排序顺序\n\n#### distinct\n\n> 用于消除流中的重复元素\n\n#### isPrime()\n\n> 用于检测是否是质数，是留下该元素\n\n### 结束操作\n\n#### forEach(Consumer)\n\n> 遍历迭代流中的每个元素，无返回值\n\n#### `forEachOrdered(Consumer)`\n\n> 确保按照原始流的顺序执行。\n\n#### collect(Collector)\n\n> 使用 `Collector` 收集流元素到结果集合中\n\n#### `collect(Supplier, BiConsumer, BiConsumer)`\n\n> 收集流元素到结果集合中，第一个参数用于**创建一个新的结果集合**，第二个参数用于**将下一个元素加入到现有结果合集中**，第三个参数用于**将两个结果合集合并**\n\n## 匹配\n\n#### `allMatch(Predicate)` ：\n\n> 如果流的每个元素根据提供的 `Predicate` 都返回 true 时，最终结果返回为 true。这个操作将会在第一个 false 之后短路，也就是不会在发生 false 之后继续执行计算。\n\n#### `anyMatch(Predicate)`：\n\n> 如果流中的任意一个元素根据提供的 `Predicate` 返回 true 时，最终结果返回为 true。这个操作将会在第一个 true 之后短路，也就是不会在发生 true 之后继续执行计算。\n\n#### `noneMatch(Predicate)`：\n\n> 如果流的每个元素根据提供的 `Predicate` 都返回 false 时，最终结果返回为 true。这个操作将会在第一个 true 之后短路，也就是不会在发生 true 之后继续执行计算。\n","source":"_posts/java/Base/JavaStream.md","raw":"---\ntitle: JavaStream\ndate: 2022-10-30T13:27:17Z\nlastmod: 2023-08-25T20:01:12Z\n---\n\n# JavaStream\n\n### Stream\n\n> Stream（流）是一个来自数据源的元素队列并支持聚合操作\n\n- 元素是特定类型的对象，形成一个队列。 Java中的Stream并不会存储元素，而是按需计算。\n- **数据源** 流的来源。 可以是集合，数组，I/O channel， 产生器generator 等。\n- **聚合操作** 类似SQL语句一样的操作， 比如filter, map, reduce, find, match, sorted等。\n\n　　Stream还有两个特征\n\n- **Pipelining**: 中间操作都会返回流对象本身。 这样多个操作可以串联成一个管道， 如同流式风格（fluent style）。 这样做可以对操作进行优化， 比如延迟执行(laziness)和短路( short-circuiting)。\n- **内部迭代**： 以前对集合遍历都是通过Iterator或者For-Each的方式, 显式的在集合外部进行迭代， 这叫做外部迭代。 Stream提供了内部迭代的方式， 通过访问者模式(Visitor)实现。\n\n### 生成流\n\n- stream() -为集合创建串行流。\n- parallelStream() − 为集合创建并行流。\n- `Stream.of()` 从一堆对象中创建 Stream 流\n\n### 数据处理\n\n#### map\n\n> 用于映射每个元素到对应的结果，可对当前元素进行数据处理\n\n#### flatmap\n\n> 将流的每个元素, 转换为其他对象的流,入参接受一个返回对象流的函数\n\n#### filter（lamda表达式）\n\n> 用于通过设置的条件过滤出元素(过滤条件对应的是留下的元素)\n\n#### limit\n\n> 用于获取指定数量的流\n\n#### sorted\n\n> 用于对流进行排序，可以传入**Comparator**参数控制排序顺序\n\n#### distinct\n\n> 用于消除流中的重复元素\n\n#### isPrime()\n\n> 用于检测是否是质数，是留下该元素\n\n### 结束操作\n\n#### forEach(Consumer)\n\n> 遍历迭代流中的每个元素，无返回值\n\n#### `forEachOrdered(Consumer)`\n\n> 确保按照原始流的顺序执行。\n\n#### collect(Collector)\n\n> 使用 `Collector` 收集流元素到结果集合中\n\n#### `collect(Supplier, BiConsumer, BiConsumer)`\n\n> 收集流元素到结果集合中，第一个参数用于**创建一个新的结果集合**，第二个参数用于**将下一个元素加入到现有结果合集中**，第三个参数用于**将两个结果合集合并**\n\n## 匹配\n\n#### `allMatch(Predicate)` ：\n\n> 如果流的每个元素根据提供的 `Predicate` 都返回 true 时，最终结果返回为 true。这个操作将会在第一个 false 之后短路，也就是不会在发生 false 之后继续执行计算。\n\n#### `anyMatch(Predicate)`：\n\n> 如果流中的任意一个元素根据提供的 `Predicate` 返回 true 时，最终结果返回为 true。这个操作将会在第一个 true 之后短路，也就是不会在发生 true 之后继续执行计算。\n\n#### `noneMatch(Predicate)`：\n\n> 如果流的每个元素根据提供的 `Predicate` 都返回 false 时，最终结果返回为 true。这个操作将会在第一个 true 之后短路，也就是不会在发生 true 之后继续执行计算。\n","slug":"java-Base-JavaStream","published":1,"updated":"2025-04-20T00:08:55.544Z","_id":"cm9s3f40e002rbfg4h9fb2dxj","comments":1,"layout":"post","photos":[],"content":"<h1>JavaStream</h1>\n<h3 id=\"Stream\">Stream</h3>\n<blockquote>\n<p>Stream（流）是一个来自数据源的元素队列并支持聚合操作</p>\n</blockquote>\n<ul>\n<li>元素是特定类型的对象，形成一个队列。 Java中的Stream并不会存储元素，而是按需计算。</li>\n<li><strong>数据源</strong> 流的来源。 可以是集合，数组，I/O channel， 产生器generator 等。</li>\n<li><strong>聚合操作</strong> 类似SQL语句一样的操作， 比如filter, map, reduce, find, match, sorted等。</li>\n</ul>\n<p>Stream还有两个特征</p>\n<ul>\n<li><strong>Pipelining</strong>: 中间操作都会返回流对象本身。 这样多个操作可以串联成一个管道， 如同流式风格（fluent style）。 这样做可以对操作进行优化， 比如延迟执行(laziness)和短路( short-circuiting)。</li>\n<li><strong>内部迭代</strong>： 以前对集合遍历都是通过Iterator或者For-Each的方式, 显式的在集合外部进行迭代， 这叫做外部迭代。 Stream提供了内部迭代的方式， 通过访问者模式(Visitor)实现。</li>\n</ul>\n<h3 id=\"生成流\">生成流</h3>\n<ul>\n<li>stream() -为集合创建串行流。</li>\n<li>parallelStream() − 为集合创建并行流。</li>\n<li><code>Stream.of()</code> 从一堆对象中创建 Stream 流</li>\n</ul>\n<h3 id=\"数据处理\">数据处理</h3>\n<h4 id=\"map\">map</h4>\n<blockquote>\n<p>用于映射每个元素到对应的结果，可对当前元素进行数据处理</p>\n</blockquote>\n<h4 id=\"flatmap\">flatmap</h4>\n<blockquote>\n<p>将流的每个元素, 转换为其他对象的流,入参接受一个返回对象流的函数</p>\n</blockquote>\n<h4 id=\"filter（lamda表达式）\">filter（lamda表达式）</h4>\n<blockquote>\n<p>用于通过设置的条件过滤出元素(过滤条件对应的是留下的元素)</p>\n</blockquote>\n<h4 id=\"limit\">limit</h4>\n<blockquote>\n<p>用于获取指定数量的流</p>\n</blockquote>\n<h4 id=\"sorted\">sorted</h4>\n<blockquote>\n<p>用于对流进行排序，可以传入<strong>Comparator</strong>参数控制排序顺序</p>\n</blockquote>\n<h4 id=\"distinct\">distinct</h4>\n<blockquote>\n<p>用于消除流中的重复元素</p>\n</blockquote>\n<h4 id=\"isPrime\">isPrime()</h4>\n<blockquote>\n<p>用于检测是否是质数，是留下该元素</p>\n</blockquote>\n<h3 id=\"结束操作\">结束操作</h3>\n<h4 id=\"forEach-Consumer\">forEach(Consumer)</h4>\n<blockquote>\n<p>遍历迭代流中的每个元素，无返回值</p>\n</blockquote>\n<h4 id=\"forEachOrdered-Consumer\"><code>forEachOrdered(Consumer)</code></h4>\n<blockquote>\n<p>确保按照原始流的顺序执行。</p>\n</blockquote>\n<h4 id=\"collect-Collector\">collect(Collector)</h4>\n<blockquote>\n<p>使用 <code>Collector</code> 收集流元素到结果集合中</p>\n</blockquote>\n<h4 id=\"collect-Supplier-BiConsumer-BiConsumer\"><code>collect(Supplier, BiConsumer, BiConsumer)</code></h4>\n<blockquote>\n<p>收集流元素到结果集合中，第一个参数用于<strong>创建一个新的结果集合</strong>，第二个参数用于<strong>将下一个元素加入到现有结果合集中</strong>，第三个参数用于<strong>将两个结果合集合并</strong></p>\n</blockquote>\n<h2 id=\"匹配\">匹配</h2>\n<h4 id=\"allMatch-Predicate-：\"><code>allMatch(Predicate)</code> ：</h4>\n<blockquote>\n<p>如果流的每个元素根据提供的 <code>Predicate</code> 都返回 true 时，最终结果返回为 true。这个操作将会在第一个 false 之后短路，也就是不会在发生 false 之后继续执行计算。</p>\n</blockquote>\n<h4 id=\"anyMatch-Predicate-：\"><code>anyMatch(Predicate)</code>：</h4>\n<blockquote>\n<p>如果流中的任意一个元素根据提供的 <code>Predicate</code> 返回 true 时，最终结果返回为 true。这个操作将会在第一个 true 之后短路，也就是不会在发生 true 之后继续执行计算。</p>\n</blockquote>\n<h4 id=\"noneMatch-Predicate-：\"><code>noneMatch(Predicate)</code>：</h4>\n<blockquote>\n<p>如果流的每个元素根据提供的 <code>Predicate</code> 都返回 false 时，最终结果返回为 true。这个操作将会在第一个 true 之后短路，也就是不会在发生 true 之后继续执行计算。</p>\n</blockquote>\n","excerpt":"","more":"<h1>JavaStream</h1>\n<h3 id=\"Stream\">Stream</h3>\n<blockquote>\n<p>Stream（流）是一个来自数据源的元素队列并支持聚合操作</p>\n</blockquote>\n<ul>\n<li>元素是特定类型的对象，形成一个队列。 Java中的Stream并不会存储元素，而是按需计算。</li>\n<li><strong>数据源</strong> 流的来源。 可以是集合，数组，I/O channel， 产生器generator 等。</li>\n<li><strong>聚合操作</strong> 类似SQL语句一样的操作， 比如filter, map, reduce, find, match, sorted等。</li>\n</ul>\n<p>Stream还有两个特征</p>\n<ul>\n<li><strong>Pipelining</strong>: 中间操作都会返回流对象本身。 这样多个操作可以串联成一个管道， 如同流式风格（fluent style）。 这样做可以对操作进行优化， 比如延迟执行(laziness)和短路( short-circuiting)。</li>\n<li><strong>内部迭代</strong>： 以前对集合遍历都是通过Iterator或者For-Each的方式, 显式的在集合外部进行迭代， 这叫做外部迭代。 Stream提供了内部迭代的方式， 通过访问者模式(Visitor)实现。</li>\n</ul>\n<h3 id=\"生成流\">生成流</h3>\n<ul>\n<li>stream() -为集合创建串行流。</li>\n<li>parallelStream() − 为集合创建并行流。</li>\n<li><code>Stream.of()</code> 从一堆对象中创建 Stream 流</li>\n</ul>\n<h3 id=\"数据处理\">数据处理</h3>\n<h4 id=\"map\">map</h4>\n<blockquote>\n<p>用于映射每个元素到对应的结果，可对当前元素进行数据处理</p>\n</blockquote>\n<h4 id=\"flatmap\">flatmap</h4>\n<blockquote>\n<p>将流的每个元素, 转换为其他对象的流,入参接受一个返回对象流的函数</p>\n</blockquote>\n<h4 id=\"filter（lamda表达式）\">filter（lamda表达式）</h4>\n<blockquote>\n<p>用于通过设置的条件过滤出元素(过滤条件对应的是留下的元素)</p>\n</blockquote>\n<h4 id=\"limit\">limit</h4>\n<blockquote>\n<p>用于获取指定数量的流</p>\n</blockquote>\n<h4 id=\"sorted\">sorted</h4>\n<blockquote>\n<p>用于对流进行排序，可以传入<strong>Comparator</strong>参数控制排序顺序</p>\n</blockquote>\n<h4 id=\"distinct\">distinct</h4>\n<blockquote>\n<p>用于消除流中的重复元素</p>\n</blockquote>\n<h4 id=\"isPrime\">isPrime()</h4>\n<blockquote>\n<p>用于检测是否是质数，是留下该元素</p>\n</blockquote>\n<h3 id=\"结束操作\">结束操作</h3>\n<h4 id=\"forEach-Consumer\">forEach(Consumer)</h4>\n<blockquote>\n<p>遍历迭代流中的每个元素，无返回值</p>\n</blockquote>\n<h4 id=\"forEachOrdered-Consumer\"><code>forEachOrdered(Consumer)</code></h4>\n<blockquote>\n<p>确保按照原始流的顺序执行。</p>\n</blockquote>\n<h4 id=\"collect-Collector\">collect(Collector)</h4>\n<blockquote>\n<p>使用 <code>Collector</code> 收集流元素到结果集合中</p>\n</blockquote>\n<h4 id=\"collect-Supplier-BiConsumer-BiConsumer\"><code>collect(Supplier, BiConsumer, BiConsumer)</code></h4>\n<blockquote>\n<p>收集流元素到结果集合中，第一个参数用于<strong>创建一个新的结果集合</strong>，第二个参数用于<strong>将下一个元素加入到现有结果合集中</strong>，第三个参数用于<strong>将两个结果合集合并</strong></p>\n</blockquote>\n<h2 id=\"匹配\">匹配</h2>\n<h4 id=\"allMatch-Predicate-：\"><code>allMatch(Predicate)</code> ：</h4>\n<blockquote>\n<p>如果流的每个元素根据提供的 <code>Predicate</code> 都返回 true 时，最终结果返回为 true。这个操作将会在第一个 false 之后短路，也就是不会在发生 false 之后继续执行计算。</p>\n</blockquote>\n<h4 id=\"anyMatch-Predicate-：\"><code>anyMatch(Predicate)</code>：</h4>\n<blockquote>\n<p>如果流中的任意一个元素根据提供的 <code>Predicate</code> 返回 true 时，最终结果返回为 true。这个操作将会在第一个 true 之后短路，也就是不会在发生 true 之后继续执行计算。</p>\n</blockquote>\n<h4 id=\"noneMatch-Predicate-：\"><code>noneMatch(Predicate)</code>：</h4>\n<blockquote>\n<p>如果流的每个元素根据提供的 <code>Predicate</code> 都返回 false 时，最终结果返回为 true。这个操作将会在第一个 true 之后短路，也就是不会在发生 true 之后继续执行计算。</p>\n</blockquote>\n"},{"title":"ThreadLocal","date":"2023-05-27T11:29:23.000Z","lastmod":"2023-05-29T14:47:04.000Z","_content":"\n# ThreadLocal\n\n## ThreadLocal\n\n　　ThreadLocal 提供线程局部变量，即为使用相同变量的每一个线程维护一个该变量的副本。当某些数据是以线程为作用域并且不同线程具有不同的数据副本的时候，就可以考虑采用 ThreadLocal，比如数据库连接 Connection，每个请求处理线程都需要，但又不相互影响，就是用 ThreadLocal 实现。\n\n### 为何要Entry使用用弱引用\n\n　　如果使用强引用,情况会如下:\n\n* ThreadLocalMap 作为 Thread 的成员变量,会随 Thread 一直保留。\n* ThreadLocalMap 的 key 是 ThreadLocal 对象,如果使用强引用,ThreadLocal 对象会被 ThreadLocalMap 强引用,无法被回收。\n* 而 ThreadLocal 对象可能是唯一对某个对象的引用,这会导致这个对象也无法被回收,发生内存泄露。\n\n　　使用弱引用可以避免这种情况:\n\n* 当 ThreadLocal 对象没有其他强引用时,由于 ThreadLocalMap 中的引用是弱引用,ThreadLocal 对象仍然可以被垃圾回收。\n* 垃圾回收 ThreadLocal 对象后,ThreadLocalMap 中对应的 Entry 的 key 变为 null。\n* 之后 ThreadLocalMap 在执行 get、set、remove 等操作时,会忽略 key 为 null 的 Entry,达到清理作用。\n* 这样就避免了 ThreadLocal 对象由于 ThreadLocalMap 的强引用而无法被回收的问题,解决了内存泄露。\n\n### ThreadLocal 内存泄漏条件\n\n　　ThreadLocal被回收&&线程被复用&&线程复用后不再调用ThreadLocal的set/get/remove方法 才可能 发生内存泄露（条件还是相对苛刻）\n","source":"_posts/java/Base/ThreadLocal.md","raw":"---\ntitle: ThreadLocal\ndate: 2023-05-27T19:29:23Z\nlastmod: 2023-05-29T22:47:04Z\n---\n\n# ThreadLocal\n\n## ThreadLocal\n\n　　ThreadLocal 提供线程局部变量，即为使用相同变量的每一个线程维护一个该变量的副本。当某些数据是以线程为作用域并且不同线程具有不同的数据副本的时候，就可以考虑采用 ThreadLocal，比如数据库连接 Connection，每个请求处理线程都需要，但又不相互影响，就是用 ThreadLocal 实现。\n\n### 为何要Entry使用用弱引用\n\n　　如果使用强引用,情况会如下:\n\n* ThreadLocalMap 作为 Thread 的成员变量,会随 Thread 一直保留。\n* ThreadLocalMap 的 key 是 ThreadLocal 对象,如果使用强引用,ThreadLocal 对象会被 ThreadLocalMap 强引用,无法被回收。\n* 而 ThreadLocal 对象可能是唯一对某个对象的引用,这会导致这个对象也无法被回收,发生内存泄露。\n\n　　使用弱引用可以避免这种情况:\n\n* 当 ThreadLocal 对象没有其他强引用时,由于 ThreadLocalMap 中的引用是弱引用,ThreadLocal 对象仍然可以被垃圾回收。\n* 垃圾回收 ThreadLocal 对象后,ThreadLocalMap 中对应的 Entry 的 key 变为 null。\n* 之后 ThreadLocalMap 在执行 get、set、remove 等操作时,会忽略 key 为 null 的 Entry,达到清理作用。\n* 这样就避免了 ThreadLocal 对象由于 ThreadLocalMap 的强引用而无法被回收的问题,解决了内存泄露。\n\n### ThreadLocal 内存泄漏条件\n\n　　ThreadLocal被回收&&线程被复用&&线程复用后不再调用ThreadLocal的set/get/remove方法 才可能 发生内存泄露（条件还是相对苛刻）\n","slug":"java-Base-ThreadLocal","published":1,"updated":"2025-04-20T00:08:55.546Z","_id":"cm9s3f40f002sbfg44me58uks","comments":1,"layout":"post","photos":[],"content":"<h1>ThreadLocal</h1>\n<h2 id=\"ThreadLocal\">ThreadLocal</h2>\n<p>ThreadLocal 提供线程局部变量，即为使用相同变量的每一个线程维护一个该变量的副本。当某些数据是以线程为作用域并且不同线程具有不同的数据副本的时候，就可以考虑采用 ThreadLocal，比如数据库连接 Connection，每个请求处理线程都需要，但又不相互影响，就是用 ThreadLocal 实现。</p>\n<h3 id=\"为何要Entry使用用弱引用\">为何要Entry使用用弱引用</h3>\n<p>如果使用强引用,情况会如下:</p>\n<ul>\n<li>ThreadLocalMap 作为 Thread 的成员变量,会随 Thread 一直保留。</li>\n<li>ThreadLocalMap 的 key 是 ThreadLocal 对象,如果使用强引用,ThreadLocal 对象会被 ThreadLocalMap 强引用,无法被回收。</li>\n<li>而 ThreadLocal 对象可能是唯一对某个对象的引用,这会导致这个对象也无法被回收,发生内存泄露。</li>\n</ul>\n<p>使用弱引用可以避免这种情况:</p>\n<ul>\n<li>当 ThreadLocal 对象没有其他强引用时,由于 ThreadLocalMap 中的引用是弱引用,ThreadLocal 对象仍然可以被垃圾回收。</li>\n<li>垃圾回收 ThreadLocal 对象后,ThreadLocalMap 中对应的 Entry 的 key 变为 null。</li>\n<li>之后 ThreadLocalMap 在执行 get、set、remove 等操作时,会忽略 key 为 null 的 Entry,达到清理作用。</li>\n<li>这样就避免了 ThreadLocal 对象由于 ThreadLocalMap 的强引用而无法被回收的问题,解决了内存泄露。</li>\n</ul>\n<h3 id=\"ThreadLocal-内存泄漏条件\">ThreadLocal 内存泄漏条件</h3>\n<p>ThreadLocal被回收&amp;&amp;线程被复用&amp;&amp;线程复用后不再调用ThreadLocal的set/get/remove方法 才可能 发生内存泄露（条件还是相对苛刻）</p>\n","excerpt":"","more":"<h1>ThreadLocal</h1>\n<h2 id=\"ThreadLocal\">ThreadLocal</h2>\n<p>ThreadLocal 提供线程局部变量，即为使用相同变量的每一个线程维护一个该变量的副本。当某些数据是以线程为作用域并且不同线程具有不同的数据副本的时候，就可以考虑采用 ThreadLocal，比如数据库连接 Connection，每个请求处理线程都需要，但又不相互影响，就是用 ThreadLocal 实现。</p>\n<h3 id=\"为何要Entry使用用弱引用\">为何要Entry使用用弱引用</h3>\n<p>如果使用强引用,情况会如下:</p>\n<ul>\n<li>ThreadLocalMap 作为 Thread 的成员变量,会随 Thread 一直保留。</li>\n<li>ThreadLocalMap 的 key 是 ThreadLocal 对象,如果使用强引用,ThreadLocal 对象会被 ThreadLocalMap 强引用,无法被回收。</li>\n<li>而 ThreadLocal 对象可能是唯一对某个对象的引用,这会导致这个对象也无法被回收,发生内存泄露。</li>\n</ul>\n<p>使用弱引用可以避免这种情况:</p>\n<ul>\n<li>当 ThreadLocal 对象没有其他强引用时,由于 ThreadLocalMap 中的引用是弱引用,ThreadLocal 对象仍然可以被垃圾回收。</li>\n<li>垃圾回收 ThreadLocal 对象后,ThreadLocalMap 中对应的 Entry 的 key 变为 null。</li>\n<li>之后 ThreadLocalMap 在执行 get、set、remove 等操作时,会忽略 key 为 null 的 Entry,达到清理作用。</li>\n<li>这样就避免了 ThreadLocal 对象由于 ThreadLocalMap 的强引用而无法被回收的问题,解决了内存泄露。</li>\n</ul>\n<h3 id=\"ThreadLocal-内存泄漏条件\">ThreadLocal 内存泄漏条件</h3>\n<p>ThreadLocal被回收&amp;&amp;线程被复用&amp;&amp;线程复用后不再调用ThreadLocal的set/get/remove方法 才可能 发生内存泄露（条件还是相对苛刻）</p>\n"},{"title":"Volatile","date":"2022-10-30T05:27:45.000Z","lastmod":"2023-05-27T10:46:40.000Z","_content":"\n# Volatile\n\n## Volatile的可见性和指令重排是如何实现的.内存模型的相关概念\n\n### 内存模型\n\n　　计算机在执行程序过程中，每条指令都是在CPU中执行的，而在执行过程中，程序的临时数据是放在主内存上的，此时就存在一个问题，CPU执行速度很快，从内存中读取和写入数据相比于CPU执行指令的速度慢很多，因此如果任何数据操作都需要和内存交互进行，会大大降低指令执行速度，因为在CPU中引入的高速缓存。\n也就是说当程序在运行过程中会先将运算的数据从主存中复制一份到CPU高速缓存中，CPU直接从高速缓存中获取数据和写入数据，运算结束后在将高速缓存中的数据刷新到内存中。这种操作在单核CPU中没有问题，但是在多核CPU中就存在问题。\n**例如**\n\n```java\ni = i + 1;\n```\n\n　　如果同时有2个线程执行这段代码，假如初始时i的值为0，那么我们希望两个线程执行完之后i的值变为2。但是事实会是这样吗？  \n可能存在下面一种情况：初始时，两个线程分别读取i的值存入各自所在的CPU的高速缓存当中，然后线程1进行加1操作，然后把i的最新值1写入到内存。此时线程2的高速缓存当中i的值还是0，进行加1操作之后，i的值为1，然后线程2把i的值写入内存。  \n最终结果i的值是1，而不是2。这就是著名的缓存一致性问题。通常称这种被多个线程访问的变量为共享变量。  \n也就是说，如果一个变量在多个CPU中都存在缓存（一般在多线程编程时才会出现），那么就可能存在缓存不一致的问题。  \n为了解决缓存不一致性问题，通常来说有以下2种解决方法（硬件层面上提供）：  \n1）通过在总线加LOCK​锁的方式\n\n　　​2）通过缓存一致性协议​​在早期的CPU当中，是通过在总线上加LOCK​锁的形式来解决缓存不一致的问题。因为CPU和其他部件进行通信都是通过总线来进行的，如果对总线加LOCK​锁的话，也就是说阻塞了其他CPU对其他部件访问（如内存），从而使得只能有一个CPU能使用这个变量的内存。比如上面例子中 如果一个线程在执行 i = i +1，如果在执行这段代码的过程中，在总线上发出了LCOK​锁的信号，那么只有等待这段代码完全执行完毕之后，其他CPU才能从变量i所在的内存读取变量，然后进行相应的操作。这样就解决了缓存不一致的问题。  \n但是上面的方式会有一个问题，由于在锁住总线期间，其他CPU无法访问内存，导致效率低下。  \n所以就出现了缓存一致性协议。最出名的就是Intel 的MESI协议，MESI协议保证了每个缓存中使用的共享变量的副本是一致的。它核心的思想是：当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。\n\n![](/assets/net-img-1639574230606-ee713d6a-1223-4275-bfaa-f60258aa6eea-20221030132914-2yfiwaf.jpeg)\n\n### Java内存模型\n\n> Java内存模型规定所有的变量都是存在主存当中（类似于前面说的物理内存），每个线程都有自己的工作内存（类似于前面的高速缓存）。线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作。并且每个线程不能访问其他线程的工作内存。\n\n#### java为确保原子性、可见性、有序性\n\n1. 原子性\n\n　　java中对基本类型的变量的读取和赋值操作是原子性的\n\n```java\nx = 10;         //语句1\ny = x;         //语句2\nx++;           //语句3\nx = x + 1;     //语句4\n```\n\n　　除了语句1之外都非原子性操作\n语句1是直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中。\n语句2实际上包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及 将x的值写入工作内存 这2个操作都是原子性操作，但是合起来就不是原子性操作了。\n同样的，x++和 x = x+1包括3个操作：读取x的值，进行加1操作，写入新的值。\n\n　　**注 **\n\n> **jvm32位 对于64位的基础类型long和double不是原子操作，而是分成两个32位操作**\n> **jvm64位 jdk8 未确定是否是分成两次操作，测试验证64位并未出现long和double非原子性问题**\n\n2. 可见性\n\n　　当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。\n而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。\n另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。\n\n3. 有序性\n\n　　在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。\n在Java里面，可以通过volatile关键字来保证一定的“有序性”（具体原理在下一节讲述）。另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。\n另外，Java内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为 happens-before 原则。如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。\n下面就来具体介绍下happens-before原则（先行发生原则）：\n\n- 程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作\n- 锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作\n- volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作\n- 传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C\n- 线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作\n- 线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生\n- 线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行\n- 对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始\n\n### volatile关键字\n\n1. **volatile关键字的两层语义**\n\n　　一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：\n1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。\n2）禁止进行指令重排序。\n\n> 用volatile修饰之后\n> 第一：使用volatile关键字会强制将修改的值立即写入主存；\n> 第二：使用volatile关键字的话，当线程2进行修改时，会导致线程1的工作内存中缓存变量stop的缓存行无效（反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效）；\n> 第三：由于线程1的工作内存中缓存变量stop的缓存行无效，所以线程1再次读取变量stop的值时会去主存读取。\n\n2. **volatile保证原子性吗**\n3. **volatile能保证有序性吗**\n4. **volatile的原理和实现机制**\n\n　　《深入理解Java虚拟机》：“观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令”  \nlock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能：  \n1）它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；  \n2）它会强制将对缓存的修改操作立即写入主存；  \n3）如果是写操作，它会导致其他CPU中对应的缓存行无效。  \n**参考**[https://www.cnblogs.com/dolphin0520/p/3920373.html](https://www.cnblogs.com/dolphin0520/p/3920373.html)\n\n　　[https://www.zhihu.com/question/296949412/answer/747494794](https://www.zhihu.com/question/296949412/answer/747494794)\n\n　　[https://blog.csdn.net/wll1228/article/details/107775976](https://blog.csdn.net/wll1228/article/details/107775976)\n\n　　‍\n","source":"_posts/java/Base/Volatile.md","raw":"---\ntitle: Volatile\ndate: 2022-10-30T13:27:45Z\nlastmod: 2023-05-27T18:46:40Z\n---\n\n# Volatile\n\n## Volatile的可见性和指令重排是如何实现的.内存模型的相关概念\n\n### 内存模型\n\n　　计算机在执行程序过程中，每条指令都是在CPU中执行的，而在执行过程中，程序的临时数据是放在主内存上的，此时就存在一个问题，CPU执行速度很快，从内存中读取和写入数据相比于CPU执行指令的速度慢很多，因此如果任何数据操作都需要和内存交互进行，会大大降低指令执行速度，因为在CPU中引入的高速缓存。\n也就是说当程序在运行过程中会先将运算的数据从主存中复制一份到CPU高速缓存中，CPU直接从高速缓存中获取数据和写入数据，运算结束后在将高速缓存中的数据刷新到内存中。这种操作在单核CPU中没有问题，但是在多核CPU中就存在问题。\n**例如**\n\n```java\ni = i + 1;\n```\n\n　　如果同时有2个线程执行这段代码，假如初始时i的值为0，那么我们希望两个线程执行完之后i的值变为2。但是事实会是这样吗？  \n可能存在下面一种情况：初始时，两个线程分别读取i的值存入各自所在的CPU的高速缓存当中，然后线程1进行加1操作，然后把i的最新值1写入到内存。此时线程2的高速缓存当中i的值还是0，进行加1操作之后，i的值为1，然后线程2把i的值写入内存。  \n最终结果i的值是1，而不是2。这就是著名的缓存一致性问题。通常称这种被多个线程访问的变量为共享变量。  \n也就是说，如果一个变量在多个CPU中都存在缓存（一般在多线程编程时才会出现），那么就可能存在缓存不一致的问题。  \n为了解决缓存不一致性问题，通常来说有以下2种解决方法（硬件层面上提供）：  \n1）通过在总线加LOCK​锁的方式\n\n　　​2）通过缓存一致性协议​​在早期的CPU当中，是通过在总线上加LOCK​锁的形式来解决缓存不一致的问题。因为CPU和其他部件进行通信都是通过总线来进行的，如果对总线加LOCK​锁的话，也就是说阻塞了其他CPU对其他部件访问（如内存），从而使得只能有一个CPU能使用这个变量的内存。比如上面例子中 如果一个线程在执行 i = i +1，如果在执行这段代码的过程中，在总线上发出了LCOK​锁的信号，那么只有等待这段代码完全执行完毕之后，其他CPU才能从变量i所在的内存读取变量，然后进行相应的操作。这样就解决了缓存不一致的问题。  \n但是上面的方式会有一个问题，由于在锁住总线期间，其他CPU无法访问内存，导致效率低下。  \n所以就出现了缓存一致性协议。最出名的就是Intel 的MESI协议，MESI协议保证了每个缓存中使用的共享变量的副本是一致的。它核心的思想是：当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。\n\n![](/assets/net-img-1639574230606-ee713d6a-1223-4275-bfaa-f60258aa6eea-20221030132914-2yfiwaf.jpeg)\n\n### Java内存模型\n\n> Java内存模型规定所有的变量都是存在主存当中（类似于前面说的物理内存），每个线程都有自己的工作内存（类似于前面的高速缓存）。线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作。并且每个线程不能访问其他线程的工作内存。\n\n#### java为确保原子性、可见性、有序性\n\n1. 原子性\n\n　　java中对基本类型的变量的读取和赋值操作是原子性的\n\n```java\nx = 10;         //语句1\ny = x;         //语句2\nx++;           //语句3\nx = x + 1;     //语句4\n```\n\n　　除了语句1之外都非原子性操作\n语句1是直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中。\n语句2实际上包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及 将x的值写入工作内存 这2个操作都是原子性操作，但是合起来就不是原子性操作了。\n同样的，x++和 x = x+1包括3个操作：读取x的值，进行加1操作，写入新的值。\n\n　　**注 **\n\n> **jvm32位 对于64位的基础类型long和double不是原子操作，而是分成两个32位操作**\n> **jvm64位 jdk8 未确定是否是分成两次操作，测试验证64位并未出现long和double非原子性问题**\n\n2. 可见性\n\n　　当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。\n而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。\n另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。\n\n3. 有序性\n\n　　在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。\n在Java里面，可以通过volatile关键字来保证一定的“有序性”（具体原理在下一节讲述）。另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。\n另外，Java内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为 happens-before 原则。如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。\n下面就来具体介绍下happens-before原则（先行发生原则）：\n\n- 程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作\n- 锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作\n- volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作\n- 传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C\n- 线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作\n- 线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生\n- 线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行\n- 对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始\n\n### volatile关键字\n\n1. **volatile关键字的两层语义**\n\n　　一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：\n1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。\n2）禁止进行指令重排序。\n\n> 用volatile修饰之后\n> 第一：使用volatile关键字会强制将修改的值立即写入主存；\n> 第二：使用volatile关键字的话，当线程2进行修改时，会导致线程1的工作内存中缓存变量stop的缓存行无效（反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效）；\n> 第三：由于线程1的工作内存中缓存变量stop的缓存行无效，所以线程1再次读取变量stop的值时会去主存读取。\n\n2. **volatile保证原子性吗**\n3. **volatile能保证有序性吗**\n4. **volatile的原理和实现机制**\n\n　　《深入理解Java虚拟机》：“观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令”  \nlock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能：  \n1）它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；  \n2）它会强制将对缓存的修改操作立即写入主存；  \n3）如果是写操作，它会导致其他CPU中对应的缓存行无效。  \n**参考**[https://www.cnblogs.com/dolphin0520/p/3920373.html](https://www.cnblogs.com/dolphin0520/p/3920373.html)\n\n　　[https://www.zhihu.com/question/296949412/answer/747494794](https://www.zhihu.com/question/296949412/answer/747494794)\n\n　　[https://blog.csdn.net/wll1228/article/details/107775976](https://blog.csdn.net/wll1228/article/details/107775976)\n\n　　‍\n","slug":"java-Base-Volatile","published":1,"updated":"2025-04-28T08:41:48.383Z","_id":"cm9s3f40g002tbfg47ps2fa45","comments":1,"layout":"post","photos":[],"content":"<h1>Volatile</h1>\n<h2 id=\"Volatile的可见性和指令重排是如何实现的-内存模型的相关概念\">Volatile的可见性和指令重排是如何实现的.内存模型的相关概念</h2>\n<h3 id=\"内存模型\">内存模型</h3>\n<p>计算机在执行程序过程中，每条指令都是在CPU中执行的，而在执行过程中，程序的临时数据是放在主内存上的，此时就存在一个问题，CPU执行速度很快，从内存中读取和写入数据相比于CPU执行指令的速度慢很多，因此如果任何数据操作都需要和内存交互进行，会大大降低指令执行速度，因为在CPU中引入的高速缓存。<br>\n也就是说当程序在运行过程中会先将运算的数据从主存中复制一份到CPU高速缓存中，CPU直接从高速缓存中获取数据和写入数据，运算结束后在将高速缓存中的数据刷新到内存中。这种操作在单核CPU中没有问题，但是在多核CPU中就存在问题。<br>\n<strong>例如</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">i = i + <span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\n<p>如果同时有2个线程执行这段代码，假如初始时i的值为0，那么我们希望两个线程执行完之后i的值变为2。但是事实会是这样吗？<br>\n可能存在下面一种情况：初始时，两个线程分别读取i的值存入各自所在的CPU的高速缓存当中，然后线程1进行加1操作，然后把i的最新值1写入到内存。此时线程2的高速缓存当中i的值还是0，进行加1操作之后，i的值为1，然后线程2把i的值写入内存。<br>\n最终结果i的值是1，而不是2。这就是著名的缓存一致性问题。通常称这种被多个线程访问的变量为共享变量。<br>\n也就是说，如果一个变量在多个CPU中都存在缓存（一般在多线程编程时才会出现），那么就可能存在缓存不一致的问题。<br>\n为了解决缓存不一致性问题，通常来说有以下2种解决方法（硬件层面上提供）：<br>\n1）通过在总线加LOCK​锁的方式</p>\n<p>​2）通过缓存一致性协议​​在早期的CPU当中，是通过在总线上加LOCK​锁的形式来解决缓存不一致的问题。因为CPU和其他部件进行通信都是通过总线来进行的，如果对总线加LOCK​锁的话，也就是说阻塞了其他CPU对其他部件访问（如内存），从而使得只能有一个CPU能使用这个变量的内存。比如上面例子中 如果一个线程在执行 i = i +1，如果在执行这段代码的过程中，在总线上发出了LCOK​锁的信号，那么只有等待这段代码完全执行完毕之后，其他CPU才能从变量i所在的内存读取变量，然后进行相应的操作。这样就解决了缓存不一致的问题。<br>\n但是上面的方式会有一个问题，由于在锁住总线期间，其他CPU无法访问内存，导致效率低下。<br>\n所以就出现了缓存一致性协议。最出名的就是Intel 的MESI协议，MESI协议保证了每个缓存中使用的共享变量的副本是一致的。它核心的思想是：当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。</p>\n<p><img src=\"/assets/net-img-1639574230606-ee713d6a-1223-4275-bfaa-f60258aa6eea-20221030132914-2yfiwaf.jpeg\" alt=\"\"></p>\n<h3 id=\"Java内存模型\">Java内存模型</h3>\n<blockquote>\n<p>Java内存模型规定所有的变量都是存在主存当中（类似于前面说的物理内存），每个线程都有自己的工作内存（类似于前面的高速缓存）。线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作。并且每个线程不能访问其他线程的工作内存。</p>\n</blockquote>\n<h4 id=\"java为确保原子性、可见性、有序性\">java为确保原子性、可见性、有序性</h4>\n<ol>\n<li>原子性</li>\n</ol>\n<p>java中对基本类型的变量的读取和赋值操作是原子性的</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x = <span class=\"number\">10</span>;         <span class=\"comment\">//语句1</span></span><br><span class=\"line\">y = x;         <span class=\"comment\">//语句2</span></span><br><span class=\"line\">x++;           <span class=\"comment\">//语句3</span></span><br><span class=\"line\">x = x + <span class=\"number\">1</span>;     <span class=\"comment\">//语句4</span></span><br></pre></td></tr></table></figure>\n<p>除了语句1之外都非原子性操作<br>\n语句1是直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中。<br>\n语句2实际上包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及 将x的值写入工作内存 这2个操作都是原子性操作，但是合起来就不是原子性操作了。<br>\n同样的，x++和 x = x+1包括3个操作：读取x的值，进行加1操作，写入新的值。</p>\n<p>**注 **</p>\n<blockquote>\n<p><strong>jvm32位 对于64位的基础类型long和double不是原子操作，而是分成两个32位操作</strong><br>\n<strong>jvm64位 jdk8 未确定是否是分成两次操作，测试验证64位并未出现long和double非原子性问题</strong></p>\n</blockquote>\n<ol start=\"2\">\n<li>可见性</li>\n</ol>\n<p>当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。<br>\n而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。<br>\n另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。</p>\n<ol start=\"3\">\n<li>有序性</li>\n</ol>\n<p>在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。<br>\n在Java里面，可以通过volatile关键字来保证一定的“有序性”（具体原理在下一节讲述）。另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。<br>\n另外，Java内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为 happens-before 原则。如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。<br>\n下面就来具体介绍下happens-before原则（先行发生原则）：</p>\n<ul>\n<li>程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作</li>\n<li>锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作</li>\n<li>volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作</li>\n<li>传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C</li>\n<li>线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作</li>\n<li>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生</li>\n<li>线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行</li>\n<li>对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始</li>\n</ul>\n<h3 id=\"volatile关键字\">volatile关键字</h3>\n<ol>\n<li><strong>volatile关键字的两层语义</strong></li>\n</ol>\n<p>一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：<br>\n1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。<br>\n2）禁止进行指令重排序。</p>\n<blockquote>\n<p>用volatile修饰之后<br>\n第一：使用volatile关键字会强制将修改的值立即写入主存；<br>\n第二：使用volatile关键字的话，当线程2进行修改时，会导致线程1的工作内存中缓存变量stop的缓存行无效（反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效）；<br>\n第三：由于线程1的工作内存中缓存变量stop的缓存行无效，所以线程1再次读取变量stop的值时会去主存读取。</p>\n</blockquote>\n<ol start=\"2\">\n<li><strong>volatile保证原子性吗</strong></li>\n<li><strong>volatile能保证有序性吗</strong></li>\n<li><strong>volatile的原理和实现机制</strong></li>\n</ol>\n<p>《深入理解Java虚拟机》：“观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令”<br>\nlock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能：<br>\n1）它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；<br>\n2）它会强制将对缓存的修改操作立即写入主存；<br>\n3）如果是写操作，它会导致其他CPU中对应的缓存行无效。<br>\n<strong>参考</strong><a href=\"https://www.cnblogs.com/dolphin0520/p/3920373.html\">https://www.cnblogs.com/dolphin0520/p/3920373.html</a></p>\n<p><a href=\"https://www.zhihu.com/question/296949412/answer/747494794\">https://www.zhihu.com/question/296949412/answer/747494794</a></p>\n<p><a href=\"https://blog.csdn.net/wll1228/article/details/107775976\">https://blog.csdn.net/wll1228/article/details/107775976</a></p>\n<p>‍</p>\n","excerpt":"","more":"<h1>Volatile</h1>\n<h2 id=\"Volatile的可见性和指令重排是如何实现的-内存模型的相关概念\">Volatile的可见性和指令重排是如何实现的.内存模型的相关概念</h2>\n<h3 id=\"内存模型\">内存模型</h3>\n<p>计算机在执行程序过程中，每条指令都是在CPU中执行的，而在执行过程中，程序的临时数据是放在主内存上的，此时就存在一个问题，CPU执行速度很快，从内存中读取和写入数据相比于CPU执行指令的速度慢很多，因此如果任何数据操作都需要和内存交互进行，会大大降低指令执行速度，因为在CPU中引入的高速缓存。<br>\n也就是说当程序在运行过程中会先将运算的数据从主存中复制一份到CPU高速缓存中，CPU直接从高速缓存中获取数据和写入数据，运算结束后在将高速缓存中的数据刷新到内存中。这种操作在单核CPU中没有问题，但是在多核CPU中就存在问题。<br>\n<strong>例如</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">i = i + <span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\n<p>如果同时有2个线程执行这段代码，假如初始时i的值为0，那么我们希望两个线程执行完之后i的值变为2。但是事实会是这样吗？<br>\n可能存在下面一种情况：初始时，两个线程分别读取i的值存入各自所在的CPU的高速缓存当中，然后线程1进行加1操作，然后把i的最新值1写入到内存。此时线程2的高速缓存当中i的值还是0，进行加1操作之后，i的值为1，然后线程2把i的值写入内存。<br>\n最终结果i的值是1，而不是2。这就是著名的缓存一致性问题。通常称这种被多个线程访问的变量为共享变量。<br>\n也就是说，如果一个变量在多个CPU中都存在缓存（一般在多线程编程时才会出现），那么就可能存在缓存不一致的问题。<br>\n为了解决缓存不一致性问题，通常来说有以下2种解决方法（硬件层面上提供）：<br>\n1）通过在总线加LOCK​锁的方式</p>\n<p>​2）通过缓存一致性协议​​在早期的CPU当中，是通过在总线上加LOCK​锁的形式来解决缓存不一致的问题。因为CPU和其他部件进行通信都是通过总线来进行的，如果对总线加LOCK​锁的话，也就是说阻塞了其他CPU对其他部件访问（如内存），从而使得只能有一个CPU能使用这个变量的内存。比如上面例子中 如果一个线程在执行 i = i +1，如果在执行这段代码的过程中，在总线上发出了LCOK​锁的信号，那么只有等待这段代码完全执行完毕之后，其他CPU才能从变量i所在的内存读取变量，然后进行相应的操作。这样就解决了缓存不一致的问题。<br>\n但是上面的方式会有一个问题，由于在锁住总线期间，其他CPU无法访问内存，导致效率低下。<br>\n所以就出现了缓存一致性协议。最出名的就是Intel 的MESI协议，MESI协议保证了每个缓存中使用的共享变量的副本是一致的。它核心的思想是：当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。</p>\n<p><img src=\"/assets/net-img-1639574230606-ee713d6a-1223-4275-bfaa-f60258aa6eea-20221030132914-2yfiwaf.jpeg\" alt=\"\"></p>\n<h3 id=\"Java内存模型\">Java内存模型</h3>\n<blockquote>\n<p>Java内存模型规定所有的变量都是存在主存当中（类似于前面说的物理内存），每个线程都有自己的工作内存（类似于前面的高速缓存）。线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作。并且每个线程不能访问其他线程的工作内存。</p>\n</blockquote>\n<h4 id=\"java为确保原子性、可见性、有序性\">java为确保原子性、可见性、有序性</h4>\n<ol>\n<li>原子性</li>\n</ol>\n<p>java中对基本类型的变量的读取和赋值操作是原子性的</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x = <span class=\"number\">10</span>;         <span class=\"comment\">//语句1</span></span><br><span class=\"line\">y = x;         <span class=\"comment\">//语句2</span></span><br><span class=\"line\">x++;           <span class=\"comment\">//语句3</span></span><br><span class=\"line\">x = x + <span class=\"number\">1</span>;     <span class=\"comment\">//语句4</span></span><br></pre></td></tr></table></figure>\n<p>除了语句1之外都非原子性操作<br>\n语句1是直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中。<br>\n语句2实际上包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及 将x的值写入工作内存 这2个操作都是原子性操作，但是合起来就不是原子性操作了。<br>\n同样的，x++和 x = x+1包括3个操作：读取x的值，进行加1操作，写入新的值。</p>\n<p>**注 **</p>\n<blockquote>\n<p><strong>jvm32位 对于64位的基础类型long和double不是原子操作，而是分成两个32位操作</strong><br>\n<strong>jvm64位 jdk8 未确定是否是分成两次操作，测试验证64位并未出现long和double非原子性问题</strong></p>\n</blockquote>\n<ol start=\"2\">\n<li>可见性</li>\n</ol>\n<p>当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。<br>\n而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。<br>\n另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。</p>\n<ol start=\"3\">\n<li>有序性</li>\n</ol>\n<p>在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。<br>\n在Java里面，可以通过volatile关键字来保证一定的“有序性”（具体原理在下一节讲述）。另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。<br>\n另外，Java内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为 happens-before 原则。如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。<br>\n下面就来具体介绍下happens-before原则（先行发生原则）：</p>\n<ul>\n<li>程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作</li>\n<li>锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作</li>\n<li>volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作</li>\n<li>传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C</li>\n<li>线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作</li>\n<li>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生</li>\n<li>线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行</li>\n<li>对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始</li>\n</ul>\n<h3 id=\"volatile关键字\">volatile关键字</h3>\n<ol>\n<li><strong>volatile关键字的两层语义</strong></li>\n</ol>\n<p>一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：<br>\n1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。<br>\n2）禁止进行指令重排序。</p>\n<blockquote>\n<p>用volatile修饰之后<br>\n第一：使用volatile关键字会强制将修改的值立即写入主存；<br>\n第二：使用volatile关键字的话，当线程2进行修改时，会导致线程1的工作内存中缓存变量stop的缓存行无效（反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效）；<br>\n第三：由于线程1的工作内存中缓存变量stop的缓存行无效，所以线程1再次读取变量stop的值时会去主存读取。</p>\n</blockquote>\n<ol start=\"2\">\n<li><strong>volatile保证原子性吗</strong></li>\n<li><strong>volatile能保证有序性吗</strong></li>\n<li><strong>volatile的原理和实现机制</strong></li>\n</ol>\n<p>《深入理解Java虚拟机》：“观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令”<br>\nlock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能：<br>\n1）它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；<br>\n2）它会强制将对缓存的修改操作立即写入主存；<br>\n3）如果是写操作，它会导致其他CPU中对应的缓存行无效。<br>\n<strong>参考</strong><a href=\"https://www.cnblogs.com/dolphin0520/p/3920373.html\">https://www.cnblogs.com/dolphin0520/p/3920373.html</a></p>\n<p><a href=\"https://www.zhihu.com/question/296949412/answer/747494794\">https://www.zhihu.com/question/296949412/answer/747494794</a></p>\n<p><a href=\"https://blog.csdn.net/wll1228/article/details/107775976\">https://blog.csdn.net/wll1228/article/details/107775976</a></p>\n<p>‍</p>\n"},{"title":"List","date":"2022-10-30T05:22:01.000Z","lastmod":"2023-05-27T07:43:26.000Z","_content":"\n# List\n\n---\n\n　　**List 集合的三个子类：**\n\n- ArrayList :底层数据结构是数组。线程不安全\n- LinkedList :底层数据结构是链表。线程不安全\n- Vector:底层数据结构是数组。线程安全\n\n## ArrayList\n\n### 简介\n\n- ArrayList 继承了 AbstractList，实现了 List。它是一个数组队列，提供了相关的添加、删除、修改、遍历等功能。\n- ArrayList 实现了 RandomAccess 接口， RandomAccess 是一个标志接口，表明实现这个这个接口的 List 集合是支持快速随机访问的。在 ArrayList 中，我们即可以通过元素的序号快速获取元素对象，这就是快速随机访问。\n- ArrayList 实现了 Cloneable 接口，即覆盖了函数 clone()，能被克隆。\n- ArrayList 实现 java.io.Serializable 接口，这意味着 ArrayList 支持序列化，能通过序列化去传输。\n- 和 Vector 不同，ArrayList 中的操作不是线程安全的！所以，建议在单线程中才使用 ArrayList，而在多线程中可以选择 Vector 或者 CopyOnWriteArrayList。\n\n### System.arraycopy()和 Arrays.copyOf()方法\n\n#### 两者联系与区别\n\n　　**联系：**\n\n　　看两者源代码可以发现 copyOf()内部调用了 System.arraycopy()方法\n\n　　**区别：**\n\n　　arraycopy()需要目标数组，将原数组拷贝到你自己定义的数组里，而且可以选择拷贝的起点和长度以及放入新数组中的位置\n\n　　copyOf()是系统自动在内部新建一个数组，并返回该数组。\n\n　　**注意的是：**\n\n- java 中的 length 属性是针对数组说的,比如说你声明了一个数组,想知道这个数组的长度则用到了 length 这个属性.\n- java 中的 length()方法是针对字 符串 String 说的,如果想看这个字符串的长度则用到 length()这个方法.\n- java 中的 size()方法是针对泛型集合说的,如果想看这个泛型有多少个元素,就调用此方法来查看!\n\n### 细节\n\n- ArrayList 是基于动态数组实现的，在增删时候，需要数组的拷贝复制。(navite 方法由 C/C++实现)\n- ArrayList 的默认初始化容量是 10，每次扩容时候增加原先容量的一半，也就是变为原来的 1.5 倍\n- 删除元素时不会减少容量，若希望减少容量则调用 trimToSize()\n- 它不是线程安全的。它能存放 null 值。\n\n## LinkedList\n\n### 简介\n\n> 底层实现是双向链表(双向链表方便实现往前遍历)\n> LinkedList 是一个实现了 List 接口和 Deque 接口的双端链表。 LinkedList 底层的链表结构使它支持高效的插入和删除操作，另外它实现了 Deque 接口，使得 LinkedList 类也具有队列的特性; LinkedList 不是线程安全的，如果想使 LinkedList 变成线程安全的，可以调用静态类 Collections 类中的 synchronizedList 方法：\n\n## Vector：\n\n- 底层是数组，现在已少用，被 ArrayList 替代，原因有两个：\n- Vector 所有方法都是同步，有性能损失。\n- Vector 初始 length 是 10 超过 length 时 以 100%比率增长，相比于 ArrayList 更多消耗内存。\n- ArrayList 在底层数组不够用时在原来的基础上扩展 0.5 倍，Vector 是扩展 1 倍。\n\n　　**总的来说：查询多用 ArrayList，增删多用 LinkedList。**\n\n　　ArrayList 增删慢不是绝对的(在数量大的情况下，已测试)：\n\n　　如果增加元素一直是使用 add()(增加到末尾)的话，那是 ArrayList 要快\n\n　　一直删除末尾的元素也是 ArrayList 要快【不用复制移动位置】\n\n　　至于如果删除的是中间的位置的话，还是 ArrayList 要快！\n\n## SkipList\n\n## CopyOnWriteArrayList\n\n　　‍\n\n### 适用场景\n\n* **读操作可以尽可能的快，而写即使慢一些也没关系**\n\n　　在很多应用场景中，读操作可能会远远多于写操作。比如，有些系统级别的信息，往往只需要加载或者修改很少的次数，但是会被系统内所有模块频繁的访问。对于这种场景，我们最希望看到的就是读操作可以尽可能的快，而写即使慢一些也没关系。\n\n* **读多写少**\n\n　　黑名单是最典型的场景，假如我们有一个搜索网站，用户在这个网站的搜索框中，输入关键字搜索内容，但是某些关键字不允许被搜索。这些不能被搜索的关键字会被放在一个黑名单中，黑名单并不需要实时更新，可能每天晚上更新一次就可以了。当用户搜索时，会检查当前关键字在不在黑名单中，如果在，则提示不能搜索。这种读多写少的场景也很适合使用 CopyOnWrite 集合。\n\n### 读写规则\n\n* **读写锁的规则**\n\n　　读写锁的思想是：读读共享、其他都互斥（写写互斥、读写互斥、写读互斥），原因是由于读操作不会修改原有的数据，因此并发读并不会有安全问题；而写操作是危险的，所以当写操作发生时，不允许有读操作加入，也不允许第二个写线程加入。\n\n* **对读写锁规则的升级**\n\n　　CopyOnWriteArrayList 的思想比读写锁的思想又更进一步。为了将读取的性能发挥到极致，CopyOnWriteArrayList 读取是完全不用加锁的，更厉害的是，**写入也不会阻塞读取操作，也就是说你可以在写入的同时进行读取**，只有写入和写入之间需要进行同步，也就是不允许多个写入同时发生，但是在写入发生时允许读取同时发生。这样一来，读操作的性能就会大幅度提升。\n\n### 特点\n\n* **CopyOnWrite的含义**\n\n　　从 CopyOnWriteArrayList 的名字就能看出它是满足 CopyOnWrite 的 ArrayList，CopyOnWrite 的意思是说，当容器需要被修改的时候，不直接修改当前容器，而是先将当前容器进行 Copy，复制出一个新的容器，然后修改新的容器，**完成修改之后，再将原容器的引用指向新的容器**。这样就完成了整个修改过程。\n\n　　这样做的好处是，CopyOnWriteArrayList 利用了“不变性”原理，因为容器每次修改都是创建新副本，所以对于旧容器来说，其实是不可变的，也是线程安全的，无需进一步的同步操作。我们可以对 CopyOnWrite 容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素，也不会有修改。\n\n　　CopyOnWriteArrayList 的所有修改操作（add，set等）都是通过创建底层数组的新副本来实现的，所以 CopyOnWrite 容器也是一种读写分离的思想体现，读和写使用不同的容器。\n\n* **迭代期间允许修改集合内容**\n\n　　ArrayList 在迭代期间如果修改集合的内容，会抛出 ConcurrentModificationException 异常。CopyOnWriteArrayList 的迭代器在迭代的时候，如果数组内容被修改了，CopyOnWriteArrayList 不会报 ConcurrentModificationException 的异常，因为迭代器使用的依然是旧数组，只不过迭代的内容可能已经过时了\n\n### 缺点\n\n　　这些缺点不仅是针对 CopyOnWriteArrayList，其实同样也适用于其他的 CopyOnWrite 容器：\n\n* **内存占用问题**\n\n　　因为 CopyOnWrite 的写时复制机制，所以在进行写操作的时候，内存里会同时驻扎两个对象的内存，这一点会占用额外的内存空间。\n\n* **在元素较多或者复杂的情况下，复制的开销很大**\n\n　　复制过程不仅会占用双倍内存，还需要消耗 CPU 等资源，会降低整体性能。\n\n* **数据一致性问题**\n\n　　由于 CopyOnWrite 容器的修改是先修改副本，所以这次修改对于其他线程来说，并不是实时能看到的，只有在修改完之后才能体现出来。如果你希望写入的的数据马上能被其他线程看到，CopyOnWrite 容器是不适用的。\n\n　　内部使用ReentrantLock 锁，用来保证修改操作的线程安全\n","source":"_posts/java/Collection/List.md","raw":"---\ntitle: List\ndate: 2022-10-30T13:22:01Z\nlastmod: 2023-05-27T15:43:26Z\n---\n\n# List\n\n---\n\n　　**List 集合的三个子类：**\n\n- ArrayList :底层数据结构是数组。线程不安全\n- LinkedList :底层数据结构是链表。线程不安全\n- Vector:底层数据结构是数组。线程安全\n\n## ArrayList\n\n### 简介\n\n- ArrayList 继承了 AbstractList，实现了 List。它是一个数组队列，提供了相关的添加、删除、修改、遍历等功能。\n- ArrayList 实现了 RandomAccess 接口， RandomAccess 是一个标志接口，表明实现这个这个接口的 List 集合是支持快速随机访问的。在 ArrayList 中，我们即可以通过元素的序号快速获取元素对象，这就是快速随机访问。\n- ArrayList 实现了 Cloneable 接口，即覆盖了函数 clone()，能被克隆。\n- ArrayList 实现 java.io.Serializable 接口，这意味着 ArrayList 支持序列化，能通过序列化去传输。\n- 和 Vector 不同，ArrayList 中的操作不是线程安全的！所以，建议在单线程中才使用 ArrayList，而在多线程中可以选择 Vector 或者 CopyOnWriteArrayList。\n\n### System.arraycopy()和 Arrays.copyOf()方法\n\n#### 两者联系与区别\n\n　　**联系：**\n\n　　看两者源代码可以发现 copyOf()内部调用了 System.arraycopy()方法\n\n　　**区别：**\n\n　　arraycopy()需要目标数组，将原数组拷贝到你自己定义的数组里，而且可以选择拷贝的起点和长度以及放入新数组中的位置\n\n　　copyOf()是系统自动在内部新建一个数组，并返回该数组。\n\n　　**注意的是：**\n\n- java 中的 length 属性是针对数组说的,比如说你声明了一个数组,想知道这个数组的长度则用到了 length 这个属性.\n- java 中的 length()方法是针对字 符串 String 说的,如果想看这个字符串的长度则用到 length()这个方法.\n- java 中的 size()方法是针对泛型集合说的,如果想看这个泛型有多少个元素,就调用此方法来查看!\n\n### 细节\n\n- ArrayList 是基于动态数组实现的，在增删时候，需要数组的拷贝复制。(navite 方法由 C/C++实现)\n- ArrayList 的默认初始化容量是 10，每次扩容时候增加原先容量的一半，也就是变为原来的 1.5 倍\n- 删除元素时不会减少容量，若希望减少容量则调用 trimToSize()\n- 它不是线程安全的。它能存放 null 值。\n\n## LinkedList\n\n### 简介\n\n> 底层实现是双向链表(双向链表方便实现往前遍历)\n> LinkedList 是一个实现了 List 接口和 Deque 接口的双端链表。 LinkedList 底层的链表结构使它支持高效的插入和删除操作，另外它实现了 Deque 接口，使得 LinkedList 类也具有队列的特性; LinkedList 不是线程安全的，如果想使 LinkedList 变成线程安全的，可以调用静态类 Collections 类中的 synchronizedList 方法：\n\n## Vector：\n\n- 底层是数组，现在已少用，被 ArrayList 替代，原因有两个：\n- Vector 所有方法都是同步，有性能损失。\n- Vector 初始 length 是 10 超过 length 时 以 100%比率增长，相比于 ArrayList 更多消耗内存。\n- ArrayList 在底层数组不够用时在原来的基础上扩展 0.5 倍，Vector 是扩展 1 倍。\n\n　　**总的来说：查询多用 ArrayList，增删多用 LinkedList。**\n\n　　ArrayList 增删慢不是绝对的(在数量大的情况下，已测试)：\n\n　　如果增加元素一直是使用 add()(增加到末尾)的话，那是 ArrayList 要快\n\n　　一直删除末尾的元素也是 ArrayList 要快【不用复制移动位置】\n\n　　至于如果删除的是中间的位置的话，还是 ArrayList 要快！\n\n## SkipList\n\n## CopyOnWriteArrayList\n\n　　‍\n\n### 适用场景\n\n* **读操作可以尽可能的快，而写即使慢一些也没关系**\n\n　　在很多应用场景中，读操作可能会远远多于写操作。比如，有些系统级别的信息，往往只需要加载或者修改很少的次数，但是会被系统内所有模块频繁的访问。对于这种场景，我们最希望看到的就是读操作可以尽可能的快，而写即使慢一些也没关系。\n\n* **读多写少**\n\n　　黑名单是最典型的场景，假如我们有一个搜索网站，用户在这个网站的搜索框中，输入关键字搜索内容，但是某些关键字不允许被搜索。这些不能被搜索的关键字会被放在一个黑名单中，黑名单并不需要实时更新，可能每天晚上更新一次就可以了。当用户搜索时，会检查当前关键字在不在黑名单中，如果在，则提示不能搜索。这种读多写少的场景也很适合使用 CopyOnWrite 集合。\n\n### 读写规则\n\n* **读写锁的规则**\n\n　　读写锁的思想是：读读共享、其他都互斥（写写互斥、读写互斥、写读互斥），原因是由于读操作不会修改原有的数据，因此并发读并不会有安全问题；而写操作是危险的，所以当写操作发生时，不允许有读操作加入，也不允许第二个写线程加入。\n\n* **对读写锁规则的升级**\n\n　　CopyOnWriteArrayList 的思想比读写锁的思想又更进一步。为了将读取的性能发挥到极致，CopyOnWriteArrayList 读取是完全不用加锁的，更厉害的是，**写入也不会阻塞读取操作，也就是说你可以在写入的同时进行读取**，只有写入和写入之间需要进行同步，也就是不允许多个写入同时发生，但是在写入发生时允许读取同时发生。这样一来，读操作的性能就会大幅度提升。\n\n### 特点\n\n* **CopyOnWrite的含义**\n\n　　从 CopyOnWriteArrayList 的名字就能看出它是满足 CopyOnWrite 的 ArrayList，CopyOnWrite 的意思是说，当容器需要被修改的时候，不直接修改当前容器，而是先将当前容器进行 Copy，复制出一个新的容器，然后修改新的容器，**完成修改之后，再将原容器的引用指向新的容器**。这样就完成了整个修改过程。\n\n　　这样做的好处是，CopyOnWriteArrayList 利用了“不变性”原理，因为容器每次修改都是创建新副本，所以对于旧容器来说，其实是不可变的，也是线程安全的，无需进一步的同步操作。我们可以对 CopyOnWrite 容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素，也不会有修改。\n\n　　CopyOnWriteArrayList 的所有修改操作（add，set等）都是通过创建底层数组的新副本来实现的，所以 CopyOnWrite 容器也是一种读写分离的思想体现，读和写使用不同的容器。\n\n* **迭代期间允许修改集合内容**\n\n　　ArrayList 在迭代期间如果修改集合的内容，会抛出 ConcurrentModificationException 异常。CopyOnWriteArrayList 的迭代器在迭代的时候，如果数组内容被修改了，CopyOnWriteArrayList 不会报 ConcurrentModificationException 的异常，因为迭代器使用的依然是旧数组，只不过迭代的内容可能已经过时了\n\n### 缺点\n\n　　这些缺点不仅是针对 CopyOnWriteArrayList，其实同样也适用于其他的 CopyOnWrite 容器：\n\n* **内存占用问题**\n\n　　因为 CopyOnWrite 的写时复制机制，所以在进行写操作的时候，内存里会同时驻扎两个对象的内存，这一点会占用额外的内存空间。\n\n* **在元素较多或者复杂的情况下，复制的开销很大**\n\n　　复制过程不仅会占用双倍内存，还需要消耗 CPU 等资源，会降低整体性能。\n\n* **数据一致性问题**\n\n　　由于 CopyOnWrite 容器的修改是先修改副本，所以这次修改对于其他线程来说，并不是实时能看到的，只有在修改完之后才能体现出来。如果你希望写入的的数据马上能被其他线程看到，CopyOnWrite 容器是不适用的。\n\n　　内部使用ReentrantLock 锁，用来保证修改操作的线程安全\n","slug":"java-Collection-List","published":1,"updated":"2025-04-20T00:08:55.548Z","_id":"cm9s3f40g002ubfg45fj24j57","comments":1,"layout":"post","photos":[],"content":"<h1>List</h1>\n<hr>\n<p><strong>List 集合的三个子类：</strong></p>\n<ul>\n<li>ArrayList :底层数据结构是数组。线程不安全</li>\n<li>LinkedList :底层数据结构是链表。线程不安全</li>\n<li>Vector:底层数据结构是数组。线程安全</li>\n</ul>\n<h2 id=\"ArrayList\">ArrayList</h2>\n<h3 id=\"简介\">简介</h3>\n<ul>\n<li>ArrayList 继承了 AbstractList，实现了 List。它是一个数组队列，提供了相关的添加、删除、修改、遍历等功能。</li>\n<li>ArrayList 实现了 RandomAccess 接口， RandomAccess 是一个标志接口，表明实现这个这个接口的 List 集合是支持快速随机访问的。在 ArrayList 中，我们即可以通过元素的序号快速获取元素对象，这就是快速随机访问。</li>\n<li>ArrayList 实现了 Cloneable 接口，即覆盖了函数 clone()，能被克隆。</li>\n<li>ArrayList 实现 java.io.Serializable 接口，这意味着 ArrayList 支持序列化，能通过序列化去传输。</li>\n<li>和 Vector 不同，ArrayList 中的操作不是线程安全的！所以，建议在单线程中才使用 ArrayList，而在多线程中可以选择 Vector 或者 CopyOnWriteArrayList。</li>\n</ul>\n<h3 id=\"System-arraycopy-和-Arrays-copyOf-方法\">System.arraycopy()和 Arrays.copyOf()方法</h3>\n<h4 id=\"两者联系与区别\">两者联系与区别</h4>\n<p><strong>联系：</strong></p>\n<p>看两者源代码可以发现 copyOf()内部调用了 System.arraycopy()方法</p>\n<p><strong>区别：</strong></p>\n<p>arraycopy()需要目标数组，将原数组拷贝到你自己定义的数组里，而且可以选择拷贝的起点和长度以及放入新数组中的位置</p>\n<p>copyOf()是系统自动在内部新建一个数组，并返回该数组。</p>\n<p><strong>注意的是：</strong></p>\n<ul>\n<li>java 中的 length 属性是针对数组说的,比如说你声明了一个数组,想知道这个数组的长度则用到了 length 这个属性.</li>\n<li>java 中的 length()方法是针对字 符串 String 说的,如果想看这个字符串的长度则用到 length()这个方法.</li>\n<li>java 中的 size()方法是针对泛型集合说的,如果想看这个泛型有多少个元素,就调用此方法来查看!</li>\n</ul>\n<h3 id=\"细节\">细节</h3>\n<ul>\n<li>ArrayList 是基于动态数组实现的，在增删时候，需要数组的拷贝复制。(navite 方法由 C/C++实现)</li>\n<li>ArrayList 的默认初始化容量是 10，每次扩容时候增加原先容量的一半，也就是变为原来的 1.5 倍</li>\n<li>删除元素时不会减少容量，若希望减少容量则调用 trimToSize()</li>\n<li>它不是线程安全的。它能存放 null 值。</li>\n</ul>\n<h2 id=\"LinkedList\">LinkedList</h2>\n<h3 id=\"简介-2\">简介</h3>\n<blockquote>\n<p>底层实现是双向链表(双向链表方便实现往前遍历)<br>\nLinkedList 是一个实现了 List 接口和 Deque 接口的双端链表。 LinkedList 底层的链表结构使它支持高效的插入和删除操作，另外它实现了 Deque 接口，使得 LinkedList 类也具有队列的特性; LinkedList 不是线程安全的，如果想使 LinkedList 变成线程安全的，可以调用静态类 Collections 类中的 synchronizedList 方法：</p>\n</blockquote>\n<h2 id=\"Vector：\">Vector：</h2>\n<ul>\n<li>底层是数组，现在已少用，被 ArrayList 替代，原因有两个：</li>\n<li>Vector 所有方法都是同步，有性能损失。</li>\n<li>Vector 初始 length 是 10 超过 length 时 以 100%比率增长，相比于 ArrayList 更多消耗内存。</li>\n<li>ArrayList 在底层数组不够用时在原来的基础上扩展 0.5 倍，Vector 是扩展 1 倍。</li>\n</ul>\n<p><strong>总的来说：查询多用 ArrayList，增删多用 LinkedList。</strong></p>\n<p>ArrayList 增删慢不是绝对的(在数量大的情况下，已测试)：</p>\n<p>如果增加元素一直是使用 add()(增加到末尾)的话，那是 ArrayList 要快</p>\n<p>一直删除末尾的元素也是 ArrayList 要快【不用复制移动位置】</p>\n<p>至于如果删除的是中间的位置的话，还是 ArrayList 要快！</p>\n<h2 id=\"SkipList\">SkipList</h2>\n<h2 id=\"CopyOnWriteArrayList\">CopyOnWriteArrayList</h2>\n<p>‍</p>\n<h3 id=\"适用场景\">适用场景</h3>\n<ul>\n<li><strong>读操作可以尽可能的快，而写即使慢一些也没关系</strong></li>\n</ul>\n<p>在很多应用场景中，读操作可能会远远多于写操作。比如，有些系统级别的信息，往往只需要加载或者修改很少的次数，但是会被系统内所有模块频繁的访问。对于这种场景，我们最希望看到的就是读操作可以尽可能的快，而写即使慢一些也没关系。</p>\n<ul>\n<li><strong>读多写少</strong></li>\n</ul>\n<p>黑名单是最典型的场景，假如我们有一个搜索网站，用户在这个网站的搜索框中，输入关键字搜索内容，但是某些关键字不允许被搜索。这些不能被搜索的关键字会被放在一个黑名单中，黑名单并不需要实时更新，可能每天晚上更新一次就可以了。当用户搜索时，会检查当前关键字在不在黑名单中，如果在，则提示不能搜索。这种读多写少的场景也很适合使用 CopyOnWrite 集合。</p>\n<h3 id=\"读写规则\">读写规则</h3>\n<ul>\n<li><strong>读写锁的规则</strong></li>\n</ul>\n<p>读写锁的思想是：读读共享、其他都互斥（写写互斥、读写互斥、写读互斥），原因是由于读操作不会修改原有的数据，因此并发读并不会有安全问题；而写操作是危险的，所以当写操作发生时，不允许有读操作加入，也不允许第二个写线程加入。</p>\n<ul>\n<li><strong>对读写锁规则的升级</strong></li>\n</ul>\n<p>CopyOnWriteArrayList 的思想比读写锁的思想又更进一步。为了将读取的性能发挥到极致，CopyOnWriteArrayList 读取是完全不用加锁的，更厉害的是，<strong>写入也不会阻塞读取操作，也就是说你可以在写入的同时进行读取</strong>，只有写入和写入之间需要进行同步，也就是不允许多个写入同时发生，但是在写入发生时允许读取同时发生。这样一来，读操作的性能就会大幅度提升。</p>\n<h3 id=\"特点\">特点</h3>\n<ul>\n<li><strong>CopyOnWrite的含义</strong></li>\n</ul>\n<p>从 CopyOnWriteArrayList 的名字就能看出它是满足 CopyOnWrite 的 ArrayList，CopyOnWrite 的意思是说，当容器需要被修改的时候，不直接修改当前容器，而是先将当前容器进行 Copy，复制出一个新的容器，然后修改新的容器，<strong>完成修改之后，再将原容器的引用指向新的容器</strong>。这样就完成了整个修改过程。</p>\n<p>这样做的好处是，CopyOnWriteArrayList 利用了“不变性”原理，因为容器每次修改都是创建新副本，所以对于旧容器来说，其实是不可变的，也是线程安全的，无需进一步的同步操作。我们可以对 CopyOnWrite 容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素，也不会有修改。</p>\n<p>CopyOnWriteArrayList 的所有修改操作（add，set等）都是通过创建底层数组的新副本来实现的，所以 CopyOnWrite 容器也是一种读写分离的思想体现，读和写使用不同的容器。</p>\n<ul>\n<li><strong>迭代期间允许修改集合内容</strong></li>\n</ul>\n<p>ArrayList 在迭代期间如果修改集合的内容，会抛出 ConcurrentModificationException 异常。CopyOnWriteArrayList 的迭代器在迭代的时候，如果数组内容被修改了，CopyOnWriteArrayList 不会报 ConcurrentModificationException 的异常，因为迭代器使用的依然是旧数组，只不过迭代的内容可能已经过时了</p>\n<h3 id=\"缺点\">缺点</h3>\n<p>这些缺点不仅是针对 CopyOnWriteArrayList，其实同样也适用于其他的 CopyOnWrite 容器：</p>\n<ul>\n<li><strong>内存占用问题</strong></li>\n</ul>\n<p>因为 CopyOnWrite 的写时复制机制，所以在进行写操作的时候，内存里会同时驻扎两个对象的内存，这一点会占用额外的内存空间。</p>\n<ul>\n<li><strong>在元素较多或者复杂的情况下，复制的开销很大</strong></li>\n</ul>\n<p>复制过程不仅会占用双倍内存，还需要消耗 CPU 等资源，会降低整体性能。</p>\n<ul>\n<li><strong>数据一致性问题</strong></li>\n</ul>\n<p>由于 CopyOnWrite 容器的修改是先修改副本，所以这次修改对于其他线程来说，并不是实时能看到的，只有在修改完之后才能体现出来。如果你希望写入的的数据马上能被其他线程看到，CopyOnWrite 容器是不适用的。</p>\n<p>内部使用ReentrantLock 锁，用来保证修改操作的线程安全</p>\n","excerpt":"","more":"<h1>List</h1>\n<hr>\n<p><strong>List 集合的三个子类：</strong></p>\n<ul>\n<li>ArrayList :底层数据结构是数组。线程不安全</li>\n<li>LinkedList :底层数据结构是链表。线程不安全</li>\n<li>Vector:底层数据结构是数组。线程安全</li>\n</ul>\n<h2 id=\"ArrayList\">ArrayList</h2>\n<h3 id=\"简介\">简介</h3>\n<ul>\n<li>ArrayList 继承了 AbstractList，实现了 List。它是一个数组队列，提供了相关的添加、删除、修改、遍历等功能。</li>\n<li>ArrayList 实现了 RandomAccess 接口， RandomAccess 是一个标志接口，表明实现这个这个接口的 List 集合是支持快速随机访问的。在 ArrayList 中，我们即可以通过元素的序号快速获取元素对象，这就是快速随机访问。</li>\n<li>ArrayList 实现了 Cloneable 接口，即覆盖了函数 clone()，能被克隆。</li>\n<li>ArrayList 实现 java.io.Serializable 接口，这意味着 ArrayList 支持序列化，能通过序列化去传输。</li>\n<li>和 Vector 不同，ArrayList 中的操作不是线程安全的！所以，建议在单线程中才使用 ArrayList，而在多线程中可以选择 Vector 或者 CopyOnWriteArrayList。</li>\n</ul>\n<h3 id=\"System-arraycopy-和-Arrays-copyOf-方法\">System.arraycopy()和 Arrays.copyOf()方法</h3>\n<h4 id=\"两者联系与区别\">两者联系与区别</h4>\n<p><strong>联系：</strong></p>\n<p>看两者源代码可以发现 copyOf()内部调用了 System.arraycopy()方法</p>\n<p><strong>区别：</strong></p>\n<p>arraycopy()需要目标数组，将原数组拷贝到你自己定义的数组里，而且可以选择拷贝的起点和长度以及放入新数组中的位置</p>\n<p>copyOf()是系统自动在内部新建一个数组，并返回该数组。</p>\n<p><strong>注意的是：</strong></p>\n<ul>\n<li>java 中的 length 属性是针对数组说的,比如说你声明了一个数组,想知道这个数组的长度则用到了 length 这个属性.</li>\n<li>java 中的 length()方法是针对字 符串 String 说的,如果想看这个字符串的长度则用到 length()这个方法.</li>\n<li>java 中的 size()方法是针对泛型集合说的,如果想看这个泛型有多少个元素,就调用此方法来查看!</li>\n</ul>\n<h3 id=\"细节\">细节</h3>\n<ul>\n<li>ArrayList 是基于动态数组实现的，在增删时候，需要数组的拷贝复制。(navite 方法由 C/C++实现)</li>\n<li>ArrayList 的默认初始化容量是 10，每次扩容时候增加原先容量的一半，也就是变为原来的 1.5 倍</li>\n<li>删除元素时不会减少容量，若希望减少容量则调用 trimToSize()</li>\n<li>它不是线程安全的。它能存放 null 值。</li>\n</ul>\n<h2 id=\"LinkedList\">LinkedList</h2>\n<h3 id=\"简介-2\">简介</h3>\n<blockquote>\n<p>底层实现是双向链表(双向链表方便实现往前遍历)<br>\nLinkedList 是一个实现了 List 接口和 Deque 接口的双端链表。 LinkedList 底层的链表结构使它支持高效的插入和删除操作，另外它实现了 Deque 接口，使得 LinkedList 类也具有队列的特性; LinkedList 不是线程安全的，如果想使 LinkedList 变成线程安全的，可以调用静态类 Collections 类中的 synchronizedList 方法：</p>\n</blockquote>\n<h2 id=\"Vector：\">Vector：</h2>\n<ul>\n<li>底层是数组，现在已少用，被 ArrayList 替代，原因有两个：</li>\n<li>Vector 所有方法都是同步，有性能损失。</li>\n<li>Vector 初始 length 是 10 超过 length 时 以 100%比率增长，相比于 ArrayList 更多消耗内存。</li>\n<li>ArrayList 在底层数组不够用时在原来的基础上扩展 0.5 倍，Vector 是扩展 1 倍。</li>\n</ul>\n<p><strong>总的来说：查询多用 ArrayList，增删多用 LinkedList。</strong></p>\n<p>ArrayList 增删慢不是绝对的(在数量大的情况下，已测试)：</p>\n<p>如果增加元素一直是使用 add()(增加到末尾)的话，那是 ArrayList 要快</p>\n<p>一直删除末尾的元素也是 ArrayList 要快【不用复制移动位置】</p>\n<p>至于如果删除的是中间的位置的话，还是 ArrayList 要快！</p>\n<h2 id=\"SkipList\">SkipList</h2>\n<h2 id=\"CopyOnWriteArrayList\">CopyOnWriteArrayList</h2>\n<p>‍</p>\n<h3 id=\"适用场景\">适用场景</h3>\n<ul>\n<li><strong>读操作可以尽可能的快，而写即使慢一些也没关系</strong></li>\n</ul>\n<p>在很多应用场景中，读操作可能会远远多于写操作。比如，有些系统级别的信息，往往只需要加载或者修改很少的次数，但是会被系统内所有模块频繁的访问。对于这种场景，我们最希望看到的就是读操作可以尽可能的快，而写即使慢一些也没关系。</p>\n<ul>\n<li><strong>读多写少</strong></li>\n</ul>\n<p>黑名单是最典型的场景，假如我们有一个搜索网站，用户在这个网站的搜索框中，输入关键字搜索内容，但是某些关键字不允许被搜索。这些不能被搜索的关键字会被放在一个黑名单中，黑名单并不需要实时更新，可能每天晚上更新一次就可以了。当用户搜索时，会检查当前关键字在不在黑名单中，如果在，则提示不能搜索。这种读多写少的场景也很适合使用 CopyOnWrite 集合。</p>\n<h3 id=\"读写规则\">读写规则</h3>\n<ul>\n<li><strong>读写锁的规则</strong></li>\n</ul>\n<p>读写锁的思想是：读读共享、其他都互斥（写写互斥、读写互斥、写读互斥），原因是由于读操作不会修改原有的数据，因此并发读并不会有安全问题；而写操作是危险的，所以当写操作发生时，不允许有读操作加入，也不允许第二个写线程加入。</p>\n<ul>\n<li><strong>对读写锁规则的升级</strong></li>\n</ul>\n<p>CopyOnWriteArrayList 的思想比读写锁的思想又更进一步。为了将读取的性能发挥到极致，CopyOnWriteArrayList 读取是完全不用加锁的，更厉害的是，<strong>写入也不会阻塞读取操作，也就是说你可以在写入的同时进行读取</strong>，只有写入和写入之间需要进行同步，也就是不允许多个写入同时发生，但是在写入发生时允许读取同时发生。这样一来，读操作的性能就会大幅度提升。</p>\n<h3 id=\"特点\">特点</h3>\n<ul>\n<li><strong>CopyOnWrite的含义</strong></li>\n</ul>\n<p>从 CopyOnWriteArrayList 的名字就能看出它是满足 CopyOnWrite 的 ArrayList，CopyOnWrite 的意思是说，当容器需要被修改的时候，不直接修改当前容器，而是先将当前容器进行 Copy，复制出一个新的容器，然后修改新的容器，<strong>完成修改之后，再将原容器的引用指向新的容器</strong>。这样就完成了整个修改过程。</p>\n<p>这样做的好处是，CopyOnWriteArrayList 利用了“不变性”原理，因为容器每次修改都是创建新副本，所以对于旧容器来说，其实是不可变的，也是线程安全的，无需进一步的同步操作。我们可以对 CopyOnWrite 容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素，也不会有修改。</p>\n<p>CopyOnWriteArrayList 的所有修改操作（add，set等）都是通过创建底层数组的新副本来实现的，所以 CopyOnWrite 容器也是一种读写分离的思想体现，读和写使用不同的容器。</p>\n<ul>\n<li><strong>迭代期间允许修改集合内容</strong></li>\n</ul>\n<p>ArrayList 在迭代期间如果修改集合的内容，会抛出 ConcurrentModificationException 异常。CopyOnWriteArrayList 的迭代器在迭代的时候，如果数组内容被修改了，CopyOnWriteArrayList 不会报 ConcurrentModificationException 的异常，因为迭代器使用的依然是旧数组，只不过迭代的内容可能已经过时了</p>\n<h3 id=\"缺点\">缺点</h3>\n<p>这些缺点不仅是针对 CopyOnWriteArrayList，其实同样也适用于其他的 CopyOnWrite 容器：</p>\n<ul>\n<li><strong>内存占用问题</strong></li>\n</ul>\n<p>因为 CopyOnWrite 的写时复制机制，所以在进行写操作的时候，内存里会同时驻扎两个对象的内存，这一点会占用额外的内存空间。</p>\n<ul>\n<li><strong>在元素较多或者复杂的情况下，复制的开销很大</strong></li>\n</ul>\n<p>复制过程不仅会占用双倍内存，还需要消耗 CPU 等资源，会降低整体性能。</p>\n<ul>\n<li><strong>数据一致性问题</strong></li>\n</ul>\n<p>由于 CopyOnWrite 容器的修改是先修改副本，所以这次修改对于其他线程来说，并不是实时能看到的，只有在修改完之后才能体现出来。如果你希望写入的的数据马上能被其他线程看到，CopyOnWrite 容器是不适用的。</p>\n<p>内部使用ReentrantLock 锁，用来保证修改操作的线程安全</p>\n"},{"title":"Map","date":"2022-10-30T05:21:46.000Z","lastmod":"2022-10-30T05:21:46.000Z","_content":"\n# Map\n\n## HashMap\n\n　　JDK1.8 之前 HashMap 底层是 **数组和链表** 结合在一起使用也就是 **链表散列**。HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash 值，然后通过 (n - 1) & hash 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。\n\n　　所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。\n\n### JDK1.8 之前\n\n　　“拉链法” 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。\n\n### JDK1.8 之后\n\n　　当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。\n\n![](/assets/net-img-1591690908749-8d13658b-f28f-4a16-9787-5d802366b2bb-20221030132339-jhzqts2.png)\n\n> TreeMap、TreeSet 以及 JDK1.8 之后的 HashMap 底层都用到了红黑树。红黑树就是为了解决二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构。\n\n## ConcurrentHashMap\n\n　　1.8及之后\n\n> 1. 用table保存数据，锁的粒度更小，减少并发冲突的概率。采用table数组元素作为锁，从而实现了对每一行数据进行加锁，进一步减少并发冲突的概率，并发控制使用Synchronized和CAS来操作。\n> 2. 存储数据时采用了数组+ 链表+红黑树的形式。\n\n1. CurrentHashMap重要参数：\n\n```java\nprivate static final int MAXIMUM_CAPACITY = 1 << 30; // 数组的最大值 \n\nprivate static final int DEFAULT_CAPACITY = 16; // 默认数组长度 \n\nstatic final int TREEIFY_THRESHOLD = 8; // 链表转红黑树的一个条件 \n\nstatic final int UNTREEIFY_THRESHOLD = 6; // 红黑树转链表的一个条件 \n\nstatic final int MIN_TREEIFY_CAPACITY = 64; // 链表转红黑树的另一个条件\n\nstatic final int MOVED     = -1;  // 表示正在扩容转移 \n\nstatic final int TREEBIN   = -2; // 表示已经转换成树 \n\nstatic final int RESERVED  = -3; // hash for transient reservations \n\nstatic final int HASH_BITS = 0x7fffffff; // 获得hash值的辅助参数\n\ntransient volatile Node<K,V>[] table;// 默认没初始化的数组，用来保存元素 \n\nprivate transient volatile Node<K,V>[] nextTable; // 转移的时候用的数组 \n\nstatic final int NCPU = Runtime.getRuntime().availableProcessors();// 获取可用的CPU个数 \n\nprivate transient volatile Node<K,V>[] nextTable; // 连接表，用于哈希表扩容，扩容完成后会被重置为 null \n\nprivate transient volatile long baseCount; //保存着整个哈希表中存储的所有的结点的个数总和，有点类似于 HashMap 的 size 属性。\nprivate transient volatile int sizeCtl; \n//sizeCtl = 0：表示没有指定初始容量\n//sizeCtl > 0：表示初始容量(可以使用阶段)\n//sizeCtl = -1,标记作用，告知其他线程，正在初始化\n//sizeCtl = 0.75n ,扩容阈值\n//sizeCtl < 0 : 表示有其他线程正在执行扩容or初始化(不能使用阶段)\n//sizeCtl = (resizeStamp(n) << RESIZE_STAMP_SHIFT) + 2 :表示此时只有一个线程在执行扩容\n```\n\n2. 扩容机制\n\n> - nextTable: 扩容期间，将元素迁移到 nextTable 新Map, nextTable是共享变量。\n> - sizeCtl: 多线程之间，sizeCtl来判断ConcurrentHashMap当前所处的状态。\n>   - 通过CAS设置sizeCtl属性，告知其他线程ConcurrentHashMap的状态变更。\n> - transferIndex: 扩容索引，表示已经完成数据分配的table数组索引位置。\n>   - 数据转移已经到了哪个位置? 其他线程根据这个值帮助扩容从这个索引位置继续转移数据\n> - ForwardingNode节点: 标记作用,表示此节点已经扩容完毕，hash值等于-1\n>   - 数组位置的数据已经被转移到新Map中,此位置就会被设置为这个属性\n>   - 这个属性包装了新Map,可以用find方法取扩容转移后的值\n\n　　**扩容流程：**\n\n- 线程执行put操作，发现容量已经达到扩容阈值，需要进行扩容操作\n- 扩容线程A 以CAS机制修改`transferindex`值,然后按照降序迁移数据,`transferindex`是数组尾部的索引\n  - `transferindex`的初始值: 新数组的长度 - 1 -> 就是数组的最后一位\n- 迁移hash桶时，会将桶内的链表或者红黑树，按照一定算法，拆分成2份，将其插入`nextTable[i]`和`nextTable[i+n]`（n是之前table数组的长度）。\n  - 扩容后重新计算的hash值与之前hash值一样,则存放位置不变\n  - 重新计算的hash值与之前hash值不一样,则存放再索引i +n处(之前的数组长度 + 计算的索引)\n- 迁移完毕的hash桶,都会被设置成`ForwardingNode`节点，以此告知访问此桶的其他线程，此节点已经迁移完毕,但数据并没有全部迁移完成。\n- 此时线程2访问到了`ForwardingNode`节点，如果线程2执行的put或remove等写操作，那么就会先帮其扩容。\n  - 如果线程2执行的是get等读方法，则会调用`ForwardingNode`的find方法，去`nextTable`里面查找相关元素。\n\n3. put\n\n> put操作采用 CAS + synchronized 实现并发插入或更新操作\n\n```java\n// Node 节点的 hash值在HashMap中存储的就是hash值，在currenthashmap中可能有多种情况哦！\n/** Implementation for put and putIfAbsent */\n    final V putVal(K key, V value, boolean onlyIfAbsent) {\n        if (key == null || value == null) throw new NullPointerException();\n        int hash = spread(key.hashCode());// 最终hash值计算\n        int binCount = 0;\n        for (Node<K,V>[] tab = table;;) { //循环表\n            Node<K,V> f; int n, i, fh; K fk; V fv;\n            if (tab == null || (n = tab.length) == 0)\n                tab = initTable(); // 初始化表 如果为空,懒汉式\n            else if ((f = tabAt(tab, i = (n - 1) & hash)) == null) {\n                //// 如果对应桶位置为空\n                if (casTabAt(tab, i, null, new Node<K,V>(hash, key, value)))\n                    break;                    // CAS 原子性的尝试插入\n            }\n            else if ((fh = f.hash) == MOVED)\n                //f.hash == MOVED 表示为：ForwardingNode，说明其他线程正在扩容\n                //并且这个数组的位置数据已经转移到新的数组结构中\n                //但是数据还没有全部转移完成,帮助线程先扩容\n                // 如果当前节点正在扩容。还要帮着去扩容 \n                tab = helpTransfer(tab, f);\n            else if (onlyIfAbsent //jdk 检查第一个节点 是否已存在key 存在返回对应value值 check first node without acquiring lock\n                     && fh == hash\n                     && ((fk = f.key) == key || (fk != null && key.equals(fk)))\n                     && (fv = f.val) != null)\n                return fv;\n            else {\n                V oldVal = null;//桶存在数据 加锁操作进行处理\n                synchronized (f) {\n                    if (tabAt(tab, i) == f) {\n                        if (fh >= 0) {// 如果存储的是链表 存储的是节点的hash值\n                            binCount = 1;\n                            for (Node<K,V> e = f;; ++binCount) {\n                                K ek;\n                                // 遍历链表去查找，如果找到key 选择性覆盖\n                                if (e.hash == hash &&\n                                    ((ek = e.key) == key ||\n                                     (ek != null && key.equals(ek)))) {\n                                    oldVal = e.val;\n                                    if (!onlyIfAbsent)\n                                        e.val = value;\n                                    break;\n                                }\n                                Node<K,V> pred = e;\n                                if ((e = e.next) == null) {// 找到尾部插入\n                                    pred.next = new Node<K,V>(hash, key, value);\n                                    break;\n                                }\n                            }\n                        }\n                        else if (f instanceof TreeBin) {// 如果桶节点类型为TreeBin\n                            Node<K,V> p;\n                            binCount = 2;\n                            if ((p = ((TreeBin<K,V>)f).putTreeVal(hash, key,\n                                                           value)) != null) {\n                                 // 尝试红黑树插入，同时也要防止节点本来就有，选择性覆盖\n                                oldVal = p.val;\n                                if (!onlyIfAbsent)\n                                    p.val = value;\n                            }\n                        }\n                        else if (f instanceof ReservationNode)\n                            throw new IllegalStateException(\"Recursive update\");\n                    }\n                }\n                if (binCount != 0) {// 如果链表数量\n                    if (binCount >= TREEIFY_THRESHOLD)\n                        treeifyBin(tab, i);//  链表转红黑树哦！\n                    if (oldVal != null)\n                        return oldVal;\n                    break;\n                }\n            }\n        }\n        addCount(1L, binCount); // 统计大小 并且检查是否要扩容。\n        return null;\n    }\n```\n\n　　涉及到重要函数initTable、tabAt、casTabAt、helpTransfer、putTreeVal、treeifyBin、addCount函数。\n\n3. initTable\n\n>  **「只允许一个线程」** 对表进行初始化，如果不巧有其他线程进来了，那么会让其他线程交出 CPU 等待下次系统调度Thread.yield。这样，保证了表同时只会被一个线程初始化，对于table的大小，会根据sizeCtl的值进行设置，如果没有设置szieCtl的值，那么默认生成的table大小为16，否则，会根据sizeCtl的大小设置table大小。\n\n```java\n// 容器初始化 操作\nprivate final Node<K,V>[] initTable() {\n    Node<K,V>[] tab; int sc;\n    while ((tab = table)  null || tab.length  0) {\n        if ((sc = sizeCtl) < 0) // 如果正在初始化-1，-N 正在扩容。\n            Thread.yield(); // 进行线程让步等待\n     // 让掉当前线程 CPU 的时间片，使正在运行中的线程重新变成就绪状态，并重新竞争 CPU 的调度权。\n     // 它可能会获取到，也有可能被其他线程获取到。\n        else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) { \n          //  比较sizeCtl的值与sc是否相等，相等则用 -1 替换,这表明我这个线程在进行初始化了！\n            try {\n                if ((tab = table)  null || tab.length  0) {\n                    int n = (sc > 0) ? sc : DEFAULT_CAPACITY; // 默认为16\n                    @SuppressWarnings(\"unchecked\")\n                    Node<K,V>[] nt = (Node<K,V>[])new Node<?,?>[n];\n                    table = tab = nt;\n                    sc = n - (n >>> 2); \n                }\n            } finally {\n                sizeCtl = sc; //设置sizeCtl 类似threshold\n            }\n            break;\n        }\n    }\n    return tab;\n}\n```\n","source":"_posts/java/Collection/Map.md","raw":"---\ntitle: Map\ndate: 2022-10-30T13:21:46Z\nlastmod: 2022-10-30T13:21:46Z\n---\n\n# Map\n\n## HashMap\n\n　　JDK1.8 之前 HashMap 底层是 **数组和链表** 结合在一起使用也就是 **链表散列**。HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash 值，然后通过 (n - 1) & hash 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。\n\n　　所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。\n\n### JDK1.8 之前\n\n　　“拉链法” 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。\n\n### JDK1.8 之后\n\n　　当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。\n\n![](/assets/net-img-1591690908749-8d13658b-f28f-4a16-9787-5d802366b2bb-20221030132339-jhzqts2.png)\n\n> TreeMap、TreeSet 以及 JDK1.8 之后的 HashMap 底层都用到了红黑树。红黑树就是为了解决二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构。\n\n## ConcurrentHashMap\n\n　　1.8及之后\n\n> 1. 用table保存数据，锁的粒度更小，减少并发冲突的概率。采用table数组元素作为锁，从而实现了对每一行数据进行加锁，进一步减少并发冲突的概率，并发控制使用Synchronized和CAS来操作。\n> 2. 存储数据时采用了数组+ 链表+红黑树的形式。\n\n1. CurrentHashMap重要参数：\n\n```java\nprivate static final int MAXIMUM_CAPACITY = 1 << 30; // 数组的最大值 \n\nprivate static final int DEFAULT_CAPACITY = 16; // 默认数组长度 \n\nstatic final int TREEIFY_THRESHOLD = 8; // 链表转红黑树的一个条件 \n\nstatic final int UNTREEIFY_THRESHOLD = 6; // 红黑树转链表的一个条件 \n\nstatic final int MIN_TREEIFY_CAPACITY = 64; // 链表转红黑树的另一个条件\n\nstatic final int MOVED     = -1;  // 表示正在扩容转移 \n\nstatic final int TREEBIN   = -2; // 表示已经转换成树 \n\nstatic final int RESERVED  = -3; // hash for transient reservations \n\nstatic final int HASH_BITS = 0x7fffffff; // 获得hash值的辅助参数\n\ntransient volatile Node<K,V>[] table;// 默认没初始化的数组，用来保存元素 \n\nprivate transient volatile Node<K,V>[] nextTable; // 转移的时候用的数组 \n\nstatic final int NCPU = Runtime.getRuntime().availableProcessors();// 获取可用的CPU个数 \n\nprivate transient volatile Node<K,V>[] nextTable; // 连接表，用于哈希表扩容，扩容完成后会被重置为 null \n\nprivate transient volatile long baseCount; //保存着整个哈希表中存储的所有的结点的个数总和，有点类似于 HashMap 的 size 属性。\nprivate transient volatile int sizeCtl; \n//sizeCtl = 0：表示没有指定初始容量\n//sizeCtl > 0：表示初始容量(可以使用阶段)\n//sizeCtl = -1,标记作用，告知其他线程，正在初始化\n//sizeCtl = 0.75n ,扩容阈值\n//sizeCtl < 0 : 表示有其他线程正在执行扩容or初始化(不能使用阶段)\n//sizeCtl = (resizeStamp(n) << RESIZE_STAMP_SHIFT) + 2 :表示此时只有一个线程在执行扩容\n```\n\n2. 扩容机制\n\n> - nextTable: 扩容期间，将元素迁移到 nextTable 新Map, nextTable是共享变量。\n> - sizeCtl: 多线程之间，sizeCtl来判断ConcurrentHashMap当前所处的状态。\n>   - 通过CAS设置sizeCtl属性，告知其他线程ConcurrentHashMap的状态变更。\n> - transferIndex: 扩容索引，表示已经完成数据分配的table数组索引位置。\n>   - 数据转移已经到了哪个位置? 其他线程根据这个值帮助扩容从这个索引位置继续转移数据\n> - ForwardingNode节点: 标记作用,表示此节点已经扩容完毕，hash值等于-1\n>   - 数组位置的数据已经被转移到新Map中,此位置就会被设置为这个属性\n>   - 这个属性包装了新Map,可以用find方法取扩容转移后的值\n\n　　**扩容流程：**\n\n- 线程执行put操作，发现容量已经达到扩容阈值，需要进行扩容操作\n- 扩容线程A 以CAS机制修改`transferindex`值,然后按照降序迁移数据,`transferindex`是数组尾部的索引\n  - `transferindex`的初始值: 新数组的长度 - 1 -> 就是数组的最后一位\n- 迁移hash桶时，会将桶内的链表或者红黑树，按照一定算法，拆分成2份，将其插入`nextTable[i]`和`nextTable[i+n]`（n是之前table数组的长度）。\n  - 扩容后重新计算的hash值与之前hash值一样,则存放位置不变\n  - 重新计算的hash值与之前hash值不一样,则存放再索引i +n处(之前的数组长度 + 计算的索引)\n- 迁移完毕的hash桶,都会被设置成`ForwardingNode`节点，以此告知访问此桶的其他线程，此节点已经迁移完毕,但数据并没有全部迁移完成。\n- 此时线程2访问到了`ForwardingNode`节点，如果线程2执行的put或remove等写操作，那么就会先帮其扩容。\n  - 如果线程2执行的是get等读方法，则会调用`ForwardingNode`的find方法，去`nextTable`里面查找相关元素。\n\n3. put\n\n> put操作采用 CAS + synchronized 实现并发插入或更新操作\n\n```java\n// Node 节点的 hash值在HashMap中存储的就是hash值，在currenthashmap中可能有多种情况哦！\n/** Implementation for put and putIfAbsent */\n    final V putVal(K key, V value, boolean onlyIfAbsent) {\n        if (key == null || value == null) throw new NullPointerException();\n        int hash = spread(key.hashCode());// 最终hash值计算\n        int binCount = 0;\n        for (Node<K,V>[] tab = table;;) { //循环表\n            Node<K,V> f; int n, i, fh; K fk; V fv;\n            if (tab == null || (n = tab.length) == 0)\n                tab = initTable(); // 初始化表 如果为空,懒汉式\n            else if ((f = tabAt(tab, i = (n - 1) & hash)) == null) {\n                //// 如果对应桶位置为空\n                if (casTabAt(tab, i, null, new Node<K,V>(hash, key, value)))\n                    break;                    // CAS 原子性的尝试插入\n            }\n            else if ((fh = f.hash) == MOVED)\n                //f.hash == MOVED 表示为：ForwardingNode，说明其他线程正在扩容\n                //并且这个数组的位置数据已经转移到新的数组结构中\n                //但是数据还没有全部转移完成,帮助线程先扩容\n                // 如果当前节点正在扩容。还要帮着去扩容 \n                tab = helpTransfer(tab, f);\n            else if (onlyIfAbsent //jdk 检查第一个节点 是否已存在key 存在返回对应value值 check first node without acquiring lock\n                     && fh == hash\n                     && ((fk = f.key) == key || (fk != null && key.equals(fk)))\n                     && (fv = f.val) != null)\n                return fv;\n            else {\n                V oldVal = null;//桶存在数据 加锁操作进行处理\n                synchronized (f) {\n                    if (tabAt(tab, i) == f) {\n                        if (fh >= 0) {// 如果存储的是链表 存储的是节点的hash值\n                            binCount = 1;\n                            for (Node<K,V> e = f;; ++binCount) {\n                                K ek;\n                                // 遍历链表去查找，如果找到key 选择性覆盖\n                                if (e.hash == hash &&\n                                    ((ek = e.key) == key ||\n                                     (ek != null && key.equals(ek)))) {\n                                    oldVal = e.val;\n                                    if (!onlyIfAbsent)\n                                        e.val = value;\n                                    break;\n                                }\n                                Node<K,V> pred = e;\n                                if ((e = e.next) == null) {// 找到尾部插入\n                                    pred.next = new Node<K,V>(hash, key, value);\n                                    break;\n                                }\n                            }\n                        }\n                        else if (f instanceof TreeBin) {// 如果桶节点类型为TreeBin\n                            Node<K,V> p;\n                            binCount = 2;\n                            if ((p = ((TreeBin<K,V>)f).putTreeVal(hash, key,\n                                                           value)) != null) {\n                                 // 尝试红黑树插入，同时也要防止节点本来就有，选择性覆盖\n                                oldVal = p.val;\n                                if (!onlyIfAbsent)\n                                    p.val = value;\n                            }\n                        }\n                        else if (f instanceof ReservationNode)\n                            throw new IllegalStateException(\"Recursive update\");\n                    }\n                }\n                if (binCount != 0) {// 如果链表数量\n                    if (binCount >= TREEIFY_THRESHOLD)\n                        treeifyBin(tab, i);//  链表转红黑树哦！\n                    if (oldVal != null)\n                        return oldVal;\n                    break;\n                }\n            }\n        }\n        addCount(1L, binCount); // 统计大小 并且检查是否要扩容。\n        return null;\n    }\n```\n\n　　涉及到重要函数initTable、tabAt、casTabAt、helpTransfer、putTreeVal、treeifyBin、addCount函数。\n\n3. initTable\n\n>  **「只允许一个线程」** 对表进行初始化，如果不巧有其他线程进来了，那么会让其他线程交出 CPU 等待下次系统调度Thread.yield。这样，保证了表同时只会被一个线程初始化，对于table的大小，会根据sizeCtl的值进行设置，如果没有设置szieCtl的值，那么默认生成的table大小为16，否则，会根据sizeCtl的大小设置table大小。\n\n```java\n// 容器初始化 操作\nprivate final Node<K,V>[] initTable() {\n    Node<K,V>[] tab; int sc;\n    while ((tab = table)  null || tab.length  0) {\n        if ((sc = sizeCtl) < 0) // 如果正在初始化-1，-N 正在扩容。\n            Thread.yield(); // 进行线程让步等待\n     // 让掉当前线程 CPU 的时间片，使正在运行中的线程重新变成就绪状态，并重新竞争 CPU 的调度权。\n     // 它可能会获取到，也有可能被其他线程获取到。\n        else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) { \n          //  比较sizeCtl的值与sc是否相等，相等则用 -1 替换,这表明我这个线程在进行初始化了！\n            try {\n                if ((tab = table)  null || tab.length  0) {\n                    int n = (sc > 0) ? sc : DEFAULT_CAPACITY; // 默认为16\n                    @SuppressWarnings(\"unchecked\")\n                    Node<K,V>[] nt = (Node<K,V>[])new Node<?,?>[n];\n                    table = tab = nt;\n                    sc = n - (n >>> 2); \n                }\n            } finally {\n                sizeCtl = sc; //设置sizeCtl 类似threshold\n            }\n            break;\n        }\n    }\n    return tab;\n}\n```\n","slug":"java-Collection-Map","published":1,"updated":"2025-04-28T08:41:48.387Z","_id":"cm9s3f40h002vbfg4fv1oherx","comments":1,"layout":"post","photos":[],"content":"<h1>Map</h1>\n<h2 id=\"HashMap\">HashMap</h2>\n<p>JDK1.8 之前 HashMap 底层是 <strong>数组和链表</strong> 结合在一起使用也就是 <strong>链表散列</strong>。HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash 值，然后通过 (n - 1) &amp; hash 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</p>\n<p>所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。</p>\n<h3 id=\"JDK1-8-之前\">JDK1.8 之前</h3>\n<p>“拉链法” 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</p>\n<h3 id=\"JDK1-8-之后\">JDK1.8 之后</h3>\n<p>当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。</p>\n<p><img src=\"/assets/net-img-1591690908749-8d13658b-f28f-4a16-9787-5d802366b2bb-20221030132339-jhzqts2.png\" alt=\"\"></p>\n<blockquote>\n<p>TreeMap、TreeSet 以及 JDK1.8 之后的 HashMap 底层都用到了红黑树。红黑树就是为了解决二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构。</p>\n</blockquote>\n<h2 id=\"ConcurrentHashMap\">ConcurrentHashMap</h2>\n<p>1.8及之后</p>\n<blockquote>\n<ol>\n<li>用table保存数据，锁的粒度更小，减少并发冲突的概率。采用table数组元素作为锁，从而实现了对每一行数据进行加锁，进一步减少并发冲突的概率，并发控制使用Synchronized和CAS来操作。</li>\n<li>存储数据时采用了数组+ 链表+红黑树的形式。</li>\n</ol>\n</blockquote>\n<ol>\n<li>CurrentHashMap重要参数：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">MAXIMUM_CAPACITY</span> <span class=\"operator\">=</span> <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">30</span>; <span class=\"comment\">// 数组的最大值 </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">DEFAULT_CAPACITY</span> <span class=\"operator\">=</span> <span class=\"number\">16</span>; <span class=\"comment\">// 默认数组长度 </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">TREEIFY_THRESHOLD</span> <span class=\"operator\">=</span> <span class=\"number\">8</span>; <span class=\"comment\">// 链表转红黑树的一个条件 </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">UNTREEIFY_THRESHOLD</span> <span class=\"operator\">=</span> <span class=\"number\">6</span>; <span class=\"comment\">// 红黑树转链表的一个条件 </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">MIN_TREEIFY_CAPACITY</span> <span class=\"operator\">=</span> <span class=\"number\">64</span>; <span class=\"comment\">// 链表转红黑树的另一个条件</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">MOVED</span>     <span class=\"operator\">=</span> -<span class=\"number\">1</span>;  <span class=\"comment\">// 表示正在扩容转移 </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">TREEBIN</span>   <span class=\"operator\">=</span> -<span class=\"number\">2</span>; <span class=\"comment\">// 表示已经转换成树 </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">RESERVED</span>  <span class=\"operator\">=</span> -<span class=\"number\">3</span>; <span class=\"comment\">// hash for transient reservations </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">HASH_BITS</span> <span class=\"operator\">=</span> <span class=\"number\">0x7fffffff</span>; <span class=\"comment\">// 获得hash值的辅助参数</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">transient</span> <span class=\"keyword\">volatile</span> Node&lt;K,V&gt;[] table;<span class=\"comment\">// 默认没初始化的数组，用来保存元素 </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> <span class=\"keyword\">volatile</span> Node&lt;K,V&gt;[] nextTable; <span class=\"comment\">// 转移的时候用的数组 </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">NCPU</span> <span class=\"operator\">=</span> Runtime.getRuntime().availableProcessors();<span class=\"comment\">// 获取可用的CPU个数 </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> <span class=\"keyword\">volatile</span> Node&lt;K,V&gt;[] nextTable; <span class=\"comment\">// 连接表，用于哈希表扩容，扩容完成后会被重置为 null </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> <span class=\"keyword\">volatile</span> <span class=\"type\">long</span> baseCount; <span class=\"comment\">//保存着整个哈希表中存储的所有的结点的个数总和，有点类似于 HashMap 的 size 属性。</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> <span class=\"keyword\">volatile</span> <span class=\"type\">int</span> sizeCtl; </span><br><span class=\"line\"><span class=\"comment\">//sizeCtl = 0：表示没有指定初始容量</span></span><br><span class=\"line\"><span class=\"comment\">//sizeCtl &gt; 0：表示初始容量(可以使用阶段)</span></span><br><span class=\"line\"><span class=\"comment\">//sizeCtl = -1,标记作用，告知其他线程，正在初始化</span></span><br><span class=\"line\"><span class=\"comment\">//sizeCtl = 0.75n ,扩容阈值</span></span><br><span class=\"line\"><span class=\"comment\">//sizeCtl &lt; 0 : 表示有其他线程正在执行扩容or初始化(不能使用阶段)</span></span><br><span class=\"line\"><span class=\"comment\">//sizeCtl = (resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT) + 2 :表示此时只有一个线程在执行扩容</span></span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>扩容机制</li>\n</ol>\n<blockquote>\n<ul>\n<li>nextTable: 扩容期间，将元素迁移到 nextTable 新Map, nextTable是共享变量。</li>\n<li>sizeCtl: 多线程之间，sizeCtl来判断ConcurrentHashMap当前所处的状态。\n<ul>\n<li>通过CAS设置sizeCtl属性，告知其他线程ConcurrentHashMap的状态变更。</li>\n</ul>\n</li>\n<li>transferIndex: 扩容索引，表示已经完成数据分配的table数组索引位置。\n<ul>\n<li>数据转移已经到了哪个位置? 其他线程根据这个值帮助扩容从这个索引位置继续转移数据</li>\n</ul>\n</li>\n<li>ForwardingNode节点: 标记作用,表示此节点已经扩容完毕，hash值等于-1\n<ul>\n<li>数组位置的数据已经被转移到新Map中,此位置就会被设置为这个属性</li>\n<li>这个属性包装了新Map,可以用find方法取扩容转移后的值</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<p><strong>扩容流程：</strong></p>\n<ul>\n<li>线程执行put操作，发现容量已经达到扩容阈值，需要进行扩容操作</li>\n<li>扩容线程A 以CAS机制修改<code>transferindex</code>值,然后按照降序迁移数据,<code>transferindex</code>是数组尾部的索引\n<ul>\n<li><code>transferindex</code>的初始值: 新数组的长度 - 1 -&gt; 就是数组的最后一位</li>\n</ul>\n</li>\n<li>迁移hash桶时，会将桶内的链表或者红黑树，按照一定算法，拆分成2份，将其插入<code>nextTable[i]</code>和<code>nextTable[i+n]</code>（n是之前table数组的长度）。\n<ul>\n<li>扩容后重新计算的hash值与之前hash值一样,则存放位置不变</li>\n<li>重新计算的hash值与之前hash值不一样,则存放再索引i +n处(之前的数组长度 + 计算的索引)</li>\n</ul>\n</li>\n<li>迁移完毕的hash桶,都会被设置成<code>ForwardingNode</code>节点，以此告知访问此桶的其他线程，此节点已经迁移完毕,但数据并没有全部迁移完成。</li>\n<li>此时线程2访问到了<code>ForwardingNode</code>节点，如果线程2执行的put或remove等写操作，那么就会先帮其扩容。\n<ul>\n<li>如果线程2执行的是get等读方法，则会调用<code>ForwardingNode</code>的find方法，去<code>nextTable</code>里面查找相关元素。</li>\n</ul>\n</li>\n</ul>\n<ol start=\"3\">\n<li>put</li>\n</ol>\n<blockquote>\n<p>put操作采用 CAS + synchronized 实现并发插入或更新操作</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Node 节点的 hash值在HashMap中存储的就是hash值，在currenthashmap中可能有多种情况哦！</span></span><br><span class=\"line\"><span class=\"comment\">/** Implementation for put and putIfAbsent */</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> V <span class=\"title function_\">putVal</span><span class=\"params\">(K key, V value, <span class=\"type\">boolean</span> onlyIfAbsent)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (key == <span class=\"literal\">null</span> || value == <span class=\"literal\">null</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NullPointerException</span>();</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">hash</span> <span class=\"operator\">=</span> spread(key.hashCode());<span class=\"comment\">// 最终hash值计算</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">binCount</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123; <span class=\"comment\">//循环表</span></span><br><span class=\"line\">            Node&lt;K,V&gt; f; <span class=\"type\">int</span> n, i, fh; K fk; V fv;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (tab == <span class=\"literal\">null</span> || (n = tab.length) == <span class=\"number\">0</span>)</span><br><span class=\"line\">                tab = initTable(); <span class=\"comment\">// 初始化表 如果为空,懒汉式</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((f = tabAt(tab, i = (n - <span class=\"number\">1</span>) &amp; hash)) == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//// 如果对应桶位置为空</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (casTabAt(tab, i, <span class=\"literal\">null</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">Node</span>&lt;K,V&gt;(hash, key, value)))</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;                    <span class=\"comment\">// CAS 原子性的尝试插入</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((fh = f.hash) == MOVED)</span><br><span class=\"line\">                <span class=\"comment\">//f.hash == MOVED 表示为：ForwardingNode，说明其他线程正在扩容</span></span><br><span class=\"line\">                <span class=\"comment\">//并且这个数组的位置数据已经转移到新的数组结构中</span></span><br><span class=\"line\">                <span class=\"comment\">//但是数据还没有全部转移完成,帮助线程先扩容</span></span><br><span class=\"line\">                <span class=\"comment\">// 如果当前节点正在扩容。还要帮着去扩容 </span></span><br><span class=\"line\">                tab = helpTransfer(tab, f);</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (onlyIfAbsent <span class=\"comment\">//jdk 检查第一个节点 是否已存在key 存在返回对应value值 check first node without acquiring lock</span></span><br><span class=\"line\">                     &amp;&amp; fh == hash</span><br><span class=\"line\">                     &amp;&amp; ((fk = f.key) == key || (fk != <span class=\"literal\">null</span> &amp;&amp; key.equals(fk)))</span><br><span class=\"line\">                     &amp;&amp; (fv = f.val) != <span class=\"literal\">null</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> fv;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"type\">V</span> <span class=\"variable\">oldVal</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;<span class=\"comment\">//桶存在数据 加锁操作进行处理</span></span><br><span class=\"line\">                <span class=\"keyword\">synchronized</span> (f) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (fh &gt;= <span class=\"number\">0</span>) &#123;<span class=\"comment\">// 如果存储的是链表 存储的是节点的hash值</span></span><br><span class=\"line\">                            binCount = <span class=\"number\">1</span>;</span><br><span class=\"line\">                            <span class=\"keyword\">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class=\"line\">                                K ek;</span><br><span class=\"line\">                                <span class=\"comment\">// 遍历链表去查找，如果找到key 选择性覆盖</span></span><br><span class=\"line\">                                <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</span><br><span class=\"line\">                                    ((ek = e.key) == key ||</span><br><span class=\"line\">                                     (ek != <span class=\"literal\">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class=\"line\">                                    oldVal = e.val;</span><br><span class=\"line\">                                    <span class=\"keyword\">if</span> (!onlyIfAbsent)</span><br><span class=\"line\">                                        e.val = value;</span><br><span class=\"line\">                                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                                &#125;</span><br><span class=\"line\">                                Node&lt;K,V&gt; pred = e;</span><br><span class=\"line\">                                <span class=\"keyword\">if</span> ((e = e.next) == <span class=\"literal\">null</span>) &#123;<span class=\"comment\">// 找到尾部插入</span></span><br><span class=\"line\">                                    pred.next = <span class=\"keyword\">new</span> <span class=\"title class_\">Node</span>&lt;K,V&gt;(hash, key, value);</span><br><span class=\"line\">                                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                                &#125;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (f <span class=\"keyword\">instanceof</span> TreeBin) &#123;<span class=\"comment\">// 如果桶节点类型为TreeBin</span></span><br><span class=\"line\">                            Node&lt;K,V&gt; p;</span><br><span class=\"line\">                            binCount = <span class=\"number\">2</span>;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class=\"line\">                                                           value)) != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                                 <span class=\"comment\">// 尝试红黑树插入，同时也要防止节点本来就有，选择性覆盖</span></span><br><span class=\"line\">                                oldVal = p.val;</span><br><span class=\"line\">                                <span class=\"keyword\">if</span> (!onlyIfAbsent)</span><br><span class=\"line\">                                    p.val = value;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (f <span class=\"keyword\">instanceof</span> ReservationNode)</span><br><span class=\"line\">                            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalStateException</span>(<span class=\"string\">&quot;Recursive update&quot;</span>);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (binCount != <span class=\"number\">0</span>) &#123;<span class=\"comment\">// 如果链表数量</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class=\"line\">                        treeifyBin(tab, i);<span class=\"comment\">//  链表转红黑树哦！</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (oldVal != <span class=\"literal\">null</span>)</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> oldVal;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        addCount(<span class=\"number\">1L</span>, binCount); <span class=\"comment\">// 统计大小 并且检查是否要扩容。</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>涉及到重要函数initTable、tabAt、casTabAt、helpTransfer、putTreeVal、treeifyBin、addCount函数。</p>\n<ol start=\"3\">\n<li>initTable</li>\n</ol>\n<blockquote>\n<p><strong>「只允许一个线程」</strong> 对表进行初始化，如果不巧有其他线程进来了，那么会让其他线程交出 CPU 等待下次系统调度Thread.yield。这样，保证了表同时只会被一个线程初始化，对于table的大小，会根据sizeCtl的值进行设置，如果没有设置szieCtl的值，那么默认生成的table大小为16，否则，会根据sizeCtl的大小设置table大小。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 容器初始化 操作</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class=\"line\">    Node&lt;K,V&gt;[] tab; <span class=\"type\">int</span> sc;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ((tab = table)  <span class=\"literal\">null</span> || tab.length  <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((sc = sizeCtl) &lt; <span class=\"number\">0</span>) <span class=\"comment\">// 如果正在初始化-1，-N 正在扩容。</span></span><br><span class=\"line\">            Thread.<span class=\"keyword\">yield</span>(); <span class=\"comment\">// 进行线程让步等待</span></span><br><span class=\"line\">     <span class=\"comment\">// 让掉当前线程 CPU 的时间片，使正在运行中的线程重新变成就绪状态，并重新竞争 CPU 的调度权。</span></span><br><span class=\"line\">     <span class=\"comment\">// 它可能会获取到，也有可能被其他线程获取到。</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (U.compareAndSwapInt(<span class=\"built_in\">this</span>, SIZECTL, sc, -<span class=\"number\">1</span>)) &#123; </span><br><span class=\"line\">          <span class=\"comment\">//  比较sizeCtl的值与sc是否相等，相等则用 -1 替换,这表明我这个线程在进行初始化了！</span></span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((tab = table)  <span class=\"literal\">null</span> || tab.length  <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> (sc &gt; <span class=\"number\">0</span>) ? sc : DEFAULT_CAPACITY; <span class=\"comment\">// 默认为16</span></span><br><span class=\"line\">                    <span class=\"meta\">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class=\"line\">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class=\"keyword\">new</span> <span class=\"title class_\">Node</span>&lt;?,?&gt;[n];</span><br><span class=\"line\">                    table = tab = nt;</span><br><span class=\"line\">                    sc = n - (n &gt;&gt;&gt; <span class=\"number\">2</span>); </span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                sizeCtl = sc; <span class=\"comment\">//设置sizeCtl 类似threshold</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> tab;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","excerpt":"","more":"<h1>Map</h1>\n<h2 id=\"HashMap\">HashMap</h2>\n<p>JDK1.8 之前 HashMap 底层是 <strong>数组和链表</strong> 结合在一起使用也就是 <strong>链表散列</strong>。HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash 值，然后通过 (n - 1) &amp; hash 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</p>\n<p>所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。</p>\n<h3 id=\"JDK1-8-之前\">JDK1.8 之前</h3>\n<p>“拉链法” 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</p>\n<h3 id=\"JDK1-8-之后\">JDK1.8 之后</h3>\n<p>当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。</p>\n<p><img src=\"/assets/net-img-1591690908749-8d13658b-f28f-4a16-9787-5d802366b2bb-20221030132339-jhzqts2.png\" alt=\"\"></p>\n<blockquote>\n<p>TreeMap、TreeSet 以及 JDK1.8 之后的 HashMap 底层都用到了红黑树。红黑树就是为了解决二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构。</p>\n</blockquote>\n<h2 id=\"ConcurrentHashMap\">ConcurrentHashMap</h2>\n<p>1.8及之后</p>\n<blockquote>\n<ol>\n<li>用table保存数据，锁的粒度更小，减少并发冲突的概率。采用table数组元素作为锁，从而实现了对每一行数据进行加锁，进一步减少并发冲突的概率，并发控制使用Synchronized和CAS来操作。</li>\n<li>存储数据时采用了数组+ 链表+红黑树的形式。</li>\n</ol>\n</blockquote>\n<ol>\n<li>CurrentHashMap重要参数：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">MAXIMUM_CAPACITY</span> <span class=\"operator\">=</span> <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">30</span>; <span class=\"comment\">// 数组的最大值 </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">DEFAULT_CAPACITY</span> <span class=\"operator\">=</span> <span class=\"number\">16</span>; <span class=\"comment\">// 默认数组长度 </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">TREEIFY_THRESHOLD</span> <span class=\"operator\">=</span> <span class=\"number\">8</span>; <span class=\"comment\">// 链表转红黑树的一个条件 </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">UNTREEIFY_THRESHOLD</span> <span class=\"operator\">=</span> <span class=\"number\">6</span>; <span class=\"comment\">// 红黑树转链表的一个条件 </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">MIN_TREEIFY_CAPACITY</span> <span class=\"operator\">=</span> <span class=\"number\">64</span>; <span class=\"comment\">// 链表转红黑树的另一个条件</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">MOVED</span>     <span class=\"operator\">=</span> -<span class=\"number\">1</span>;  <span class=\"comment\">// 表示正在扩容转移 </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">TREEBIN</span>   <span class=\"operator\">=</span> -<span class=\"number\">2</span>; <span class=\"comment\">// 表示已经转换成树 </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">RESERVED</span>  <span class=\"operator\">=</span> -<span class=\"number\">3</span>; <span class=\"comment\">// hash for transient reservations </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">HASH_BITS</span> <span class=\"operator\">=</span> <span class=\"number\">0x7fffffff</span>; <span class=\"comment\">// 获得hash值的辅助参数</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">transient</span> <span class=\"keyword\">volatile</span> Node&lt;K,V&gt;[] table;<span class=\"comment\">// 默认没初始化的数组，用来保存元素 </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> <span class=\"keyword\">volatile</span> Node&lt;K,V&gt;[] nextTable; <span class=\"comment\">// 转移的时候用的数组 </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">NCPU</span> <span class=\"operator\">=</span> Runtime.getRuntime().availableProcessors();<span class=\"comment\">// 获取可用的CPU个数 </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> <span class=\"keyword\">volatile</span> Node&lt;K,V&gt;[] nextTable; <span class=\"comment\">// 连接表，用于哈希表扩容，扩容完成后会被重置为 null </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> <span class=\"keyword\">volatile</span> <span class=\"type\">long</span> baseCount; <span class=\"comment\">//保存着整个哈希表中存储的所有的结点的个数总和，有点类似于 HashMap 的 size 属性。</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> <span class=\"keyword\">volatile</span> <span class=\"type\">int</span> sizeCtl; </span><br><span class=\"line\"><span class=\"comment\">//sizeCtl = 0：表示没有指定初始容量</span></span><br><span class=\"line\"><span class=\"comment\">//sizeCtl &gt; 0：表示初始容量(可以使用阶段)</span></span><br><span class=\"line\"><span class=\"comment\">//sizeCtl = -1,标记作用，告知其他线程，正在初始化</span></span><br><span class=\"line\"><span class=\"comment\">//sizeCtl = 0.75n ,扩容阈值</span></span><br><span class=\"line\"><span class=\"comment\">//sizeCtl &lt; 0 : 表示有其他线程正在执行扩容or初始化(不能使用阶段)</span></span><br><span class=\"line\"><span class=\"comment\">//sizeCtl = (resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT) + 2 :表示此时只有一个线程在执行扩容</span></span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>扩容机制</li>\n</ol>\n<blockquote>\n<ul>\n<li>nextTable: 扩容期间，将元素迁移到 nextTable 新Map, nextTable是共享变量。</li>\n<li>sizeCtl: 多线程之间，sizeCtl来判断ConcurrentHashMap当前所处的状态。\n<ul>\n<li>通过CAS设置sizeCtl属性，告知其他线程ConcurrentHashMap的状态变更。</li>\n</ul>\n</li>\n<li>transferIndex: 扩容索引，表示已经完成数据分配的table数组索引位置。\n<ul>\n<li>数据转移已经到了哪个位置? 其他线程根据这个值帮助扩容从这个索引位置继续转移数据</li>\n</ul>\n</li>\n<li>ForwardingNode节点: 标记作用,表示此节点已经扩容完毕，hash值等于-1\n<ul>\n<li>数组位置的数据已经被转移到新Map中,此位置就会被设置为这个属性</li>\n<li>这个属性包装了新Map,可以用find方法取扩容转移后的值</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<p><strong>扩容流程：</strong></p>\n<ul>\n<li>线程执行put操作，发现容量已经达到扩容阈值，需要进行扩容操作</li>\n<li>扩容线程A 以CAS机制修改<code>transferindex</code>值,然后按照降序迁移数据,<code>transferindex</code>是数组尾部的索引\n<ul>\n<li><code>transferindex</code>的初始值: 新数组的长度 - 1 -&gt; 就是数组的最后一位</li>\n</ul>\n</li>\n<li>迁移hash桶时，会将桶内的链表或者红黑树，按照一定算法，拆分成2份，将其插入<code>nextTable[i]</code>和<code>nextTable[i+n]</code>（n是之前table数组的长度）。\n<ul>\n<li>扩容后重新计算的hash值与之前hash值一样,则存放位置不变</li>\n<li>重新计算的hash值与之前hash值不一样,则存放再索引i +n处(之前的数组长度 + 计算的索引)</li>\n</ul>\n</li>\n<li>迁移完毕的hash桶,都会被设置成<code>ForwardingNode</code>节点，以此告知访问此桶的其他线程，此节点已经迁移完毕,但数据并没有全部迁移完成。</li>\n<li>此时线程2访问到了<code>ForwardingNode</code>节点，如果线程2执行的put或remove等写操作，那么就会先帮其扩容。\n<ul>\n<li>如果线程2执行的是get等读方法，则会调用<code>ForwardingNode</code>的find方法，去<code>nextTable</code>里面查找相关元素。</li>\n</ul>\n</li>\n</ul>\n<ol start=\"3\">\n<li>put</li>\n</ol>\n<blockquote>\n<p>put操作采用 CAS + synchronized 实现并发插入或更新操作</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Node 节点的 hash值在HashMap中存储的就是hash值，在currenthashmap中可能有多种情况哦！</span></span><br><span class=\"line\"><span class=\"comment\">/** Implementation for put and putIfAbsent */</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> V <span class=\"title function_\">putVal</span><span class=\"params\">(K key, V value, <span class=\"type\">boolean</span> onlyIfAbsent)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (key == <span class=\"literal\">null</span> || value == <span class=\"literal\">null</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NullPointerException</span>();</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">hash</span> <span class=\"operator\">=</span> spread(key.hashCode());<span class=\"comment\">// 最终hash值计算</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">binCount</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123; <span class=\"comment\">//循环表</span></span><br><span class=\"line\">            Node&lt;K,V&gt; f; <span class=\"type\">int</span> n, i, fh; K fk; V fv;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (tab == <span class=\"literal\">null</span> || (n = tab.length) == <span class=\"number\">0</span>)</span><br><span class=\"line\">                tab = initTable(); <span class=\"comment\">// 初始化表 如果为空,懒汉式</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((f = tabAt(tab, i = (n - <span class=\"number\">1</span>) &amp; hash)) == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//// 如果对应桶位置为空</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (casTabAt(tab, i, <span class=\"literal\">null</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">Node</span>&lt;K,V&gt;(hash, key, value)))</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;                    <span class=\"comment\">// CAS 原子性的尝试插入</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((fh = f.hash) == MOVED)</span><br><span class=\"line\">                <span class=\"comment\">//f.hash == MOVED 表示为：ForwardingNode，说明其他线程正在扩容</span></span><br><span class=\"line\">                <span class=\"comment\">//并且这个数组的位置数据已经转移到新的数组结构中</span></span><br><span class=\"line\">                <span class=\"comment\">//但是数据还没有全部转移完成,帮助线程先扩容</span></span><br><span class=\"line\">                <span class=\"comment\">// 如果当前节点正在扩容。还要帮着去扩容 </span></span><br><span class=\"line\">                tab = helpTransfer(tab, f);</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (onlyIfAbsent <span class=\"comment\">//jdk 检查第一个节点 是否已存在key 存在返回对应value值 check first node without acquiring lock</span></span><br><span class=\"line\">                     &amp;&amp; fh == hash</span><br><span class=\"line\">                     &amp;&amp; ((fk = f.key) == key || (fk != <span class=\"literal\">null</span> &amp;&amp; key.equals(fk)))</span><br><span class=\"line\">                     &amp;&amp; (fv = f.val) != <span class=\"literal\">null</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> fv;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"type\">V</span> <span class=\"variable\">oldVal</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;<span class=\"comment\">//桶存在数据 加锁操作进行处理</span></span><br><span class=\"line\">                <span class=\"keyword\">synchronized</span> (f) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (fh &gt;= <span class=\"number\">0</span>) &#123;<span class=\"comment\">// 如果存储的是链表 存储的是节点的hash值</span></span><br><span class=\"line\">                            binCount = <span class=\"number\">1</span>;</span><br><span class=\"line\">                            <span class=\"keyword\">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class=\"line\">                                K ek;</span><br><span class=\"line\">                                <span class=\"comment\">// 遍历链表去查找，如果找到key 选择性覆盖</span></span><br><span class=\"line\">                                <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</span><br><span class=\"line\">                                    ((ek = e.key) == key ||</span><br><span class=\"line\">                                     (ek != <span class=\"literal\">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class=\"line\">                                    oldVal = e.val;</span><br><span class=\"line\">                                    <span class=\"keyword\">if</span> (!onlyIfAbsent)</span><br><span class=\"line\">                                        e.val = value;</span><br><span class=\"line\">                                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                                &#125;</span><br><span class=\"line\">                                Node&lt;K,V&gt; pred = e;</span><br><span class=\"line\">                                <span class=\"keyword\">if</span> ((e = e.next) == <span class=\"literal\">null</span>) &#123;<span class=\"comment\">// 找到尾部插入</span></span><br><span class=\"line\">                                    pred.next = <span class=\"keyword\">new</span> <span class=\"title class_\">Node</span>&lt;K,V&gt;(hash, key, value);</span><br><span class=\"line\">                                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                                &#125;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (f <span class=\"keyword\">instanceof</span> TreeBin) &#123;<span class=\"comment\">// 如果桶节点类型为TreeBin</span></span><br><span class=\"line\">                            Node&lt;K,V&gt; p;</span><br><span class=\"line\">                            binCount = <span class=\"number\">2</span>;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class=\"line\">                                                           value)) != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                                 <span class=\"comment\">// 尝试红黑树插入，同时也要防止节点本来就有，选择性覆盖</span></span><br><span class=\"line\">                                oldVal = p.val;</span><br><span class=\"line\">                                <span class=\"keyword\">if</span> (!onlyIfAbsent)</span><br><span class=\"line\">                                    p.val = value;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (f <span class=\"keyword\">instanceof</span> ReservationNode)</span><br><span class=\"line\">                            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalStateException</span>(<span class=\"string\">&quot;Recursive update&quot;</span>);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (binCount != <span class=\"number\">0</span>) &#123;<span class=\"comment\">// 如果链表数量</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class=\"line\">                        treeifyBin(tab, i);<span class=\"comment\">//  链表转红黑树哦！</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (oldVal != <span class=\"literal\">null</span>)</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> oldVal;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        addCount(<span class=\"number\">1L</span>, binCount); <span class=\"comment\">// 统计大小 并且检查是否要扩容。</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>涉及到重要函数initTable、tabAt、casTabAt、helpTransfer、putTreeVal、treeifyBin、addCount函数。</p>\n<ol start=\"3\">\n<li>initTable</li>\n</ol>\n<blockquote>\n<p><strong>「只允许一个线程」</strong> 对表进行初始化，如果不巧有其他线程进来了，那么会让其他线程交出 CPU 等待下次系统调度Thread.yield。这样，保证了表同时只会被一个线程初始化，对于table的大小，会根据sizeCtl的值进行设置，如果没有设置szieCtl的值，那么默认生成的table大小为16，否则，会根据sizeCtl的大小设置table大小。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 容器初始化 操作</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class=\"line\">    Node&lt;K,V&gt;[] tab; <span class=\"type\">int</span> sc;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ((tab = table)  <span class=\"literal\">null</span> || tab.length  <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((sc = sizeCtl) &lt; <span class=\"number\">0</span>) <span class=\"comment\">// 如果正在初始化-1，-N 正在扩容。</span></span><br><span class=\"line\">            Thread.<span class=\"keyword\">yield</span>(); <span class=\"comment\">// 进行线程让步等待</span></span><br><span class=\"line\">     <span class=\"comment\">// 让掉当前线程 CPU 的时间片，使正在运行中的线程重新变成就绪状态，并重新竞争 CPU 的调度权。</span></span><br><span class=\"line\">     <span class=\"comment\">// 它可能会获取到，也有可能被其他线程获取到。</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (U.compareAndSwapInt(<span class=\"built_in\">this</span>, SIZECTL, sc, -<span class=\"number\">1</span>)) &#123; </span><br><span class=\"line\">          <span class=\"comment\">//  比较sizeCtl的值与sc是否相等，相等则用 -1 替换,这表明我这个线程在进行初始化了！</span></span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((tab = table)  <span class=\"literal\">null</span> || tab.length  <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> (sc &gt; <span class=\"number\">0</span>) ? sc : DEFAULT_CAPACITY; <span class=\"comment\">// 默认为16</span></span><br><span class=\"line\">                    <span class=\"meta\">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class=\"line\">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class=\"keyword\">new</span> <span class=\"title class_\">Node</span>&lt;?,?&gt;[n];</span><br><span class=\"line\">                    table = tab = nt;</span><br><span class=\"line\">                    sc = n - (n &gt;&gt;&gt; <span class=\"number\">2</span>); </span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                sizeCtl = sc; <span class=\"comment\">//设置sizeCtl 类似threshold</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> tab;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Queue","date":"2022-10-30T05:22:56.000Z","lastmod":"2023-05-27T07:51:10.000Z","_content":"\n# Queue\n\n## Queue \t​![image](/assets/image-20230527154724-v674duu.png)​\n\n　　**注意：不要把 null 添加到队列中，否则 poll()方法返回 null 时，很难确定是取到了 null 元素还是队列为空。**\n\n## PriorityQueue(优先队列) `extends AbstractQueue`\n\n> 通过二叉小顶堆实现，可以用一棵完全二叉树表示\n> 优先队列的作用是能保证每次取出的元素都是队列中权值最小的\n> PriorityQueue 实现了 Queue 接口，不允许放入 null 元素；其通过堆实现，具体说是通过完全二叉树 （complete binary tree） 实现的小顶堆（任意一个非叶子节点的权值，都不大于其左右子节点的权值），也就意味着可以通过数组来作为 PriorityQueue 的底层实现\n> 放入 PriorityQueue 的元素，必须实现 Comparable 接口，PriorityQueue 会根据元素的排序顺序决定出队的优先级\n\n## Deque `extends Queue`(接口)\n\n　　**队列和 Deque 方法的比较**\n\n|队列方法|等效的 Deque 方法|\n| ---------| -----------------|\n|add(e)|addLast(e)|\n|offer(e)|offerLast(e)|\n|remove()|removeFirst()|\n|poll()|pollFirst()|\n|element()|getFirst()|\n|peek()|peekFirst()|\n\n## ArrayDeque `implements Deque` (实现接口)\n\n## ArrayBlockingQueue\n\n## SynchronousQueue\n\n## PriorityBlockingQueue\n\n## DelayQueue\n","source":"_posts/java/Collection/Queue.md","raw":"---\ntitle: Queue\ndate: 2022-10-30T13:22:56Z\nlastmod: 2023-05-27T15:51:10Z\n---\n\n# Queue\n\n## Queue \t​![image](/assets/image-20230527154724-v674duu.png)​\n\n　　**注意：不要把 null 添加到队列中，否则 poll()方法返回 null 时，很难确定是取到了 null 元素还是队列为空。**\n\n## PriorityQueue(优先队列) `extends AbstractQueue`\n\n> 通过二叉小顶堆实现，可以用一棵完全二叉树表示\n> 优先队列的作用是能保证每次取出的元素都是队列中权值最小的\n> PriorityQueue 实现了 Queue 接口，不允许放入 null 元素；其通过堆实现，具体说是通过完全二叉树 （complete binary tree） 实现的小顶堆（任意一个非叶子节点的权值，都不大于其左右子节点的权值），也就意味着可以通过数组来作为 PriorityQueue 的底层实现\n> 放入 PriorityQueue 的元素，必须实现 Comparable 接口，PriorityQueue 会根据元素的排序顺序决定出队的优先级\n\n## Deque `extends Queue`(接口)\n\n　　**队列和 Deque 方法的比较**\n\n|队列方法|等效的 Deque 方法|\n| ---------| -----------------|\n|add(e)|addLast(e)|\n|offer(e)|offerLast(e)|\n|remove()|removeFirst()|\n|poll()|pollFirst()|\n|element()|getFirst()|\n|peek()|peekFirst()|\n\n## ArrayDeque `implements Deque` (实现接口)\n\n## ArrayBlockingQueue\n\n## SynchronousQueue\n\n## PriorityBlockingQueue\n\n## DelayQueue\n","slug":"java-Collection-Queue","published":1,"updated":"2025-04-28T08:41:48.388Z","_id":"cm9s3f40i002wbfg41b4hcgsc","comments":1,"layout":"post","photos":[],"content":"<h1>Queue</h1>\n<h2 id=\"Queue-​image​\">Queue \t​<img src=\"/assets/image-20230527154724-v674duu.png\" alt=\"image\">​</h2>\n<p><strong>注意：不要把 null 添加到队列中，否则 poll()方法返回 null 时，很难确定是取到了 null 元素还是队列为空。</strong></p>\n<h2 id=\"PriorityQueue-优先队列-extends-AbstractQueue\">PriorityQueue(优先队列) <code>extends AbstractQueue</code></h2>\n<blockquote>\n<p>通过二叉小顶堆实现，可以用一棵完全二叉树表示<br>\n优先队列的作用是能保证每次取出的元素都是队列中权值最小的<br>\nPriorityQueue 实现了 Queue 接口，不允许放入 null 元素；其通过堆实现，具体说是通过完全二叉树 （complete binary tree） 实现的小顶堆（任意一个非叶子节点的权值，都不大于其左右子节点的权值），也就意味着可以通过数组来作为 PriorityQueue 的底层实现<br>\n放入 PriorityQueue 的元素，必须实现 Comparable 接口，PriorityQueue 会根据元素的排序顺序决定出队的优先级</p>\n</blockquote>\n<h2 id=\"Deque-extends-Queue-接口\">Deque <code>extends Queue</code>(接口)</h2>\n<p><strong>队列和 Deque 方法的比较</strong></p>\n<table>\n<thead>\n<tr>\n<th>队列方法</th>\n<th>等效的 Deque 方法</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>add(e)</td>\n<td>addLast(e)</td>\n</tr>\n<tr>\n<td>offer(e)</td>\n<td>offerLast(e)</td>\n</tr>\n<tr>\n<td>remove()</td>\n<td>removeFirst()</td>\n</tr>\n<tr>\n<td>poll()</td>\n<td>pollFirst()</td>\n</tr>\n<tr>\n<td>element()</td>\n<td>getFirst()</td>\n</tr>\n<tr>\n<td>peek()</td>\n<td>peekFirst()</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"ArrayDeque-implements-Deque-实现接口\">ArrayDeque <code>implements Deque</code> (实现接口)</h2>\n<h2 id=\"ArrayBlockingQueue\">ArrayBlockingQueue</h2>\n<h2 id=\"SynchronousQueue\">SynchronousQueue</h2>\n<h2 id=\"PriorityBlockingQueue\">PriorityBlockingQueue</h2>\n<h2 id=\"DelayQueue\">DelayQueue</h2>\n","excerpt":"","more":"<h1>Queue</h1>\n<h2 id=\"Queue-​image​\">Queue \t​<img src=\"/assets/image-20230527154724-v674duu.png\" alt=\"image\">​</h2>\n<p><strong>注意：不要把 null 添加到队列中，否则 poll()方法返回 null 时，很难确定是取到了 null 元素还是队列为空。</strong></p>\n<h2 id=\"PriorityQueue-优先队列-extends-AbstractQueue\">PriorityQueue(优先队列) <code>extends AbstractQueue</code></h2>\n<blockquote>\n<p>通过二叉小顶堆实现，可以用一棵完全二叉树表示<br>\n优先队列的作用是能保证每次取出的元素都是队列中权值最小的<br>\nPriorityQueue 实现了 Queue 接口，不允许放入 null 元素；其通过堆实现，具体说是通过完全二叉树 （complete binary tree） 实现的小顶堆（任意一个非叶子节点的权值，都不大于其左右子节点的权值），也就意味着可以通过数组来作为 PriorityQueue 的底层实现<br>\n放入 PriorityQueue 的元素，必须实现 Comparable 接口，PriorityQueue 会根据元素的排序顺序决定出队的优先级</p>\n</blockquote>\n<h2 id=\"Deque-extends-Queue-接口\">Deque <code>extends Queue</code>(接口)</h2>\n<p><strong>队列和 Deque 方法的比较</strong></p>\n<table>\n<thead>\n<tr>\n<th>队列方法</th>\n<th>等效的 Deque 方法</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>add(e)</td>\n<td>addLast(e)</td>\n</tr>\n<tr>\n<td>offer(e)</td>\n<td>offerLast(e)</td>\n</tr>\n<tr>\n<td>remove()</td>\n<td>removeFirst()</td>\n</tr>\n<tr>\n<td>poll()</td>\n<td>pollFirst()</td>\n</tr>\n<tr>\n<td>element()</td>\n<td>getFirst()</td>\n</tr>\n<tr>\n<td>peek()</td>\n<td>peekFirst()</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"ArrayDeque-implements-Deque-实现接口\">ArrayDeque <code>implements Deque</code> (实现接口)</h2>\n<h2 id=\"ArrayBlockingQueue\">ArrayBlockingQueue</h2>\n<h2 id=\"SynchronousQueue\">SynchronousQueue</h2>\n<h2 id=\"PriorityBlockingQueue\">PriorityBlockingQueue</h2>\n<h2 id=\"DelayQueue\">DelayQueue</h2>\n"},{"title":"Set","date":"2022-10-30T05:22:31.000Z","lastmod":"2022-10-30T05:22:31.000Z","_content":"\n# Set\n\n---\n\n## HashSet 集合\n\n> 底层数据结构是哈希表(是一个元素为链表的数组) + 红黑树\n\n　　**要点**\n\n- 实现 Set 接口\n- 不保证迭代顺序\n- 允许元素为 null\n- 底层实际上是一个 HashMap 实例\n- 非同步\n- 初始容量非常影响迭代性能\n\n　　HashSet 实际上就是封装了 HashMap，操作 HashSet 元素实际上就是操作 HashMap。这也是面向对象的一种体现，重用性贼高！\n\n　　详解见 [HashMap](map.md##HashMap)\n\n## TreeSet 集合\n\n> 底层数据结构是红黑树(是一个自平衡的二叉树)\n\n　　保证元素的排序方式\n\n　　**要点**\n\n- 实现NavigableSet接口\n- 可以实现排序功能\n- 底层实际上是一个TreeMap实例\n- 非同步\n\n## LinkedHashSet 集合\n\n> 底层数据结构由哈希表(是一个元素为链表的数组)和双向链表组成。\n","source":"_posts/java/Collection/Set.md","raw":"---\ntitle: Set\ndate: 2022-10-30T13:22:31Z\nlastmod: 2022-10-30T13:22:31Z\n---\n\n# Set\n\n---\n\n## HashSet 集合\n\n> 底层数据结构是哈希表(是一个元素为链表的数组) + 红黑树\n\n　　**要点**\n\n- 实现 Set 接口\n- 不保证迭代顺序\n- 允许元素为 null\n- 底层实际上是一个 HashMap 实例\n- 非同步\n- 初始容量非常影响迭代性能\n\n　　HashSet 实际上就是封装了 HashMap，操作 HashSet 元素实际上就是操作 HashMap。这也是面向对象的一种体现，重用性贼高！\n\n　　详解见 [HashMap](map.md##HashMap)\n\n## TreeSet 集合\n\n> 底层数据结构是红黑树(是一个自平衡的二叉树)\n\n　　保证元素的排序方式\n\n　　**要点**\n\n- 实现NavigableSet接口\n- 可以实现排序功能\n- 底层实际上是一个TreeMap实例\n- 非同步\n\n## LinkedHashSet 集合\n\n> 底层数据结构由哈希表(是一个元素为链表的数组)和双向链表组成。\n","slug":"java-Collection-Set","published":1,"updated":"2025-04-20T00:08:55.549Z","_id":"cm9s3f40j002xbfg44nml29lz","comments":1,"layout":"post","photos":[],"content":"<h1>Set</h1>\n<hr>\n<h2 id=\"HashSet-集合\">HashSet 集合</h2>\n<blockquote>\n<p>底层数据结构是哈希表(是一个元素为链表的数组) + 红黑树</p>\n</blockquote>\n<p><strong>要点</strong></p>\n<ul>\n<li>实现 Set 接口</li>\n<li>不保证迭代顺序</li>\n<li>允许元素为 null</li>\n<li>底层实际上是一个 HashMap 实例</li>\n<li>非同步</li>\n<li>初始容量非常影响迭代性能</li>\n</ul>\n<p>HashSet 实际上就是封装了 HashMap，操作 HashSet 元素实际上就是操作 HashMap。这也是面向对象的一种体现，重用性贼高！</p>\n<p>详解见 <a href=\"map.md##HashMap\">HashMap</a></p>\n<h2 id=\"TreeSet-集合\">TreeSet 集合</h2>\n<blockquote>\n<p>底层数据结构是红黑树(是一个自平衡的二叉树)</p>\n</blockquote>\n<p>保证元素的排序方式</p>\n<p><strong>要点</strong></p>\n<ul>\n<li>实现NavigableSet接口</li>\n<li>可以实现排序功能</li>\n<li>底层实际上是一个TreeMap实例</li>\n<li>非同步</li>\n</ul>\n<h2 id=\"LinkedHashSet-集合\">LinkedHashSet 集合</h2>\n<blockquote>\n<p>底层数据结构由哈希表(是一个元素为链表的数组)和双向链表组成。</p>\n</blockquote>\n","excerpt":"","more":"<h1>Set</h1>\n<hr>\n<h2 id=\"HashSet-集合\">HashSet 集合</h2>\n<blockquote>\n<p>底层数据结构是哈希表(是一个元素为链表的数组) + 红黑树</p>\n</blockquote>\n<p><strong>要点</strong></p>\n<ul>\n<li>实现 Set 接口</li>\n<li>不保证迭代顺序</li>\n<li>允许元素为 null</li>\n<li>底层实际上是一个 HashMap 实例</li>\n<li>非同步</li>\n<li>初始容量非常影响迭代性能</li>\n</ul>\n<p>HashSet 实际上就是封装了 HashMap，操作 HashSet 元素实际上就是操作 HashMap。这也是面向对象的一种体现，重用性贼高！</p>\n<p>详解见 <a href=\"map.md##HashMap\">HashMap</a></p>\n<h2 id=\"TreeSet-集合\">TreeSet 集合</h2>\n<blockquote>\n<p>底层数据结构是红黑树(是一个自平衡的二叉树)</p>\n</blockquote>\n<p>保证元素的排序方式</p>\n<p><strong>要点</strong></p>\n<ul>\n<li>实现NavigableSet接口</li>\n<li>可以实现排序功能</li>\n<li>底层实际上是一个TreeMap实例</li>\n<li>非同步</li>\n</ul>\n<h2 id=\"LinkedHashSet-集合\">LinkedHashSet 集合</h2>\n<blockquote>\n<p>底层数据结构由哈希表(是一个元素为链表的数组)和双向链表组成。</p>\n</blockquote>\n"},{"title":"Java虚拟机栈栈帧","date":"2022-10-30T05:42:05.000Z","lastmod":"2023-08-25T12:01:25.000Z","_content":"\n# Java虚拟机栈栈帧\n\n　　java虚拟机以方法作为最基本的执行单位。“栈帧”是用于支持虚拟机进行方法调用和方法执行背后的数据结构。栈帧存储了方法的局部变量表，操作数栈，动态链接和方法返回地址等信息。  \n​![image.png](/assets/net-img-1631431982904-ce964c3b-4c64-4915-84a9-a3799dd2cf92-20230330213415-i9cgn1s.png)\n\n　　***栈帧的概念结构***\n\n## 局部变量表\n\n- 局部变量表是一组变量值的存储空间，局部变量表以变量槽为单位\n- java虚拟机规范中未规定一个变量槽应该占有内存空间大小，只是有导向的说明没个变量槽都应该存放一个boolean，byte，char，short，int，float，reference，returnAddress类型的数据\n\n　　**reference 表示对一个对象的引用，java虚拟机规范中并没有明确指出reference类型的长度。** \n虚拟机至少通过这个应用确认两件事：\n\n1. 根据引用直接或间接的查找到对象在java堆中的数据存放的起始地址或索引\n2. 根据引用直接或间接的查找对象所属数据类型在方法区中的存储的类型信息\n\n　　**returnAddress现在基本很少出现**\n\n## 操作数栈\n\n　　![image.png](/assets/net-img-1631436389678-e6910ed9-8e3c-4d73-93bf-362566a4ebb0-20230330213421-crfgpeh.png)\n **_ 两个栈帧之间的数据共享  _**\n\n## 动态链接\n\n## 方法返回地址\n\n## 附加信息\n","source":"_posts/java/JVM/Java虚拟机栈栈帧.md","raw":"---\ntitle: Java虚拟机栈栈帧\ndate: 2022-10-30T13:42:05Z\nlastmod: 2023-08-25T20:01:25Z\n---\n\n# Java虚拟机栈栈帧\n\n　　java虚拟机以方法作为最基本的执行单位。“栈帧”是用于支持虚拟机进行方法调用和方法执行背后的数据结构。栈帧存储了方法的局部变量表，操作数栈，动态链接和方法返回地址等信息。  \n​![image.png](/assets/net-img-1631431982904-ce964c3b-4c64-4915-84a9-a3799dd2cf92-20230330213415-i9cgn1s.png)\n\n　　***栈帧的概念结构***\n\n## 局部变量表\n\n- 局部变量表是一组变量值的存储空间，局部变量表以变量槽为单位\n- java虚拟机规范中未规定一个变量槽应该占有内存空间大小，只是有导向的说明没个变量槽都应该存放一个boolean，byte，char，short，int，float，reference，returnAddress类型的数据\n\n　　**reference 表示对一个对象的引用，java虚拟机规范中并没有明确指出reference类型的长度。** \n虚拟机至少通过这个应用确认两件事：\n\n1. 根据引用直接或间接的查找到对象在java堆中的数据存放的起始地址或索引\n2. 根据引用直接或间接的查找对象所属数据类型在方法区中的存储的类型信息\n\n　　**returnAddress现在基本很少出现**\n\n## 操作数栈\n\n　　![image.png](/assets/net-img-1631436389678-e6910ed9-8e3c-4d73-93bf-362566a4ebb0-20230330213421-crfgpeh.png)\n **_ 两个栈帧之间的数据共享  _**\n\n## 动态链接\n\n## 方法返回地址\n\n## 附加信息\n","slug":"java-JVM-Java虚拟机栈栈帧","published":1,"updated":"2025-04-28T08:41:48.390Z","_id":"cm9s3f40j002ybfg4ezjh7een","comments":1,"layout":"post","photos":[],"content":"<h1>Java虚拟机栈栈帧</h1>\n<p>java虚拟机以方法作为最基本的执行单位。“栈帧”是用于支持虚拟机进行方法调用和方法执行背后的数据结构。栈帧存储了方法的局部变量表，操作数栈，动态链接和方法返回地址等信息。<br>\n​<img src=\"/assets/net-img-1631431982904-ce964c3b-4c64-4915-84a9-a3799dd2cf92-20230330213415-i9cgn1s.png\" alt=\"image.png\"></p>\n<p><em><strong>栈帧的概念结构</strong></em></p>\n<h2 id=\"局部变量表\">局部变量表</h2>\n<ul>\n<li>局部变量表是一组变量值的存储空间，局部变量表以变量槽为单位</li>\n<li>java虚拟机规范中未规定一个变量槽应该占有内存空间大小，只是有导向的说明没个变量槽都应该存放一个boolean，byte，char，short，int，float，reference，returnAddress类型的数据</li>\n</ul>\n<p><strong>reference 表示对一个对象的引用，java虚拟机规范中并没有明确指出reference类型的长度。</strong><br>\n虚拟机至少通过这个应用确认两件事：</p>\n<ol>\n<li>根据引用直接或间接的查找到对象在java堆中的数据存放的起始地址或索引</li>\n<li>根据引用直接或间接的查找对象所属数据类型在方法区中的存储的类型信息</li>\n</ol>\n<p><strong>returnAddress现在基本很少出现</strong></p>\n<h2 id=\"操作数栈\">操作数栈</h2>\n<p><img src=\"/assets/net-img-1631436389678-e6910ed9-8e3c-4d73-93bf-362566a4ebb0-20230330213421-crfgpeh.png\" alt=\"image.png\"><br>\n<strong>_ 两个栈帧之间的数据共享  _</strong></p>\n<h2 id=\"动态链接\">动态链接</h2>\n<h2 id=\"方法返回地址\">方法返回地址</h2>\n<h2 id=\"附加信息\">附加信息</h2>\n","excerpt":"","more":"<h1>Java虚拟机栈栈帧</h1>\n<p>java虚拟机以方法作为最基本的执行单位。“栈帧”是用于支持虚拟机进行方法调用和方法执行背后的数据结构。栈帧存储了方法的局部变量表，操作数栈，动态链接和方法返回地址等信息。<br>\n​<img src=\"/assets/net-img-1631431982904-ce964c3b-4c64-4915-84a9-a3799dd2cf92-20230330213415-i9cgn1s.png\" alt=\"image.png\"></p>\n<p><em><strong>栈帧的概念结构</strong></em></p>\n<h2 id=\"局部变量表\">局部变量表</h2>\n<ul>\n<li>局部变量表是一组变量值的存储空间，局部变量表以变量槽为单位</li>\n<li>java虚拟机规范中未规定一个变量槽应该占有内存空间大小，只是有导向的说明没个变量槽都应该存放一个boolean，byte，char，short，int，float，reference，returnAddress类型的数据</li>\n</ul>\n<p><strong>reference 表示对一个对象的引用，java虚拟机规范中并没有明确指出reference类型的长度。</strong><br>\n虚拟机至少通过这个应用确认两件事：</p>\n<ol>\n<li>根据引用直接或间接的查找到对象在java堆中的数据存放的起始地址或索引</li>\n<li>根据引用直接或间接的查找对象所属数据类型在方法区中的存储的类型信息</li>\n</ol>\n<p><strong>returnAddress现在基本很少出现</strong></p>\n<h2 id=\"操作数栈\">操作数栈</h2>\n<p><img src=\"/assets/net-img-1631436389678-e6910ed9-8e3c-4d73-93bf-362566a4ebb0-20230330213421-crfgpeh.png\" alt=\"image.png\"><br>\n<strong>_ 两个栈帧之间的数据共享  _</strong></p>\n<h2 id=\"动态链接\">动态链接</h2>\n<h2 id=\"方法返回地址\">方法返回地址</h2>\n<h2 id=\"附加信息\">附加信息</h2>\n"},{"title":"虚拟机中的对象","date":"2022-10-30T05:38:14.000Z","lastmod":"2023-12-02T04:34:15.000Z","_content":"\n# 虚拟机中的对象\n\n　　‍\n\n## 虚拟机类加载机制\n\n　　![image.png](/assets/net-img-1629870852837-ca139768-9f26-412a-8940-49ed6e38f57a-20230330213513-n1dmxgm.png)\n*类的生命周期*\n_加载，验证，准备，初始化_和_卸载_这五个顺序是可以确定的，类型的加载过成必须按照这种顺序按部就班的_**开始，** _而_解析_阶段可以在初始化阶段后再开始。（并非完成一步后再进行其他部分，通常可以交叉混合进行）\n有且只有六种情况必须对类立刻进行_**初始化**_（加载，验证等在此之前已完成）；\n\n- 遇到 new getstatic，putstatic或invokestatic四条字节码指令时，如果类型没有进行初始化，则会先出发其初始化阶段。生成该四种指令的典型java代码有：\n  - new 一个实例对象\n  - 读取或设置一个类型的静态字段（被final修饰或已在编译器把结果放入常量池的静态字段除外）\n  - 调用一个类型的静态方法的时候\n- 使用java.lang.reflect包的方法对类型进行反射调用的时候，如果类型没有进行过初始化，则需 要先触发其初始化。\n- 当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。\n- 当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先 初始化这个主类\n- 当一个接口中定义了JDK 8新加入的默认方法（被default关键字修饰的接口方法）时，如果有 这个接口的实现类发生了初始化，那该接口要在其之前被初始化。\n- ** 当使用JDK 7新加入的动态语言支持时？？？**\n\n### 加载\n\n　　 在加载阶段，Java虚拟机需要完成以下三件事情：\n\n- 通过一个类的全限定名来获取定义此类的二进制字节流。\n- 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。\n- 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入 口。\n\n### 验证\n\n- 文件格式验证：检验文件是否符合Class文件规范，从而保证输入的字节流能够正确的解析并存储于方法区内。\n  - 是否以魔数0xCAFEBABE开头。 ·主、次版本号是否在当前Java虚拟机接受范围之内。\n  - 常量池的常量中是否有不被支持的常量类型（检查常量tag标志）。\n  - 指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量。\n  - CONSTANT_Utf8_info型的常量中是否有不符合UTF-8编码的数据。\n  - Class文件中各个部分及文件本身是否有被删除的或附加的其他信息。\n  - ........ 等\n- 元数据验证：对字节码描述的信息进行语义分析\n  - 这个类是否有父类（除了java.lang.Object之外，所有的类都应当有父类）。\n  - 这个类的父类是否继承了不允许被继承的类（被final修饰的类）。\n  - 如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法。\n  - 类中的字段、方法是否与父类产生矛盾（例如覆盖了父类的final字段，或者出现不符合规则的方 法重载，例如方法参数都一致，但返回值类型却不同等）。\n  - ...........等\n- 字节码验证：主要是通过数据流分析和控制流分析，确定程序语义是否合法、符合逻辑。\n  - 保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作，例如不会出现类似于“在操作 栈放置了一个int类型的数据，使用时却按long类型来加载入本地变量表中”这样的情况。\n  - 保证任何跳转指令都不会跳转到方法体以外的字节码指令上。\n  - 保证方法体中的类型转换总是有效的，例如可以把一个子类对象赋值给父类数据类型，这是安全的，但是把父类对象赋值给子类数据类型，甚至把对象赋值给与它毫无继承关系、完全不相干的一个 数据类型，则是危险和不合法的。\n  - ……\n- 符号引用验证： 发生在虚拟机将符号引用转化为直接引用的时候。符号引用验证可以看作是对类自身以外（常量池中的各种符号 引用）的各类信息进行匹配性校验，通俗来说就是，该类是否缺少或者被禁止访问它依赖的某些外部 类、方法、字段等资源。\n  - 符号引用中通过字符串描述的全限定名是否能找到对应的类。\n  - 在指定类中是否存在符合方法的字段描述符及简单名称所描述的方法和字段。\n  - 符号引用中的类、字段、方法的可访问性（private、protected、public、）是否可被当 前类访问。\n  - …… 等\n\n### 准备\n\n　　正式为类中定义的变量（即静态变量，被static修饰的变量）分配内存并设置类变量初始值（值“通常情况”下是数据类型的零值）\n如果类字段的字段属性表中存在ConstantValue属性，那在准备阶段变量值就会被初始化为ConstantValue属性所指定的初始值。\n\n> - ConstantValue属于属性表集合中的一个属性，属性表集合中一共有21个不同属性。\n> - ConstantValue属性的使用位置：字段表；含义：final关键字定义的常量值。\n> - ConstantValue属性作用：通知虚拟机自动为静态变量赋值。\n\n　　int x =123; static int x = 123;\n\n> - 对虚拟机来说上面两种变量赋值的方式和时刻都有所不同。\n> - 非static类型变量（实例变量）\n>   - 赋值是在实例构造器<init>方法中进行的。\n> - static类型变量（类变量）\n>   - 有两种选择：在类构造器<clinit>方法或者使用ConstantValue属性。\n>     - 同时使用final 、static来修饰的变量（常量），并且这个变量的数据类型是基本类型或者String类型，就生成ConstantValue属性来进行初始化。\n>     - 没有final修饰或者并非基本类型及String类型，则选择在<clinit>方法中进行初始化。\n\n### 解析\n\n　　 将常量池内的符号引用替换为直接引用\n\n> 符号引用（Symbolic References）：符号引用以一组符号来描述所引用的目标，符号可以是任何 形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定是已经加载到虚拟机内存当中的内容。各种虚拟机实现的内存布局可以各不相同， 但是它们能接受的符号引用必须都是一致的，因为符号引用的字面量形式明确定义在《Java虚拟机规 范》的Class文件格式中。\n> ·直接引用（Direct References）：直接引用是可以直接指向目标的指针、相对偏移量或者是一个能 间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局直接相关的，同一个符号引用在不同虚 拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在虚拟机 的内存中存在。\n\n### 初始化\n\n### 卸载\n\n## 虚拟机中的对象\n\n![](/assets/net-img-4122e8fc2d6e2995074ede61ff44aef4-20230330213516-hs7yexh.svg)\n\n### 对象的创建\n\n1. 类加载\n   1. 加载\n   2. 链接\n   3. 初始化\n2. 分配空间\n   1. 指针碰撞：假设java内存绝对规整，被使用的和未使用的中间放一个指针作为分界点的指示器，分配内存时，仅需把指针挪动挪动一段和对象大小相同的距离即可。\n   2. 空闲列表：虚拟机维护一个列表，记录那些内存块是可用的，分配时从列表中获取一块足够大的空间去分配，并更新列表。\n\n> 使用Serial，ParNew等压缩整理整理过程的收集器是，系统采用指针碰撞；而是用CMS等交换算法收集器时，采用空闲列表分配空间\n\n　　内存分配（指针碰撞存在并发安全）并发问题解决方案：\n\n- CAS+重试：\n- TLAB（本地线程分配缓存）：把内存分配的动作按照线程划分在不同的空间之中进行，每个线程在JAVA堆中预先分配小块内存，只有本地缓存用完，分配新的缓存区时才需要同步锁定。\n\n> 内存分配完成，虚拟机必须将已分配的内存空间初始化零值，如果使用TLAB，初始化零值也可以提前至TLAB分配时顺便初始化零值\n\n3. 初始化零值\n   1. 将分配的空间都初始化为零值\n4. 设置对象头\n5. 执行init方法\n\n### 对象的卸载\n\n　　Java虚拟机自带的类加载器所加载的类，在整个虚拟机的生命周期中，都不会被卸载。\n用户自定义的类加载器是可以被卸载的。\n**卸载时机：**\n\n1. 该类的所有实例对象都被回收\n2. 该类的类加载器对象已经被回收\n3. 该类对应的Class对象没有被引用，无法在任何地方通过反射获取\n\n### 对象的内存布局\n\n​![图像](/assets/image-20231202123415-e2licnx.jpeg)​\n\n　　**jvm默认开启class pointer压缩 为4字节**  \n普通对象 markword 默认八个字节 instance data 若属性则为零 padding 补足被8整除  \n​![image.png](/assets/net-img-1615611389351-2cfaa4d5-b52c-4a2e-a170-c32ce97d17a6-20230330213518-3fydrb9.png)  \n数组对象  \n​![image.png](/assets/net-img-1615611419969-14ba7126-9f92-482c-a851-9898cece7e8f-20230330213518-2ptpa3a.png)  \nhotspot 虚拟机对象头markword\n\n|存储内容|标志位|状态|\n| ------------------------------------| ------| ----------------|\n|对象哈希码，对象分代年龄|01|未锁定|\n|指向锁记录的指针|00|轻量级锁状态|\n|指向重量级锁的指针|10|重量级锁状态|\n|空，不需要记录信息|11|gc标志|\n|偏向线程id、偏向时间戳、对象分代年龄|01|可偏向（偏向锁）|\n\n![image.png](/assets/net-img-1615614053644-2e45ea92-d426-42ca-a609-91b095ff7e83-20230330213519-1im5mrq.png)\n\n## 虚拟机类加载器\n\n​![image](/assets/image-20231117162020-0zic8ee.png)​\n\n​![image](/assets/image-20231117162030-ue9pyz9.png)​\n\n### jdk8\n\n1. 引导类加载器\n2. 扩展类加载器\n3. 应用类加载器\n\n### jdk9\n\n1. 引导类加载器\n2. 平台类加载器（原扩展类加载器，因兼容性被保留）\n3. 应用类加载器\n\n### jdk9后的变化\n\n　　为了保证兼容性，JDK 9没有从根本上改变三层类加载器架构和双亲委派模型，但为了模块化系统的顺利运行，仍然发生了一些值得被注意的变动。\n\n1. 扩展机制被移除，扩展类加载器由于向后兼容性的原因被保留，不过被重命名为平台类加载器（platform class loader）。可以通过ClassLoader的新方法getPlatformClassLoader()来获取。\n\n　　JDK 9 时基于模块化进行构建（原来的 rt.jar 和 tools.jar 被拆分成数十个 JMOD 文件），其中的 Java 类库就已天然地满足了可扩展的需求，那自然无须再保留 <JAVA_HOME>\\lib\\ext 目录，此前使用这个目录或者 java.ext.dirs 系统变量来扩展 JDK 功能的机制已经没有继续存在的价值了。\n\n2. 平台类加载器和应用程序类加载器都不再继承自 java.net.URLClassLoader。  \n    现在启动类加载器、平台类加载器、应用程序类加载器全都继承于 jdk.internal.loader.BuiltinClassLoader。\n\n​![image](/assets/image-20231119124040-5kytmcz.png)​\n\n　　如果有程序直接依赖了这种继承关系，或者依赖了 URLClassLoader 类的特定方法，那代码很可能会在 JDK 9 及更高版本的 JDK 中崩溃。\n\n3. 在Java 9中，类加载器有了名称。该名称在构造方法中指定，可以通过getName()方法来获取。平台类加载器的名称是platform，应用类加载器的名称是app。类加载器的名称在调试与类加载器相关的问题时会非常有用。\n4. 启动类加载器现在是在jvm内部和java类库共同协作实现的类加载器（以前是 C++实现），但为了与之前代码兼容，在获取启动类加载器的场景中仍然会返回null，而不会得到BootClassLoader实例。\n5. 类加载的委派关系也发生了变动。  \n    当平台及应用程序类加载器收到类加载请求，在委派给父加载器加载前，要先判断该类是否能够归属到某一个系统模块中，如果可以找到这样的归属关系，就要优先委派给负责那个模块的加载器完成加载。\n\n　　‍\n\n　　双亲委派模式示意图\n\n​![image](/assets/image-20231119124137-6apottn.png)​\n\n　　附加：  \n在 Java 模块化系统明确规定了三个类加载器负责各自加载的模块：  \n启动类加载器负责加载的模块  \njava.base                        java.security.sasl  \njava.datatransfer                java.xml  \njava.desktop                     jdk.httpserver  \njava.instrument                  jdk.internal.vm.ci  \njava.logging                     jdk.management  \njava.management                  jdk.management.agent  \njava.management.rmi              jdk.naming.rmi  \njava.naming                      jdk.net  \njava.prefs                       jdk.sctp  \njava.rmi                         jdk.unsupported\n\n　　平台类加载器负责加载的模块  \njava.activation*                jdk.accessibility  \njava.compiler*                  jdk.charsets  \njava.corba*                     jdk.crypto.cryptoki  \njava.scripting                  jdk.crypto.ec  \njava.se                         jdk.dynalink  \njava.se.ee                      jdk.incubator.httpclient  \njava.security.jgss              jdk.internal.vm.compiler*  \njava.smartcardio                jdk.jsobject  \njava.sql                        jdk.localedata  \njava.sql.rowset                 jdk.naming.dns  \njava.transaction*               jdk.scripting.nashorn  \njava.xml.bind*                  jdk.security.auth  \njava.xml.crypto                 jdk.security.jgss  \njava.xml.ws*                    jdk.xml.dom  \njava.xml.ws.annotation*         jdk.zipfs\n\n　　应用程序类加载器负责加载的模块  \njdk.aot                         jdk.jdeps  \njdk.attach                      jdk.jdi  \njdk.compiler                    jdk.jdwp.agent  \njdk.editpad                     jdk.jlink  \njdk.hotspot.agent               jdk.jshell  \njdk.internal.ed                 jdk.jstatd  \njdk.internal.jvmstat            jdk.pack  \njdk.internal.le                 jdk.policytool  \njdk.internal.opt                jdk.rmic  \njdk.jartool                     jdk.scripting.nashorn.shell  \njdk.javadoc                     jdk.xml.bind*  \njdk.jcmd                        jdk.xml.ws*  \njdk.jconsole\n\n　　‍\n","source":"_posts/java/JVM/虚拟机中的对象.md","raw":"---\ntitle: 虚拟机中的对象\ndate: 2022-10-30T13:38:14Z\nlastmod: 2023-12-02T12:34:15Z\n---\n\n# 虚拟机中的对象\n\n　　‍\n\n## 虚拟机类加载机制\n\n　　![image.png](/assets/net-img-1629870852837-ca139768-9f26-412a-8940-49ed6e38f57a-20230330213513-n1dmxgm.png)\n*类的生命周期*\n_加载，验证，准备，初始化_和_卸载_这五个顺序是可以确定的，类型的加载过成必须按照这种顺序按部就班的_**开始，** _而_解析_阶段可以在初始化阶段后再开始。（并非完成一步后再进行其他部分，通常可以交叉混合进行）\n有且只有六种情况必须对类立刻进行_**初始化**_（加载，验证等在此之前已完成）；\n\n- 遇到 new getstatic，putstatic或invokestatic四条字节码指令时，如果类型没有进行初始化，则会先出发其初始化阶段。生成该四种指令的典型java代码有：\n  - new 一个实例对象\n  - 读取或设置一个类型的静态字段（被final修饰或已在编译器把结果放入常量池的静态字段除外）\n  - 调用一个类型的静态方法的时候\n- 使用java.lang.reflect包的方法对类型进行反射调用的时候，如果类型没有进行过初始化，则需 要先触发其初始化。\n- 当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。\n- 当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先 初始化这个主类\n- 当一个接口中定义了JDK 8新加入的默认方法（被default关键字修饰的接口方法）时，如果有 这个接口的实现类发生了初始化，那该接口要在其之前被初始化。\n- ** 当使用JDK 7新加入的动态语言支持时？？？**\n\n### 加载\n\n　　 在加载阶段，Java虚拟机需要完成以下三件事情：\n\n- 通过一个类的全限定名来获取定义此类的二进制字节流。\n- 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。\n- 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入 口。\n\n### 验证\n\n- 文件格式验证：检验文件是否符合Class文件规范，从而保证输入的字节流能够正确的解析并存储于方法区内。\n  - 是否以魔数0xCAFEBABE开头。 ·主、次版本号是否在当前Java虚拟机接受范围之内。\n  - 常量池的常量中是否有不被支持的常量类型（检查常量tag标志）。\n  - 指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量。\n  - CONSTANT_Utf8_info型的常量中是否有不符合UTF-8编码的数据。\n  - Class文件中各个部分及文件本身是否有被删除的或附加的其他信息。\n  - ........ 等\n- 元数据验证：对字节码描述的信息进行语义分析\n  - 这个类是否有父类（除了java.lang.Object之外，所有的类都应当有父类）。\n  - 这个类的父类是否继承了不允许被继承的类（被final修饰的类）。\n  - 如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法。\n  - 类中的字段、方法是否与父类产生矛盾（例如覆盖了父类的final字段，或者出现不符合规则的方 法重载，例如方法参数都一致，但返回值类型却不同等）。\n  - ...........等\n- 字节码验证：主要是通过数据流分析和控制流分析，确定程序语义是否合法、符合逻辑。\n  - 保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作，例如不会出现类似于“在操作 栈放置了一个int类型的数据，使用时却按long类型来加载入本地变量表中”这样的情况。\n  - 保证任何跳转指令都不会跳转到方法体以外的字节码指令上。\n  - 保证方法体中的类型转换总是有效的，例如可以把一个子类对象赋值给父类数据类型，这是安全的，但是把父类对象赋值给子类数据类型，甚至把对象赋值给与它毫无继承关系、完全不相干的一个 数据类型，则是危险和不合法的。\n  - ……\n- 符号引用验证： 发生在虚拟机将符号引用转化为直接引用的时候。符号引用验证可以看作是对类自身以外（常量池中的各种符号 引用）的各类信息进行匹配性校验，通俗来说就是，该类是否缺少或者被禁止访问它依赖的某些外部 类、方法、字段等资源。\n  - 符号引用中通过字符串描述的全限定名是否能找到对应的类。\n  - 在指定类中是否存在符合方法的字段描述符及简单名称所描述的方法和字段。\n  - 符号引用中的类、字段、方法的可访问性（private、protected、public、）是否可被当 前类访问。\n  - …… 等\n\n### 准备\n\n　　正式为类中定义的变量（即静态变量，被static修饰的变量）分配内存并设置类变量初始值（值“通常情况”下是数据类型的零值）\n如果类字段的字段属性表中存在ConstantValue属性，那在准备阶段变量值就会被初始化为ConstantValue属性所指定的初始值。\n\n> - ConstantValue属于属性表集合中的一个属性，属性表集合中一共有21个不同属性。\n> - ConstantValue属性的使用位置：字段表；含义：final关键字定义的常量值。\n> - ConstantValue属性作用：通知虚拟机自动为静态变量赋值。\n\n　　int x =123; static int x = 123;\n\n> - 对虚拟机来说上面两种变量赋值的方式和时刻都有所不同。\n> - 非static类型变量（实例变量）\n>   - 赋值是在实例构造器<init>方法中进行的。\n> - static类型变量（类变量）\n>   - 有两种选择：在类构造器<clinit>方法或者使用ConstantValue属性。\n>     - 同时使用final 、static来修饰的变量（常量），并且这个变量的数据类型是基本类型或者String类型，就生成ConstantValue属性来进行初始化。\n>     - 没有final修饰或者并非基本类型及String类型，则选择在<clinit>方法中进行初始化。\n\n### 解析\n\n　　 将常量池内的符号引用替换为直接引用\n\n> 符号引用（Symbolic References）：符号引用以一组符号来描述所引用的目标，符号可以是任何 形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定是已经加载到虚拟机内存当中的内容。各种虚拟机实现的内存布局可以各不相同， 但是它们能接受的符号引用必须都是一致的，因为符号引用的字面量形式明确定义在《Java虚拟机规 范》的Class文件格式中。\n> ·直接引用（Direct References）：直接引用是可以直接指向目标的指针、相对偏移量或者是一个能 间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局直接相关的，同一个符号引用在不同虚 拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在虚拟机 的内存中存在。\n\n### 初始化\n\n### 卸载\n\n## 虚拟机中的对象\n\n![](/assets/net-img-4122e8fc2d6e2995074ede61ff44aef4-20230330213516-hs7yexh.svg)\n\n### 对象的创建\n\n1. 类加载\n   1. 加载\n   2. 链接\n   3. 初始化\n2. 分配空间\n   1. 指针碰撞：假设java内存绝对规整，被使用的和未使用的中间放一个指针作为分界点的指示器，分配内存时，仅需把指针挪动挪动一段和对象大小相同的距离即可。\n   2. 空闲列表：虚拟机维护一个列表，记录那些内存块是可用的，分配时从列表中获取一块足够大的空间去分配，并更新列表。\n\n> 使用Serial，ParNew等压缩整理整理过程的收集器是，系统采用指针碰撞；而是用CMS等交换算法收集器时，采用空闲列表分配空间\n\n　　内存分配（指针碰撞存在并发安全）并发问题解决方案：\n\n- CAS+重试：\n- TLAB（本地线程分配缓存）：把内存分配的动作按照线程划分在不同的空间之中进行，每个线程在JAVA堆中预先分配小块内存，只有本地缓存用完，分配新的缓存区时才需要同步锁定。\n\n> 内存分配完成，虚拟机必须将已分配的内存空间初始化零值，如果使用TLAB，初始化零值也可以提前至TLAB分配时顺便初始化零值\n\n3. 初始化零值\n   1. 将分配的空间都初始化为零值\n4. 设置对象头\n5. 执行init方法\n\n### 对象的卸载\n\n　　Java虚拟机自带的类加载器所加载的类，在整个虚拟机的生命周期中，都不会被卸载。\n用户自定义的类加载器是可以被卸载的。\n**卸载时机：**\n\n1. 该类的所有实例对象都被回收\n2. 该类的类加载器对象已经被回收\n3. 该类对应的Class对象没有被引用，无法在任何地方通过反射获取\n\n### 对象的内存布局\n\n​![图像](/assets/image-20231202123415-e2licnx.jpeg)​\n\n　　**jvm默认开启class pointer压缩 为4字节**  \n普通对象 markword 默认八个字节 instance data 若属性则为零 padding 补足被8整除  \n​![image.png](/assets/net-img-1615611389351-2cfaa4d5-b52c-4a2e-a170-c32ce97d17a6-20230330213518-3fydrb9.png)  \n数组对象  \n​![image.png](/assets/net-img-1615611419969-14ba7126-9f92-482c-a851-9898cece7e8f-20230330213518-2ptpa3a.png)  \nhotspot 虚拟机对象头markword\n\n|存储内容|标志位|状态|\n| ------------------------------------| ------| ----------------|\n|对象哈希码，对象分代年龄|01|未锁定|\n|指向锁记录的指针|00|轻量级锁状态|\n|指向重量级锁的指针|10|重量级锁状态|\n|空，不需要记录信息|11|gc标志|\n|偏向线程id、偏向时间戳、对象分代年龄|01|可偏向（偏向锁）|\n\n![image.png](/assets/net-img-1615614053644-2e45ea92-d426-42ca-a609-91b095ff7e83-20230330213519-1im5mrq.png)\n\n## 虚拟机类加载器\n\n​![image](/assets/image-20231117162020-0zic8ee.png)​\n\n​![image](/assets/image-20231117162030-ue9pyz9.png)​\n\n### jdk8\n\n1. 引导类加载器\n2. 扩展类加载器\n3. 应用类加载器\n\n### jdk9\n\n1. 引导类加载器\n2. 平台类加载器（原扩展类加载器，因兼容性被保留）\n3. 应用类加载器\n\n### jdk9后的变化\n\n　　为了保证兼容性，JDK 9没有从根本上改变三层类加载器架构和双亲委派模型，但为了模块化系统的顺利运行，仍然发生了一些值得被注意的变动。\n\n1. 扩展机制被移除，扩展类加载器由于向后兼容性的原因被保留，不过被重命名为平台类加载器（platform class loader）。可以通过ClassLoader的新方法getPlatformClassLoader()来获取。\n\n　　JDK 9 时基于模块化进行构建（原来的 rt.jar 和 tools.jar 被拆分成数十个 JMOD 文件），其中的 Java 类库就已天然地满足了可扩展的需求，那自然无须再保留 <JAVA_HOME>\\lib\\ext 目录，此前使用这个目录或者 java.ext.dirs 系统变量来扩展 JDK 功能的机制已经没有继续存在的价值了。\n\n2. 平台类加载器和应用程序类加载器都不再继承自 java.net.URLClassLoader。  \n    现在启动类加载器、平台类加载器、应用程序类加载器全都继承于 jdk.internal.loader.BuiltinClassLoader。\n\n​![image](/assets/image-20231119124040-5kytmcz.png)​\n\n　　如果有程序直接依赖了这种继承关系，或者依赖了 URLClassLoader 类的特定方法，那代码很可能会在 JDK 9 及更高版本的 JDK 中崩溃。\n\n3. 在Java 9中，类加载器有了名称。该名称在构造方法中指定，可以通过getName()方法来获取。平台类加载器的名称是platform，应用类加载器的名称是app。类加载器的名称在调试与类加载器相关的问题时会非常有用。\n4. 启动类加载器现在是在jvm内部和java类库共同协作实现的类加载器（以前是 C++实现），但为了与之前代码兼容，在获取启动类加载器的场景中仍然会返回null，而不会得到BootClassLoader实例。\n5. 类加载的委派关系也发生了变动。  \n    当平台及应用程序类加载器收到类加载请求，在委派给父加载器加载前，要先判断该类是否能够归属到某一个系统模块中，如果可以找到这样的归属关系，就要优先委派给负责那个模块的加载器完成加载。\n\n　　‍\n\n　　双亲委派模式示意图\n\n​![image](/assets/image-20231119124137-6apottn.png)​\n\n　　附加：  \n在 Java 模块化系统明确规定了三个类加载器负责各自加载的模块：  \n启动类加载器负责加载的模块  \njava.base                        java.security.sasl  \njava.datatransfer                java.xml  \njava.desktop                     jdk.httpserver  \njava.instrument                  jdk.internal.vm.ci  \njava.logging                     jdk.management  \njava.management                  jdk.management.agent  \njava.management.rmi              jdk.naming.rmi  \njava.naming                      jdk.net  \njava.prefs                       jdk.sctp  \njava.rmi                         jdk.unsupported\n\n　　平台类加载器负责加载的模块  \njava.activation*                jdk.accessibility  \njava.compiler*                  jdk.charsets  \njava.corba*                     jdk.crypto.cryptoki  \njava.scripting                  jdk.crypto.ec  \njava.se                         jdk.dynalink  \njava.se.ee                      jdk.incubator.httpclient  \njava.security.jgss              jdk.internal.vm.compiler*  \njava.smartcardio                jdk.jsobject  \njava.sql                        jdk.localedata  \njava.sql.rowset                 jdk.naming.dns  \njava.transaction*               jdk.scripting.nashorn  \njava.xml.bind*                  jdk.security.auth  \njava.xml.crypto                 jdk.security.jgss  \njava.xml.ws*                    jdk.xml.dom  \njava.xml.ws.annotation*         jdk.zipfs\n\n　　应用程序类加载器负责加载的模块  \njdk.aot                         jdk.jdeps  \njdk.attach                      jdk.jdi  \njdk.compiler                    jdk.jdwp.agent  \njdk.editpad                     jdk.jlink  \njdk.hotspot.agent               jdk.jshell  \njdk.internal.ed                 jdk.jstatd  \njdk.internal.jvmstat            jdk.pack  \njdk.internal.le                 jdk.policytool  \njdk.internal.opt                jdk.rmic  \njdk.jartool                     jdk.scripting.nashorn.shell  \njdk.javadoc                     jdk.xml.bind*  \njdk.jcmd                        jdk.xml.ws*  \njdk.jconsole\n\n　　‍\n","slug":"java-JVM-虚拟机中的对象","published":1,"updated":"2025-04-28T08:41:48.391Z","_id":"cm9s3f40k002zbfg47g4cdort","comments":1,"layout":"post","photos":[],"content":"<h1>虚拟机中的对象</h1>\n<p>‍</p>\n<h2 id=\"虚拟机类加载机制\">虚拟机类加载机制</h2>\n<p><img src=\"/assets/net-img-1629870852837-ca139768-9f26-412a-8940-49ed6e38f57a-20230330213513-n1dmxgm.png\" alt=\"image.png\"><br>\n<em>类的生命周期</em><br>\n<em>加载，验证，准备，初始化_和_卸载_这五个顺序是可以确定的，类型的加载过成必须按照这种顺序按部就班的</em><strong>开始，</strong> <em>而_解析_阶段可以在初始化阶段后再开始。（并非完成一步后再进行其他部分，通常可以交叉混合进行）<br>\n有且只有六种情况必须对类立刻进行</em><strong>初始化</strong>_（加载，验证等在此之前已完成）；</p>\n<ul>\n<li>遇到 new getstatic，putstatic或invokestatic四条字节码指令时，如果类型没有进行初始化，则会先出发其初始化阶段。生成该四种指令的典型java代码有：\n<ul>\n<li>new 一个实例对象</li>\n<li>读取或设置一个类型的静态字段（被final修饰或已在编译器把结果放入常量池的静态字段除外）</li>\n<li>调用一个类型的静态方法的时候</li>\n</ul>\n</li>\n<li>使用java.lang.reflect包的方法对类型进行反射调用的时候，如果类型没有进行过初始化，则需 要先触发其初始化。</li>\n<li>当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</li>\n<li>当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先 初始化这个主类</li>\n<li>当一个接口中定义了JDK 8新加入的默认方法（被default关键字修饰的接口方法）时，如果有 这个接口的实现类发生了初始化，那该接口要在其之前被初始化。</li>\n<li>** 当使用JDK 7新加入的动态语言支持时？？？**</li>\n</ul>\n<h3 id=\"加载\">加载</h3>\n<p>在加载阶段，Java虚拟机需要完成以下三件事情：</p>\n<ul>\n<li>通过一个类的全限定名来获取定义此类的二进制字节流。</li>\n<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li>\n<li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入 口。</li>\n</ul>\n<h3 id=\"验证\">验证</h3>\n<ul>\n<li>文件格式验证：检验文件是否符合Class文件规范，从而保证输入的字节流能够正确的解析并存储于方法区内。\n<ul>\n<li>是否以魔数0xCAFEBABE开头。 ·主、次版本号是否在当前Java虚拟机接受范围之内。</li>\n<li>常量池的常量中是否有不被支持的常量类型（检查常量tag标志）。</li>\n<li>指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量。</li>\n<li>CONSTANT_Utf8_info型的常量中是否有不符合UTF-8编码的数据。</li>\n<li>Class文件中各个部分及文件本身是否有被删除的或附加的其他信息。</li>\n<li>… 等</li>\n</ul>\n</li>\n<li>元数据验证：对字节码描述的信息进行语义分析\n<ul>\n<li>这个类是否有父类（除了java.lang.Object之外，所有的类都应当有父类）。</li>\n<li>这个类的父类是否继承了不允许被继承的类（被final修饰的类）。</li>\n<li>如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法。</li>\n<li>类中的字段、方法是否与父类产生矛盾（例如覆盖了父类的final字段，或者出现不符合规则的方 法重载，例如方法参数都一致，但返回值类型却不同等）。</li>\n<li>…等</li>\n</ul>\n</li>\n<li>字节码验证：主要是通过数据流分析和控制流分析，确定程序语义是否合法、符合逻辑。\n<ul>\n<li>保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作，例如不会出现类似于“在操作 栈放置了一个int类型的数据，使用时却按long类型来加载入本地变量表中”这样的情况。</li>\n<li>保证任何跳转指令都不会跳转到方法体以外的字节码指令上。</li>\n<li>保证方法体中的类型转换总是有效的，例如可以把一个子类对象赋值给父类数据类型，这是安全的，但是把父类对象赋值给子类数据类型，甚至把对象赋值给与它毫无继承关系、完全不相干的一个 数据类型，则是危险和不合法的。</li>\n<li>……</li>\n</ul>\n</li>\n<li>符号引用验证： 发生在虚拟机将符号引用转化为直接引用的时候。符号引用验证可以看作是对类自身以外（常量池中的各种符号 引用）的各类信息进行匹配性校验，通俗来说就是，该类是否缺少或者被禁止访问它依赖的某些外部 类、方法、字段等资源。\n<ul>\n<li>符号引用中通过字符串描述的全限定名是否能找到对应的类。</li>\n<li>在指定类中是否存在符合方法的字段描述符及简单名称所描述的方法和字段。</li>\n<li>符号引用中的类、字段、方法的可访问性（private、protected、public、）是否可被当 前类访问。</li>\n<li>…… 等</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"准备\">准备</h3>\n<p>正式为类中定义的变量（即静态变量，被static修饰的变量）分配内存并设置类变量初始值（值“通常情况”下是数据类型的零值）<br>\n如果类字段的字段属性表中存在ConstantValue属性，那在准备阶段变量值就会被初始化为ConstantValue属性所指定的初始值。</p>\n<blockquote>\n<ul>\n<li>ConstantValue属于属性表集合中的一个属性，属性表集合中一共有21个不同属性。</li>\n<li>ConstantValue属性的使用位置：字段表；含义：final关键字定义的常量值。</li>\n<li>ConstantValue属性作用：通知虚拟机自动为静态变量赋值。</li>\n</ul>\n</blockquote>\n<p>int x =123; static int x = 123;</p>\n<blockquote>\n<ul>\n<li>对虚拟机来说上面两种变量赋值的方式和时刻都有所不同。</li>\n<li>非static类型变量（实例变量）\n<ul>\n<li>赋值是在实例构造器<init>方法中进行的。</li>\n</ul>\n</li>\n<li>static类型变量（类变量）\n<ul>\n<li>有两种选择：在类构造器<clinit>方法或者使用ConstantValue属性。\n<ul>\n<li>同时使用final 、static来修饰的变量（常量），并且这个变量的数据类型是基本类型或者String类型，就生成ConstantValue属性来进行初始化。</li>\n<li>没有final修饰或者并非基本类型及String类型，则选择在<clinit>方法中进行初始化。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<h3 id=\"解析\">解析</h3>\n<p>将常量池内的符号引用替换为直接引用</p>\n<blockquote>\n<p>符号引用（Symbolic References）：符号引用以一组符号来描述所引用的目标，符号可以是任何 形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定是已经加载到虚拟机内存当中的内容。各种虚拟机实现的内存布局可以各不相同， 但是它们能接受的符号引用必须都是一致的，因为符号引用的字面量形式明确定义在《Java虚拟机规 范》的Class文件格式中。<br>\n·直接引用（Direct References）：直接引用是可以直接指向目标的指针、相对偏移量或者是一个能 间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局直接相关的，同一个符号引用在不同虚 拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在虚拟机 的内存中存在。</p>\n</blockquote>\n<h3 id=\"初始化\">初始化</h3>\n<h3 id=\"卸载\">卸载</h3>\n<h2 id=\"虚拟机中的对象\">虚拟机中的对象</h2>\n<p><img src=\"/assets/net-img-4122e8fc2d6e2995074ede61ff44aef4-20230330213516-hs7yexh.svg\" alt=\"\"></p>\n<h3 id=\"对象的创建\">对象的创建</h3>\n<ol>\n<li>类加载\n<ol>\n<li>加载</li>\n<li>链接</li>\n<li>初始化</li>\n</ol>\n</li>\n<li>分配空间\n<ol>\n<li>指针碰撞：假设java内存绝对规整，被使用的和未使用的中间放一个指针作为分界点的指示器，分配内存时，仅需把指针挪动挪动一段和对象大小相同的距离即可。</li>\n<li>空闲列表：虚拟机维护一个列表，记录那些内存块是可用的，分配时从列表中获取一块足够大的空间去分配，并更新列表。</li>\n</ol>\n</li>\n</ol>\n<blockquote>\n<p>使用Serial，ParNew等压缩整理整理过程的收集器是，系统采用指针碰撞；而是用CMS等交换算法收集器时，采用空闲列表分配空间</p>\n</blockquote>\n<p>内存分配（指针碰撞存在并发安全）并发问题解决方案：</p>\n<ul>\n<li>CAS+重试：</li>\n<li>TLAB（本地线程分配缓存）：把内存分配的动作按照线程划分在不同的空间之中进行，每个线程在JAVA堆中预先分配小块内存，只有本地缓存用完，分配新的缓存区时才需要同步锁定。</li>\n</ul>\n<blockquote>\n<p>内存分配完成，虚拟机必须将已分配的内存空间初始化零值，如果使用TLAB，初始化零值也可以提前至TLAB分配时顺便初始化零值</p>\n</blockquote>\n<ol start=\"3\">\n<li>初始化零值\n<ol>\n<li>将分配的空间都初始化为零值</li>\n</ol>\n</li>\n<li>设置对象头</li>\n<li>执行init方法</li>\n</ol>\n<h3 id=\"对象的卸载\">对象的卸载</h3>\n<p>Java虚拟机自带的类加载器所加载的类，在整个虚拟机的生命周期中，都不会被卸载。<br>\n用户自定义的类加载器是可以被卸载的。<br>\n<strong>卸载时机：</strong></p>\n<ol>\n<li>该类的所有实例对象都被回收</li>\n<li>该类的类加载器对象已经被回收</li>\n<li>该类对应的Class对象没有被引用，无法在任何地方通过反射获取</li>\n</ol>\n<h3 id=\"对象的内存布局\">对象的内存布局</h3>\n<p>​<img src=\"/assets/image-20231202123415-e2licnx.jpeg\" alt=\"图像\">​</p>\n<p><strong>jvm默认开启class pointer压缩 为4字节</strong><br>\n普通对象 markword 默认八个字节 instance data 若属性则为零 padding 补足被8整除<br>\n​<img src=\"/assets/net-img-1615611389351-2cfaa4d5-b52c-4a2e-a170-c32ce97d17a6-20230330213518-3fydrb9.png\" alt=\"image.png\"><br>\n数组对象<br>\n​<img src=\"/assets/net-img-1615611419969-14ba7126-9f92-482c-a851-9898cece7e8f-20230330213518-2ptpa3a.png\" alt=\"image.png\"><br>\nhotspot 虚拟机对象头markword</p>\n<table>\n<thead>\n<tr>\n<th>存储内容</th>\n<th>标志位</th>\n<th>状态</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>对象哈希码，对象分代年龄</td>\n<td>01</td>\n<td>未锁定</td>\n</tr>\n<tr>\n<td>指向锁记录的指针</td>\n<td>00</td>\n<td>轻量级锁状态</td>\n</tr>\n<tr>\n<td>指向重量级锁的指针</td>\n<td>10</td>\n<td>重量级锁状态</td>\n</tr>\n<tr>\n<td>空，不需要记录信息</td>\n<td>11</td>\n<td>gc标志</td>\n</tr>\n<tr>\n<td>偏向线程id、偏向时间戳、对象分代年龄</td>\n<td>01</td>\n<td>可偏向（偏向锁）</td>\n</tr>\n</tbody>\n</table>\n<p><img src=\"/assets/net-img-1615614053644-2e45ea92-d426-42ca-a609-91b095ff7e83-20230330213519-1im5mrq.png\" alt=\"image.png\"></p>\n<h2 id=\"虚拟机类加载器\">虚拟机类加载器</h2>\n<p>​<img src=\"/assets/image-20231117162020-0zic8ee.png\" alt=\"image\">​</p>\n<p>​<img src=\"/assets/image-20231117162030-ue9pyz9.png\" alt=\"image\">​</p>\n<h3 id=\"jdk8\">jdk8</h3>\n<ol>\n<li>引导类加载器</li>\n<li>扩展类加载器</li>\n<li>应用类加载器</li>\n</ol>\n<h3 id=\"jdk9\">jdk9</h3>\n<ol>\n<li>引导类加载器</li>\n<li>平台类加载器（原扩展类加载器，因兼容性被保留）</li>\n<li>应用类加载器</li>\n</ol>\n<h3 id=\"jdk9后的变化\">jdk9后的变化</h3>\n<p>为了保证兼容性，JDK 9没有从根本上改变三层类加载器架构和双亲委派模型，但为了模块化系统的顺利运行，仍然发生了一些值得被注意的变动。</p>\n<ol>\n<li>扩展机制被移除，扩展类加载器由于向后兼容性的原因被保留，不过被重命名为平台类加载器（platform class loader）。可以通过ClassLoader的新方法getPlatformClassLoader()来获取。</li>\n</ol>\n<p>JDK 9 时基于模块化进行构建（原来的 rt.jar 和 tools.jar 被拆分成数十个 JMOD 文件），其中的 Java 类库就已天然地满足了可扩展的需求，那自然无须再保留 &lt;JAVA_HOME&gt;\\lib\\ext 目录，此前使用这个目录或者 java.ext.dirs 系统变量来扩展 JDK 功能的机制已经没有继续存在的价值了。</p>\n<ol start=\"2\">\n<li>平台类加载器和应用程序类加载器都不再继承自 java.net.URLClassLoader。<br>\n现在启动类加载器、平台类加载器、应用程序类加载器全都继承于 jdk.internal.loader.BuiltinClassLoader。</li>\n</ol>\n<p>​<img src=\"/assets/image-20231119124040-5kytmcz.png\" alt=\"image\">​</p>\n<p>如果有程序直接依赖了这种继承关系，或者依赖了 URLClassLoader 类的特定方法，那代码很可能会在 JDK 9 及更高版本的 JDK 中崩溃。</p>\n<ol start=\"3\">\n<li>在Java 9中，类加载器有了名称。该名称在构造方法中指定，可以通过getName()方法来获取。平台类加载器的名称是platform，应用类加载器的名称是app。类加载器的名称在调试与类加载器相关的问题时会非常有用。</li>\n<li>启动类加载器现在是在jvm内部和java类库共同协作实现的类加载器（以前是 C++实现），但为了与之前代码兼容，在获取启动类加载器的场景中仍然会返回null，而不会得到BootClassLoader实例。</li>\n<li>类加载的委派关系也发生了变动。<br>\n当平台及应用程序类加载器收到类加载请求，在委派给父加载器加载前，要先判断该类是否能够归属到某一个系统模块中，如果可以找到这样的归属关系，就要优先委派给负责那个模块的加载器完成加载。</li>\n</ol>\n<p>‍</p>\n<p>双亲委派模式示意图</p>\n<p>​<img src=\"/assets/image-20231119124137-6apottn.png\" alt=\"image\">​</p>\n<p>附加：<br>\n在 Java 模块化系统明确规定了三个类加载器负责各自加载的模块：<br>\n启动类加载器负责加载的模块<br>\njava.base                        java.security.sasl<br>\njava.datatransfer                java.xml<br>\njava.desktop                     jdk.httpserver<br>\njava.instrument                  <a href=\"http://jdk.internal.vm.ci\">jdk.internal.vm.ci</a><br>\njava.logging                     jdk.management<br>\njava.management                  jdk.management.agent<br>\njava.management.rmi              jdk.naming.rmi<br>\njava.naming                      <a href=\"http://jdk.net\">jdk.net</a><br>\njava.prefs                       jdk.sctp<br>\njava.rmi                         jdk.unsupported</p>\n<p>平台类加载器负责加载的模块<br>\njava.activation*                jdk.accessibility<br>\njava.compiler*                  jdk.charsets<br>\njava.corba*                     jdk.crypto.cryptoki<br>\njava.scripting                  <a href=\"http://jdk.crypto.ec\">jdk.crypto.ec</a><br>\n<a href=\"http://java.se\">java.se</a>                         jdk.dynalink<br>\n<a href=\"http://java.se.ee\">java.se.ee</a>                      jdk.incubator.httpclient<br>\njava.security.jgss              jdk.internal.vm.compiler*<br>\njava.smartcardio                jdk.jsobject<br>\njava.sql                        jdk.localedata<br>\njava.sql.rowset                 jdk.naming.dns<br>\njava.transaction*               jdk.scripting.nashorn<br>\njava.xml.bind*                  jdk.security.auth<br>\njava.xml.crypto                 jdk.security.jgss<br>\n<a href=\"http://java.xml.ws\">java.xml.ws</a>*                    jdk.xml.dom<br>\njava.xml.ws.annotation*         jdk.zipfs</p>\n<p>应用程序类加载器负责加载的模块<br>\njdk.aot                         jdk.jdeps<br>\njdk.attach                      jdk.jdi<br>\njdk.compiler                    jdk.jdwp.agent<br>\njdk.editpad                     jdk.jlink<br>\njdk.hotspot.agent               jdk.jshell<br>\njdk.internal.ed                 jdk.jstatd<br>\njdk.internal.jvmstat            jdk.pack<br>\njdk.internal.le                 jdk.policytool<br>\njdk.internal.opt                jdk.rmic<br>\njdk.jartool                     jdk.scripting.nashorn.shell<br>\njdk.javadoc                     jdk.xml.bind*<br>\njdk.jcmd                        <a href=\"http://jdk.xml.ws\">jdk.xml.ws</a>*<br>\njdk.jconsole</p>\n<p>‍</p>\n","excerpt":"","more":"<h1>虚拟机中的对象</h1>\n<p>‍</p>\n<h2 id=\"虚拟机类加载机制\">虚拟机类加载机制</h2>\n<p><img src=\"/assets/net-img-1629870852837-ca139768-9f26-412a-8940-49ed6e38f57a-20230330213513-n1dmxgm.png\" alt=\"image.png\"><br>\n<em>类的生命周期</em><br>\n<em>加载，验证，准备，初始化_和_卸载_这五个顺序是可以确定的，类型的加载过成必须按照这种顺序按部就班的</em><strong>开始，</strong> <em>而_解析_阶段可以在初始化阶段后再开始。（并非完成一步后再进行其他部分，通常可以交叉混合进行）<br>\n有且只有六种情况必须对类立刻进行</em><strong>初始化</strong>_（加载，验证等在此之前已完成）；</p>\n<ul>\n<li>遇到 new getstatic，putstatic或invokestatic四条字节码指令时，如果类型没有进行初始化，则会先出发其初始化阶段。生成该四种指令的典型java代码有：\n<ul>\n<li>new 一个实例对象</li>\n<li>读取或设置一个类型的静态字段（被final修饰或已在编译器把结果放入常量池的静态字段除外）</li>\n<li>调用一个类型的静态方法的时候</li>\n</ul>\n</li>\n<li>使用java.lang.reflect包的方法对类型进行反射调用的时候，如果类型没有进行过初始化，则需 要先触发其初始化。</li>\n<li>当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</li>\n<li>当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先 初始化这个主类</li>\n<li>当一个接口中定义了JDK 8新加入的默认方法（被default关键字修饰的接口方法）时，如果有 这个接口的实现类发生了初始化，那该接口要在其之前被初始化。</li>\n<li>** 当使用JDK 7新加入的动态语言支持时？？？**</li>\n</ul>\n<h3 id=\"加载\">加载</h3>\n<p>在加载阶段，Java虚拟机需要完成以下三件事情：</p>\n<ul>\n<li>通过一个类的全限定名来获取定义此类的二进制字节流。</li>\n<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li>\n<li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入 口。</li>\n</ul>\n<h3 id=\"验证\">验证</h3>\n<ul>\n<li>文件格式验证：检验文件是否符合Class文件规范，从而保证输入的字节流能够正确的解析并存储于方法区内。\n<ul>\n<li>是否以魔数0xCAFEBABE开头。 ·主、次版本号是否在当前Java虚拟机接受范围之内。</li>\n<li>常量池的常量中是否有不被支持的常量类型（检查常量tag标志）。</li>\n<li>指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量。</li>\n<li>CONSTANT_Utf8_info型的常量中是否有不符合UTF-8编码的数据。</li>\n<li>Class文件中各个部分及文件本身是否有被删除的或附加的其他信息。</li>\n<li>… 等</li>\n</ul>\n</li>\n<li>元数据验证：对字节码描述的信息进行语义分析\n<ul>\n<li>这个类是否有父类（除了java.lang.Object之外，所有的类都应当有父类）。</li>\n<li>这个类的父类是否继承了不允许被继承的类（被final修饰的类）。</li>\n<li>如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法。</li>\n<li>类中的字段、方法是否与父类产生矛盾（例如覆盖了父类的final字段，或者出现不符合规则的方 法重载，例如方法参数都一致，但返回值类型却不同等）。</li>\n<li>…等</li>\n</ul>\n</li>\n<li>字节码验证：主要是通过数据流分析和控制流分析，确定程序语义是否合法、符合逻辑。\n<ul>\n<li>保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作，例如不会出现类似于“在操作 栈放置了一个int类型的数据，使用时却按long类型来加载入本地变量表中”这样的情况。</li>\n<li>保证任何跳转指令都不会跳转到方法体以外的字节码指令上。</li>\n<li>保证方法体中的类型转换总是有效的，例如可以把一个子类对象赋值给父类数据类型，这是安全的，但是把父类对象赋值给子类数据类型，甚至把对象赋值给与它毫无继承关系、完全不相干的一个 数据类型，则是危险和不合法的。</li>\n<li>……</li>\n</ul>\n</li>\n<li>符号引用验证： 发生在虚拟机将符号引用转化为直接引用的时候。符号引用验证可以看作是对类自身以外（常量池中的各种符号 引用）的各类信息进行匹配性校验，通俗来说就是，该类是否缺少或者被禁止访问它依赖的某些外部 类、方法、字段等资源。\n<ul>\n<li>符号引用中通过字符串描述的全限定名是否能找到对应的类。</li>\n<li>在指定类中是否存在符合方法的字段描述符及简单名称所描述的方法和字段。</li>\n<li>符号引用中的类、字段、方法的可访问性（private、protected、public、）是否可被当 前类访问。</li>\n<li>…… 等</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"准备\">准备</h3>\n<p>正式为类中定义的变量（即静态变量，被static修饰的变量）分配内存并设置类变量初始值（值“通常情况”下是数据类型的零值）<br>\n如果类字段的字段属性表中存在ConstantValue属性，那在准备阶段变量值就会被初始化为ConstantValue属性所指定的初始值。</p>\n<blockquote>\n<ul>\n<li>ConstantValue属于属性表集合中的一个属性，属性表集合中一共有21个不同属性。</li>\n<li>ConstantValue属性的使用位置：字段表；含义：final关键字定义的常量值。</li>\n<li>ConstantValue属性作用：通知虚拟机自动为静态变量赋值。</li>\n</ul>\n</blockquote>\n<p>int x =123; static int x = 123;</p>\n<blockquote>\n<ul>\n<li>对虚拟机来说上面两种变量赋值的方式和时刻都有所不同。</li>\n<li>非static类型变量（实例变量）\n<ul>\n<li>赋值是在实例构造器<init>方法中进行的。</li>\n</ul>\n</li>\n<li>static类型变量（类变量）\n<ul>\n<li>有两种选择：在类构造器<clinit>方法或者使用ConstantValue属性。\n<ul>\n<li>同时使用final 、static来修饰的变量（常量），并且这个变量的数据类型是基本类型或者String类型，就生成ConstantValue属性来进行初始化。</li>\n<li>没有final修饰或者并非基本类型及String类型，则选择在<clinit>方法中进行初始化。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<h3 id=\"解析\">解析</h3>\n<p>将常量池内的符号引用替换为直接引用</p>\n<blockquote>\n<p>符号引用（Symbolic References）：符号引用以一组符号来描述所引用的目标，符号可以是任何 形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定是已经加载到虚拟机内存当中的内容。各种虚拟机实现的内存布局可以各不相同， 但是它们能接受的符号引用必须都是一致的，因为符号引用的字面量形式明确定义在《Java虚拟机规 范》的Class文件格式中。<br>\n·直接引用（Direct References）：直接引用是可以直接指向目标的指针、相对偏移量或者是一个能 间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局直接相关的，同一个符号引用在不同虚 拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在虚拟机 的内存中存在。</p>\n</blockquote>\n<h3 id=\"初始化\">初始化</h3>\n<h3 id=\"卸载\">卸载</h3>\n<h2 id=\"虚拟机中的对象\">虚拟机中的对象</h2>\n<p><img src=\"/assets/net-img-4122e8fc2d6e2995074ede61ff44aef4-20230330213516-hs7yexh.svg\" alt=\"\"></p>\n<h3 id=\"对象的创建\">对象的创建</h3>\n<ol>\n<li>类加载\n<ol>\n<li>加载</li>\n<li>链接</li>\n<li>初始化</li>\n</ol>\n</li>\n<li>分配空间\n<ol>\n<li>指针碰撞：假设java内存绝对规整，被使用的和未使用的中间放一个指针作为分界点的指示器，分配内存时，仅需把指针挪动挪动一段和对象大小相同的距离即可。</li>\n<li>空闲列表：虚拟机维护一个列表，记录那些内存块是可用的，分配时从列表中获取一块足够大的空间去分配，并更新列表。</li>\n</ol>\n</li>\n</ol>\n<blockquote>\n<p>使用Serial，ParNew等压缩整理整理过程的收集器是，系统采用指针碰撞；而是用CMS等交换算法收集器时，采用空闲列表分配空间</p>\n</blockquote>\n<p>内存分配（指针碰撞存在并发安全）并发问题解决方案：</p>\n<ul>\n<li>CAS+重试：</li>\n<li>TLAB（本地线程分配缓存）：把内存分配的动作按照线程划分在不同的空间之中进行，每个线程在JAVA堆中预先分配小块内存，只有本地缓存用完，分配新的缓存区时才需要同步锁定。</li>\n</ul>\n<blockquote>\n<p>内存分配完成，虚拟机必须将已分配的内存空间初始化零值，如果使用TLAB，初始化零值也可以提前至TLAB分配时顺便初始化零值</p>\n</blockquote>\n<ol start=\"3\">\n<li>初始化零值\n<ol>\n<li>将分配的空间都初始化为零值</li>\n</ol>\n</li>\n<li>设置对象头</li>\n<li>执行init方法</li>\n</ol>\n<h3 id=\"对象的卸载\">对象的卸载</h3>\n<p>Java虚拟机自带的类加载器所加载的类，在整个虚拟机的生命周期中，都不会被卸载。<br>\n用户自定义的类加载器是可以被卸载的。<br>\n<strong>卸载时机：</strong></p>\n<ol>\n<li>该类的所有实例对象都被回收</li>\n<li>该类的类加载器对象已经被回收</li>\n<li>该类对应的Class对象没有被引用，无法在任何地方通过反射获取</li>\n</ol>\n<h3 id=\"对象的内存布局\">对象的内存布局</h3>\n<p>​<img src=\"/assets/image-20231202123415-e2licnx.jpeg\" alt=\"图像\">​</p>\n<p><strong>jvm默认开启class pointer压缩 为4字节</strong><br>\n普通对象 markword 默认八个字节 instance data 若属性则为零 padding 补足被8整除<br>\n​<img src=\"/assets/net-img-1615611389351-2cfaa4d5-b52c-4a2e-a170-c32ce97d17a6-20230330213518-3fydrb9.png\" alt=\"image.png\"><br>\n数组对象<br>\n​<img src=\"/assets/net-img-1615611419969-14ba7126-9f92-482c-a851-9898cece7e8f-20230330213518-2ptpa3a.png\" alt=\"image.png\"><br>\nhotspot 虚拟机对象头markword</p>\n<table>\n<thead>\n<tr>\n<th>存储内容</th>\n<th>标志位</th>\n<th>状态</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>对象哈希码，对象分代年龄</td>\n<td>01</td>\n<td>未锁定</td>\n</tr>\n<tr>\n<td>指向锁记录的指针</td>\n<td>00</td>\n<td>轻量级锁状态</td>\n</tr>\n<tr>\n<td>指向重量级锁的指针</td>\n<td>10</td>\n<td>重量级锁状态</td>\n</tr>\n<tr>\n<td>空，不需要记录信息</td>\n<td>11</td>\n<td>gc标志</td>\n</tr>\n<tr>\n<td>偏向线程id、偏向时间戳、对象分代年龄</td>\n<td>01</td>\n<td>可偏向（偏向锁）</td>\n</tr>\n</tbody>\n</table>\n<p><img src=\"/assets/net-img-1615614053644-2e45ea92-d426-42ca-a609-91b095ff7e83-20230330213519-1im5mrq.png\" alt=\"image.png\"></p>\n<h2 id=\"虚拟机类加载器\">虚拟机类加载器</h2>\n<p>​<img src=\"/assets/image-20231117162020-0zic8ee.png\" alt=\"image\">​</p>\n<p>​<img src=\"/assets/image-20231117162030-ue9pyz9.png\" alt=\"image\">​</p>\n<h3 id=\"jdk8\">jdk8</h3>\n<ol>\n<li>引导类加载器</li>\n<li>扩展类加载器</li>\n<li>应用类加载器</li>\n</ol>\n<h3 id=\"jdk9\">jdk9</h3>\n<ol>\n<li>引导类加载器</li>\n<li>平台类加载器（原扩展类加载器，因兼容性被保留）</li>\n<li>应用类加载器</li>\n</ol>\n<h3 id=\"jdk9后的变化\">jdk9后的变化</h3>\n<p>为了保证兼容性，JDK 9没有从根本上改变三层类加载器架构和双亲委派模型，但为了模块化系统的顺利运行，仍然发生了一些值得被注意的变动。</p>\n<ol>\n<li>扩展机制被移除，扩展类加载器由于向后兼容性的原因被保留，不过被重命名为平台类加载器（platform class loader）。可以通过ClassLoader的新方法getPlatformClassLoader()来获取。</li>\n</ol>\n<p>JDK 9 时基于模块化进行构建（原来的 rt.jar 和 tools.jar 被拆分成数十个 JMOD 文件），其中的 Java 类库就已天然地满足了可扩展的需求，那自然无须再保留 &lt;JAVA_HOME&gt;\\lib\\ext 目录，此前使用这个目录或者 java.ext.dirs 系统变量来扩展 JDK 功能的机制已经没有继续存在的价值了。</p>\n<ol start=\"2\">\n<li>平台类加载器和应用程序类加载器都不再继承自 java.net.URLClassLoader。<br>\n现在启动类加载器、平台类加载器、应用程序类加载器全都继承于 jdk.internal.loader.BuiltinClassLoader。</li>\n</ol>\n<p>​<img src=\"/assets/image-20231119124040-5kytmcz.png\" alt=\"image\">​</p>\n<p>如果有程序直接依赖了这种继承关系，或者依赖了 URLClassLoader 类的特定方法，那代码很可能会在 JDK 9 及更高版本的 JDK 中崩溃。</p>\n<ol start=\"3\">\n<li>在Java 9中，类加载器有了名称。该名称在构造方法中指定，可以通过getName()方法来获取。平台类加载器的名称是platform，应用类加载器的名称是app。类加载器的名称在调试与类加载器相关的问题时会非常有用。</li>\n<li>启动类加载器现在是在jvm内部和java类库共同协作实现的类加载器（以前是 C++实现），但为了与之前代码兼容，在获取启动类加载器的场景中仍然会返回null，而不会得到BootClassLoader实例。</li>\n<li>类加载的委派关系也发生了变动。<br>\n当平台及应用程序类加载器收到类加载请求，在委派给父加载器加载前，要先判断该类是否能够归属到某一个系统模块中，如果可以找到这样的归属关系，就要优先委派给负责那个模块的加载器完成加载。</li>\n</ol>\n<p>‍</p>\n<p>双亲委派模式示意图</p>\n<p>​<img src=\"/assets/image-20231119124137-6apottn.png\" alt=\"image\">​</p>\n<p>附加：<br>\n在 Java 模块化系统明确规定了三个类加载器负责各自加载的模块：<br>\n启动类加载器负责加载的模块<br>\njava.base                        java.security.sasl<br>\njava.datatransfer                java.xml<br>\njava.desktop                     jdk.httpserver<br>\njava.instrument                  <a href=\"http://jdk.internal.vm.ci\">jdk.internal.vm.ci</a><br>\njava.logging                     jdk.management<br>\njava.management                  jdk.management.agent<br>\njava.management.rmi              jdk.naming.rmi<br>\njava.naming                      <a href=\"http://jdk.net\">jdk.net</a><br>\njava.prefs                       jdk.sctp<br>\njava.rmi                         jdk.unsupported</p>\n<p>平台类加载器负责加载的模块<br>\njava.activation*                jdk.accessibility<br>\njava.compiler*                  jdk.charsets<br>\njava.corba*                     jdk.crypto.cryptoki<br>\njava.scripting                  <a href=\"http://jdk.crypto.ec\">jdk.crypto.ec</a><br>\n<a href=\"http://java.se\">java.se</a>                         jdk.dynalink<br>\n<a href=\"http://java.se.ee\">java.se.ee</a>                      jdk.incubator.httpclient<br>\njava.security.jgss              jdk.internal.vm.compiler*<br>\njava.smartcardio                jdk.jsobject<br>\njava.sql                        jdk.localedata<br>\njava.sql.rowset                 jdk.naming.dns<br>\njava.transaction*               jdk.scripting.nashorn<br>\njava.xml.bind*                  jdk.security.auth<br>\njava.xml.crypto                 jdk.security.jgss<br>\n<a href=\"http://java.xml.ws\">java.xml.ws</a>*                    jdk.xml.dom<br>\njava.xml.ws.annotation*         jdk.zipfs</p>\n<p>应用程序类加载器负责加载的模块<br>\njdk.aot                         jdk.jdeps<br>\njdk.attach                      jdk.jdi<br>\njdk.compiler                    jdk.jdwp.agent<br>\njdk.editpad                     jdk.jlink<br>\njdk.hotspot.agent               jdk.jshell<br>\njdk.internal.ed                 jdk.jstatd<br>\njdk.internal.jvmstat            jdk.pack<br>\njdk.internal.le                 jdk.policytool<br>\njdk.internal.opt                jdk.rmic<br>\njdk.jartool                     jdk.scripting.nashorn.shell<br>\njdk.javadoc                     jdk.xml.bind*<br>\njdk.jcmd                        <a href=\"http://jdk.xml.ws\">jdk.xml.ws</a>*<br>\njdk.jconsole</p>\n<p>‍</p>\n"},{"title":"垃圾回收和内存分配","date":"2022-10-30T05:40:49.000Z","lastmod":"2023-11-26T08:16:40.000Z","_content":"\n# 垃圾回收和内存分配\n\n## 垃圾回收\n\n### 垃圾判别算法\n\n#### 引用计数法\n\n> 一个对象A，只要有任何一个对象引用了A ，则A 的引用计数器就加1，当引用失效时，引用计数器就减1。只要对象A 的引用计数器的值为0，即表示对象A不可能再被使用，可进行回收。\n\n* 优点\n\n  * 实现简单，垃圾对象便于辨识；判定效率高，回收没有延迟性。\n* 缺点\n\n  * 需要单独的字段存储计数器，增加了存储空间的开销。\n  * 每次赋值伴随着计数器的增减，增加时间开销。\n  * 无法处理循环依赖的问题\n\n#### 可达性分析 \n\n> 将对象及其引用关系看作一个图，选定活动的对象作为 GC Roots，然后跟踪引用链条，如果一个对象和GC Roots之间不可达，也就是不存在引用链条，那么即可认为是可回收对象。\n\n　　基本思路：\n\n* 可达性分析算法是以根对象集合(GC Roots)为起始点，按照从上至下的方式搜索被根对象集合所连接的目标对象是否可达。\n* 使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索所走过的路径称为引用链(Reference Chain)\n* 如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象己经死亡，可以标记为垃圾对象。\n* 在可达性分析算法中，只有能够被根对象集合直接或者间接连接的对象才是存活对象。\n\n　　可作为\"GC Roots\"的对象\n\n* 虚拟机栈（栈帧中的本地变量表）中引用的对象，例如各个线程调用的方法堆中的参数，局部变量，临时变量。\n* 方法区中类静态属性引用的对象，例如java 类中的引用类型的静态变量\n* 方法区中常量引用的对象，例如字符串常量池中的引用\n* 本地方法栈中JNI（Native方法）引用的对象\n* Java虚拟机内部的引用，例如基础类型对应的Class对象，一些常驻的异常对象，还有系统类加载器\n* 所有被同步锁持有的对象。\n* 反应java虚拟机内部情况的JMXBean，JVMTI中的注册的回调，本地代码缓存等（？？？）\n\n　　注：如果要使用可达性分析算法来判断内存是否可回收，那么分析工作必须在一个能保障*一致性的快照*中进行，这点也是导致GC进行时必须“Stop The World”的一个重要原因。\n\n### 垃圾回收算法\n\n#### 标记清除\n\n> 标记：Collector从引用根节点开始遍历，标记所有被引用的对象。一般是在对象的Header中记录为可达对象。  \n> 清除：Collector对堆内存从头到尾进行线性的遍历，如果发现某个对象在其Header中没有标记为可达对象，则将其回收。\n\n* 效率比较低：递归与全堆对象遍历两次\n* 在进行GC的时候，需要停止整个应用程序，导致用户体验差\n* 这种方式清理出来的空闲内存是不连续的，产生内存碎片。\n\n#### 标记复制\n\n> 将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收。\n\n* 优点\n\n  * 不会造成空间碎片。\n* 缺点\n\n  * 需要两倍的内存空间\n  * 对于G1这种分拆成为大量region的GC，复制而不是移动，意味着GC需要维护region之间对象引用关系，不管是内存占用或者时间开销也不小。\n\n　　注：如果系统中的存活对象很多，复制算法不会很理想。因为复制算法需要复制的存活对象数量并不会太大,或者说非常低才行。\n\n#### 标记整理\n\n> 从根节点开始标记所有被引用对象  \n> 将所有的存活对象压缩到内存的一端，按顺序排放，清理边界外所有的空间。\n\n* 优点\n\n  * 消除了标记/清除算法当中，内存区域分散的缺点，我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可。\n  * 消除了复制算法当中，内存减半的高额代价。\n* 缺点\n\n  * 效率不高，不仅要标记所有存活对象，还要整理所有存活对象的引用地址。\n  * 对于老年代每次都有大量对象存活的区域来说，极为负重。\n  * 移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址。\n  * 移动过程中，需要全程暂停用户应用程序。即：STW\n\n#### 分代收集\n\n> 基于这样一个事实：不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点使用不同的回收算法，以提高垃圾回收的效率。\n\n#### 增量回收\n\n> 垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。\n\n　　注：线程上下文切换频繁，是的垃圾回收成本上升，导致吞吐量上升\n\n#### 分区算法\n\n> 将按照对象的生命周期长短划分成两个部分，分区算法将整个堆空间划分成连续的不同小区间。每一个小区间都独立使用，独立回收。\n\n### JVM四种引用\n\n#### 强引用\n\n　　特点：GC时，永远不会被回收  \n使用场景\n\n> new 对象\n\n#### 软引用SoftReference<Object>(obj);\n\n　　特点：内存不足时（自动触发GC），会被回收  \n使用场景\n\n> 缓存\n\n#### 弱引用WeakReference<Object>(obj)\n\n　　特点：无论内存是否充足，只要进行GC，都会被回收  \n使用场景\n\n> 内部对象为弱引用 WeakReference为强引用\n\n#### 虚引用PhantomReference<>(new Object(),new ReferenceQueue<>())\n\n　　特点：如同虚设，和没有引用没什么区别  \n使用场景\n\n> 1. 管理堆外面的引用\n\n> 首先标记出所需要回收的对象，在标记完成后，统一回收掉所有被标记的对象\n\n> 将可用内存划分为两部分，每次只使用其中一块，当一块内存用完时，将还存活对象复制到另外一块上面，然后再把已使用的内存空间清理一遍\n\n> 标记出所需要回收的对象，将所有需要存活的对象都向内存空间的一端移动，然后直接清理掉边界以外的内存\n\n## JVM GC 流程\n\n> [JVM堆的内存分布](https://www.yuque.com/pride_yang/blog/qsgy0z#vfjXH)\n\n> Minor GC  新生代GC\n\n> Major GC/Full GC\n\n1. 开始时，对象会先分配到eden区\n2. 引用运行，越来越多对象分配在eden区域\n3. 当eden区域放不下时，就会发生minor GC(young GC),利用可达性分析标记出垃圾对象，然后将有用对象移动到survivor0区域，将标记出来的垃圾对象全部清除，此时eden区域就全部清理干净了。整个过程使用了 mark-sweep（标记整理）方法回收eden区，使用mark-copy（标记复制） 方法将可用对象移动到 survivor0区域。\n4. 随着时间推移，eden如果又满了，再次触发minor GC，同样还是先做标记，这时eden和s0区可能都有垃圾对象了，注意：这时s1（即：to）区是空的，S0区和eden区的存活对象（S0 区域满了），将直接搬到s1区。然后将eden和S0区的垃圾清理掉，这一轮minor GC后，eden和S0区就变成了空的了。\n5. 随着对象的不断分配，eden空可能又满了，这时会重复刚才的minor GC过程，不过要注意的是，这时候s0是空的，所以s0与s1的角色其实会互换，即：存活的对象，会从eden和s1区，向s0区移动。然后再把eden和s1区中的垃圾清除，这一轮完成后，eden与s1区变成空的\n6. 对于那些比较“长寿”的对象一直在s0与s1中挪来挪去，一来很占地方，而且也会造成一定开销，降低gc效率，于是有了“代龄(age)”及“晋升”。对象在年青代的3个区(eden,s0,s1)之间，每次从1个区移到另1区，年龄+1，在young区达到一定的年龄阈值(-XX:MaxTenuringThreshold（默认15）)后，将晋升到老年代。\n7. 如果老年代，最终也放满了，就会发生major GC（即Full GC），由于老年代的的对象通常会比较多，因为标记-清理-整理（压缩）的耗时通常会比较长，会让应用出现卡顿的现象，\n\n​![](/assets/net-img-1646740660775-762fcaa3-26b5-4d95-ac43-5cca58540969-20230330213439-sxz1b5i.png)​\n\n## 垃圾收集器\n\n​![图像](.//assets/image-20231126145713-0pou43f.png)​\n\n1. 两个收集器间有连线，表明它们可以搭配使用：  \n    Serial/Serial Old、Serial/CMS、ParNew/Serial Old、ParNew/CMS、Parallel Scavenge/Serial Old、Parallel Scavenge/Parallel Old、G1；\n2. 其中Serial Old作为CMS出现\"Concurrent Mode Failure\"失败的后备预案。\n3. (红色虚线)由于维护和兼容性测试的成本，在JDK 8时将Serial+CMS、ParNew+Serial Old这两个组合声明为废弃（JEP 173），并在JDK 9中完全取消了这些组合的支持（JEP214），即：移除。\n4. (绿色虚线)JDK 14中：弃用Parallel Scavenge和SerialOld GC组合 （JEP 366）\n5. (青色虚线)JDK 14中：删除CMS垃圾回收器 （JEP 363）\n\n### 经典垃圾收集器\n\n#### Serial 收集器/Serial Old 收集器\n\n> 简单高效，占用内存小 适合客户端\n\n![image.png](/assets/net-img-1629558034184-e1fe6601-777e-4a34-afe5-df37e5a9b720-20230330213445-e5uive7.png \"运行示意图\")\n\n#### ParNew 收集器/Serial Old 收集器\n\n> 适合多核CPU 单核由于上下文切换，收集并不理想\n\n![image.png](/assets/net-img-1629559055065-5ad8d49f-81b6-45f3-87f8-c98716f799ed-20230330213451-7nkjlzc.png \"运行示意图\")\n\n#### Parallel Scavenge/Parallel Old收集器\n\n> 吞吐量优先的垃圾收集器，有自适应调节策略 jdk8的默认垃圾收集器\n\n![image.png](/assets/net-img-1629559366006-0194df18-86f2-45fd-bd85-6f675b19bdb0-20230330213459-p7i5mm5.png \"运行示意图\")\n\n#### CMS收集器（老年代）\n\n> CMS是基于Mark-Sweep实现的，对于对象的回收效率很高。\n>\n> 对于碎片问题，CMS采用基于Mark-Compact算法的Serial Old回收器作为补偿措施：当内存回收不佳（碎片导致的Concurrent Mode Failure时），将采用Serial Old执行Full GC以达到对老年代内存的整理\n\n![image.png](/assets/net-img-1629560137959-ab93eb78-c083-4c80-8283-4cfc470c8af0-20230330213504-cteixk9.png \"运行示意图\")\n\n* 初始标记（STW）：暂时时间非常短，标记与GC Roots直接关联的对象。\n* 并发标记（最耗时）：从GC Roots开始遍历整个对象图的过程。不会停顿用户线程\n* 重新标记：（STW）：修复并发标记环节，因为用户线程的执行，导致数据的不一致性问题\n* 并发清理（最耗时）：清理删除掉标记阶段判断的已经死亡的对象，释放内存空间。由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的。\n\n#### G1 收集器\n\n> 主要针对配备多核CPU及大容量内存的机器，以极高概率满足GC停顿时间的同时，还兼具高吞吐量，JDK9 以后的默认收集器\n\n![图像](/assets/image-20231126155909-4zbslm1.png)\n\n##### 回收过程\n\n1. 年轻代GC （Young GC）\n\n    1. ‍\n\n2. 老年代并发标记过程 （Concurrent Marking）\n\n3. 混合回收（Mixed GC）\n\n4. 如果需要，单线程、独占式、高强度的Full GC还是继续存在的。它针对GC的评估失败提供了一种失败保护机制，即强力回收。\n\n![图像 (2)](/assets/image-20231126161709-b35di3t.png)\n\n　　顺时针，young gc -> young gc + concurrent mark-> Mixed GC顺序，进行垃圾回收。\n\n##### 特点\n\n*  \n\n  * 并发性：G1拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此，一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况\n\n  **并行与并发**\n\n  * 并行性：G1在回收期间，可以有多个GC线程同时工作，有效利用多核计算能力。此时用户线程STW\n\n* **分代收集**\n\n  * 从分代上看，G1依然属于分代型垃圾回收器，它会区分年轻代和老年代，年轻代依然有Eden区和Survivor区。但从堆的结构上看，它不要求整个Eden区、年轻代或者老年代都是连续的，也不再坚持固定大小和固定数量。\n  * 将堆空间分为若干个区域（Region）,这些区域中包含了逻辑上的年轻代和老年代。\n  * 和之前的各类回收器不同，它同时兼顾年轻代和老年代。对比其他回收器，或者工作在年轻代，或者工作在老年代；\n\n* 空间整合\n\n  * CMS：“标记-清除”算法、内存碎片、若干次GC后进行一次碎片整理\n  * G1将内存划分为一个个的region。内存的回收是以region作为基本单位的。Region之间是复制算法，但整体上实际可看作是标记-压缩（Mark-Compact）算法，两种算法都可以避免内存碎片。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次 GC。尤其是当Java堆非常大的时候，G1的优势更加明显。\n* 可预测的停顿时间模型\n\n  * 由于分区的原因，G1可以只选取部分区域进行内存回收，这样缩小了回收的范围，因此对于全局停顿情况的发生也能得到较好的控制。\n  * G1 跟踪各个 Region 里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。保证了 G1 收集器在有限的时间内可以获取尽可能高的收集效率。\n  * 相比于CMS GC，G1未必能做到CMS在最好情况下的延时停顿，但是最差情况要好很多。\n\n　　**注：G1无论是为了垃圾收集产生的内存占用（Footprint）还是程序运行时的额外执行负载（Overload）都要比CMS要高。在小内存应用上CMS的表现大概率会优于G1，而G1在大内存应用上则发挥其优势。平衡点在6-8GB之间。**\n\n　　‍\n","source":"_posts/java/JVM/垃圾回收和内存分配.md","raw":"---\ntitle: 垃圾回收和内存分配\ndate: 2022-10-30T13:40:49Z\nlastmod: 2023-11-26T16:16:40Z\n---\n\n# 垃圾回收和内存分配\n\n## 垃圾回收\n\n### 垃圾判别算法\n\n#### 引用计数法\n\n> 一个对象A，只要有任何一个对象引用了A ，则A 的引用计数器就加1，当引用失效时，引用计数器就减1。只要对象A 的引用计数器的值为0，即表示对象A不可能再被使用，可进行回收。\n\n* 优点\n\n  * 实现简单，垃圾对象便于辨识；判定效率高，回收没有延迟性。\n* 缺点\n\n  * 需要单独的字段存储计数器，增加了存储空间的开销。\n  * 每次赋值伴随着计数器的增减，增加时间开销。\n  * 无法处理循环依赖的问题\n\n#### 可达性分析 \n\n> 将对象及其引用关系看作一个图，选定活动的对象作为 GC Roots，然后跟踪引用链条，如果一个对象和GC Roots之间不可达，也就是不存在引用链条，那么即可认为是可回收对象。\n\n　　基本思路：\n\n* 可达性分析算法是以根对象集合(GC Roots)为起始点，按照从上至下的方式搜索被根对象集合所连接的目标对象是否可达。\n* 使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索所走过的路径称为引用链(Reference Chain)\n* 如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象己经死亡，可以标记为垃圾对象。\n* 在可达性分析算法中，只有能够被根对象集合直接或者间接连接的对象才是存活对象。\n\n　　可作为\"GC Roots\"的对象\n\n* 虚拟机栈（栈帧中的本地变量表）中引用的对象，例如各个线程调用的方法堆中的参数，局部变量，临时变量。\n* 方法区中类静态属性引用的对象，例如java 类中的引用类型的静态变量\n* 方法区中常量引用的对象，例如字符串常量池中的引用\n* 本地方法栈中JNI（Native方法）引用的对象\n* Java虚拟机内部的引用，例如基础类型对应的Class对象，一些常驻的异常对象，还有系统类加载器\n* 所有被同步锁持有的对象。\n* 反应java虚拟机内部情况的JMXBean，JVMTI中的注册的回调，本地代码缓存等（？？？）\n\n　　注：如果要使用可达性分析算法来判断内存是否可回收，那么分析工作必须在一个能保障*一致性的快照*中进行，这点也是导致GC进行时必须“Stop The World”的一个重要原因。\n\n### 垃圾回收算法\n\n#### 标记清除\n\n> 标记：Collector从引用根节点开始遍历，标记所有被引用的对象。一般是在对象的Header中记录为可达对象。  \n> 清除：Collector对堆内存从头到尾进行线性的遍历，如果发现某个对象在其Header中没有标记为可达对象，则将其回收。\n\n* 效率比较低：递归与全堆对象遍历两次\n* 在进行GC的时候，需要停止整个应用程序，导致用户体验差\n* 这种方式清理出来的空闲内存是不连续的，产生内存碎片。\n\n#### 标记复制\n\n> 将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收。\n\n* 优点\n\n  * 不会造成空间碎片。\n* 缺点\n\n  * 需要两倍的内存空间\n  * 对于G1这种分拆成为大量region的GC，复制而不是移动，意味着GC需要维护region之间对象引用关系，不管是内存占用或者时间开销也不小。\n\n　　注：如果系统中的存活对象很多，复制算法不会很理想。因为复制算法需要复制的存活对象数量并不会太大,或者说非常低才行。\n\n#### 标记整理\n\n> 从根节点开始标记所有被引用对象  \n> 将所有的存活对象压缩到内存的一端，按顺序排放，清理边界外所有的空间。\n\n* 优点\n\n  * 消除了标记/清除算法当中，内存区域分散的缺点，我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可。\n  * 消除了复制算法当中，内存减半的高额代价。\n* 缺点\n\n  * 效率不高，不仅要标记所有存活对象，还要整理所有存活对象的引用地址。\n  * 对于老年代每次都有大量对象存活的区域来说，极为负重。\n  * 移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址。\n  * 移动过程中，需要全程暂停用户应用程序。即：STW\n\n#### 分代收集\n\n> 基于这样一个事实：不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点使用不同的回收算法，以提高垃圾回收的效率。\n\n#### 增量回收\n\n> 垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。\n\n　　注：线程上下文切换频繁，是的垃圾回收成本上升，导致吞吐量上升\n\n#### 分区算法\n\n> 将按照对象的生命周期长短划分成两个部分，分区算法将整个堆空间划分成连续的不同小区间。每一个小区间都独立使用，独立回收。\n\n### JVM四种引用\n\n#### 强引用\n\n　　特点：GC时，永远不会被回收  \n使用场景\n\n> new 对象\n\n#### 软引用SoftReference<Object>(obj);\n\n　　特点：内存不足时（自动触发GC），会被回收  \n使用场景\n\n> 缓存\n\n#### 弱引用WeakReference<Object>(obj)\n\n　　特点：无论内存是否充足，只要进行GC，都会被回收  \n使用场景\n\n> 内部对象为弱引用 WeakReference为强引用\n\n#### 虚引用PhantomReference<>(new Object(),new ReferenceQueue<>())\n\n　　特点：如同虚设，和没有引用没什么区别  \n使用场景\n\n> 1. 管理堆外面的引用\n\n> 首先标记出所需要回收的对象，在标记完成后，统一回收掉所有被标记的对象\n\n> 将可用内存划分为两部分，每次只使用其中一块，当一块内存用完时，将还存活对象复制到另外一块上面，然后再把已使用的内存空间清理一遍\n\n> 标记出所需要回收的对象，将所有需要存活的对象都向内存空间的一端移动，然后直接清理掉边界以外的内存\n\n## JVM GC 流程\n\n> [JVM堆的内存分布](https://www.yuque.com/pride_yang/blog/qsgy0z#vfjXH)\n\n> Minor GC  新生代GC\n\n> Major GC/Full GC\n\n1. 开始时，对象会先分配到eden区\n2. 引用运行，越来越多对象分配在eden区域\n3. 当eden区域放不下时，就会发生minor GC(young GC),利用可达性分析标记出垃圾对象，然后将有用对象移动到survivor0区域，将标记出来的垃圾对象全部清除，此时eden区域就全部清理干净了。整个过程使用了 mark-sweep（标记整理）方法回收eden区，使用mark-copy（标记复制） 方法将可用对象移动到 survivor0区域。\n4. 随着时间推移，eden如果又满了，再次触发minor GC，同样还是先做标记，这时eden和s0区可能都有垃圾对象了，注意：这时s1（即：to）区是空的，S0区和eden区的存活对象（S0 区域满了），将直接搬到s1区。然后将eden和S0区的垃圾清理掉，这一轮minor GC后，eden和S0区就变成了空的了。\n5. 随着对象的不断分配，eden空可能又满了，这时会重复刚才的minor GC过程，不过要注意的是，这时候s0是空的，所以s0与s1的角色其实会互换，即：存活的对象，会从eden和s1区，向s0区移动。然后再把eden和s1区中的垃圾清除，这一轮完成后，eden与s1区变成空的\n6. 对于那些比较“长寿”的对象一直在s0与s1中挪来挪去，一来很占地方，而且也会造成一定开销，降低gc效率，于是有了“代龄(age)”及“晋升”。对象在年青代的3个区(eden,s0,s1)之间，每次从1个区移到另1区，年龄+1，在young区达到一定的年龄阈值(-XX:MaxTenuringThreshold（默认15）)后，将晋升到老年代。\n7. 如果老年代，最终也放满了，就会发生major GC（即Full GC），由于老年代的的对象通常会比较多，因为标记-清理-整理（压缩）的耗时通常会比较长，会让应用出现卡顿的现象，\n\n​![](/assets/net-img-1646740660775-762fcaa3-26b5-4d95-ac43-5cca58540969-20230330213439-sxz1b5i.png)​\n\n## 垃圾收集器\n\n​![图像](.//assets/image-20231126145713-0pou43f.png)​\n\n1. 两个收集器间有连线，表明它们可以搭配使用：  \n    Serial/Serial Old、Serial/CMS、ParNew/Serial Old、ParNew/CMS、Parallel Scavenge/Serial Old、Parallel Scavenge/Parallel Old、G1；\n2. 其中Serial Old作为CMS出现\"Concurrent Mode Failure\"失败的后备预案。\n3. (红色虚线)由于维护和兼容性测试的成本，在JDK 8时将Serial+CMS、ParNew+Serial Old这两个组合声明为废弃（JEP 173），并在JDK 9中完全取消了这些组合的支持（JEP214），即：移除。\n4. (绿色虚线)JDK 14中：弃用Parallel Scavenge和SerialOld GC组合 （JEP 366）\n5. (青色虚线)JDK 14中：删除CMS垃圾回收器 （JEP 363）\n\n### 经典垃圾收集器\n\n#### Serial 收集器/Serial Old 收集器\n\n> 简单高效，占用内存小 适合客户端\n\n![image.png](/assets/net-img-1629558034184-e1fe6601-777e-4a34-afe5-df37e5a9b720-20230330213445-e5uive7.png \"运行示意图\")\n\n#### ParNew 收集器/Serial Old 收集器\n\n> 适合多核CPU 单核由于上下文切换，收集并不理想\n\n![image.png](/assets/net-img-1629559055065-5ad8d49f-81b6-45f3-87f8-c98716f799ed-20230330213451-7nkjlzc.png \"运行示意图\")\n\n#### Parallel Scavenge/Parallel Old收集器\n\n> 吞吐量优先的垃圾收集器，有自适应调节策略 jdk8的默认垃圾收集器\n\n![image.png](/assets/net-img-1629559366006-0194df18-86f2-45fd-bd85-6f675b19bdb0-20230330213459-p7i5mm5.png \"运行示意图\")\n\n#### CMS收集器（老年代）\n\n> CMS是基于Mark-Sweep实现的，对于对象的回收效率很高。\n>\n> 对于碎片问题，CMS采用基于Mark-Compact算法的Serial Old回收器作为补偿措施：当内存回收不佳（碎片导致的Concurrent Mode Failure时），将采用Serial Old执行Full GC以达到对老年代内存的整理\n\n![image.png](/assets/net-img-1629560137959-ab93eb78-c083-4c80-8283-4cfc470c8af0-20230330213504-cteixk9.png \"运行示意图\")\n\n* 初始标记（STW）：暂时时间非常短，标记与GC Roots直接关联的对象。\n* 并发标记（最耗时）：从GC Roots开始遍历整个对象图的过程。不会停顿用户线程\n* 重新标记：（STW）：修复并发标记环节，因为用户线程的执行，导致数据的不一致性问题\n* 并发清理（最耗时）：清理删除掉标记阶段判断的已经死亡的对象，释放内存空间。由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的。\n\n#### G1 收集器\n\n> 主要针对配备多核CPU及大容量内存的机器，以极高概率满足GC停顿时间的同时，还兼具高吞吐量，JDK9 以后的默认收集器\n\n![图像](/assets/image-20231126155909-4zbslm1.png)\n\n##### 回收过程\n\n1. 年轻代GC （Young GC）\n\n    1. ‍\n\n2. 老年代并发标记过程 （Concurrent Marking）\n\n3. 混合回收（Mixed GC）\n\n4. 如果需要，单线程、独占式、高强度的Full GC还是继续存在的。它针对GC的评估失败提供了一种失败保护机制，即强力回收。\n\n![图像 (2)](/assets/image-20231126161709-b35di3t.png)\n\n　　顺时针，young gc -> young gc + concurrent mark-> Mixed GC顺序，进行垃圾回收。\n\n##### 特点\n\n*  \n\n  * 并发性：G1拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此，一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况\n\n  **并行与并发**\n\n  * 并行性：G1在回收期间，可以有多个GC线程同时工作，有效利用多核计算能力。此时用户线程STW\n\n* **分代收集**\n\n  * 从分代上看，G1依然属于分代型垃圾回收器，它会区分年轻代和老年代，年轻代依然有Eden区和Survivor区。但从堆的结构上看，它不要求整个Eden区、年轻代或者老年代都是连续的，也不再坚持固定大小和固定数量。\n  * 将堆空间分为若干个区域（Region）,这些区域中包含了逻辑上的年轻代和老年代。\n  * 和之前的各类回收器不同，它同时兼顾年轻代和老年代。对比其他回收器，或者工作在年轻代，或者工作在老年代；\n\n* 空间整合\n\n  * CMS：“标记-清除”算法、内存碎片、若干次GC后进行一次碎片整理\n  * G1将内存划分为一个个的region。内存的回收是以region作为基本单位的。Region之间是复制算法，但整体上实际可看作是标记-压缩（Mark-Compact）算法，两种算法都可以避免内存碎片。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次 GC。尤其是当Java堆非常大的时候，G1的优势更加明显。\n* 可预测的停顿时间模型\n\n  * 由于分区的原因，G1可以只选取部分区域进行内存回收，这样缩小了回收的范围，因此对于全局停顿情况的发生也能得到较好的控制。\n  * G1 跟踪各个 Region 里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。保证了 G1 收集器在有限的时间内可以获取尽可能高的收集效率。\n  * 相比于CMS GC，G1未必能做到CMS在最好情况下的延时停顿，但是最差情况要好很多。\n\n　　**注：G1无论是为了垃圾收集产生的内存占用（Footprint）还是程序运行时的额外执行负载（Overload）都要比CMS要高。在小内存应用上CMS的表现大概率会优于G1，而G1在大内存应用上则发挥其优势。平衡点在6-8GB之间。**\n\n　　‍\n","slug":"java-JVM-垃圾回收和内存分配","published":1,"updated":"2025-04-28T08:41:48.391Z","_id":"cm9s3f40l0030bfg46bwnbb86","comments":1,"layout":"post","photos":[],"content":"<h1>垃圾回收和内存分配</h1>\n<h2 id=\"垃圾回收\">垃圾回收</h2>\n<h3 id=\"垃圾判别算法\">垃圾判别算法</h3>\n<h4 id=\"引用计数法\">引用计数法</h4>\n<blockquote>\n<p>一个对象A，只要有任何一个对象引用了A ，则A 的引用计数器就加1，当引用失效时，引用计数器就减1。只要对象A 的引用计数器的值为0，即表示对象A不可能再被使用，可进行回收。</p>\n</blockquote>\n<ul>\n<li>\n<p>优点</p>\n<ul>\n<li>实现简单，垃圾对象便于辨识；判定效率高，回收没有延迟性。</li>\n</ul>\n</li>\n<li>\n<p>缺点</p>\n<ul>\n<li>需要单独的字段存储计数器，增加了存储空间的开销。</li>\n<li>每次赋值伴随着计数器的增减，增加时间开销。</li>\n<li>无法处理循环依赖的问题</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"可达性分析\">可达性分析</h4>\n<blockquote>\n<p>将对象及其引用关系看作一个图，选定活动的对象作为 GC Roots，然后跟踪引用链条，如果一个对象和GC Roots之间不可达，也就是不存在引用链条，那么即可认为是可回收对象。</p>\n</blockquote>\n<p>基本思路：</p>\n<ul>\n<li>可达性分析算法是以根对象集合(GC Roots)为起始点，按照从上至下的方式搜索被根对象集合所连接的目标对象是否可达。</li>\n<li>使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索所走过的路径称为引用链(Reference Chain)</li>\n<li>如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象己经死亡，可以标记为垃圾对象。</li>\n<li>在可达性分析算法中，只有能够被根对象集合直接或者间接连接的对象才是存活对象。</li>\n</ul>\n<p>可作为&quot;GC Roots&quot;的对象</p>\n<ul>\n<li>虚拟机栈（栈帧中的本地变量表）中引用的对象，例如各个线程调用的方法堆中的参数，局部变量，临时变量。</li>\n<li>方法区中类静态属性引用的对象，例如java 类中的引用类型的静态变量</li>\n<li>方法区中常量引用的对象，例如字符串常量池中的引用</li>\n<li>本地方法栈中JNI（Native方法）引用的对象</li>\n<li>Java虚拟机内部的引用，例如基础类型对应的Class对象，一些常驻的异常对象，还有系统类加载器</li>\n<li>所有被同步锁持有的对象。</li>\n<li>反应java虚拟机内部情况的JMXBean，JVMTI中的注册的回调，本地代码缓存等（？？？）</li>\n</ul>\n<p>注：如果要使用可达性分析算法来判断内存是否可回收，那么分析工作必须在一个能保障<em>一致性的快照</em>中进行，这点也是导致GC进行时必须“Stop The World”的一个重要原因。</p>\n<h3 id=\"垃圾回收算法\">垃圾回收算法</h3>\n<h4 id=\"标记清除\">标记清除</h4>\n<blockquote>\n<p>标记：Collector从引用根节点开始遍历，标记所有被引用的对象。一般是在对象的Header中记录为可达对象。<br>\n清除：Collector对堆内存从头到尾进行线性的遍历，如果发现某个对象在其Header中没有标记为可达对象，则将其回收。</p>\n</blockquote>\n<ul>\n<li>效率比较低：递归与全堆对象遍历两次</li>\n<li>在进行GC的时候，需要停止整个应用程序，导致用户体验差</li>\n<li>这种方式清理出来的空闲内存是不连续的，产生内存碎片。</li>\n</ul>\n<h4 id=\"标记复制\">标记复制</h4>\n<blockquote>\n<p>将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收。</p>\n</blockquote>\n<ul>\n<li>\n<p>优点</p>\n<ul>\n<li>不会造成空间碎片。</li>\n</ul>\n</li>\n<li>\n<p>缺点</p>\n<ul>\n<li>需要两倍的内存空间</li>\n<li>对于G1这种分拆成为大量region的GC，复制而不是移动，意味着GC需要维护region之间对象引用关系，不管是内存占用或者时间开销也不小。</li>\n</ul>\n</li>\n</ul>\n<p>注：如果系统中的存活对象很多，复制算法不会很理想。因为复制算法需要复制的存活对象数量并不会太大,或者说非常低才行。</p>\n<h4 id=\"标记整理\">标记整理</h4>\n<blockquote>\n<p>从根节点开始标记所有被引用对象<br>\n将所有的存活对象压缩到内存的一端，按顺序排放，清理边界外所有的空间。</p>\n</blockquote>\n<ul>\n<li>\n<p>优点</p>\n<ul>\n<li>消除了标记/清除算法当中，内存区域分散的缺点，我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可。</li>\n<li>消除了复制算法当中，内存减半的高额代价。</li>\n</ul>\n</li>\n<li>\n<p>缺点</p>\n<ul>\n<li>效率不高，不仅要标记所有存活对象，还要整理所有存活对象的引用地址。</li>\n<li>对于老年代每次都有大量对象存活的区域来说，极为负重。</li>\n<li>移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址。</li>\n<li>移动过程中，需要全程暂停用户应用程序。即：STW</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"分代收集\">分代收集</h4>\n<blockquote>\n<p>基于这样一个事实：不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点使用不同的回收算法，以提高垃圾回收的效率。</p>\n</blockquote>\n<h4 id=\"增量回收\">增量回收</h4>\n<blockquote>\n<p>垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。</p>\n</blockquote>\n<p>注：线程上下文切换频繁，是的垃圾回收成本上升，导致吞吐量上升</p>\n<h4 id=\"分区算法\">分区算法</h4>\n<blockquote>\n<p>将按照对象的生命周期长短划分成两个部分，分区算法将整个堆空间划分成连续的不同小区间。每一个小区间都独立使用，独立回收。</p>\n</blockquote>\n<h3 id=\"JVM四种引用\">JVM四种引用</h3>\n<h4 id=\"强引用\">强引用</h4>\n<p>特点：GC时，永远不会被回收<br>\n使用场景</p>\n<blockquote>\n<p>new 对象</p>\n</blockquote>\n<h4 id=\"软引用SoftReference-Object-obj\">软引用SoftReference<Object>(obj);</h4>\n<p>特点：内存不足时（自动触发GC），会被回收<br>\n使用场景</p>\n<blockquote>\n<p>缓存</p>\n</blockquote>\n<h4 id=\"弱引用WeakReference-Object-obj\">弱引用WeakReference<Object>(obj)</h4>\n<p>特点：无论内存是否充足，只要进行GC，都会被回收<br>\n使用场景</p>\n<blockquote>\n<p>内部对象为弱引用 WeakReference为强引用</p>\n</blockquote>\n<h4 id=\"虚引用PhantomReference-new-Object-new-ReferenceQueue\">虚引用PhantomReference&lt;&gt;(new Object(),new ReferenceQueue&lt;&gt;())</h4>\n<p>特点：如同虚设，和没有引用没什么区别<br>\n使用场景</p>\n<blockquote>\n<ol>\n<li>管理堆外面的引用</li>\n</ol>\n</blockquote>\n<blockquote>\n<p>首先标记出所需要回收的对象，在标记完成后，统一回收掉所有被标记的对象</p>\n</blockquote>\n<blockquote>\n<p>将可用内存划分为两部分，每次只使用其中一块，当一块内存用完时，将还存活对象复制到另外一块上面，然后再把已使用的内存空间清理一遍</p>\n</blockquote>\n<blockquote>\n<p>标记出所需要回收的对象，将所有需要存活的对象都向内存空间的一端移动，然后直接清理掉边界以外的内存</p>\n</blockquote>\n<h2 id=\"JVM-GC-流程\">JVM GC 流程</h2>\n<blockquote>\n<p><a href=\"https://www.yuque.com/pride_yang/blog/qsgy0z#vfjXH\">JVM堆的内存分布</a></p>\n</blockquote>\n<blockquote>\n<p>Minor GC  新生代GC</p>\n</blockquote>\n<blockquote>\n<p>Major GC/Full GC</p>\n</blockquote>\n<ol>\n<li>开始时，对象会先分配到eden区</li>\n<li>引用运行，越来越多对象分配在eden区域</li>\n<li>当eden区域放不下时，就会发生minor GC(young GC),利用可达性分析标记出垃圾对象，然后将有用对象移动到survivor0区域，将标记出来的垃圾对象全部清除，此时eden区域就全部清理干净了。整个过程使用了 mark-sweep（标记整理）方法回收eden区，使用mark-copy（标记复制） 方法将可用对象移动到 survivor0区域。</li>\n<li>随着时间推移，eden如果又满了，再次触发minor GC，同样还是先做标记，这时eden和s0区可能都有垃圾对象了，注意：这时s1（即：to）区是空的，S0区和eden区的存活对象（S0 区域满了），将直接搬到s1区。然后将eden和S0区的垃圾清理掉，这一轮minor GC后，eden和S0区就变成了空的了。</li>\n<li>随着对象的不断分配，eden空可能又满了，这时会重复刚才的minor GC过程，不过要注意的是，这时候s0是空的，所以s0与s1的角色其实会互换，即：存活的对象，会从eden和s1区，向s0区移动。然后再把eden和s1区中的垃圾清除，这一轮完成后，eden与s1区变成空的</li>\n<li>对于那些比较“长寿”的对象一直在s0与s1中挪来挪去，一来很占地方，而且也会造成一定开销，降低gc效率，于是有了“代龄(age)”及“晋升”。对象在年青代的3个区(eden,s0,s1)之间，每次从1个区移到另1区，年龄+1，在young区达到一定的年龄阈值(-XX:MaxTenuringThreshold（默认15）)后，将晋升到老年代。</li>\n<li>如果老年代，最终也放满了，就会发生major GC（即Full GC），由于老年代的的对象通常会比较多，因为标记-清理-整理（压缩）的耗时通常会比较长，会让应用出现卡顿的现象，</li>\n</ol>\n<p>​<img src=\"/assets/net-img-1646740660775-762fcaa3-26b5-4d95-ac43-5cca58540969-20230330213439-sxz1b5i.png\" alt=\"\">​</p>\n<h2 id=\"垃圾收集器\">垃圾收集器</h2>\n<p>​<img src=\".//assets/image-20231126145713-0pou43f.png\" alt=\"图像\">​</p>\n<ol>\n<li>两个收集器间有连线，表明它们可以搭配使用：<br>\nSerial/Serial Old、Serial/CMS、ParNew/Serial Old、ParNew/CMS、Parallel Scavenge/Serial Old、Parallel Scavenge/Parallel Old、G1；</li>\n<li>其中Serial Old作为CMS出现&quot;Concurrent Mode Failure&quot;失败的后备预案。</li>\n<li>(红色虚线)由于维护和兼容性测试的成本，在JDK 8时将Serial+CMS、ParNew+Serial Old这两个组合声明为废弃（JEP 173），并在JDK 9中完全取消了这些组合的支持（JEP214），即：移除。</li>\n<li>(绿色虚线)JDK 14中：弃用Parallel Scavenge和SerialOld GC组合 （JEP 366）</li>\n<li>(青色虚线)JDK 14中：删除CMS垃圾回收器 （JEP 363）</li>\n</ol>\n<h3 id=\"经典垃圾收集器\">经典垃圾收集器</h3>\n<h4 id=\"Serial-收集器-Serial-Old-收集器\">Serial 收集器/Serial Old 收集器</h4>\n<blockquote>\n<p>简单高效，占用内存小 适合客户端</p>\n</blockquote>\n<p><img src=\"/assets/net-img-1629558034184-e1fe6601-777e-4a34-afe5-df37e5a9b720-20230330213445-e5uive7.png\" alt=\"image.png\" title=\"运行示意图\"></p>\n<h4 id=\"ParNew-收集器-Serial-Old-收集器\">ParNew 收集器/Serial Old 收集器</h4>\n<blockquote>\n<p>适合多核CPU 单核由于上下文切换，收集并不理想</p>\n</blockquote>\n<p><img src=\"/assets/net-img-1629559055065-5ad8d49f-81b6-45f3-87f8-c98716f799ed-20230330213451-7nkjlzc.png\" alt=\"image.png\" title=\"运行示意图\"></p>\n<h4 id=\"Parallel-Scavenge-Parallel-Old收集器\">Parallel Scavenge/Parallel Old收集器</h4>\n<blockquote>\n<p>吞吐量优先的垃圾收集器，有自适应调节策略 jdk8的默认垃圾收集器</p>\n</blockquote>\n<p><img src=\"/assets/net-img-1629559366006-0194df18-86f2-45fd-bd85-6f675b19bdb0-20230330213459-p7i5mm5.png\" alt=\"image.png\" title=\"运行示意图\"></p>\n<h4 id=\"CMS收集器（老年代）\">CMS收集器（老年代）</h4>\n<blockquote>\n<p>CMS是基于Mark-Sweep实现的，对于对象的回收效率很高。</p>\n<p>对于碎片问题，CMS采用基于Mark-Compact算法的Serial Old回收器作为补偿措施：当内存回收不佳（碎片导致的Concurrent Mode Failure时），将采用Serial Old执行Full GC以达到对老年代内存的整理</p>\n</blockquote>\n<p><img src=\"/assets/net-img-1629560137959-ab93eb78-c083-4c80-8283-4cfc470c8af0-20230330213504-cteixk9.png\" alt=\"image.png\" title=\"运行示意图\"></p>\n<ul>\n<li>初始标记（STW）：暂时时间非常短，标记与GC Roots直接关联的对象。</li>\n<li>并发标记（最耗时）：从GC Roots开始遍历整个对象图的过程。不会停顿用户线程</li>\n<li>重新标记：（STW）：修复并发标记环节，因为用户线程的执行，导致数据的不一致性问题</li>\n<li>并发清理（最耗时）：清理删除掉标记阶段判断的已经死亡的对象，释放内存空间。由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的。</li>\n</ul>\n<h4 id=\"G1-收集器\">G1 收集器</h4>\n<blockquote>\n<p>主要针对配备多核CPU及大容量内存的机器，以极高概率满足GC停顿时间的同时，还兼具高吞吐量，JDK9 以后的默认收集器</p>\n</blockquote>\n<p><img src=\"/assets/image-20231126155909-4zbslm1.png\" alt=\"图像\"></p>\n<h5 id=\"回收过程\">回收过程</h5>\n<ol>\n<li>\n<p>年轻代GC （Young GC）</p>\n<ol>\n<li>‍</li>\n</ol>\n</li>\n<li>\n<p>老年代并发标记过程 （Concurrent Marking）</p>\n</li>\n<li>\n<p>混合回收（Mixed GC）</p>\n</li>\n<li>\n<p>如果需要，单线程、独占式、高强度的Full GC还是继续存在的。它针对GC的评估失败提供了一种失败保护机制，即强力回收。</p>\n</li>\n</ol>\n<p><img src=\"/assets/image-20231126161709-b35di3t.png\" alt=\"图像 (2)\"></p>\n<p>顺时针，young gc -&gt; young gc + concurrent mark-&gt; Mixed GC顺序，进行垃圾回收。</p>\n<h5 id=\"特点\">特点</h5>\n<ul>\n<li></li>\n<li>\n<p>并发性：G1拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此，一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况</p>\n</li>\n</ul>\n<p><strong>并行与并发</strong></p>\n<ul>\n<li>\n<p>并行性：G1在回收期间，可以有多个GC线程同时工作，有效利用多核计算能力。此时用户线程STW</p>\n</li>\n<li>\n<p><strong>分代收集</strong></p>\n<ul>\n<li>从分代上看，G1依然属于分代型垃圾回收器，它会区分年轻代和老年代，年轻代依然有Eden区和Survivor区。但从堆的结构上看，它不要求整个Eden区、年轻代或者老年代都是连续的，也不再坚持固定大小和固定数量。</li>\n<li>将堆空间分为若干个区域（Region）,这些区域中包含了逻辑上的年轻代和老年代。</li>\n<li>和之前的各类回收器不同，它同时兼顾年轻代和老年代。对比其他回收器，或者工作在年轻代，或者工作在老年代；</li>\n</ul>\n</li>\n<li>\n<p>空间整合</p>\n<ul>\n<li>CMS：“标记-清除”算法、内存碎片、若干次GC后进行一次碎片整理</li>\n<li>G1将内存划分为一个个的region。内存的回收是以region作为基本单位的。Region之间是复制算法，但整体上实际可看作是标记-压缩（Mark-Compact）算法，两种算法都可以避免内存碎片。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次 GC。尤其是当Java堆非常大的时候，G1的优势更加明显。</li>\n</ul>\n</li>\n<li>\n<p>可预测的停顿时间模型</p>\n<ul>\n<li>由于分区的原因，G1可以只选取部分区域进行内存回收，这样缩小了回收的范围，因此对于全局停顿情况的发生也能得到较好的控制。</li>\n<li>G1 跟踪各个 Region 里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。保证了 G1 收集器在有限的时间内可以获取尽可能高的收集效率。</li>\n<li>相比于CMS GC，G1未必能做到CMS在最好情况下的延时停顿，但是最差情况要好很多。</li>\n</ul>\n</li>\n</ul>\n<p><strong>注：G1无论是为了垃圾收集产生的内存占用（Footprint）还是程序运行时的额外执行负载（Overload）都要比CMS要高。在小内存应用上CMS的表现大概率会优于G1，而G1在大内存应用上则发挥其优势。平衡点在6-8GB之间。</strong></p>\n<p>‍</p>\n","excerpt":"","more":"<h1>垃圾回收和内存分配</h1>\n<h2 id=\"垃圾回收\">垃圾回收</h2>\n<h3 id=\"垃圾判别算法\">垃圾判别算法</h3>\n<h4 id=\"引用计数法\">引用计数法</h4>\n<blockquote>\n<p>一个对象A，只要有任何一个对象引用了A ，则A 的引用计数器就加1，当引用失效时，引用计数器就减1。只要对象A 的引用计数器的值为0，即表示对象A不可能再被使用，可进行回收。</p>\n</blockquote>\n<ul>\n<li>\n<p>优点</p>\n<ul>\n<li>实现简单，垃圾对象便于辨识；判定效率高，回收没有延迟性。</li>\n</ul>\n</li>\n<li>\n<p>缺点</p>\n<ul>\n<li>需要单独的字段存储计数器，增加了存储空间的开销。</li>\n<li>每次赋值伴随着计数器的增减，增加时间开销。</li>\n<li>无法处理循环依赖的问题</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"可达性分析\">可达性分析</h4>\n<blockquote>\n<p>将对象及其引用关系看作一个图，选定活动的对象作为 GC Roots，然后跟踪引用链条，如果一个对象和GC Roots之间不可达，也就是不存在引用链条，那么即可认为是可回收对象。</p>\n</blockquote>\n<p>基本思路：</p>\n<ul>\n<li>可达性分析算法是以根对象集合(GC Roots)为起始点，按照从上至下的方式搜索被根对象集合所连接的目标对象是否可达。</li>\n<li>使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索所走过的路径称为引用链(Reference Chain)</li>\n<li>如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象己经死亡，可以标记为垃圾对象。</li>\n<li>在可达性分析算法中，只有能够被根对象集合直接或者间接连接的对象才是存活对象。</li>\n</ul>\n<p>可作为&quot;GC Roots&quot;的对象</p>\n<ul>\n<li>虚拟机栈（栈帧中的本地变量表）中引用的对象，例如各个线程调用的方法堆中的参数，局部变量，临时变量。</li>\n<li>方法区中类静态属性引用的对象，例如java 类中的引用类型的静态变量</li>\n<li>方法区中常量引用的对象，例如字符串常量池中的引用</li>\n<li>本地方法栈中JNI（Native方法）引用的对象</li>\n<li>Java虚拟机内部的引用，例如基础类型对应的Class对象，一些常驻的异常对象，还有系统类加载器</li>\n<li>所有被同步锁持有的对象。</li>\n<li>反应java虚拟机内部情况的JMXBean，JVMTI中的注册的回调，本地代码缓存等（？？？）</li>\n</ul>\n<p>注：如果要使用可达性分析算法来判断内存是否可回收，那么分析工作必须在一个能保障<em>一致性的快照</em>中进行，这点也是导致GC进行时必须“Stop The World”的一个重要原因。</p>\n<h3 id=\"垃圾回收算法\">垃圾回收算法</h3>\n<h4 id=\"标记清除\">标记清除</h4>\n<blockquote>\n<p>标记：Collector从引用根节点开始遍历，标记所有被引用的对象。一般是在对象的Header中记录为可达对象。<br>\n清除：Collector对堆内存从头到尾进行线性的遍历，如果发现某个对象在其Header中没有标记为可达对象，则将其回收。</p>\n</blockquote>\n<ul>\n<li>效率比较低：递归与全堆对象遍历两次</li>\n<li>在进行GC的时候，需要停止整个应用程序，导致用户体验差</li>\n<li>这种方式清理出来的空闲内存是不连续的，产生内存碎片。</li>\n</ul>\n<h4 id=\"标记复制\">标记复制</h4>\n<blockquote>\n<p>将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收。</p>\n</blockquote>\n<ul>\n<li>\n<p>优点</p>\n<ul>\n<li>不会造成空间碎片。</li>\n</ul>\n</li>\n<li>\n<p>缺点</p>\n<ul>\n<li>需要两倍的内存空间</li>\n<li>对于G1这种分拆成为大量region的GC，复制而不是移动，意味着GC需要维护region之间对象引用关系，不管是内存占用或者时间开销也不小。</li>\n</ul>\n</li>\n</ul>\n<p>注：如果系统中的存活对象很多，复制算法不会很理想。因为复制算法需要复制的存活对象数量并不会太大,或者说非常低才行。</p>\n<h4 id=\"标记整理\">标记整理</h4>\n<blockquote>\n<p>从根节点开始标记所有被引用对象<br>\n将所有的存活对象压缩到内存的一端，按顺序排放，清理边界外所有的空间。</p>\n</blockquote>\n<ul>\n<li>\n<p>优点</p>\n<ul>\n<li>消除了标记/清除算法当中，内存区域分散的缺点，我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可。</li>\n<li>消除了复制算法当中，内存减半的高额代价。</li>\n</ul>\n</li>\n<li>\n<p>缺点</p>\n<ul>\n<li>效率不高，不仅要标记所有存活对象，还要整理所有存活对象的引用地址。</li>\n<li>对于老年代每次都有大量对象存活的区域来说，极为负重。</li>\n<li>移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址。</li>\n<li>移动过程中，需要全程暂停用户应用程序。即：STW</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"分代收集\">分代收集</h4>\n<blockquote>\n<p>基于这样一个事实：不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点使用不同的回收算法，以提高垃圾回收的效率。</p>\n</blockquote>\n<h4 id=\"增量回收\">增量回收</h4>\n<blockquote>\n<p>垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。</p>\n</blockquote>\n<p>注：线程上下文切换频繁，是的垃圾回收成本上升，导致吞吐量上升</p>\n<h4 id=\"分区算法\">分区算法</h4>\n<blockquote>\n<p>将按照对象的生命周期长短划分成两个部分，分区算法将整个堆空间划分成连续的不同小区间。每一个小区间都独立使用，独立回收。</p>\n</blockquote>\n<h3 id=\"JVM四种引用\">JVM四种引用</h3>\n<h4 id=\"强引用\">强引用</h4>\n<p>特点：GC时，永远不会被回收<br>\n使用场景</p>\n<blockquote>\n<p>new 对象</p>\n</blockquote>\n<h4 id=\"软引用SoftReference-Object-obj\">软引用SoftReference<Object>(obj);</h4>\n<p>特点：内存不足时（自动触发GC），会被回收<br>\n使用场景</p>\n<blockquote>\n<p>缓存</p>\n</blockquote>\n<h4 id=\"弱引用WeakReference-Object-obj\">弱引用WeakReference<Object>(obj)</h4>\n<p>特点：无论内存是否充足，只要进行GC，都会被回收<br>\n使用场景</p>\n<blockquote>\n<p>内部对象为弱引用 WeakReference为强引用</p>\n</blockquote>\n<h4 id=\"虚引用PhantomReference-new-Object-new-ReferenceQueue\">虚引用PhantomReference&lt;&gt;(new Object(),new ReferenceQueue&lt;&gt;())</h4>\n<p>特点：如同虚设，和没有引用没什么区别<br>\n使用场景</p>\n<blockquote>\n<ol>\n<li>管理堆外面的引用</li>\n</ol>\n</blockquote>\n<blockquote>\n<p>首先标记出所需要回收的对象，在标记完成后，统一回收掉所有被标记的对象</p>\n</blockquote>\n<blockquote>\n<p>将可用内存划分为两部分，每次只使用其中一块，当一块内存用完时，将还存活对象复制到另外一块上面，然后再把已使用的内存空间清理一遍</p>\n</blockquote>\n<blockquote>\n<p>标记出所需要回收的对象，将所有需要存活的对象都向内存空间的一端移动，然后直接清理掉边界以外的内存</p>\n</blockquote>\n<h2 id=\"JVM-GC-流程\">JVM GC 流程</h2>\n<blockquote>\n<p><a href=\"https://www.yuque.com/pride_yang/blog/qsgy0z#vfjXH\">JVM堆的内存分布</a></p>\n</blockquote>\n<blockquote>\n<p>Minor GC  新生代GC</p>\n</blockquote>\n<blockquote>\n<p>Major GC/Full GC</p>\n</blockquote>\n<ol>\n<li>开始时，对象会先分配到eden区</li>\n<li>引用运行，越来越多对象分配在eden区域</li>\n<li>当eden区域放不下时，就会发生minor GC(young GC),利用可达性分析标记出垃圾对象，然后将有用对象移动到survivor0区域，将标记出来的垃圾对象全部清除，此时eden区域就全部清理干净了。整个过程使用了 mark-sweep（标记整理）方法回收eden区，使用mark-copy（标记复制） 方法将可用对象移动到 survivor0区域。</li>\n<li>随着时间推移，eden如果又满了，再次触发minor GC，同样还是先做标记，这时eden和s0区可能都有垃圾对象了，注意：这时s1（即：to）区是空的，S0区和eden区的存活对象（S0 区域满了），将直接搬到s1区。然后将eden和S0区的垃圾清理掉，这一轮minor GC后，eden和S0区就变成了空的了。</li>\n<li>随着对象的不断分配，eden空可能又满了，这时会重复刚才的minor GC过程，不过要注意的是，这时候s0是空的，所以s0与s1的角色其实会互换，即：存活的对象，会从eden和s1区，向s0区移动。然后再把eden和s1区中的垃圾清除，这一轮完成后，eden与s1区变成空的</li>\n<li>对于那些比较“长寿”的对象一直在s0与s1中挪来挪去，一来很占地方，而且也会造成一定开销，降低gc效率，于是有了“代龄(age)”及“晋升”。对象在年青代的3个区(eden,s0,s1)之间，每次从1个区移到另1区，年龄+1，在young区达到一定的年龄阈值(-XX:MaxTenuringThreshold（默认15）)后，将晋升到老年代。</li>\n<li>如果老年代，最终也放满了，就会发生major GC（即Full GC），由于老年代的的对象通常会比较多，因为标记-清理-整理（压缩）的耗时通常会比较长，会让应用出现卡顿的现象，</li>\n</ol>\n<p>​<img src=\"/assets/net-img-1646740660775-762fcaa3-26b5-4d95-ac43-5cca58540969-20230330213439-sxz1b5i.png\" alt=\"\">​</p>\n<h2 id=\"垃圾收集器\">垃圾收集器</h2>\n<p>​<img src=\".//assets/image-20231126145713-0pou43f.png\" alt=\"图像\">​</p>\n<ol>\n<li>两个收集器间有连线，表明它们可以搭配使用：<br>\nSerial/Serial Old、Serial/CMS、ParNew/Serial Old、ParNew/CMS、Parallel Scavenge/Serial Old、Parallel Scavenge/Parallel Old、G1；</li>\n<li>其中Serial Old作为CMS出现&quot;Concurrent Mode Failure&quot;失败的后备预案。</li>\n<li>(红色虚线)由于维护和兼容性测试的成本，在JDK 8时将Serial+CMS、ParNew+Serial Old这两个组合声明为废弃（JEP 173），并在JDK 9中完全取消了这些组合的支持（JEP214），即：移除。</li>\n<li>(绿色虚线)JDK 14中：弃用Parallel Scavenge和SerialOld GC组合 （JEP 366）</li>\n<li>(青色虚线)JDK 14中：删除CMS垃圾回收器 （JEP 363）</li>\n</ol>\n<h3 id=\"经典垃圾收集器\">经典垃圾收集器</h3>\n<h4 id=\"Serial-收集器-Serial-Old-收集器\">Serial 收集器/Serial Old 收集器</h4>\n<blockquote>\n<p>简单高效，占用内存小 适合客户端</p>\n</blockquote>\n<p><img src=\"/assets/net-img-1629558034184-e1fe6601-777e-4a34-afe5-df37e5a9b720-20230330213445-e5uive7.png\" alt=\"image.png\" title=\"运行示意图\"></p>\n<h4 id=\"ParNew-收集器-Serial-Old-收集器\">ParNew 收集器/Serial Old 收集器</h4>\n<blockquote>\n<p>适合多核CPU 单核由于上下文切换，收集并不理想</p>\n</blockquote>\n<p><img src=\"/assets/net-img-1629559055065-5ad8d49f-81b6-45f3-87f8-c98716f799ed-20230330213451-7nkjlzc.png\" alt=\"image.png\" title=\"运行示意图\"></p>\n<h4 id=\"Parallel-Scavenge-Parallel-Old收集器\">Parallel Scavenge/Parallel Old收集器</h4>\n<blockquote>\n<p>吞吐量优先的垃圾收集器，有自适应调节策略 jdk8的默认垃圾收集器</p>\n</blockquote>\n<p><img src=\"/assets/net-img-1629559366006-0194df18-86f2-45fd-bd85-6f675b19bdb0-20230330213459-p7i5mm5.png\" alt=\"image.png\" title=\"运行示意图\"></p>\n<h4 id=\"CMS收集器（老年代）\">CMS收集器（老年代）</h4>\n<blockquote>\n<p>CMS是基于Mark-Sweep实现的，对于对象的回收效率很高。</p>\n<p>对于碎片问题，CMS采用基于Mark-Compact算法的Serial Old回收器作为补偿措施：当内存回收不佳（碎片导致的Concurrent Mode Failure时），将采用Serial Old执行Full GC以达到对老年代内存的整理</p>\n</blockquote>\n<p><img src=\"/assets/net-img-1629560137959-ab93eb78-c083-4c80-8283-4cfc470c8af0-20230330213504-cteixk9.png\" alt=\"image.png\" title=\"运行示意图\"></p>\n<ul>\n<li>初始标记（STW）：暂时时间非常短，标记与GC Roots直接关联的对象。</li>\n<li>并发标记（最耗时）：从GC Roots开始遍历整个对象图的过程。不会停顿用户线程</li>\n<li>重新标记：（STW）：修复并发标记环节，因为用户线程的执行，导致数据的不一致性问题</li>\n<li>并发清理（最耗时）：清理删除掉标记阶段判断的已经死亡的对象，释放内存空间。由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的。</li>\n</ul>\n<h4 id=\"G1-收集器\">G1 收集器</h4>\n<blockquote>\n<p>主要针对配备多核CPU及大容量内存的机器，以极高概率满足GC停顿时间的同时，还兼具高吞吐量，JDK9 以后的默认收集器</p>\n</blockquote>\n<p><img src=\"/assets/image-20231126155909-4zbslm1.png\" alt=\"图像\"></p>\n<h5 id=\"回收过程\">回收过程</h5>\n<ol>\n<li>\n<p>年轻代GC （Young GC）</p>\n<ol>\n<li>‍</li>\n</ol>\n</li>\n<li>\n<p>老年代并发标记过程 （Concurrent Marking）</p>\n</li>\n<li>\n<p>混合回收（Mixed GC）</p>\n</li>\n<li>\n<p>如果需要，单线程、独占式、高强度的Full GC还是继续存在的。它针对GC的评估失败提供了一种失败保护机制，即强力回收。</p>\n</li>\n</ol>\n<p><img src=\"/assets/image-20231126161709-b35di3t.png\" alt=\"图像 (2)\"></p>\n<p>顺时针，young gc -&gt; young gc + concurrent mark-&gt; Mixed GC顺序，进行垃圾回收。</p>\n<h5 id=\"特点\">特点</h5>\n<ul>\n<li></li>\n<li>\n<p>并发性：G1拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此，一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况</p>\n</li>\n</ul>\n<p><strong>并行与并发</strong></p>\n<ul>\n<li>\n<p>并行性：G1在回收期间，可以有多个GC线程同时工作，有效利用多核计算能力。此时用户线程STW</p>\n</li>\n<li>\n<p><strong>分代收集</strong></p>\n<ul>\n<li>从分代上看，G1依然属于分代型垃圾回收器，它会区分年轻代和老年代，年轻代依然有Eden区和Survivor区。但从堆的结构上看，它不要求整个Eden区、年轻代或者老年代都是连续的，也不再坚持固定大小和固定数量。</li>\n<li>将堆空间分为若干个区域（Region）,这些区域中包含了逻辑上的年轻代和老年代。</li>\n<li>和之前的各类回收器不同，它同时兼顾年轻代和老年代。对比其他回收器，或者工作在年轻代，或者工作在老年代；</li>\n</ul>\n</li>\n<li>\n<p>空间整合</p>\n<ul>\n<li>CMS：“标记-清除”算法、内存碎片、若干次GC后进行一次碎片整理</li>\n<li>G1将内存划分为一个个的region。内存的回收是以region作为基本单位的。Region之间是复制算法，但整体上实际可看作是标记-压缩（Mark-Compact）算法，两种算法都可以避免内存碎片。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次 GC。尤其是当Java堆非常大的时候，G1的优势更加明显。</li>\n</ul>\n</li>\n<li>\n<p>可预测的停顿时间模型</p>\n<ul>\n<li>由于分区的原因，G1可以只选取部分区域进行内存回收，这样缩小了回收的范围，因此对于全局停顿情况的发生也能得到较好的控制。</li>\n<li>G1 跟踪各个 Region 里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。保证了 G1 收集器在有限的时间内可以获取尽可能高的收集效率。</li>\n<li>相比于CMS GC，G1未必能做到CMS在最好情况下的延时停顿，但是最差情况要好很多。</li>\n</ul>\n</li>\n</ul>\n<p><strong>注：G1无论是为了垃圾收集产生的内存占用（Footprint）还是程序运行时的额外执行负载（Overload）都要比CMS要高。在小内存应用上CMS的表现大概率会优于G1，而G1在大内存应用上则发挥其优势。平衡点在6-8GB之间。</strong></p>\n<p>‍</p>\n"},{"title":"虚拟机运行时数据区域","date":"2022-10-30T05:40:27.000Z","lastmod":"2023-11-25T05:15:42.000Z","_content":"\n# 虚拟机运行时数据区域\n\n## 运行时数据区域\n\n​![图像](/assets/image-20231119154230-3g5nidd.png)\n\n​​![图像](/assets/image-20231119154304-hwfdw8h.jpeg)​\n\n### 程序计数器\n\n> 通过改变这个计数器 的值来选取下一条需要执行的字节码指令\n\n　　java 虚拟机的多线程是通过线程轮流切换、分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器只会执行一条线程中的指令，为了线程切换后能恢复到正确的执行位置，每条线程都需要一个独立的程序计数器。\n每个线程都会有属于自己独立的线程计数器，各线程之间计数器不会相互影响，独立存储，这些区域成为线程私有。\n\n### Java虚拟机栈\n\n> Java方法执行的线程内存模型\n\n　　每个方法被执行，Java虚拟机栈会创建一个栈帧[(1)](https://www.yuque.com/pride_yang/blog/gngtxy)，用于存储局部变量表，操作数栈，方法出口，动态链接等信息。  \n一个方法的执行对应着一个栈帧的入栈与出栈过程。\n\n　　局部变量存储存放编译期间可知java虚拟机的基础类型（boolean，byte，char、short、int、float、dubbo、long）、对象引用（reference类型）、和returnAddress类型（指向一条字节码指令的地址）。\n\n　　局部变量表的存储单位是局部**变量槽（slot）**  其中64位长度的long和 double类型的数据会占用两个变量槽，其余的数据类型只占用一个 （一个变量槽的内存占用空间由虚拟机自行决定） 。\n\n　　当进入一个方法后，栈帧中需要分配多大的局部变量空间已经固定（变量槽数量）  \n《Java虚拟机规范》中  规定如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常，当栈扩展时无法申请到足够的内存会抛出OutOfMemoryError异常。  \n\n### 本地方法栈\n\n> 为虚拟机使用到的 Native 方法服务 （一个 Native Method 就是一个 java 调用非 java 代码的接口）\n\n　　**HotSpot栈内存不允许动态扩容**\n\n```bash\n-Xss 设置栈容量 jdk11 windows最小值 180k Linux最小值228k 否则启动时会出现提示\n```\n\n### Java堆\n\n> 被所有线程共享，在虚拟机启动时创建，用于存放对象实例。\n\n- java堆是垃圾收集器管理的内存区域，也被成为GC堆。G1收集器出现之前，垃圾收集器一般基于分代收集理论设计，但是之后出现了一些不采用分代设计的垃圾收集器。所以收集器不一定存在新生代，老年代，永久代，Eden区，From Survivor区，To Survivor区等。\n- 从内存角度看，所有线程共享的java堆可以划分为多个私有进程的分配缓存区（TLAB），以提升对象分配时的效率。\n\n```bash\n-Xmx 堆最大值\n-Xms 堆最小值\n-XX:+HeapDumpOnOutOfMemoryError 发生OOM时产生dump内存堆转储快照\n-XX:HeapDumpPath=./ 设置快照文件保存位置\n```\n\n#### jvm堆的默认分配方案\n\n　　![](/assets/net-img-1646742883104-4eef3a95-3655-44f4-8887-2f5f1628732e-20230330213506-2xv20ln.png)\n老年代 ： 三分之二的堆空间\n年轻代 ： 三分之一的堆空间\neden区： 8/10 的年轻代空间\nsurvivor0 : 1/10 的年轻代空间\nsurvivor1 : 1/10 的年轻代空间（from 区）\n\n　　**由于及时编译技术的进步，逃逸分析技术的日渐强大，栈上分配，标量替换等优化手段出现，对象实例也未必都全部分配在堆上。**\n\n　　  \n从 jdk 1.7 开始已经默认开启逃逸分析，如果某些方法中的对象引用没有被返回或者未被外面使用（也就是未逃逸出去），那么对象可以直接在栈上分配内存。\n\n　　JDK8 后方法区（永生代）移除，用元空间代替，元空间使用直接内存\n\n#### gc\n\n##### MinorGC触发机制\n\n* 当年轻代空间不足时，就会触发Minor GC。这里的年轻代满指的是Eden区满，Survivor满不会引发GC。（每次 Minor GC 会清理年轻代的内存。)\n* 因为 Java 对象大多都具备朝生夕灭的特性，所以 Minor GC 非常频繁，一般回收速度也比较快。这一定义既清晰又易于理解。\n* Minor GC会引发STW，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行。\n\n##### MajorGC触发机制\n\n* 指发生在老年代的GC，对象从老年代消失时，我们说“Major GC”或“Full GC”发生了。\n\n  * 出现了Major GC，经常会伴随至少一次的Minor GC（但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程）。\n  * 也就是在老年代空间不足时，会先尝试触发Minor GC。如果之后空间还不足，则触发Major GC\n\n* Major GC的速度一般会比Minor GC慢10倍以上，STW的时间更长。\n\n* 如果Major GC 后，内存还不足，就报OOM了。\n\n##### FullGC触发机制\n\n* 调用System.gc()时，系统建议执行Full GC，但是不必然执行\n* 老年代空间不足\n* 方法区空间不足\n* 通过Minor GC后进入老年代的平均大小大于老年代的可用内存\n* 由Eden区、survivor space0（From Space）区向survivor space1（To Space）区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小\n\n### 方法区（元空间）\n\n> 主要用于存储被虚拟机加载的类型信息、常量、静态变量、及时编译器编译后的代码缓存等数据\n\n#### 存储内容\n\n* 类型信息\n* 域信息\n\n  * 域名称，域类型，域修饰符（public, private, protected, static, final, volatile, transient的某个子集）\n* 方法信息\n\n  * 方法名称\n  * 方法的返回类型(或 void)\n  * 方法参数的数量和类型(按顺序)\n  * 方法的修饰符(public, private, protected, static, final, synchronized, native, abstract的一个子集)\n  * 方法的字节码(bytecodes)、操作数栈、局部变量表及大小 （abstract和native方法除外）\n  * 异常表（abstract和native方法除外）\n\n    * 每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引\n* non-final的类变量\n* 运行时常量池\n\n　　**在HotSpot中jdk1.8之前也被称为永久代 在jdk7后将永久代的功能转移到元空间**\n\n　　**元空间默认初始大小20m**\n\n```bash\n-XX:MaxMetaspaceSize 设置元空间最大值，默认为-1 不受限制或者说收本地内存限制\n-XX:MetaspaceSize 设置元空间初始空间大小 以字节为单位，达到该值会触发垃圾收集进行类型卸载，同事收集器会对该值进行调整，如果释放大量空间则适当降低该值，如果释放很少空间，那么在不超过最大值情况下适当提高。\n-MinMetaspaceFreeRatio：在垃圾收集后控制最小的元空间剩余容量的百分比，可减少因元空间不足导致垃圾收集的频率\n-MinMetaspaceFreeRatio：用于控制最大的元空间剩余容量的百分比\n```\n\n#### 运行时常量池\n\n> 方法区的一部分，用于存放编译期产生的各种字面量和符号引用  \n> **给基本类型变量赋值的方式就叫做字面量或者字面值**\n\n　　**注： 字符串常量池在堆中**\n\n### 直接内存(非本地内存)\n\n```bash\n-XX:MaxDirectMemorySize 设置字节内存大小 如果不进行设置则与java堆的最大值一致\n```\n\n##\n","source":"_posts/java/JVM/虚拟机运行时数据区域.md","raw":"---\ntitle: 虚拟机运行时数据区域\ndate: 2022-10-30T13:40:27Z\nlastmod: 2023-11-25T13:15:42Z\n---\n\n# 虚拟机运行时数据区域\n\n## 运行时数据区域\n\n​![图像](/assets/image-20231119154230-3g5nidd.png)\n\n​​![图像](/assets/image-20231119154304-hwfdw8h.jpeg)​\n\n### 程序计数器\n\n> 通过改变这个计数器 的值来选取下一条需要执行的字节码指令\n\n　　java 虚拟机的多线程是通过线程轮流切换、分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器只会执行一条线程中的指令，为了线程切换后能恢复到正确的执行位置，每条线程都需要一个独立的程序计数器。\n每个线程都会有属于自己独立的线程计数器，各线程之间计数器不会相互影响，独立存储，这些区域成为线程私有。\n\n### Java虚拟机栈\n\n> Java方法执行的线程内存模型\n\n　　每个方法被执行，Java虚拟机栈会创建一个栈帧[(1)](https://www.yuque.com/pride_yang/blog/gngtxy)，用于存储局部变量表，操作数栈，方法出口，动态链接等信息。  \n一个方法的执行对应着一个栈帧的入栈与出栈过程。\n\n　　局部变量存储存放编译期间可知java虚拟机的基础类型（boolean，byte，char、short、int、float、dubbo、long）、对象引用（reference类型）、和returnAddress类型（指向一条字节码指令的地址）。\n\n　　局部变量表的存储单位是局部**变量槽（slot）**  其中64位长度的long和 double类型的数据会占用两个变量槽，其余的数据类型只占用一个 （一个变量槽的内存占用空间由虚拟机自行决定） 。\n\n　　当进入一个方法后，栈帧中需要分配多大的局部变量空间已经固定（变量槽数量）  \n《Java虚拟机规范》中  规定如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常，当栈扩展时无法申请到足够的内存会抛出OutOfMemoryError异常。  \n\n### 本地方法栈\n\n> 为虚拟机使用到的 Native 方法服务 （一个 Native Method 就是一个 java 调用非 java 代码的接口）\n\n　　**HotSpot栈内存不允许动态扩容**\n\n```bash\n-Xss 设置栈容量 jdk11 windows最小值 180k Linux最小值228k 否则启动时会出现提示\n```\n\n### Java堆\n\n> 被所有线程共享，在虚拟机启动时创建，用于存放对象实例。\n\n- java堆是垃圾收集器管理的内存区域，也被成为GC堆。G1收集器出现之前，垃圾收集器一般基于分代收集理论设计，但是之后出现了一些不采用分代设计的垃圾收集器。所以收集器不一定存在新生代，老年代，永久代，Eden区，From Survivor区，To Survivor区等。\n- 从内存角度看，所有线程共享的java堆可以划分为多个私有进程的分配缓存区（TLAB），以提升对象分配时的效率。\n\n```bash\n-Xmx 堆最大值\n-Xms 堆最小值\n-XX:+HeapDumpOnOutOfMemoryError 发生OOM时产生dump内存堆转储快照\n-XX:HeapDumpPath=./ 设置快照文件保存位置\n```\n\n#### jvm堆的默认分配方案\n\n　　![](/assets/net-img-1646742883104-4eef3a95-3655-44f4-8887-2f5f1628732e-20230330213506-2xv20ln.png)\n老年代 ： 三分之二的堆空间\n年轻代 ： 三分之一的堆空间\neden区： 8/10 的年轻代空间\nsurvivor0 : 1/10 的年轻代空间\nsurvivor1 : 1/10 的年轻代空间（from 区）\n\n　　**由于及时编译技术的进步，逃逸分析技术的日渐强大，栈上分配，标量替换等优化手段出现，对象实例也未必都全部分配在堆上。**\n\n　　  \n从 jdk 1.7 开始已经默认开启逃逸分析，如果某些方法中的对象引用没有被返回或者未被外面使用（也就是未逃逸出去），那么对象可以直接在栈上分配内存。\n\n　　JDK8 后方法区（永生代）移除，用元空间代替，元空间使用直接内存\n\n#### gc\n\n##### MinorGC触发机制\n\n* 当年轻代空间不足时，就会触发Minor GC。这里的年轻代满指的是Eden区满，Survivor满不会引发GC。（每次 Minor GC 会清理年轻代的内存。)\n* 因为 Java 对象大多都具备朝生夕灭的特性，所以 Minor GC 非常频繁，一般回收速度也比较快。这一定义既清晰又易于理解。\n* Minor GC会引发STW，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行。\n\n##### MajorGC触发机制\n\n* 指发生在老年代的GC，对象从老年代消失时，我们说“Major GC”或“Full GC”发生了。\n\n  * 出现了Major GC，经常会伴随至少一次的Minor GC（但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程）。\n  * 也就是在老年代空间不足时，会先尝试触发Minor GC。如果之后空间还不足，则触发Major GC\n\n* Major GC的速度一般会比Minor GC慢10倍以上，STW的时间更长。\n\n* 如果Major GC 后，内存还不足，就报OOM了。\n\n##### FullGC触发机制\n\n* 调用System.gc()时，系统建议执行Full GC，但是不必然执行\n* 老年代空间不足\n* 方法区空间不足\n* 通过Minor GC后进入老年代的平均大小大于老年代的可用内存\n* 由Eden区、survivor space0（From Space）区向survivor space1（To Space）区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小\n\n### 方法区（元空间）\n\n> 主要用于存储被虚拟机加载的类型信息、常量、静态变量、及时编译器编译后的代码缓存等数据\n\n#### 存储内容\n\n* 类型信息\n* 域信息\n\n  * 域名称，域类型，域修饰符（public, private, protected, static, final, volatile, transient的某个子集）\n* 方法信息\n\n  * 方法名称\n  * 方法的返回类型(或 void)\n  * 方法参数的数量和类型(按顺序)\n  * 方法的修饰符(public, private, protected, static, final, synchronized, native, abstract的一个子集)\n  * 方法的字节码(bytecodes)、操作数栈、局部变量表及大小 （abstract和native方法除外）\n  * 异常表（abstract和native方法除外）\n\n    * 每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引\n* non-final的类变量\n* 运行时常量池\n\n　　**在HotSpot中jdk1.8之前也被称为永久代 在jdk7后将永久代的功能转移到元空间**\n\n　　**元空间默认初始大小20m**\n\n```bash\n-XX:MaxMetaspaceSize 设置元空间最大值，默认为-1 不受限制或者说收本地内存限制\n-XX:MetaspaceSize 设置元空间初始空间大小 以字节为单位，达到该值会触发垃圾收集进行类型卸载，同事收集器会对该值进行调整，如果释放大量空间则适当降低该值，如果释放很少空间，那么在不超过最大值情况下适当提高。\n-MinMetaspaceFreeRatio：在垃圾收集后控制最小的元空间剩余容量的百分比，可减少因元空间不足导致垃圾收集的频率\n-MinMetaspaceFreeRatio：用于控制最大的元空间剩余容量的百分比\n```\n\n#### 运行时常量池\n\n> 方法区的一部分，用于存放编译期产生的各种字面量和符号引用  \n> **给基本类型变量赋值的方式就叫做字面量或者字面值**\n\n　　**注： 字符串常量池在堆中**\n\n### 直接内存(非本地内存)\n\n```bash\n-XX:MaxDirectMemorySize 设置字节内存大小 如果不进行设置则与java堆的最大值一致\n```\n\n##\n","slug":"java-JVM-虚拟机运行时数据区域","published":1,"updated":"2025-04-28T08:41:48.393Z","_id":"cm9s3f40l0031bfg4az7cd8y2","comments":1,"layout":"post","photos":[],"content":"<h1>虚拟机运行时数据区域</h1>\n<h2 id=\"运行时数据区域\">运行时数据区域</h2>\n<p>​<img src=\"/assets/image-20231119154230-3g5nidd.png\" alt=\"图像\"></p>\n<p>​​<img src=\"/assets/image-20231119154304-hwfdw8h.jpeg\" alt=\"图像\">​</p>\n<h3 id=\"程序计数器\">程序计数器</h3>\n<blockquote>\n<p>通过改变这个计数器 的值来选取下一条需要执行的字节码指令</p>\n</blockquote>\n<p>java 虚拟机的多线程是通过线程轮流切换、分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器只会执行一条线程中的指令，为了线程切换后能恢复到正确的执行位置，每条线程都需要一个独立的程序计数器。<br>\n每个线程都会有属于自己独立的线程计数器，各线程之间计数器不会相互影响，独立存储，这些区域成为线程私有。</p>\n<h3 id=\"Java虚拟机栈\">Java虚拟机栈</h3>\n<blockquote>\n<p>Java方法执行的线程内存模型</p>\n</blockquote>\n<p>每个方法被执行，Java虚拟机栈会创建一个栈帧<a href=\"https://www.yuque.com/pride_yang/blog/gngtxy\">(1)</a>，用于存储局部变量表，操作数栈，方法出口，动态链接等信息。<br>\n一个方法的执行对应着一个栈帧的入栈与出栈过程。</p>\n<p>局部变量存储存放编译期间可知java虚拟机的基础类型（boolean，byte，char、short、int、float、dubbo、long）、对象引用（reference类型）、和returnAddress类型（指向一条字节码指令的地址）。</p>\n<p>局部变量表的存储单位是局部<strong>变量槽（slot）</strong>  其中64位长度的long和 double类型的数据会占用两个变量槽，其余的数据类型只占用一个 （一个变量槽的内存占用空间由虚拟机自行决定） 。</p>\n<p>当进入一个方法后，栈帧中需要分配多大的局部变量空间已经固定（变量槽数量）<br>\n《Java虚拟机规范》中  规定如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常，当栈扩展时无法申请到足够的内存会抛出OutOfMemoryError异常。</p>\n<h3 id=\"本地方法栈\">本地方法栈</h3>\n<blockquote>\n<p>为虚拟机使用到的 Native 方法服务 （一个 Native Method 就是一个 java 调用非 java 代码的接口）</p>\n</blockquote>\n<p><strong>HotSpot栈内存不允许动态扩容</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-Xss 设置栈容量 jdk11 windows最小值 180k Linux最小值228k 否则启动时会出现提示</span><br></pre></td></tr></table></figure>\n<h3 id=\"Java堆\">Java堆</h3>\n<blockquote>\n<p>被所有线程共享，在虚拟机启动时创建，用于存放对象实例。</p>\n</blockquote>\n<ul>\n<li>java堆是垃圾收集器管理的内存区域，也被成为GC堆。G1收集器出现之前，垃圾收集器一般基于分代收集理论设计，但是之后出现了一些不采用分代设计的垃圾收集器。所以收集器不一定存在新生代，老年代，永久代，Eden区，From Survivor区，To Survivor区等。</li>\n<li>从内存角度看，所有线程共享的java堆可以划分为多个私有进程的分配缓存区（TLAB），以提升对象分配时的效率。</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-Xmx 堆最大值</span><br><span class=\"line\">-Xms 堆最小值</span><br><span class=\"line\">-XX:+HeapDumpOnOutOfMemoryError 发生OOM时产生dump内存堆转储快照</span><br><span class=\"line\">-XX:HeapDumpPath=./ 设置快照文件保存位置</span><br></pre></td></tr></table></figure>\n<h4 id=\"jvm堆的默认分配方案\">jvm堆的默认分配方案</h4>\n<p><img src=\"/assets/net-img-1646742883104-4eef3a95-3655-44f4-8887-2f5f1628732e-20230330213506-2xv20ln.png\" alt=\"\"><br>\n老年代 ： 三分之二的堆空间<br>\n年轻代 ： 三分之一的堆空间<br>\neden区： 8/10 的年轻代空间<br>\nsurvivor0 : 1/10 的年轻代空间<br>\nsurvivor1 : 1/10 的年轻代空间（from 区）</p>\n<p><strong>由于及时编译技术的进步，逃逸分析技术的日渐强大，栈上分配，标量替换等优化手段出现，对象实例也未必都全部分配在堆上。</strong></p>\n<p>从 jdk 1.7 开始已经默认开启逃逸分析，如果某些方法中的对象引用没有被返回或者未被外面使用（也就是未逃逸出去），那么对象可以直接在栈上分配内存。</p>\n<p>JDK8 后方法区（永生代）移除，用元空间代替，元空间使用直接内存</p>\n<h4 id=\"gc\">gc</h4>\n<h5 id=\"MinorGC触发机制\">MinorGC触发机制</h5>\n<ul>\n<li>当年轻代空间不足时，就会触发Minor GC。这里的年轻代满指的是Eden区满，Survivor满不会引发GC。（每次 Minor GC 会清理年轻代的内存。)</li>\n<li>因为 Java 对象大多都具备朝生夕灭的特性，所以 Minor GC 非常频繁，一般回收速度也比较快。这一定义既清晰又易于理解。</li>\n<li>Minor GC会引发STW，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行。</li>\n</ul>\n<h5 id=\"MajorGC触发机制\">MajorGC触发机制</h5>\n<ul>\n<li>\n<p>指发生在老年代的GC，对象从老年代消失时，我们说“Major GC”或“Full GC”发生了。</p>\n<ul>\n<li>出现了Major GC，经常会伴随至少一次的Minor GC（但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程）。</li>\n<li>也就是在老年代空间不足时，会先尝试触发Minor GC。如果之后空间还不足，则触发Major GC</li>\n</ul>\n</li>\n<li>\n<p>Major GC的速度一般会比Minor GC慢10倍以上，STW的时间更长。</p>\n</li>\n<li>\n<p>如果Major GC 后，内存还不足，就报OOM了。</p>\n</li>\n</ul>\n<h5 id=\"FullGC触发机制\">FullGC触发机制</h5>\n<ul>\n<li>调用System.gc()时，系统建议执行Full GC，但是不必然执行</li>\n<li>老年代空间不足</li>\n<li>方法区空间不足</li>\n<li>通过Minor GC后进入老年代的平均大小大于老年代的可用内存</li>\n<li>由Eden区、survivor space0（From Space）区向survivor space1（To Space）区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小</li>\n</ul>\n<h3 id=\"方法区（元空间）\">方法区（元空间）</h3>\n<blockquote>\n<p>主要用于存储被虚拟机加载的类型信息、常量、静态变量、及时编译器编译后的代码缓存等数据</p>\n</blockquote>\n<h4 id=\"存储内容\">存储内容</h4>\n<ul>\n<li>\n<p>类型信息</p>\n</li>\n<li>\n<p>域信息</p>\n<ul>\n<li>域名称，域类型，域修饰符（public, private, protected, static, final, volatile, transient的某个子集）</li>\n</ul>\n</li>\n<li>\n<p>方法信息</p>\n<ul>\n<li>\n<p>方法名称</p>\n</li>\n<li>\n<p>方法的返回类型(或 void)</p>\n</li>\n<li>\n<p>方法参数的数量和类型(按顺序)</p>\n</li>\n<li>\n<p>方法的修饰符(public, private, protected, static, final, synchronized, native, abstract的一个子集)</p>\n</li>\n<li>\n<p>方法的字节码(bytecodes)、操作数栈、局部变量表及大小 （abstract和native方法除外）</p>\n</li>\n<li>\n<p>异常表（abstract和native方法除外）</p>\n<ul>\n<li>每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>non-final的类变量</p>\n</li>\n<li>\n<p>运行时常量池</p>\n</li>\n</ul>\n<p><strong>在HotSpot中jdk1.8之前也被称为永久代 在jdk7后将永久代的功能转移到元空间</strong></p>\n<p><strong>元空间默认初始大小20m</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-XX:MaxMetaspaceSize 设置元空间最大值，默认为-1 不受限制或者说收本地内存限制</span><br><span class=\"line\">-XX:MetaspaceSize 设置元空间初始空间大小 以字节为单位，达到该值会触发垃圾收集进行类型卸载，同事收集器会对该值进行调整，如果释放大量空间则适当降低该值，如果释放很少空间，那么在不超过最大值情况下适当提高。</span><br><span class=\"line\">-MinMetaspaceFreeRatio：在垃圾收集后控制最小的元空间剩余容量的百分比，可减少因元空间不足导致垃圾收集的频率</span><br><span class=\"line\">-MinMetaspaceFreeRatio：用于控制最大的元空间剩余容量的百分比</span><br></pre></td></tr></table></figure>\n<h4 id=\"运行时常量池\">运行时常量池</h4>\n<blockquote>\n<p>方法区的一部分，用于存放编译期产生的各种字面量和符号引用<br>\n<strong>给基本类型变量赋值的方式就叫做字面量或者字面值</strong></p>\n</blockquote>\n<p><strong>注： 字符串常量池在堆中</strong></p>\n<h3 id=\"直接内存-非本地内存\">直接内存(非本地内存)</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-XX:MaxDirectMemorySize 设置字节内存大小 如果不进行设置则与java堆的最大值一致</span><br></pre></td></tr></table></figure>\n<h2 id=\"\"></h2>\n","excerpt":"","more":"<h1>虚拟机运行时数据区域</h1>\n<h2 id=\"运行时数据区域\">运行时数据区域</h2>\n<p>​<img src=\"/assets/image-20231119154230-3g5nidd.png\" alt=\"图像\"></p>\n<p>​​<img src=\"/assets/image-20231119154304-hwfdw8h.jpeg\" alt=\"图像\">​</p>\n<h3 id=\"程序计数器\">程序计数器</h3>\n<blockquote>\n<p>通过改变这个计数器 的值来选取下一条需要执行的字节码指令</p>\n</blockquote>\n<p>java 虚拟机的多线程是通过线程轮流切换、分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器只会执行一条线程中的指令，为了线程切换后能恢复到正确的执行位置，每条线程都需要一个独立的程序计数器。<br>\n每个线程都会有属于自己独立的线程计数器，各线程之间计数器不会相互影响，独立存储，这些区域成为线程私有。</p>\n<h3 id=\"Java虚拟机栈\">Java虚拟机栈</h3>\n<blockquote>\n<p>Java方法执行的线程内存模型</p>\n</blockquote>\n<p>每个方法被执行，Java虚拟机栈会创建一个栈帧<a href=\"https://www.yuque.com/pride_yang/blog/gngtxy\">(1)</a>，用于存储局部变量表，操作数栈，方法出口，动态链接等信息。<br>\n一个方法的执行对应着一个栈帧的入栈与出栈过程。</p>\n<p>局部变量存储存放编译期间可知java虚拟机的基础类型（boolean，byte，char、short、int、float、dubbo、long）、对象引用（reference类型）、和returnAddress类型（指向一条字节码指令的地址）。</p>\n<p>局部变量表的存储单位是局部<strong>变量槽（slot）</strong>  其中64位长度的long和 double类型的数据会占用两个变量槽，其余的数据类型只占用一个 （一个变量槽的内存占用空间由虚拟机自行决定） 。</p>\n<p>当进入一个方法后，栈帧中需要分配多大的局部变量空间已经固定（变量槽数量）<br>\n《Java虚拟机规范》中  规定如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常，当栈扩展时无法申请到足够的内存会抛出OutOfMemoryError异常。</p>\n<h3 id=\"本地方法栈\">本地方法栈</h3>\n<blockquote>\n<p>为虚拟机使用到的 Native 方法服务 （一个 Native Method 就是一个 java 调用非 java 代码的接口）</p>\n</blockquote>\n<p><strong>HotSpot栈内存不允许动态扩容</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-Xss 设置栈容量 jdk11 windows最小值 180k Linux最小值228k 否则启动时会出现提示</span><br></pre></td></tr></table></figure>\n<h3 id=\"Java堆\">Java堆</h3>\n<blockquote>\n<p>被所有线程共享，在虚拟机启动时创建，用于存放对象实例。</p>\n</blockquote>\n<ul>\n<li>java堆是垃圾收集器管理的内存区域，也被成为GC堆。G1收集器出现之前，垃圾收集器一般基于分代收集理论设计，但是之后出现了一些不采用分代设计的垃圾收集器。所以收集器不一定存在新生代，老年代，永久代，Eden区，From Survivor区，To Survivor区等。</li>\n<li>从内存角度看，所有线程共享的java堆可以划分为多个私有进程的分配缓存区（TLAB），以提升对象分配时的效率。</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-Xmx 堆最大值</span><br><span class=\"line\">-Xms 堆最小值</span><br><span class=\"line\">-XX:+HeapDumpOnOutOfMemoryError 发生OOM时产生dump内存堆转储快照</span><br><span class=\"line\">-XX:HeapDumpPath=./ 设置快照文件保存位置</span><br></pre></td></tr></table></figure>\n<h4 id=\"jvm堆的默认分配方案\">jvm堆的默认分配方案</h4>\n<p><img src=\"/assets/net-img-1646742883104-4eef3a95-3655-44f4-8887-2f5f1628732e-20230330213506-2xv20ln.png\" alt=\"\"><br>\n老年代 ： 三分之二的堆空间<br>\n年轻代 ： 三分之一的堆空间<br>\neden区： 8/10 的年轻代空间<br>\nsurvivor0 : 1/10 的年轻代空间<br>\nsurvivor1 : 1/10 的年轻代空间（from 区）</p>\n<p><strong>由于及时编译技术的进步，逃逸分析技术的日渐强大，栈上分配，标量替换等优化手段出现，对象实例也未必都全部分配在堆上。</strong></p>\n<p>从 jdk 1.7 开始已经默认开启逃逸分析，如果某些方法中的对象引用没有被返回或者未被外面使用（也就是未逃逸出去），那么对象可以直接在栈上分配内存。</p>\n<p>JDK8 后方法区（永生代）移除，用元空间代替，元空间使用直接内存</p>\n<h4 id=\"gc\">gc</h4>\n<h5 id=\"MinorGC触发机制\">MinorGC触发机制</h5>\n<ul>\n<li>当年轻代空间不足时，就会触发Minor GC。这里的年轻代满指的是Eden区满，Survivor满不会引发GC。（每次 Minor GC 会清理年轻代的内存。)</li>\n<li>因为 Java 对象大多都具备朝生夕灭的特性，所以 Minor GC 非常频繁，一般回收速度也比较快。这一定义既清晰又易于理解。</li>\n<li>Minor GC会引发STW，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行。</li>\n</ul>\n<h5 id=\"MajorGC触发机制\">MajorGC触发机制</h5>\n<ul>\n<li>\n<p>指发生在老年代的GC，对象从老年代消失时，我们说“Major GC”或“Full GC”发生了。</p>\n<ul>\n<li>出现了Major GC，经常会伴随至少一次的Minor GC（但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程）。</li>\n<li>也就是在老年代空间不足时，会先尝试触发Minor GC。如果之后空间还不足，则触发Major GC</li>\n</ul>\n</li>\n<li>\n<p>Major GC的速度一般会比Minor GC慢10倍以上，STW的时间更长。</p>\n</li>\n<li>\n<p>如果Major GC 后，内存还不足，就报OOM了。</p>\n</li>\n</ul>\n<h5 id=\"FullGC触发机制\">FullGC触发机制</h5>\n<ul>\n<li>调用System.gc()时，系统建议执行Full GC，但是不必然执行</li>\n<li>老年代空间不足</li>\n<li>方法区空间不足</li>\n<li>通过Minor GC后进入老年代的平均大小大于老年代的可用内存</li>\n<li>由Eden区、survivor space0（From Space）区向survivor space1（To Space）区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小</li>\n</ul>\n<h3 id=\"方法区（元空间）\">方法区（元空间）</h3>\n<blockquote>\n<p>主要用于存储被虚拟机加载的类型信息、常量、静态变量、及时编译器编译后的代码缓存等数据</p>\n</blockquote>\n<h4 id=\"存储内容\">存储内容</h4>\n<ul>\n<li>\n<p>类型信息</p>\n</li>\n<li>\n<p>域信息</p>\n<ul>\n<li>域名称，域类型，域修饰符（public, private, protected, static, final, volatile, transient的某个子集）</li>\n</ul>\n</li>\n<li>\n<p>方法信息</p>\n<ul>\n<li>\n<p>方法名称</p>\n</li>\n<li>\n<p>方法的返回类型(或 void)</p>\n</li>\n<li>\n<p>方法参数的数量和类型(按顺序)</p>\n</li>\n<li>\n<p>方法的修饰符(public, private, protected, static, final, synchronized, native, abstract的一个子集)</p>\n</li>\n<li>\n<p>方法的字节码(bytecodes)、操作数栈、局部变量表及大小 （abstract和native方法除外）</p>\n</li>\n<li>\n<p>异常表（abstract和native方法除外）</p>\n<ul>\n<li>每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>non-final的类变量</p>\n</li>\n<li>\n<p>运行时常量池</p>\n</li>\n</ul>\n<p><strong>在HotSpot中jdk1.8之前也被称为永久代 在jdk7后将永久代的功能转移到元空间</strong></p>\n<p><strong>元空间默认初始大小20m</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-XX:MaxMetaspaceSize 设置元空间最大值，默认为-1 不受限制或者说收本地内存限制</span><br><span class=\"line\">-XX:MetaspaceSize 设置元空间初始空间大小 以字节为单位，达到该值会触发垃圾收集进行类型卸载，同事收集器会对该值进行调整，如果释放大量空间则适当降低该值，如果释放很少空间，那么在不超过最大值情况下适当提高。</span><br><span class=\"line\">-MinMetaspaceFreeRatio：在垃圾收集后控制最小的元空间剩余容量的百分比，可减少因元空间不足导致垃圾收集的频率</span><br><span class=\"line\">-MinMetaspaceFreeRatio：用于控制最大的元空间剩余容量的百分比</span><br></pre></td></tr></table></figure>\n<h4 id=\"运行时常量池\">运行时常量池</h4>\n<blockquote>\n<p>方法区的一部分，用于存放编译期产生的各种字面量和符号引用<br>\n<strong>给基本类型变量赋值的方式就叫做字面量或者字面值</strong></p>\n</blockquote>\n<p><strong>注： 字符串常量池在堆中</strong></p>\n<h3 id=\"直接内存-非本地内存\">直接内存(非本地内存)</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-XX:MaxDirectMemorySize 设置字节内存大小 如果不进行设置则与java堆的最大值一致</span><br></pre></td></tr></table></figure>\n<h2 id=\"\"></h2>\n"},{"title":"Filter拦截器","date":"2022-10-30T05:27:28.000Z","lastmod":"2022-10-30T05:27:28.000Z","_content":"\n# Filter拦截器\n\n### 如何实现拦截\n\n　　实现Filter接口，重写doFilter方法。\n\n#### doFilter方法有三个传入参数\n\n- ServletRequest：对于简单的过滤器，大多数过滤逻辑是基于这个对象的。如果处理HTTP请求，并且需要访问诸如getHeader或getCookies等在ServletRequest中无法得到的方法，就要把此对象构造成 HttpServletRequest。\n- ServletResponse：除了在两个情形下要使用它以外，通常忽略这个参数。\n  - 首先，如果希望完全阻塞对相关 servlet或JSP页面的访问。可调用response.getWriter并直接发送一个响应到客户机。\n  - 其次，如果希望修改相关的servlet或 JSP页面的输出，可把响应包含在一个收集所有发送到它的输出的对象中。然后，在调用serlvet或JSP页面后，过滤器可检查输出，如果合适就修改 它，之后发送到客户机。\n- FilterChain：对此对象调用doFilter以激活与servlet或JSP页面相关的下一个过滤器。如果没有另一个相关的过滤器，则对doFilter的调用激活servlet或JSP本身\n","source":"_posts/java/JavaWeb/Filter拦截器.md","raw":"---\ntitle: Filter拦截器\ndate: 2022-10-30T13:27:28Z\nlastmod: 2022-10-30T13:27:28Z\n---\n\n# Filter拦截器\n\n### 如何实现拦截\n\n　　实现Filter接口，重写doFilter方法。\n\n#### doFilter方法有三个传入参数\n\n- ServletRequest：对于简单的过滤器，大多数过滤逻辑是基于这个对象的。如果处理HTTP请求，并且需要访问诸如getHeader或getCookies等在ServletRequest中无法得到的方法，就要把此对象构造成 HttpServletRequest。\n- ServletResponse：除了在两个情形下要使用它以外，通常忽略这个参数。\n  - 首先，如果希望完全阻塞对相关 servlet或JSP页面的访问。可调用response.getWriter并直接发送一个响应到客户机。\n  - 其次，如果希望修改相关的servlet或 JSP页面的输出，可把响应包含在一个收集所有发送到它的输出的对象中。然后，在调用serlvet或JSP页面后，过滤器可检查输出，如果合适就修改 它，之后发送到客户机。\n- FilterChain：对此对象调用doFilter以激活与servlet或JSP页面相关的下一个过滤器。如果没有另一个相关的过滤器，则对doFilter的调用激活servlet或JSP本身\n","slug":"java-JavaWeb-Filter拦截器","published":1,"updated":"2025-04-20T00:08:55.554Z","_id":"cm9s3f40m0032bfg40x2w6zz5","comments":1,"layout":"post","photos":[],"content":"<h1>Filter拦截器</h1>\n<h3 id=\"如何实现拦截\">如何实现拦截</h3>\n<p>实现Filter接口，重写doFilter方法。</p>\n<h4 id=\"doFilter方法有三个传入参数\">doFilter方法有三个传入参数</h4>\n<ul>\n<li>ServletRequest：对于简单的过滤器，大多数过滤逻辑是基于这个对象的。如果处理HTTP请求，并且需要访问诸如getHeader或getCookies等在ServletRequest中无法得到的方法，就要把此对象构造成 HttpServletRequest。</li>\n<li>ServletResponse：除了在两个情形下要使用它以外，通常忽略这个参数。\n<ul>\n<li>首先，如果希望完全阻塞对相关 servlet或JSP页面的访问。可调用response.getWriter并直接发送一个响应到客户机。</li>\n<li>其次，如果希望修改相关的servlet或 JSP页面的输出，可把响应包含在一个收集所有发送到它的输出的对象中。然后，在调用serlvet或JSP页面后，过滤器可检查输出，如果合适就修改 它，之后发送到客户机。</li>\n</ul>\n</li>\n<li>FilterChain：对此对象调用doFilter以激活与servlet或JSP页面相关的下一个过滤器。如果没有另一个相关的过滤器，则对doFilter的调用激活servlet或JSP本身</li>\n</ul>\n","excerpt":"","more":"<h1>Filter拦截器</h1>\n<h3 id=\"如何实现拦截\">如何实现拦截</h3>\n<p>实现Filter接口，重写doFilter方法。</p>\n<h4 id=\"doFilter方法有三个传入参数\">doFilter方法有三个传入参数</h4>\n<ul>\n<li>ServletRequest：对于简单的过滤器，大多数过滤逻辑是基于这个对象的。如果处理HTTP请求，并且需要访问诸如getHeader或getCookies等在ServletRequest中无法得到的方法，就要把此对象构造成 HttpServletRequest。</li>\n<li>ServletResponse：除了在两个情形下要使用它以外，通常忽略这个参数。\n<ul>\n<li>首先，如果希望完全阻塞对相关 servlet或JSP页面的访问。可调用response.getWriter并直接发送一个响应到客户机。</li>\n<li>其次，如果希望修改相关的servlet或 JSP页面的输出，可把响应包含在一个收集所有发送到它的输出的对象中。然后，在调用serlvet或JSP页面后，过滤器可检查输出，如果合适就修改 它，之后发送到客户机。</li>\n</ul>\n</li>\n<li>FilterChain：对此对象调用doFilter以激活与servlet或JSP页面相关的下一个过滤器。如果没有另一个相关的过滤器，则对doFilter的调用激活servlet或JSP本身</li>\n</ul>\n"},{"title":"并发锁","date":"2023-05-14T14:53:28.000Z","lastmod":"2023-05-27T07:18:35.000Z","_content":"\n# 并发锁\n\n　　根据分类标准我们把锁分为以下 7 大类别，分别是：\n\n* 偏向锁/轻量级锁/重量级锁：这三种锁特指 synchronized 锁的状态，通过在对象头中的 mark word 来表明锁的状态。\n\n  * 偏向锁\n\n    * 如果自始至终，对于这把锁都不存在竞争，那么其实就没必要上锁，只需要打个标记就行了，这就是偏向锁的思想。一个对象被初始化后，还没有任何线程来获取它的锁时，那么它就是可偏向的，当有第一个线程来访问它并尝试获取锁的时候，它就将这个线程记录下来，以后如果尝试获取锁的线程正是偏向锁的拥有者，就可以直接获得锁，开销很小，性能最好。\n  * 重量级锁\n\n    * 重量级锁是互斥锁，它是利用操作系统的同步机制实现的，所以开销相对比较大。当多个线程直接有实际竞争，且锁竞争时间长的时候，轻量级锁不能满足需求，锁就会膨胀为重量级锁。重量级锁会让其他申请却拿不到锁的线程进入阻塞状态。\n  * 轻量级锁\n\n    * JVM 开发者发现在很多情况下，synchronized 中的代码是被多个线程交替执行的，而不是同时执行的，也就是说并不存在实际的竞争，或者是只有短时间的锁竞争，用 CAS 就可以解决，这种情况下，用完全互斥的重量级锁是没必要的。轻量级锁是指当锁原来是偏向锁的时候，被另一个线程访问，说明存在竞争，那么偏向锁就会升级为轻量级锁，线程会通过自旋的形式尝试获取锁，而不会陷入阻塞。\n* 可重入锁/非可重入锁；\n\n  * 不可重入锁：线程当前持有了这把锁，但是如果想再次获取这把锁，也必须要先释放锁后才能再次尝试获取。\n  * 可重入锁：线程当前已经持有这把锁了，能在不释放这把锁的情况下，再次获取这把锁。\n* 共享锁/独占锁；\n\n  * 共享锁：同一把锁可以被多个线程同时获得，\n  * 独占锁：锁只能同时被一个线程获得。\n* 公平锁/非公平锁；\n\n  * 公平锁的公平的含义在于如果线程现在拿不到这把锁，那么线程就都会进入等待，开始排队，在等待队列里等待时间长的线程会优先拿到这把锁，有先来先得的意思。\n  * 非公平锁就不那么“完美”了，它会在一定情况下，忽略掉已经在排队的线程，发生插队现象。\n* 悲观锁/乐观锁；\n\n  * 悲观锁的概念是在获取资源之前，必须先拿到锁，以便达到“独占”的状态，当前线程在操作资源的时候，其他线程由于不能拿到锁，所以其他线程不能来影响我。\n  * 乐观锁恰恰相反，它并不要求在获取资源前拿到锁，也不会锁住资源；相反，乐观锁利用 CAS 理念，在不独占资源的情况下，完成了对资源的修改。\n* 自旋锁/非自旋锁；\n\n  * 自旋锁的理念是如果线程现在拿不到锁，并不直接陷入阻塞或者释放 CPU 资源，而是开始利用循环，不停地尝试获取锁，这个循环过程被形象地比喻为“自旋”，就像是线程在“自我旋转”。\n  * 非自旋锁的理念就是没有自旋的过程，如果拿不到锁就直接放弃，或者进行其他的处理逻辑，例如去排队、陷入阻塞等。\n* 可中断锁/不可中断锁。\n\n  * 在 Java 中，synchronized 关键字修饰的锁代表的是不可中断锁，一旦线程申请了锁，就没有回头路了，只能等到拿到锁以后才能进行其他的逻辑处理。而我们的 ReentrantLock 是一种典型的可中断锁，例如使用 lockInterruptibly 方法在获取锁的过程中，突然不想获取了，那么也可以在中断之后去做其他的事情，不需要一直傻等到获取到锁才离开。\n\n## Synchronized\n\n### 原理:\n\n　　每个对象都有一个monitor锁，当一个monitor被线程持有后会处于锁定状态，使用的是monitorenter和monitorexit指令，其中monitorenter指令指向同步代码块的开始位置，monitorexit指令则指明同步代码块的结束位置。当执行monitorenter指令时，monitor计数器加一，取锁成功，当monitor的计数器为0时释放锁。\n\n　　Synchronized方法锁为该方法所在的对象本身，静态Synchronized方法从Class对象获取\n\n　　**Synchronized是可重入锁**\n\n　　当一个线程请求方法时，会去检查锁状态，如果锁状态是0，代表该锁没有被占用，直接进行CAS操作获取锁，将线程ID替换成自己的线程ID。如果锁状态不是0，代表有线程在访问该方法。此时，如果线程ID是自己的线程ID，如果是可重入锁，会将status自增1，然后获取到该锁，进而执行相应的方法。如果是非重入锁，就会进入阻塞队列等待。释放锁时，可重入锁，每一次退出方法，就会将status减1，直至status的值为0，最后释放该锁。释放锁时，非可重入锁，线程退出方法，直接就会释放该锁。\n\n### 对象的内存布局\n\n　　**jvm默认开启class pointer压缩 为4字节**  \n普通对象 markword 默认八个字节 instance data 若属性则为零 padding 补足被8整除  \n​![image.png](/assets/net-img-1615611389351-2cfaa4d5-b52c-4a2e-a170-c32ce97d17a6-20221030135532-u420fpk.png)  \n数组对象  \n​![image.png](/assets/net-img-1615611419969-14ba7126-9f92-482c-a851-9898cece7e8f-20221030135532-6itdbiz.png)​\n\n### 实现\n\n　　MONITORENTER 进入锁\nMONITOREXIT 退出锁\n在jvm执行过程中实现锁升级\n\n### 锁升级\n\n|锁状态||25位||31位|||1位|4bit|1bit（偏向锁位）|2bit锁标志||\n| --------------| -| -----------------------------| -| ----------------------| -| -----| ------| --------| ----------------| ----------| -|\n|无锁（new）||unused||　hashcode（如果调用）|||unused|分代年龄|0|0|1|\n|||||||||||||\n|锁状态||54位||||2位|1位|4bit|1bit（偏向锁位）|2bit锁标志||\n|偏向锁||当前线程指针||||Epoch|unused|分代年龄|1|0|1|\n|||||||||||||\n|锁状态||62位||||||||2bit锁标志||\n|轻量锁，自旋锁||指向线程栈中Lock Record的指针||||||||0|0|\n|重量级锁||指向互斥量（重量级锁）的指针||||||||1|0|\n|GC标记信息||CMS过程中用到的标记信息||||||||1|1|\n\n![image.png](/assets/net-img-1615614053644-2e45ea92-d426-42ca-a609-91b095ff7e83-20221030135532-iwc3p25.png)\n\n#### 锁升级流程(hashcode存储到Lock Record)\n\n1. 先new一个对象\n2. 若有一个线程进入，将线程id放入对象头中（偏向锁）\n3. 若再来一个线程，将使用CAS进行锁竞争，并这小偏向锁标识（自旋锁）（CAS等待自旋会消耗CPU）\n4. jdk1.6之前为自旋10次货自旋线程大于CPU核心的一半则进入重量锁 之后则为jvm自适应锁\n\n　　为何要升级到重量锁：升级重量锁后，其他线程进入等待状态，不消耗CPU，但是申请重量锁需要与内核打交道，会消耗资源。\n\n#### 锁粗化\n\n　　jvm检测到一连串操作都对同一对象加锁，此时jvm就会将锁范围加到一连串操作的外围（比如for循环append）\n\n#### 锁消除\n\n　　一个资源为非共享资源，jvm会自动把锁去除（比如只在一个方法内使用StringBuffer的append方法）\n\n## 显式锁\n\n​![1-12.png](/assets/net-img-1582875478351-18a69ed7-cb09-4a5a-a020-097490219718-20221030135517-0h9pq4n.png)​\n\n```\nLock和ReadWriteLock是两大锁的根接口\nLock 接口支持重入、公平等的锁规则：实现类 ReentrantLock、ReadLock和WriteLock。\nReadWriteLock 接口定义读取者共享而写入者独占的锁，实现类：ReentrantReadWriteLock。\n```\n\n### Lock 类\n\n#### ReentrantLock\n\n　　ReentrantLock方法：\n\n```java\n\t//传入boolean值,true时create一个公平锁，false为非公平锁\n        ReentrantLock(boolean fair) \n  \n\t//查看有多少线程等待锁\n\tint getQueueLength()\n\n\t//是否有线程等待抢锁\n\tboolean hasQueuedThreads()\n\n\t//是否有指定线程等待抢锁\n\tboolean hasQueuedThread(Thread thread)\n\n\t//当前线程是否抢到锁。返回0代表没有\n\tint getHoldCount()\n\n\t//查询此锁是否由任何线程持有\n\tboolean isLocked()\n\t \n\t //是否为公平锁\n\tboolean isFair() \n\n```\n\n　　Condition 方法：\n\n```java\npublic interface Condition {\n\t/**\n\t*Condition线程进入阻塞状态,调用signal()或者signalAll()再次唤醒，\n\t*允许中断如果在阻塞时锁持有线程中断，会抛出异常；\n\t*重要一点是：在当前持有Lock的线程中，当外部调用会await()后，ReentrantLock就允许其他线程来抢夺锁当前锁，\n\t*注意：通过创建Condition对象来使线程wait，必须先执行lock.lock方法获得锁\n\t*/\n    void await() throws InterruptedException;\n\n    //Condition线程进入阻塞状态,调用signal()或者signalAll()再次唤醒，不允许中断，如果在阻塞时锁持有线程中断，继续等待唤醒\n    void awaitUninterruptibly();\n\n    //设置阻塞时间，超时继续，超时时间单位为纳秒，其他同await()；返回时间大于零，表示是被唤醒，等待时间并且可以作为等待时间期望值，小于零表示超时\n    long awaitNanos(long nanosTimeout) throws InterruptedException;\n\n\t//类似awaitNanos(long nanosTimeout);返回值：被唤醒true，超时false\n    boolean await(long time, TimeUnit unit) throws InterruptedException;\n\n   //类似await(long time, TimeUnit unit) \n    boolean awaitUntil(Date deadline) throws InterruptedException;\n\n   //唤醒指定线程\n    void signal();\n\n    //唤醒全部线程\n    void signalAll();\n}\n\n```\n\n> Condition是Lock上的一个条件，可以多次newCondition()获得多个条件，Condition可用于线程间通信，通过Condition能够更加精细的控制多线程的休眠与唤醒\n\n> ReentrantLock.Condition线程通信注意点：  \n> \t1. 使用**ReentrantLock.Condition的signal()、await()、signalAll()方法使用之前必须要先进行lock()操作**[记得unlock()]，类似使用Object的notify()、wait()、notifyAll()之前必须要对Object对象进行synchronized操作；否则就会抛IllegalMonitorStateException；  \n> \t2. 注意在使用**ReentrantLock.Condition中使用signal()、await()、signalAll()方法，不能和Object的notify()、wait()、notifyAll()方法混用，否则抛出IllegalMonitorStateException`;\n\n#### ReentrantReadWriteLock\n\n##### 读写锁的实现分析\n\n　　读写锁因为也是维护一个整数状态(volatile修饰)，但是因为是一个整数，需要保证读写，两种状态，所以对32位整型进行了高16位和低16位的设计，其中高16为代表读锁，低16为代表写锁。\n\n* 写锁的获取与释放  \n          写锁是一个可重入的锁，允许同一个线程重复获取锁，所以在获取锁的逻辑中会进行是否当前线程以及是否有其他读线程的状态判断。如果当前线程在获取写锁时，读锁已经被获取(读状态不为0)，或者该线程不是已经获得了写锁的线程，则当前线程进入等待状态。  \n  写锁的释放和ReentrantLock的释放很像，当释放锁时，需要对状态递减一，并且前一次写线程修改对后续读线程可见。\n\n* 读锁的获取与释放  \n         读锁是一个可重入锁，在没有其他写线程时，读锁总是可以成功的获取，安全地进行状态加1。state这个值可以判断整个读锁被获得了多少次，而每个线程获取读锁的次数，是存储在ThreadLocal中的。  \n  读锁的每次释放均线程安全的减少读状态\n\n##### 锁降级\n\n　　锁降级指的是一个线程先拥有写锁，然后拥有读锁，在对数据处理完成后，释放写锁，此时该线程所持有的锁是读锁，从写锁降级为读锁。\n\n## 自旋锁\n\n### CAS （Compare and Swap（比较与交换））\n\n　　CAS是实现自旋锁的基础\n\n　　CAS的原理：\n\n　　\t线程从内存中取值i 赋值给k 对k进行运算，运算完毕后与内存中的i值进行比较，若相等证明无线程修改i ，结果正确，更新结果值。若不相等则证明有其他线程修改过该值，结果不正确进行重试。\n\n　　‍\n\n### 自旋锁\n\n> 自旋锁和非自旋锁的获取锁的过程。\n\n​![image](/assets/image-20230527140729-waan312.png)​\n\n　　自旋锁，它并不会放弃  CPU  时间片，而是通过自旋等待锁的释放，也就是说，它会不停地再次地尝试获取锁，如果失败就再次尝试，直到成功为止。\n\n　　非自旋锁，如果它发现此时获取不到锁，它就把自己的线程切换状态，让线程休眠，然后 CPU 就可以在这段时间去做很多其他的事情，直到之前持有这把锁的线程释放了锁，于是 CPU 再把之前的线程恢复回来，让这个线程再去尝试获取这把锁。如果再次失败，就再次让线程休眠，如果成功，一样可以成功获取到同步资源的锁。\n\n* 优点\n\n  * 自旋锁用循环去不停地尝试获取锁，让线程始终处于 Runnable 状态，节省了线程状态切换带来的开销。\n\n* 缺点\n\n  * 虽然避免了线程切换的开销，但是它在避免线程切换开销的同时也带来了新的开销，因为它需要不停得去尝试获取锁。如果这把锁一直不能被释放，那么这种尝试只是无用的尝试，会白白浪费处理器资源。也就是说，虽然一开始自旋锁的开销低于线程切换，但是随着时间的增加，这种开销也是水涨船高，后期甚至会超过线程切换的开销，得不偿失。\n\n### 注意事项\n\n　　‍\n\n　　**虽然避免了线程切换的开销，但是它在避免线程切换开销的同时也带来了新的开销，因为它需要不停得去尝试获取锁。如果这把锁一直不能被释放，那么这种尝试只是无用的尝试，会白白浪费处理器资源。**\n\n　　**ABA问题**\n\n### 适应场景\n\n　　适用于并发度不是特别高的场景，以及临界区比较短小的情况，这样我们可以利用避免线程切换来提高效率。如果临界区很大，线程一旦拿到锁，很久才会释放的话，那就不合适用自旋锁，因为自旋会一直占用 CPU 却无法拿到锁，白白消耗资源。\n\n　　‍\n\n　　‍\n\n　　‍\n\n　　‍\n\n　　‍\n\n　　‍\n\n　　‍\n\n　　‍\n\n　　‍\n\n## 问题\n\n### Synchronized 和 Lock 区别\n\n```\nsynchronized是java内置关键字，在jvm层面，Lock是个java类；\nsynchronized无法判断是否获取锁的状态，Lock可以判断是否获取到锁；\nsynchronized会自动释放锁(a 线程执行完同步代码会释放锁 ；b 线程执行过程中发生异常会释放锁)，Lock需在finally中手工释放锁（unlock()方法释放锁），否则容易造成线程死锁；\n用synchronized关键字的两个线程1和线程2，如果当前线程1获得锁，线程2线程等待。如果线程1阻塞，线程2则会一直等待下去，而Lock锁就不一定会等待下去，如果尝试获取不到锁，线程可以不用一直等待就结束了；\nsynchronized的锁可重入、不可中断、非公平，而Lock锁可重入、可判断、可公平（两者皆可）\nLock锁适合大量同步的代码的同步问题，synchronized锁适合代码少量的同步问题。\n```\n\n　　‍\n","source":"_posts/java/thread/并发锁.md","raw":"---\ntitle: 并发锁\ndate: 2023-05-14T22:53:28Z\nlastmod: 2023-05-27T15:18:35Z\n---\n\n# 并发锁\n\n　　根据分类标准我们把锁分为以下 7 大类别，分别是：\n\n* 偏向锁/轻量级锁/重量级锁：这三种锁特指 synchronized 锁的状态，通过在对象头中的 mark word 来表明锁的状态。\n\n  * 偏向锁\n\n    * 如果自始至终，对于这把锁都不存在竞争，那么其实就没必要上锁，只需要打个标记就行了，这就是偏向锁的思想。一个对象被初始化后，还没有任何线程来获取它的锁时，那么它就是可偏向的，当有第一个线程来访问它并尝试获取锁的时候，它就将这个线程记录下来，以后如果尝试获取锁的线程正是偏向锁的拥有者，就可以直接获得锁，开销很小，性能最好。\n  * 重量级锁\n\n    * 重量级锁是互斥锁，它是利用操作系统的同步机制实现的，所以开销相对比较大。当多个线程直接有实际竞争，且锁竞争时间长的时候，轻量级锁不能满足需求，锁就会膨胀为重量级锁。重量级锁会让其他申请却拿不到锁的线程进入阻塞状态。\n  * 轻量级锁\n\n    * JVM 开发者发现在很多情况下，synchronized 中的代码是被多个线程交替执行的，而不是同时执行的，也就是说并不存在实际的竞争，或者是只有短时间的锁竞争，用 CAS 就可以解决，这种情况下，用完全互斥的重量级锁是没必要的。轻量级锁是指当锁原来是偏向锁的时候，被另一个线程访问，说明存在竞争，那么偏向锁就会升级为轻量级锁，线程会通过自旋的形式尝试获取锁，而不会陷入阻塞。\n* 可重入锁/非可重入锁；\n\n  * 不可重入锁：线程当前持有了这把锁，但是如果想再次获取这把锁，也必须要先释放锁后才能再次尝试获取。\n  * 可重入锁：线程当前已经持有这把锁了，能在不释放这把锁的情况下，再次获取这把锁。\n* 共享锁/独占锁；\n\n  * 共享锁：同一把锁可以被多个线程同时获得，\n  * 独占锁：锁只能同时被一个线程获得。\n* 公平锁/非公平锁；\n\n  * 公平锁的公平的含义在于如果线程现在拿不到这把锁，那么线程就都会进入等待，开始排队，在等待队列里等待时间长的线程会优先拿到这把锁，有先来先得的意思。\n  * 非公平锁就不那么“完美”了，它会在一定情况下，忽略掉已经在排队的线程，发生插队现象。\n* 悲观锁/乐观锁；\n\n  * 悲观锁的概念是在获取资源之前，必须先拿到锁，以便达到“独占”的状态，当前线程在操作资源的时候，其他线程由于不能拿到锁，所以其他线程不能来影响我。\n  * 乐观锁恰恰相反，它并不要求在获取资源前拿到锁，也不会锁住资源；相反，乐观锁利用 CAS 理念，在不独占资源的情况下，完成了对资源的修改。\n* 自旋锁/非自旋锁；\n\n  * 自旋锁的理念是如果线程现在拿不到锁，并不直接陷入阻塞或者释放 CPU 资源，而是开始利用循环，不停地尝试获取锁，这个循环过程被形象地比喻为“自旋”，就像是线程在“自我旋转”。\n  * 非自旋锁的理念就是没有自旋的过程，如果拿不到锁就直接放弃，或者进行其他的处理逻辑，例如去排队、陷入阻塞等。\n* 可中断锁/不可中断锁。\n\n  * 在 Java 中，synchronized 关键字修饰的锁代表的是不可中断锁，一旦线程申请了锁，就没有回头路了，只能等到拿到锁以后才能进行其他的逻辑处理。而我们的 ReentrantLock 是一种典型的可中断锁，例如使用 lockInterruptibly 方法在获取锁的过程中，突然不想获取了，那么也可以在中断之后去做其他的事情，不需要一直傻等到获取到锁才离开。\n\n## Synchronized\n\n### 原理:\n\n　　每个对象都有一个monitor锁，当一个monitor被线程持有后会处于锁定状态，使用的是monitorenter和monitorexit指令，其中monitorenter指令指向同步代码块的开始位置，monitorexit指令则指明同步代码块的结束位置。当执行monitorenter指令时，monitor计数器加一，取锁成功，当monitor的计数器为0时释放锁。\n\n　　Synchronized方法锁为该方法所在的对象本身，静态Synchronized方法从Class对象获取\n\n　　**Synchronized是可重入锁**\n\n　　当一个线程请求方法时，会去检查锁状态，如果锁状态是0，代表该锁没有被占用，直接进行CAS操作获取锁，将线程ID替换成自己的线程ID。如果锁状态不是0，代表有线程在访问该方法。此时，如果线程ID是自己的线程ID，如果是可重入锁，会将status自增1，然后获取到该锁，进而执行相应的方法。如果是非重入锁，就会进入阻塞队列等待。释放锁时，可重入锁，每一次退出方法，就会将status减1，直至status的值为0，最后释放该锁。释放锁时，非可重入锁，线程退出方法，直接就会释放该锁。\n\n### 对象的内存布局\n\n　　**jvm默认开启class pointer压缩 为4字节**  \n普通对象 markword 默认八个字节 instance data 若属性则为零 padding 补足被8整除  \n​![image.png](/assets/net-img-1615611389351-2cfaa4d5-b52c-4a2e-a170-c32ce97d17a6-20221030135532-u420fpk.png)  \n数组对象  \n​![image.png](/assets/net-img-1615611419969-14ba7126-9f92-482c-a851-9898cece7e8f-20221030135532-6itdbiz.png)​\n\n### 实现\n\n　　MONITORENTER 进入锁\nMONITOREXIT 退出锁\n在jvm执行过程中实现锁升级\n\n### 锁升级\n\n|锁状态||25位||31位|||1位|4bit|1bit（偏向锁位）|2bit锁标志||\n| --------------| -| -----------------------------| -| ----------------------| -| -----| ------| --------| ----------------| ----------| -|\n|无锁（new）||unused||　hashcode（如果调用）|||unused|分代年龄|0|0|1|\n|||||||||||||\n|锁状态||54位||||2位|1位|4bit|1bit（偏向锁位）|2bit锁标志||\n|偏向锁||当前线程指针||||Epoch|unused|分代年龄|1|0|1|\n|||||||||||||\n|锁状态||62位||||||||2bit锁标志||\n|轻量锁，自旋锁||指向线程栈中Lock Record的指针||||||||0|0|\n|重量级锁||指向互斥量（重量级锁）的指针||||||||1|0|\n|GC标记信息||CMS过程中用到的标记信息||||||||1|1|\n\n![image.png](/assets/net-img-1615614053644-2e45ea92-d426-42ca-a609-91b095ff7e83-20221030135532-iwc3p25.png)\n\n#### 锁升级流程(hashcode存储到Lock Record)\n\n1. 先new一个对象\n2. 若有一个线程进入，将线程id放入对象头中（偏向锁）\n3. 若再来一个线程，将使用CAS进行锁竞争，并这小偏向锁标识（自旋锁）（CAS等待自旋会消耗CPU）\n4. jdk1.6之前为自旋10次货自旋线程大于CPU核心的一半则进入重量锁 之后则为jvm自适应锁\n\n　　为何要升级到重量锁：升级重量锁后，其他线程进入等待状态，不消耗CPU，但是申请重量锁需要与内核打交道，会消耗资源。\n\n#### 锁粗化\n\n　　jvm检测到一连串操作都对同一对象加锁，此时jvm就会将锁范围加到一连串操作的外围（比如for循环append）\n\n#### 锁消除\n\n　　一个资源为非共享资源，jvm会自动把锁去除（比如只在一个方法内使用StringBuffer的append方法）\n\n## 显式锁\n\n​![1-12.png](/assets/net-img-1582875478351-18a69ed7-cb09-4a5a-a020-097490219718-20221030135517-0h9pq4n.png)​\n\n```\nLock和ReadWriteLock是两大锁的根接口\nLock 接口支持重入、公平等的锁规则：实现类 ReentrantLock、ReadLock和WriteLock。\nReadWriteLock 接口定义读取者共享而写入者独占的锁，实现类：ReentrantReadWriteLock。\n```\n\n### Lock 类\n\n#### ReentrantLock\n\n　　ReentrantLock方法：\n\n```java\n\t//传入boolean值,true时create一个公平锁，false为非公平锁\n        ReentrantLock(boolean fair) \n  \n\t//查看有多少线程等待锁\n\tint getQueueLength()\n\n\t//是否有线程等待抢锁\n\tboolean hasQueuedThreads()\n\n\t//是否有指定线程等待抢锁\n\tboolean hasQueuedThread(Thread thread)\n\n\t//当前线程是否抢到锁。返回0代表没有\n\tint getHoldCount()\n\n\t//查询此锁是否由任何线程持有\n\tboolean isLocked()\n\t \n\t //是否为公平锁\n\tboolean isFair() \n\n```\n\n　　Condition 方法：\n\n```java\npublic interface Condition {\n\t/**\n\t*Condition线程进入阻塞状态,调用signal()或者signalAll()再次唤醒，\n\t*允许中断如果在阻塞时锁持有线程中断，会抛出异常；\n\t*重要一点是：在当前持有Lock的线程中，当外部调用会await()后，ReentrantLock就允许其他线程来抢夺锁当前锁，\n\t*注意：通过创建Condition对象来使线程wait，必须先执行lock.lock方法获得锁\n\t*/\n    void await() throws InterruptedException;\n\n    //Condition线程进入阻塞状态,调用signal()或者signalAll()再次唤醒，不允许中断，如果在阻塞时锁持有线程中断，继续等待唤醒\n    void awaitUninterruptibly();\n\n    //设置阻塞时间，超时继续，超时时间单位为纳秒，其他同await()；返回时间大于零，表示是被唤醒，等待时间并且可以作为等待时间期望值，小于零表示超时\n    long awaitNanos(long nanosTimeout) throws InterruptedException;\n\n\t//类似awaitNanos(long nanosTimeout);返回值：被唤醒true，超时false\n    boolean await(long time, TimeUnit unit) throws InterruptedException;\n\n   //类似await(long time, TimeUnit unit) \n    boolean awaitUntil(Date deadline) throws InterruptedException;\n\n   //唤醒指定线程\n    void signal();\n\n    //唤醒全部线程\n    void signalAll();\n}\n\n```\n\n> Condition是Lock上的一个条件，可以多次newCondition()获得多个条件，Condition可用于线程间通信，通过Condition能够更加精细的控制多线程的休眠与唤醒\n\n> ReentrantLock.Condition线程通信注意点：  \n> \t1. 使用**ReentrantLock.Condition的signal()、await()、signalAll()方法使用之前必须要先进行lock()操作**[记得unlock()]，类似使用Object的notify()、wait()、notifyAll()之前必须要对Object对象进行synchronized操作；否则就会抛IllegalMonitorStateException；  \n> \t2. 注意在使用**ReentrantLock.Condition中使用signal()、await()、signalAll()方法，不能和Object的notify()、wait()、notifyAll()方法混用，否则抛出IllegalMonitorStateException`;\n\n#### ReentrantReadWriteLock\n\n##### 读写锁的实现分析\n\n　　读写锁因为也是维护一个整数状态(volatile修饰)，但是因为是一个整数，需要保证读写，两种状态，所以对32位整型进行了高16位和低16位的设计，其中高16为代表读锁，低16为代表写锁。\n\n* 写锁的获取与释放  \n          写锁是一个可重入的锁，允许同一个线程重复获取锁，所以在获取锁的逻辑中会进行是否当前线程以及是否有其他读线程的状态判断。如果当前线程在获取写锁时，读锁已经被获取(读状态不为0)，或者该线程不是已经获得了写锁的线程，则当前线程进入等待状态。  \n  写锁的释放和ReentrantLock的释放很像，当释放锁时，需要对状态递减一，并且前一次写线程修改对后续读线程可见。\n\n* 读锁的获取与释放  \n         读锁是一个可重入锁，在没有其他写线程时，读锁总是可以成功的获取，安全地进行状态加1。state这个值可以判断整个读锁被获得了多少次，而每个线程获取读锁的次数，是存储在ThreadLocal中的。  \n  读锁的每次释放均线程安全的减少读状态\n\n##### 锁降级\n\n　　锁降级指的是一个线程先拥有写锁，然后拥有读锁，在对数据处理完成后，释放写锁，此时该线程所持有的锁是读锁，从写锁降级为读锁。\n\n## 自旋锁\n\n### CAS （Compare and Swap（比较与交换））\n\n　　CAS是实现自旋锁的基础\n\n　　CAS的原理：\n\n　　\t线程从内存中取值i 赋值给k 对k进行运算，运算完毕后与内存中的i值进行比较，若相等证明无线程修改i ，结果正确，更新结果值。若不相等则证明有其他线程修改过该值，结果不正确进行重试。\n\n　　‍\n\n### 自旋锁\n\n> 自旋锁和非自旋锁的获取锁的过程。\n\n​![image](/assets/image-20230527140729-waan312.png)​\n\n　　自旋锁，它并不会放弃  CPU  时间片，而是通过自旋等待锁的释放，也就是说，它会不停地再次地尝试获取锁，如果失败就再次尝试，直到成功为止。\n\n　　非自旋锁，如果它发现此时获取不到锁，它就把自己的线程切换状态，让线程休眠，然后 CPU 就可以在这段时间去做很多其他的事情，直到之前持有这把锁的线程释放了锁，于是 CPU 再把之前的线程恢复回来，让这个线程再去尝试获取这把锁。如果再次失败，就再次让线程休眠，如果成功，一样可以成功获取到同步资源的锁。\n\n* 优点\n\n  * 自旋锁用循环去不停地尝试获取锁，让线程始终处于 Runnable 状态，节省了线程状态切换带来的开销。\n\n* 缺点\n\n  * 虽然避免了线程切换的开销，但是它在避免线程切换开销的同时也带来了新的开销，因为它需要不停得去尝试获取锁。如果这把锁一直不能被释放，那么这种尝试只是无用的尝试，会白白浪费处理器资源。也就是说，虽然一开始自旋锁的开销低于线程切换，但是随着时间的增加，这种开销也是水涨船高，后期甚至会超过线程切换的开销，得不偿失。\n\n### 注意事项\n\n　　‍\n\n　　**虽然避免了线程切换的开销，但是它在避免线程切换开销的同时也带来了新的开销，因为它需要不停得去尝试获取锁。如果这把锁一直不能被释放，那么这种尝试只是无用的尝试，会白白浪费处理器资源。**\n\n　　**ABA问题**\n\n### 适应场景\n\n　　适用于并发度不是特别高的场景，以及临界区比较短小的情况，这样我们可以利用避免线程切换来提高效率。如果临界区很大，线程一旦拿到锁，很久才会释放的话，那就不合适用自旋锁，因为自旋会一直占用 CPU 却无法拿到锁，白白消耗资源。\n\n　　‍\n\n　　‍\n\n　　‍\n\n　　‍\n\n　　‍\n\n　　‍\n\n　　‍\n\n　　‍\n\n　　‍\n\n## 问题\n\n### Synchronized 和 Lock 区别\n\n```\nsynchronized是java内置关键字，在jvm层面，Lock是个java类；\nsynchronized无法判断是否获取锁的状态，Lock可以判断是否获取到锁；\nsynchronized会自动释放锁(a 线程执行完同步代码会释放锁 ；b 线程执行过程中发生异常会释放锁)，Lock需在finally中手工释放锁（unlock()方法释放锁），否则容易造成线程死锁；\n用synchronized关键字的两个线程1和线程2，如果当前线程1获得锁，线程2线程等待。如果线程1阻塞，线程2则会一直等待下去，而Lock锁就不一定会等待下去，如果尝试获取不到锁，线程可以不用一直等待就结束了；\nsynchronized的锁可重入、不可中断、非公平，而Lock锁可重入、可判断、可公平（两者皆可）\nLock锁适合大量同步的代码的同步问题，synchronized锁适合代码少量的同步问题。\n```\n\n　　‍\n","slug":"java-thread-并发锁","published":1,"updated":"2025-04-28T08:41:48.396Z","_id":"cm9s3f40n0033bfg4c8u83b89","comments":1,"layout":"post","photos":[],"content":"<h1>并发锁</h1>\n<p>根据分类标准我们把锁分为以下 7 大类别，分别是：</p>\n<ul>\n<li>\n<p>偏向锁/轻量级锁/重量级锁：这三种锁特指 synchronized 锁的状态，通过在对象头中的 mark word 来表明锁的状态。</p>\n<ul>\n<li>\n<p>偏向锁</p>\n<ul>\n<li>如果自始至终，对于这把锁都不存在竞争，那么其实就没必要上锁，只需要打个标记就行了，这就是偏向锁的思想。一个对象被初始化后，还没有任何线程来获取它的锁时，那么它就是可偏向的，当有第一个线程来访问它并尝试获取锁的时候，它就将这个线程记录下来，以后如果尝试获取锁的线程正是偏向锁的拥有者，就可以直接获得锁，开销很小，性能最好。</li>\n</ul>\n</li>\n<li>\n<p>重量级锁</p>\n<ul>\n<li>重量级锁是互斥锁，它是利用操作系统的同步机制实现的，所以开销相对比较大。当多个线程直接有实际竞争，且锁竞争时间长的时候，轻量级锁不能满足需求，锁就会膨胀为重量级锁。重量级锁会让其他申请却拿不到锁的线程进入阻塞状态。</li>\n</ul>\n</li>\n<li>\n<p>轻量级锁</p>\n<ul>\n<li>JVM 开发者发现在很多情况下，synchronized 中的代码是被多个线程交替执行的，而不是同时执行的，也就是说并不存在实际的竞争，或者是只有短时间的锁竞争，用 CAS 就可以解决，这种情况下，用完全互斥的重量级锁是没必要的。轻量级锁是指当锁原来是偏向锁的时候，被另一个线程访问，说明存在竞争，那么偏向锁就会升级为轻量级锁，线程会通过自旋的形式尝试获取锁，而不会陷入阻塞。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>可重入锁/非可重入锁；</p>\n<ul>\n<li>不可重入锁：线程当前持有了这把锁，但是如果想再次获取这把锁，也必须要先释放锁后才能再次尝试获取。</li>\n<li>可重入锁：线程当前已经持有这把锁了，能在不释放这把锁的情况下，再次获取这把锁。</li>\n</ul>\n</li>\n<li>\n<p>共享锁/独占锁；</p>\n<ul>\n<li>共享锁：同一把锁可以被多个线程同时获得，</li>\n<li>独占锁：锁只能同时被一个线程获得。</li>\n</ul>\n</li>\n<li>\n<p>公平锁/非公平锁；</p>\n<ul>\n<li>公平锁的公平的含义在于如果线程现在拿不到这把锁，那么线程就都会进入等待，开始排队，在等待队列里等待时间长的线程会优先拿到这把锁，有先来先得的意思。</li>\n<li>非公平锁就不那么“完美”了，它会在一定情况下，忽略掉已经在排队的线程，发生插队现象。</li>\n</ul>\n</li>\n<li>\n<p>悲观锁/乐观锁；</p>\n<ul>\n<li>悲观锁的概念是在获取资源之前，必须先拿到锁，以便达到“独占”的状态，当前线程在操作资源的时候，其他线程由于不能拿到锁，所以其他线程不能来影响我。</li>\n<li>乐观锁恰恰相反，它并不要求在获取资源前拿到锁，也不会锁住资源；相反，乐观锁利用 CAS 理念，在不独占资源的情况下，完成了对资源的修改。</li>\n</ul>\n</li>\n<li>\n<p>自旋锁/非自旋锁；</p>\n<ul>\n<li>自旋锁的理念是如果线程现在拿不到锁，并不直接陷入阻塞或者释放 CPU 资源，而是开始利用循环，不停地尝试获取锁，这个循环过程被形象地比喻为“自旋”，就像是线程在“自我旋转”。</li>\n<li>非自旋锁的理念就是没有自旋的过程，如果拿不到锁就直接放弃，或者进行其他的处理逻辑，例如去排队、陷入阻塞等。</li>\n</ul>\n</li>\n<li>\n<p>可中断锁/不可中断锁。</p>\n<ul>\n<li>在 Java 中，synchronized 关键字修饰的锁代表的是不可中断锁，一旦线程申请了锁，就没有回头路了，只能等到拿到锁以后才能进行其他的逻辑处理。而我们的 ReentrantLock 是一种典型的可中断锁，例如使用 lockInterruptibly 方法在获取锁的过程中，突然不想获取了，那么也可以在中断之后去做其他的事情，不需要一直傻等到获取到锁才离开。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Synchronized\">Synchronized</h2>\n<h3 id=\"原理\">原理:</h3>\n<p>每个对象都有一个monitor锁，当一个monitor被线程持有后会处于锁定状态，使用的是monitorenter和monitorexit指令，其中monitorenter指令指向同步代码块的开始位置，monitorexit指令则指明同步代码块的结束位置。当执行monitorenter指令时，monitor计数器加一，取锁成功，当monitor的计数器为0时释放锁。</p>\n<p>Synchronized方法锁为该方法所在的对象本身，静态Synchronized方法从Class对象获取</p>\n<p><strong>Synchronized是可重入锁</strong></p>\n<p>当一个线程请求方法时，会去检查锁状态，如果锁状态是0，代表该锁没有被占用，直接进行CAS操作获取锁，将线程ID替换成自己的线程ID。如果锁状态不是0，代表有线程在访问该方法。此时，如果线程ID是自己的线程ID，如果是可重入锁，会将status自增1，然后获取到该锁，进而执行相应的方法。如果是非重入锁，就会进入阻塞队列等待。释放锁时，可重入锁，每一次退出方法，就会将status减1，直至status的值为0，最后释放该锁。释放锁时，非可重入锁，线程退出方法，直接就会释放该锁。</p>\n<h3 id=\"对象的内存布局\">对象的内存布局</h3>\n<p><strong>jvm默认开启class pointer压缩 为4字节</strong><br>\n普通对象 markword 默认八个字节 instance data 若属性则为零 padding 补足被8整除<br>\n​<img src=\"/assets/net-img-1615611389351-2cfaa4d5-b52c-4a2e-a170-c32ce97d17a6-20221030135532-u420fpk.png\" alt=\"image.png\"><br>\n数组对象<br>\n​<img src=\"/assets/net-img-1615611419969-14ba7126-9f92-482c-a851-9898cece7e8f-20221030135532-6itdbiz.png\" alt=\"image.png\">​</p>\n<h3 id=\"实现\">实现</h3>\n<p>MONITORENTER 进入锁<br>\nMONITOREXIT 退出锁<br>\n在jvm执行过程中实现锁升级</p>\n<h3 id=\"锁升级\">锁升级</h3>\n<table>\n<thead>\n<tr>\n<th>锁状态</th>\n<th></th>\n<th>25位</th>\n<th></th>\n<th>31位</th>\n<th></th>\n<th></th>\n<th>1位</th>\n<th>4bit</th>\n<th>1bit（偏向锁位）</th>\n<th>2bit锁标志</th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>无锁（new）</td>\n<td></td>\n<td>unused</td>\n<td></td>\n<td>hashcode（如果调用）</td>\n<td></td>\n<td></td>\n<td>unused</td>\n<td>分代年龄</td>\n<td>0</td>\n<td>0</td>\n<td>1</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>锁状态</td>\n<td></td>\n<td>54位</td>\n<td></td>\n<td></td>\n<td></td>\n<td>2位</td>\n<td>1位</td>\n<td>4bit</td>\n<td>1bit（偏向锁位）</td>\n<td>2bit锁标志</td>\n<td></td>\n</tr>\n<tr>\n<td>偏向锁</td>\n<td></td>\n<td>当前线程指针</td>\n<td></td>\n<td></td>\n<td></td>\n<td>Epoch</td>\n<td>unused</td>\n<td>分代年龄</td>\n<td>1</td>\n<td>0</td>\n<td>1</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>锁状态</td>\n<td></td>\n<td>62位</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td>2bit锁标志</td>\n<td></td>\n</tr>\n<tr>\n<td>轻量锁，自旋锁</td>\n<td></td>\n<td>指向线程栈中Lock Record的指针</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td>0</td>\n<td>0</td>\n</tr>\n<tr>\n<td>重量级锁</td>\n<td></td>\n<td>指向互斥量（重量级锁）的指针</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td>1</td>\n<td>0</td>\n</tr>\n<tr>\n<td>GC标记信息</td>\n<td></td>\n<td>CMS过程中用到的标记信息</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>\n<p><img src=\"/assets/net-img-1615614053644-2e45ea92-d426-42ca-a609-91b095ff7e83-20221030135532-iwc3p25.png\" alt=\"image.png\"></p>\n<h4 id=\"锁升级流程-hashcode存储到Lock-Record\">锁升级流程(hashcode存储到Lock Record)</h4>\n<ol>\n<li>先new一个对象</li>\n<li>若有一个线程进入，将线程id放入对象头中（偏向锁）</li>\n<li>若再来一个线程，将使用CAS进行锁竞争，并这小偏向锁标识（自旋锁）（CAS等待自旋会消耗CPU）</li>\n<li>jdk1.6之前为自旋10次货自旋线程大于CPU核心的一半则进入重量锁 之后则为jvm自适应锁</li>\n</ol>\n<p>为何要升级到重量锁：升级重量锁后，其他线程进入等待状态，不消耗CPU，但是申请重量锁需要与内核打交道，会消耗资源。</p>\n<h4 id=\"锁粗化\">锁粗化</h4>\n<p>jvm检测到一连串操作都对同一对象加锁，此时jvm就会将锁范围加到一连串操作的外围（比如for循环append）</p>\n<h4 id=\"锁消除\">锁消除</h4>\n<p>一个资源为非共享资源，jvm会自动把锁去除（比如只在一个方法内使用StringBuffer的append方法）</p>\n<h2 id=\"显式锁\">显式锁</h2>\n<p>​<img src=\"/assets/net-img-1582875478351-18a69ed7-cb09-4a5a-a020-097490219718-20221030135517-0h9pq4n.png\" alt=\"1-12.png\">​</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Lock和ReadWriteLock是两大锁的根接口</span><br><span class=\"line\">Lock 接口支持重入、公平等的锁规则：实现类 ReentrantLock、ReadLock和WriteLock。</span><br><span class=\"line\">ReadWriteLock 接口定义读取者共享而写入者独占的锁，实现类：ReentrantReadWriteLock。</span><br></pre></td></tr></table></figure>\n<h3 id=\"Lock-类\">Lock 类</h3>\n<h4 id=\"ReentrantLock\">ReentrantLock</h4>\n<p>ReentrantLock方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//传入boolean值,true时create一个公平锁，false为非公平锁</span></span><br><span class=\"line\">       ReentrantLock(<span class=\"type\">boolean</span> fair) </span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">//查看有多少线程等待锁</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">getQueueLength</span><span class=\"params\">()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//是否有线程等待抢锁</span></span><br><span class=\"line\"><span class=\"type\">boolean</span> <span class=\"title function_\">hasQueuedThreads</span><span class=\"params\">()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//是否有指定线程等待抢锁</span></span><br><span class=\"line\"><span class=\"type\">boolean</span> <span class=\"title function_\">hasQueuedThread</span><span class=\"params\">(Thread thread)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//当前线程是否抢到锁。返回0代表没有</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">getHoldCount</span><span class=\"params\">()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//查询此锁是否由任何线程持有</span></span><br><span class=\"line\"><span class=\"type\">boolean</span> <span class=\"title function_\">isLocked</span><span class=\"params\">()</span></span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"comment\">//是否为公平锁</span></span><br><span class=\"line\"><span class=\"type\">boolean</span> <span class=\"title function_\">isFair</span><span class=\"params\">()</span> </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>Condition 方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Condition</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t*Condition线程进入阻塞状态,调用signal()或者signalAll()再次唤醒，</span></span><br><span class=\"line\"><span class=\"comment\">\t*允许中断如果在阻塞时锁持有线程中断，会抛出异常；</span></span><br><span class=\"line\"><span class=\"comment\">\t*重要一点是：在当前持有Lock的线程中，当外部调用会await()后，ReentrantLock就允许其他线程来抢夺锁当前锁，</span></span><br><span class=\"line\"><span class=\"comment\">\t*注意：通过创建Condition对象来使线程wait，必须先执行lock.lock方法获得锁</span></span><br><span class=\"line\"><span class=\"comment\">\t*/</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">await</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//Condition线程进入阻塞状态,调用signal()或者signalAll()再次唤醒，不允许中断，如果在阻塞时锁持有线程中断，继续等待唤醒</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">awaitUninterruptibly</span><span class=\"params\">()</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//设置阻塞时间，超时继续，超时时间单位为纳秒，其他同await()；返回时间大于零，表示是被唤醒，等待时间并且可以作为等待时间期望值，小于零表示超时</span></span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"title function_\">awaitNanos</span><span class=\"params\">(<span class=\"type\">long</span> nanosTimeout)</span> <span class=\"keyword\">throws</span> InterruptedException;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//类似awaitNanos(long nanosTimeout);返回值：被唤醒true，超时false</span></span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"title function_\">await</span><span class=\"params\">(<span class=\"type\">long</span> time, TimeUnit unit)</span> <span class=\"keyword\">throws</span> InterruptedException;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">//类似await(long time, TimeUnit unit) </span></span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"title function_\">awaitUntil</span><span class=\"params\">(Date deadline)</span> <span class=\"keyword\">throws</span> InterruptedException;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">//唤醒指定线程</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">signal</span><span class=\"params\">()</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//唤醒全部线程</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">signalAll</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>Condition是Lock上的一个条件，可以多次newCondition()获得多个条件，Condition可用于线程间通信，通过Condition能够更加精细的控制多线程的休眠与唤醒</p>\n</blockquote>\n<blockquote>\n<p>ReentrantLock.Condition线程通信注意点：</p>\n<ol>\n<li>使用<strong>ReentrantLock.Condition的signal()、await()、signalAll()方法使用之前必须要先进行lock()操作</strong>[记得unlock()]，类似使用Object的notify()、wait()、notifyAll()之前必须要对Object对象进行synchronized操作；否则就会抛IllegalMonitorStateException；</li>\n<li>注意在使用**ReentrantLock.Condition中使用signal()、await()、signalAll()方法，不能和Object的notify()、wait()、notifyAll()方法混用，否则抛出IllegalMonitorStateException`;</li>\n</ol>\n</blockquote>\n<h4 id=\"ReentrantReadWriteLock\">ReentrantReadWriteLock</h4>\n<h5 id=\"读写锁的实现分析\">读写锁的实现分析</h5>\n<p>读写锁因为也是维护一个整数状态(volatile修饰)，但是因为是一个整数，需要保证读写，两种状态，所以对32位整型进行了高16位和低16位的设计，其中高16为代表读锁，低16为代表写锁。</p>\n<ul>\n<li>\n<p>写锁的获取与释放<br>\n写锁是一个可重入的锁，允许同一个线程重复获取锁，所以在获取锁的逻辑中会进行是否当前线程以及是否有其他读线程的状态判断。如果当前线程在获取写锁时，读锁已经被获取(读状态不为0)，或者该线程不是已经获得了写锁的线程，则当前线程进入等待状态。<br>\n写锁的释放和ReentrantLock的释放很像，当释放锁时，需要对状态递减一，并且前一次写线程修改对后续读线程可见。</p>\n</li>\n<li>\n<p>读锁的获取与释放<br>\n读锁是一个可重入锁，在没有其他写线程时，读锁总是可以成功的获取，安全地进行状态加1。state这个值可以判断整个读锁被获得了多少次，而每个线程获取读锁的次数，是存储在ThreadLocal中的。<br>\n读锁的每次释放均线程安全的减少读状态</p>\n</li>\n</ul>\n<h5 id=\"锁降级\">锁降级</h5>\n<p>锁降级指的是一个线程先拥有写锁，然后拥有读锁，在对数据处理完成后，释放写锁，此时该线程所持有的锁是读锁，从写锁降级为读锁。</p>\n<h2 id=\"自旋锁\">自旋锁</h2>\n<h3 id=\"CAS-（Compare-and-Swap（比较与交换））\">CAS （Compare and Swap（比较与交换））</h3>\n<p>CAS是实现自旋锁的基础</p>\n<p>CAS的原理：</p>\n<p>线程从内存中取值i 赋值给k 对k进行运算，运算完毕后与内存中的i值进行比较，若相等证明无线程修改i ，结果正确，更新结果值。若不相等则证明有其他线程修改过该值，结果不正确进行重试。</p>\n<p>‍</p>\n<h3 id=\"自旋锁-2\">自旋锁</h3>\n<blockquote>\n<p>自旋锁和非自旋锁的获取锁的过程。</p>\n</blockquote>\n<p>​<img src=\"/assets/image-20230527140729-waan312.png\" alt=\"image\">​</p>\n<p>自旋锁，它并不会放弃  CPU  时间片，而是通过自旋等待锁的释放，也就是说，它会不停地再次地尝试获取锁，如果失败就再次尝试，直到成功为止。</p>\n<p>非自旋锁，如果它发现此时获取不到锁，它就把自己的线程切换状态，让线程休眠，然后 CPU 就可以在这段时间去做很多其他的事情，直到之前持有这把锁的线程释放了锁，于是 CPU 再把之前的线程恢复回来，让这个线程再去尝试获取这把锁。如果再次失败，就再次让线程休眠，如果成功，一样可以成功获取到同步资源的锁。</p>\n<ul>\n<li>\n<p>优点</p>\n<ul>\n<li>自旋锁用循环去不停地尝试获取锁，让线程始终处于 Runnable 状态，节省了线程状态切换带来的开销。</li>\n</ul>\n</li>\n<li>\n<p>缺点</p>\n<ul>\n<li>虽然避免了线程切换的开销，但是它在避免线程切换开销的同时也带来了新的开销，因为它需要不停得去尝试获取锁。如果这把锁一直不能被释放，那么这种尝试只是无用的尝试，会白白浪费处理器资源。也就是说，虽然一开始自旋锁的开销低于线程切换，但是随着时间的增加，这种开销也是水涨船高，后期甚至会超过线程切换的开销，得不偿失。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"注意事项\">注意事项</h3>\n<p>‍</p>\n<p><strong>虽然避免了线程切换的开销，但是它在避免线程切换开销的同时也带来了新的开销，因为它需要不停得去尝试获取锁。如果这把锁一直不能被释放，那么这种尝试只是无用的尝试，会白白浪费处理器资源。</strong></p>\n<p><strong>ABA问题</strong></p>\n<h3 id=\"适应场景\">适应场景</h3>\n<p>适用于并发度不是特别高的场景，以及临界区比较短小的情况，这样我们可以利用避免线程切换来提高效率。如果临界区很大，线程一旦拿到锁，很久才会释放的话，那就不合适用自旋锁，因为自旋会一直占用 CPU 却无法拿到锁，白白消耗资源。</p>\n<p>‍</p>\n<p>‍</p>\n<p>‍</p>\n<p>‍</p>\n<p>‍</p>\n<p>‍</p>\n<p>‍</p>\n<p>‍</p>\n<p>‍</p>\n<h2 id=\"问题\">问题</h2>\n<h3 id=\"Synchronized-和-Lock-区别\">Synchronized 和 Lock 区别</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">synchronized是java内置关键字，在jvm层面，Lock是个java类；</span><br><span class=\"line\">synchronized无法判断是否获取锁的状态，Lock可以判断是否获取到锁；</span><br><span class=\"line\">synchronized会自动释放锁(a 线程执行完同步代码会释放锁 ；b 线程执行过程中发生异常会释放锁)，Lock需在finally中手工释放锁（unlock()方法释放锁），否则容易造成线程死锁；</span><br><span class=\"line\">用synchronized关键字的两个线程1和线程2，如果当前线程1获得锁，线程2线程等待。如果线程1阻塞，线程2则会一直等待下去，而Lock锁就不一定会等待下去，如果尝试获取不到锁，线程可以不用一直等待就结束了；</span><br><span class=\"line\">synchronized的锁可重入、不可中断、非公平，而Lock锁可重入、可判断、可公平（两者皆可）</span><br><span class=\"line\">Lock锁适合大量同步的代码的同步问题，synchronized锁适合代码少量的同步问题。</span><br></pre></td></tr></table></figure>\n<p>‍</p>\n","excerpt":"","more":"<h1>并发锁</h1>\n<p>根据分类标准我们把锁分为以下 7 大类别，分别是：</p>\n<ul>\n<li>\n<p>偏向锁/轻量级锁/重量级锁：这三种锁特指 synchronized 锁的状态，通过在对象头中的 mark word 来表明锁的状态。</p>\n<ul>\n<li>\n<p>偏向锁</p>\n<ul>\n<li>如果自始至终，对于这把锁都不存在竞争，那么其实就没必要上锁，只需要打个标记就行了，这就是偏向锁的思想。一个对象被初始化后，还没有任何线程来获取它的锁时，那么它就是可偏向的，当有第一个线程来访问它并尝试获取锁的时候，它就将这个线程记录下来，以后如果尝试获取锁的线程正是偏向锁的拥有者，就可以直接获得锁，开销很小，性能最好。</li>\n</ul>\n</li>\n<li>\n<p>重量级锁</p>\n<ul>\n<li>重量级锁是互斥锁，它是利用操作系统的同步机制实现的，所以开销相对比较大。当多个线程直接有实际竞争，且锁竞争时间长的时候，轻量级锁不能满足需求，锁就会膨胀为重量级锁。重量级锁会让其他申请却拿不到锁的线程进入阻塞状态。</li>\n</ul>\n</li>\n<li>\n<p>轻量级锁</p>\n<ul>\n<li>JVM 开发者发现在很多情况下，synchronized 中的代码是被多个线程交替执行的，而不是同时执行的，也就是说并不存在实际的竞争，或者是只有短时间的锁竞争，用 CAS 就可以解决，这种情况下，用完全互斥的重量级锁是没必要的。轻量级锁是指当锁原来是偏向锁的时候，被另一个线程访问，说明存在竞争，那么偏向锁就会升级为轻量级锁，线程会通过自旋的形式尝试获取锁，而不会陷入阻塞。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>可重入锁/非可重入锁；</p>\n<ul>\n<li>不可重入锁：线程当前持有了这把锁，但是如果想再次获取这把锁，也必须要先释放锁后才能再次尝试获取。</li>\n<li>可重入锁：线程当前已经持有这把锁了，能在不释放这把锁的情况下，再次获取这把锁。</li>\n</ul>\n</li>\n<li>\n<p>共享锁/独占锁；</p>\n<ul>\n<li>共享锁：同一把锁可以被多个线程同时获得，</li>\n<li>独占锁：锁只能同时被一个线程获得。</li>\n</ul>\n</li>\n<li>\n<p>公平锁/非公平锁；</p>\n<ul>\n<li>公平锁的公平的含义在于如果线程现在拿不到这把锁，那么线程就都会进入等待，开始排队，在等待队列里等待时间长的线程会优先拿到这把锁，有先来先得的意思。</li>\n<li>非公平锁就不那么“完美”了，它会在一定情况下，忽略掉已经在排队的线程，发生插队现象。</li>\n</ul>\n</li>\n<li>\n<p>悲观锁/乐观锁；</p>\n<ul>\n<li>悲观锁的概念是在获取资源之前，必须先拿到锁，以便达到“独占”的状态，当前线程在操作资源的时候，其他线程由于不能拿到锁，所以其他线程不能来影响我。</li>\n<li>乐观锁恰恰相反，它并不要求在获取资源前拿到锁，也不会锁住资源；相反，乐观锁利用 CAS 理念，在不独占资源的情况下，完成了对资源的修改。</li>\n</ul>\n</li>\n<li>\n<p>自旋锁/非自旋锁；</p>\n<ul>\n<li>自旋锁的理念是如果线程现在拿不到锁，并不直接陷入阻塞或者释放 CPU 资源，而是开始利用循环，不停地尝试获取锁，这个循环过程被形象地比喻为“自旋”，就像是线程在“自我旋转”。</li>\n<li>非自旋锁的理念就是没有自旋的过程，如果拿不到锁就直接放弃，或者进行其他的处理逻辑，例如去排队、陷入阻塞等。</li>\n</ul>\n</li>\n<li>\n<p>可中断锁/不可中断锁。</p>\n<ul>\n<li>在 Java 中，synchronized 关键字修饰的锁代表的是不可中断锁，一旦线程申请了锁，就没有回头路了，只能等到拿到锁以后才能进行其他的逻辑处理。而我们的 ReentrantLock 是一种典型的可中断锁，例如使用 lockInterruptibly 方法在获取锁的过程中，突然不想获取了，那么也可以在中断之后去做其他的事情，不需要一直傻等到获取到锁才离开。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Synchronized\">Synchronized</h2>\n<h3 id=\"原理\">原理:</h3>\n<p>每个对象都有一个monitor锁，当一个monitor被线程持有后会处于锁定状态，使用的是monitorenter和monitorexit指令，其中monitorenter指令指向同步代码块的开始位置，monitorexit指令则指明同步代码块的结束位置。当执行monitorenter指令时，monitor计数器加一，取锁成功，当monitor的计数器为0时释放锁。</p>\n<p>Synchronized方法锁为该方法所在的对象本身，静态Synchronized方法从Class对象获取</p>\n<p><strong>Synchronized是可重入锁</strong></p>\n<p>当一个线程请求方法时，会去检查锁状态，如果锁状态是0，代表该锁没有被占用，直接进行CAS操作获取锁，将线程ID替换成自己的线程ID。如果锁状态不是0，代表有线程在访问该方法。此时，如果线程ID是自己的线程ID，如果是可重入锁，会将status自增1，然后获取到该锁，进而执行相应的方法。如果是非重入锁，就会进入阻塞队列等待。释放锁时，可重入锁，每一次退出方法，就会将status减1，直至status的值为0，最后释放该锁。释放锁时，非可重入锁，线程退出方法，直接就会释放该锁。</p>\n<h3 id=\"对象的内存布局\">对象的内存布局</h3>\n<p><strong>jvm默认开启class pointer压缩 为4字节</strong><br>\n普通对象 markword 默认八个字节 instance data 若属性则为零 padding 补足被8整除<br>\n​<img src=\"/assets/net-img-1615611389351-2cfaa4d5-b52c-4a2e-a170-c32ce97d17a6-20221030135532-u420fpk.png\" alt=\"image.png\"><br>\n数组对象<br>\n​<img src=\"/assets/net-img-1615611419969-14ba7126-9f92-482c-a851-9898cece7e8f-20221030135532-6itdbiz.png\" alt=\"image.png\">​</p>\n<h3 id=\"实现\">实现</h3>\n<p>MONITORENTER 进入锁<br>\nMONITOREXIT 退出锁<br>\n在jvm执行过程中实现锁升级</p>\n<h3 id=\"锁升级\">锁升级</h3>\n<table>\n<thead>\n<tr>\n<th>锁状态</th>\n<th></th>\n<th>25位</th>\n<th></th>\n<th>31位</th>\n<th></th>\n<th></th>\n<th>1位</th>\n<th>4bit</th>\n<th>1bit（偏向锁位）</th>\n<th>2bit锁标志</th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>无锁（new）</td>\n<td></td>\n<td>unused</td>\n<td></td>\n<td>hashcode（如果调用）</td>\n<td></td>\n<td></td>\n<td>unused</td>\n<td>分代年龄</td>\n<td>0</td>\n<td>0</td>\n<td>1</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>锁状态</td>\n<td></td>\n<td>54位</td>\n<td></td>\n<td></td>\n<td></td>\n<td>2位</td>\n<td>1位</td>\n<td>4bit</td>\n<td>1bit（偏向锁位）</td>\n<td>2bit锁标志</td>\n<td></td>\n</tr>\n<tr>\n<td>偏向锁</td>\n<td></td>\n<td>当前线程指针</td>\n<td></td>\n<td></td>\n<td></td>\n<td>Epoch</td>\n<td>unused</td>\n<td>分代年龄</td>\n<td>1</td>\n<td>0</td>\n<td>1</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>锁状态</td>\n<td></td>\n<td>62位</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td>2bit锁标志</td>\n<td></td>\n</tr>\n<tr>\n<td>轻量锁，自旋锁</td>\n<td></td>\n<td>指向线程栈中Lock Record的指针</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td>0</td>\n<td>0</td>\n</tr>\n<tr>\n<td>重量级锁</td>\n<td></td>\n<td>指向互斥量（重量级锁）的指针</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td>1</td>\n<td>0</td>\n</tr>\n<tr>\n<td>GC标记信息</td>\n<td></td>\n<td>CMS过程中用到的标记信息</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>\n<p><img src=\"/assets/net-img-1615614053644-2e45ea92-d426-42ca-a609-91b095ff7e83-20221030135532-iwc3p25.png\" alt=\"image.png\"></p>\n<h4 id=\"锁升级流程-hashcode存储到Lock-Record\">锁升级流程(hashcode存储到Lock Record)</h4>\n<ol>\n<li>先new一个对象</li>\n<li>若有一个线程进入，将线程id放入对象头中（偏向锁）</li>\n<li>若再来一个线程，将使用CAS进行锁竞争，并这小偏向锁标识（自旋锁）（CAS等待自旋会消耗CPU）</li>\n<li>jdk1.6之前为自旋10次货自旋线程大于CPU核心的一半则进入重量锁 之后则为jvm自适应锁</li>\n</ol>\n<p>为何要升级到重量锁：升级重量锁后，其他线程进入等待状态，不消耗CPU，但是申请重量锁需要与内核打交道，会消耗资源。</p>\n<h4 id=\"锁粗化\">锁粗化</h4>\n<p>jvm检测到一连串操作都对同一对象加锁，此时jvm就会将锁范围加到一连串操作的外围（比如for循环append）</p>\n<h4 id=\"锁消除\">锁消除</h4>\n<p>一个资源为非共享资源，jvm会自动把锁去除（比如只在一个方法内使用StringBuffer的append方法）</p>\n<h2 id=\"显式锁\">显式锁</h2>\n<p>​<img src=\"/assets/net-img-1582875478351-18a69ed7-cb09-4a5a-a020-097490219718-20221030135517-0h9pq4n.png\" alt=\"1-12.png\">​</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Lock和ReadWriteLock是两大锁的根接口</span><br><span class=\"line\">Lock 接口支持重入、公平等的锁规则：实现类 ReentrantLock、ReadLock和WriteLock。</span><br><span class=\"line\">ReadWriteLock 接口定义读取者共享而写入者独占的锁，实现类：ReentrantReadWriteLock。</span><br></pre></td></tr></table></figure>\n<h3 id=\"Lock-类\">Lock 类</h3>\n<h4 id=\"ReentrantLock\">ReentrantLock</h4>\n<p>ReentrantLock方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//传入boolean值,true时create一个公平锁，false为非公平锁</span></span><br><span class=\"line\">       ReentrantLock(<span class=\"type\">boolean</span> fair) </span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">//查看有多少线程等待锁</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">getQueueLength</span><span class=\"params\">()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//是否有线程等待抢锁</span></span><br><span class=\"line\"><span class=\"type\">boolean</span> <span class=\"title function_\">hasQueuedThreads</span><span class=\"params\">()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//是否有指定线程等待抢锁</span></span><br><span class=\"line\"><span class=\"type\">boolean</span> <span class=\"title function_\">hasQueuedThread</span><span class=\"params\">(Thread thread)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//当前线程是否抢到锁。返回0代表没有</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">getHoldCount</span><span class=\"params\">()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//查询此锁是否由任何线程持有</span></span><br><span class=\"line\"><span class=\"type\">boolean</span> <span class=\"title function_\">isLocked</span><span class=\"params\">()</span></span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"comment\">//是否为公平锁</span></span><br><span class=\"line\"><span class=\"type\">boolean</span> <span class=\"title function_\">isFair</span><span class=\"params\">()</span> </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>Condition 方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Condition</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t*Condition线程进入阻塞状态,调用signal()或者signalAll()再次唤醒，</span></span><br><span class=\"line\"><span class=\"comment\">\t*允许中断如果在阻塞时锁持有线程中断，会抛出异常；</span></span><br><span class=\"line\"><span class=\"comment\">\t*重要一点是：在当前持有Lock的线程中，当外部调用会await()后，ReentrantLock就允许其他线程来抢夺锁当前锁，</span></span><br><span class=\"line\"><span class=\"comment\">\t*注意：通过创建Condition对象来使线程wait，必须先执行lock.lock方法获得锁</span></span><br><span class=\"line\"><span class=\"comment\">\t*/</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">await</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//Condition线程进入阻塞状态,调用signal()或者signalAll()再次唤醒，不允许中断，如果在阻塞时锁持有线程中断，继续等待唤醒</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">awaitUninterruptibly</span><span class=\"params\">()</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//设置阻塞时间，超时继续，超时时间单位为纳秒，其他同await()；返回时间大于零，表示是被唤醒，等待时间并且可以作为等待时间期望值，小于零表示超时</span></span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"title function_\">awaitNanos</span><span class=\"params\">(<span class=\"type\">long</span> nanosTimeout)</span> <span class=\"keyword\">throws</span> InterruptedException;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//类似awaitNanos(long nanosTimeout);返回值：被唤醒true，超时false</span></span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"title function_\">await</span><span class=\"params\">(<span class=\"type\">long</span> time, TimeUnit unit)</span> <span class=\"keyword\">throws</span> InterruptedException;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">//类似await(long time, TimeUnit unit) </span></span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"title function_\">awaitUntil</span><span class=\"params\">(Date deadline)</span> <span class=\"keyword\">throws</span> InterruptedException;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">//唤醒指定线程</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">signal</span><span class=\"params\">()</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//唤醒全部线程</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">signalAll</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>Condition是Lock上的一个条件，可以多次newCondition()获得多个条件，Condition可用于线程间通信，通过Condition能够更加精细的控制多线程的休眠与唤醒</p>\n</blockquote>\n<blockquote>\n<p>ReentrantLock.Condition线程通信注意点：</p>\n<ol>\n<li>使用<strong>ReentrantLock.Condition的signal()、await()、signalAll()方法使用之前必须要先进行lock()操作</strong>[记得unlock()]，类似使用Object的notify()、wait()、notifyAll()之前必须要对Object对象进行synchronized操作；否则就会抛IllegalMonitorStateException；</li>\n<li>注意在使用**ReentrantLock.Condition中使用signal()、await()、signalAll()方法，不能和Object的notify()、wait()、notifyAll()方法混用，否则抛出IllegalMonitorStateException`;</li>\n</ol>\n</blockquote>\n<h4 id=\"ReentrantReadWriteLock\">ReentrantReadWriteLock</h4>\n<h5 id=\"读写锁的实现分析\">读写锁的实现分析</h5>\n<p>读写锁因为也是维护一个整数状态(volatile修饰)，但是因为是一个整数，需要保证读写，两种状态，所以对32位整型进行了高16位和低16位的设计，其中高16为代表读锁，低16为代表写锁。</p>\n<ul>\n<li>\n<p>写锁的获取与释放<br>\n写锁是一个可重入的锁，允许同一个线程重复获取锁，所以在获取锁的逻辑中会进行是否当前线程以及是否有其他读线程的状态判断。如果当前线程在获取写锁时，读锁已经被获取(读状态不为0)，或者该线程不是已经获得了写锁的线程，则当前线程进入等待状态。<br>\n写锁的释放和ReentrantLock的释放很像，当释放锁时，需要对状态递减一，并且前一次写线程修改对后续读线程可见。</p>\n</li>\n<li>\n<p>读锁的获取与释放<br>\n读锁是一个可重入锁，在没有其他写线程时，读锁总是可以成功的获取，安全地进行状态加1。state这个值可以判断整个读锁被获得了多少次，而每个线程获取读锁的次数，是存储在ThreadLocal中的。<br>\n读锁的每次释放均线程安全的减少读状态</p>\n</li>\n</ul>\n<h5 id=\"锁降级\">锁降级</h5>\n<p>锁降级指的是一个线程先拥有写锁，然后拥有读锁，在对数据处理完成后，释放写锁，此时该线程所持有的锁是读锁，从写锁降级为读锁。</p>\n<h2 id=\"自旋锁\">自旋锁</h2>\n<h3 id=\"CAS-（Compare-and-Swap（比较与交换））\">CAS （Compare and Swap（比较与交换））</h3>\n<p>CAS是实现自旋锁的基础</p>\n<p>CAS的原理：</p>\n<p>线程从内存中取值i 赋值给k 对k进行运算，运算完毕后与内存中的i值进行比较，若相等证明无线程修改i ，结果正确，更新结果值。若不相等则证明有其他线程修改过该值，结果不正确进行重试。</p>\n<p>‍</p>\n<h3 id=\"自旋锁-2\">自旋锁</h3>\n<blockquote>\n<p>自旋锁和非自旋锁的获取锁的过程。</p>\n</blockquote>\n<p>​<img src=\"/assets/image-20230527140729-waan312.png\" alt=\"image\">​</p>\n<p>自旋锁，它并不会放弃  CPU  时间片，而是通过自旋等待锁的释放，也就是说，它会不停地再次地尝试获取锁，如果失败就再次尝试，直到成功为止。</p>\n<p>非自旋锁，如果它发现此时获取不到锁，它就把自己的线程切换状态，让线程休眠，然后 CPU 就可以在这段时间去做很多其他的事情，直到之前持有这把锁的线程释放了锁，于是 CPU 再把之前的线程恢复回来，让这个线程再去尝试获取这把锁。如果再次失败，就再次让线程休眠，如果成功，一样可以成功获取到同步资源的锁。</p>\n<ul>\n<li>\n<p>优点</p>\n<ul>\n<li>自旋锁用循环去不停地尝试获取锁，让线程始终处于 Runnable 状态，节省了线程状态切换带来的开销。</li>\n</ul>\n</li>\n<li>\n<p>缺点</p>\n<ul>\n<li>虽然避免了线程切换的开销，但是它在避免线程切换开销的同时也带来了新的开销，因为它需要不停得去尝试获取锁。如果这把锁一直不能被释放，那么这种尝试只是无用的尝试，会白白浪费处理器资源。也就是说，虽然一开始自旋锁的开销低于线程切换，但是随着时间的增加，这种开销也是水涨船高，后期甚至会超过线程切换的开销，得不偿失。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"注意事项\">注意事项</h3>\n<p>‍</p>\n<p><strong>虽然避免了线程切换的开销，但是它在避免线程切换开销的同时也带来了新的开销，因为它需要不停得去尝试获取锁。如果这把锁一直不能被释放，那么这种尝试只是无用的尝试，会白白浪费处理器资源。</strong></p>\n<p><strong>ABA问题</strong></p>\n<h3 id=\"适应场景\">适应场景</h3>\n<p>适用于并发度不是特别高的场景，以及临界区比较短小的情况，这样我们可以利用避免线程切换来提高效率。如果临界区很大，线程一旦拿到锁，很久才会释放的话，那就不合适用自旋锁，因为自旋会一直占用 CPU 却无法拿到锁，白白消耗资源。</p>\n<p>‍</p>\n<p>‍</p>\n<p>‍</p>\n<p>‍</p>\n<p>‍</p>\n<p>‍</p>\n<p>‍</p>\n<p>‍</p>\n<p>‍</p>\n<h2 id=\"问题\">问题</h2>\n<h3 id=\"Synchronized-和-Lock-区别\">Synchronized 和 Lock 区别</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">synchronized是java内置关键字，在jvm层面，Lock是个java类；</span><br><span class=\"line\">synchronized无法判断是否获取锁的状态，Lock可以判断是否获取到锁；</span><br><span class=\"line\">synchronized会自动释放锁(a 线程执行完同步代码会释放锁 ；b 线程执行过程中发生异常会释放锁)，Lock需在finally中手工释放锁（unlock()方法释放锁），否则容易造成线程死锁；</span><br><span class=\"line\">用synchronized关键字的两个线程1和线程2，如果当前线程1获得锁，线程2线程等待。如果线程1阻塞，线程2则会一直等待下去，而Lock锁就不一定会等待下去，如果尝试获取不到锁，线程可以不用一直等待就结束了；</span><br><span class=\"line\">synchronized的锁可重入、不可中断、非公平，而Lock锁可重入、可判断、可公平（两者皆可）</span><br><span class=\"line\">Lock锁适合大量同步的代码的同步问题，synchronized锁适合代码少量的同步问题。</span><br></pre></td></tr></table></figure>\n<p>‍</p>\n"},{"title":"线程池","date":"2023-05-14T14:53:28.000Z","lastmod":"2023-05-14T14:53:28.000Z","_content":"\n# 线程池 \n\n## 线程池\n\n1. Executor 接口：\n   声明了 execute(Runnable runnable)方法，执行任务代码\n2. ExecutorService 接口：\n   继承 Executor 接口，声明方法：submit、invokeAll、invokeAny 以及 shutDown 等\n3. AbstractExecutorService 抽象类：\n   实现 ExecutorService 接口，基本实现 ExecutorService 中声明的所有方法\n4. ScheduledExecutorService 接口：\n   继承 ExecutorService 接口，声明定时执行任务方法\n5. ThreadPoolExecutor 类：\n   继承类 AbstractExecutorService，实现 execute、submit、shutdown、shutdownNow 方法\n6. ScheduledThreadPoolExecutor 类：\n   继承 ThreadPoolExecutor 类，实现 ScheduledExecutorService 接口并实现其中的方法\n7. Executors 类：\n   提供快速创建线程池的方法\n\n## Executor 框架与线程池\n\n　　Executor 框架包括：线程池，Executor，Executors，ExecutorService，CompletionService，Future，Callable 等\n\n　　Executor 接口中之定义了一个方法 execute（Runnable command），该方法接收一个 Runable 实例，它用来执行一个任务\n\n　　ExecutorService 接口继承自 Executor 接口，它提供了更丰富的实现多线程的方法，比如\n\n1. submit()方法可以返回Future对象，可以调用isDone()方法查询Future是否已完成，当任务完成时，它具有一个结果，可以通过get()方法获取到该结果，Future提供了cancel()方法用来取消执行pending中的任务。\n2. shutdown()方法允许之前已经提交的任务执行完毕之后再挂起关闭，shutdownNow()方法则阻止正在等待的任务启动，并尝试停止之前正在执行的任务。\n\n　　**多线程的缺点：**\n\n- 处理任务的线程创建和销毁都非常耗时并消耗资源。\n- 多线程之间的切换也会非常耗时并消耗资源。\n  **解决方法：采用线程池**\n- 使用时线程已存在，消除了线程创建的时耗\n- 通过设置线程数目，防止资源不足\n\n### ThreadPoolExecutor 的全参构造函数参数\n\n　　在 Java 中创建线程池常用的类是 ThreadPoolExecutor，该类的全参构造函数如下：\n\n```java\npublic ThreadPoolExecutor(int corePoolSize,\n                          int maximumPoolSize,\n                          long keepAliveTime,\n                          TimeUnit unit,\n                          BlockingQueue<Runnable> workQueue,\n                          ThreadFactory threadFactory,\n                          RejectedExecutionHandler handler) {\n```\n\n　　参数介绍：\n\n* ​`corePoolSize`​：线程池中核心线程数的最大值\n* ​`maximumPoolSize`​：线程池中能拥有最多线程数\n* ​`workQueue`​：用于缓存任务的阻塞队列，对于不同的应用场景我们可能会采取不同的排队策略，这就需要不同类型的阻塞队列，在线程池中常用的阻塞队列有以下 2 种：\n\n  * ​`SynchronousQueue<Runnable>`​：此队列中不缓存任何一个任务。向线程池提交任务时，如果没有空闲线程来运行任务，则入列操作会阻塞。当有线程来获取任务时，出列操作会唤醒执行入列操作的线程。从这个特性来看，`SynchronousQueue`​ 是一个无界队列，因此当使用 `SynchronousQueue`​ 作为线程池的阻塞队列时，参数 `maximumPoolSizes`​ 没有任何作用。\n  * ​`LinkedBlockingQueue<Runnable>`​：顾名思义是用链表实现的队列，可以是有界的，也可以是无界的，但在 `Executors`​ 中默认使用无界的。\n* ​`keepAliveTime`​：表示空闲线程的存活时间。\n* ​`unit`​：表示 `keepAliveTime`​ 的单位。\n* ​`handler`​：表示当 `workQueue`​ 已满，且池中的线程数达到 `maximumPoolSize`​ 时，线程池拒绝添加新任务时采取的策略。一般可以采取以下四种取值。\n\n  1. 如果没有空闲的线程执行该任务且当前运行的线程数少于 `corePoolSize`​，则添加新的线程执行该任务。\n  2. 如果没有空闲的线程执行该任务且当前的线程数等于 `corePoolSize`​ 同时**阻塞队列未满**，则将任务入队列，而不添加新的线程。\n  3. 如果没有空闲的线程执行该任务且阻塞队列已满同时池中的线程数小于 `maximumPoolSize`​，则创建新的线程执行任务。\n  4. 如果没有空闲的线程执行该任务且阻塞队列已满同时池中的线程数等于 `maximumPoolSize`​，则根据构造函数中的 `handler`​ 指定的拒绝策略来拒绝新的任务。\n* ​`threadFactory`​：指定创建线程的工厂\n\n### 四种线程池拒绝策略\n\n#### `ThreadPoolExecutor.AbortPolicy()`​\n\n　　抛出 `RejectedExecutionException`​\n\n#### `ThreadPoolExecutor.CallerRunsPolicy()`​\n\n　　由向线程池提交任务的线程来执行该任务\n\n#### `ThreadPoolExecutor.DiscardOldestPolicy()`​\n\n　　抛弃最旧的任务（最先提交而没有得到执行的任务）\n\n#### `ThreadPoolExecutor.DiscardPolicy()`​\n\n　　抛弃当前的任务\n\n### 阻塞队列\n\n* ​`ArrayBlockingQueue`​：基于数组的阻塞队列实现，在ArrayBlockingQueue内部，维护了一个定长的数组，以便缓存队列中的数据对象，其内部没实现读写分离，也就意味着生产和消费者不能完全并行。长度是需要定义的，可以指定先进先出或者先进后出，因为长度是需要定义的，所以也叫有界队列，在很多场合非常适合使用。\n* ​`LinkedBlockingQueue`​：基于链表的阻塞队列，同ArrayBlockingQueue类似，其内部也维持着一个数据缓冲队列（该队列由一个链表构成），LinkedBlockingQueue之所以能够高效地处理并发数据，是因为其内部实现采用分离锁（读写分离两个锁），从而实现生产者和消费者操作完全并行运行。需要注意一下，它是一个无界队列。\n* ​`SynchronousQueue`​：一种没有缓冲的队列，生产者产生的数据直接会被消费者获取并且立刻消费。\n* ​`PriorityBlockingQueue`​：基于优先级别的阻塞队列（优先级的判断通过构造函数传入的Compator对象来决定，也就是说传入队列的对象必须实现Comparable接口），在实现PriorityBlockingQueue时，内部控制线程同步的锁采用的是公平锁，需要注意的是它也是一个无界的队列。\n* ​`DelayQueue`​：带有延迟时间的Queue，其中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素。DelayQueue中的元素必须先实现Delayed接口，DelayQueue是一个没有大小限制的队列，应用场景很多，比如对缓存超时的数据进行移除、任务超时处理、空闲连接的关闭等等\n\n​![image](/assets/image-20230519215732-zz9jpqo.png)​\n\n### 四种常用线程池（ExecutorService的实现类）\n\n　　ThreadPoolExecutor 构造函数的参数很多，使用起来很麻烦，为了方便的创建线程池，JavaSE 中又定义了 Executors 类，Eexcutors 类提供了四个创建线程池的方法，分别如下\n\n#### newCachedThreadPool\n\n　　该方法创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。\n此类型线程池特点是：\n\n1. .工作线程的创建数量几乎没有限制(其实也有限制的,数目为 Interger. MAX_VALUE)\n2. 空闲的工作线程会自动销毁，有新任务会重新创建\n3. 在使用 CachedThreadPool 时，一定要注意控制任务的数量，否则，由于大量线程同时运行，很有会造成系统瘫痪。\n\n#### newFixedThreadPool\n\n　　该方法创建一个指定工作线程数量的线程池。每当提交一个任务就创建一个工作线程，如果工作线程数量达到线程池初始的最大数，则将提交的任务存入到池队列中。\n优点：具有线程池提高程序效率和节省创建线程时所耗的开销。\n缺点：在线程池空闲时，即线程池中没有可运行任务时，它不会释放工作线程，还会占用一定的系统资源。\n\n#### newSingleThreadExecutor\n\n　　该方法创建一个单线程化的 Executor，即只创建唯一的工作者线程来执行任务，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO,优先级)执行。如果这个线程异常结束，会有另一个取代它，保证顺序执行。\n单工作线程最大的特点是可保证顺序地执行各个任务，并且在任意给定的时间不会有多个线程是活动的。\n\n#### newScheduleThreadPool\n\n　　该方法创建一个定长的线程池，而且支持定时的以及周期性的任务执行，支持定时及周期性任务执行。\n\n> FixedThreadPool、SingleThreadPool：使用的是无界队列（LinkedBlockingQueue），当任务堆积很多时，会占用大量内存，最终导致OOM。ChachedTheadPool：可以无限创建线程（Integer.MAX_VALUE），任务过多时会导致创建线程达到操作系统上线或者发生OOM。ScheduledThreadPool、SingleThreadScheduledPool：使用的是DelayedWorkQueue队列，实质上也是一种无界队列，会导致OOM。\n\n## 问题\n\n### 为什么java的线程池当核心线程满了以后,先往blockingQueue中存任务,queue满了以后\n\n　　起到一个缓冲的作用。最大线程数这个参数更像是无奈之举，在最坏的情况下做最后的努力，去新建线程去帮助消化任务。但是这种情况可能存在丢任务的情况。\n","source":"_posts/java/thread/线程池.md","raw":"---\ntitle: 线程池 \ndate: 2023-05-14T22:53:28Z\nlastmod: 2023-05-14T22:53:28Z\n---\n\n# 线程池 \n\n## 线程池\n\n1. Executor 接口：\n   声明了 execute(Runnable runnable)方法，执行任务代码\n2. ExecutorService 接口：\n   继承 Executor 接口，声明方法：submit、invokeAll、invokeAny 以及 shutDown 等\n3. AbstractExecutorService 抽象类：\n   实现 ExecutorService 接口，基本实现 ExecutorService 中声明的所有方法\n4. ScheduledExecutorService 接口：\n   继承 ExecutorService 接口，声明定时执行任务方法\n5. ThreadPoolExecutor 类：\n   继承类 AbstractExecutorService，实现 execute、submit、shutdown、shutdownNow 方法\n6. ScheduledThreadPoolExecutor 类：\n   继承 ThreadPoolExecutor 类，实现 ScheduledExecutorService 接口并实现其中的方法\n7. Executors 类：\n   提供快速创建线程池的方法\n\n## Executor 框架与线程池\n\n　　Executor 框架包括：线程池，Executor，Executors，ExecutorService，CompletionService，Future，Callable 等\n\n　　Executor 接口中之定义了一个方法 execute（Runnable command），该方法接收一个 Runable 实例，它用来执行一个任务\n\n　　ExecutorService 接口继承自 Executor 接口，它提供了更丰富的实现多线程的方法，比如\n\n1. submit()方法可以返回Future对象，可以调用isDone()方法查询Future是否已完成，当任务完成时，它具有一个结果，可以通过get()方法获取到该结果，Future提供了cancel()方法用来取消执行pending中的任务。\n2. shutdown()方法允许之前已经提交的任务执行完毕之后再挂起关闭，shutdownNow()方法则阻止正在等待的任务启动，并尝试停止之前正在执行的任务。\n\n　　**多线程的缺点：**\n\n- 处理任务的线程创建和销毁都非常耗时并消耗资源。\n- 多线程之间的切换也会非常耗时并消耗资源。\n  **解决方法：采用线程池**\n- 使用时线程已存在，消除了线程创建的时耗\n- 通过设置线程数目，防止资源不足\n\n### ThreadPoolExecutor 的全参构造函数参数\n\n　　在 Java 中创建线程池常用的类是 ThreadPoolExecutor，该类的全参构造函数如下：\n\n```java\npublic ThreadPoolExecutor(int corePoolSize,\n                          int maximumPoolSize,\n                          long keepAliveTime,\n                          TimeUnit unit,\n                          BlockingQueue<Runnable> workQueue,\n                          ThreadFactory threadFactory,\n                          RejectedExecutionHandler handler) {\n```\n\n　　参数介绍：\n\n* ​`corePoolSize`​：线程池中核心线程数的最大值\n* ​`maximumPoolSize`​：线程池中能拥有最多线程数\n* ​`workQueue`​：用于缓存任务的阻塞队列，对于不同的应用场景我们可能会采取不同的排队策略，这就需要不同类型的阻塞队列，在线程池中常用的阻塞队列有以下 2 种：\n\n  * ​`SynchronousQueue<Runnable>`​：此队列中不缓存任何一个任务。向线程池提交任务时，如果没有空闲线程来运行任务，则入列操作会阻塞。当有线程来获取任务时，出列操作会唤醒执行入列操作的线程。从这个特性来看，`SynchronousQueue`​ 是一个无界队列，因此当使用 `SynchronousQueue`​ 作为线程池的阻塞队列时，参数 `maximumPoolSizes`​ 没有任何作用。\n  * ​`LinkedBlockingQueue<Runnable>`​：顾名思义是用链表实现的队列，可以是有界的，也可以是无界的，但在 `Executors`​ 中默认使用无界的。\n* ​`keepAliveTime`​：表示空闲线程的存活时间。\n* ​`unit`​：表示 `keepAliveTime`​ 的单位。\n* ​`handler`​：表示当 `workQueue`​ 已满，且池中的线程数达到 `maximumPoolSize`​ 时，线程池拒绝添加新任务时采取的策略。一般可以采取以下四种取值。\n\n  1. 如果没有空闲的线程执行该任务且当前运行的线程数少于 `corePoolSize`​，则添加新的线程执行该任务。\n  2. 如果没有空闲的线程执行该任务且当前的线程数等于 `corePoolSize`​ 同时**阻塞队列未满**，则将任务入队列，而不添加新的线程。\n  3. 如果没有空闲的线程执行该任务且阻塞队列已满同时池中的线程数小于 `maximumPoolSize`​，则创建新的线程执行任务。\n  4. 如果没有空闲的线程执行该任务且阻塞队列已满同时池中的线程数等于 `maximumPoolSize`​，则根据构造函数中的 `handler`​ 指定的拒绝策略来拒绝新的任务。\n* ​`threadFactory`​：指定创建线程的工厂\n\n### 四种线程池拒绝策略\n\n#### `ThreadPoolExecutor.AbortPolicy()`​\n\n　　抛出 `RejectedExecutionException`​\n\n#### `ThreadPoolExecutor.CallerRunsPolicy()`​\n\n　　由向线程池提交任务的线程来执行该任务\n\n#### `ThreadPoolExecutor.DiscardOldestPolicy()`​\n\n　　抛弃最旧的任务（最先提交而没有得到执行的任务）\n\n#### `ThreadPoolExecutor.DiscardPolicy()`​\n\n　　抛弃当前的任务\n\n### 阻塞队列\n\n* ​`ArrayBlockingQueue`​：基于数组的阻塞队列实现，在ArrayBlockingQueue内部，维护了一个定长的数组，以便缓存队列中的数据对象，其内部没实现读写分离，也就意味着生产和消费者不能完全并行。长度是需要定义的，可以指定先进先出或者先进后出，因为长度是需要定义的，所以也叫有界队列，在很多场合非常适合使用。\n* ​`LinkedBlockingQueue`​：基于链表的阻塞队列，同ArrayBlockingQueue类似，其内部也维持着一个数据缓冲队列（该队列由一个链表构成），LinkedBlockingQueue之所以能够高效地处理并发数据，是因为其内部实现采用分离锁（读写分离两个锁），从而实现生产者和消费者操作完全并行运行。需要注意一下，它是一个无界队列。\n* ​`SynchronousQueue`​：一种没有缓冲的队列，生产者产生的数据直接会被消费者获取并且立刻消费。\n* ​`PriorityBlockingQueue`​：基于优先级别的阻塞队列（优先级的判断通过构造函数传入的Compator对象来决定，也就是说传入队列的对象必须实现Comparable接口），在实现PriorityBlockingQueue时，内部控制线程同步的锁采用的是公平锁，需要注意的是它也是一个无界的队列。\n* ​`DelayQueue`​：带有延迟时间的Queue，其中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素。DelayQueue中的元素必须先实现Delayed接口，DelayQueue是一个没有大小限制的队列，应用场景很多，比如对缓存超时的数据进行移除、任务超时处理、空闲连接的关闭等等\n\n​![image](/assets/image-20230519215732-zz9jpqo.png)​\n\n### 四种常用线程池（ExecutorService的实现类）\n\n　　ThreadPoolExecutor 构造函数的参数很多，使用起来很麻烦，为了方便的创建线程池，JavaSE 中又定义了 Executors 类，Eexcutors 类提供了四个创建线程池的方法，分别如下\n\n#### newCachedThreadPool\n\n　　该方法创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。\n此类型线程池特点是：\n\n1. .工作线程的创建数量几乎没有限制(其实也有限制的,数目为 Interger. MAX_VALUE)\n2. 空闲的工作线程会自动销毁，有新任务会重新创建\n3. 在使用 CachedThreadPool 时，一定要注意控制任务的数量，否则，由于大量线程同时运行，很有会造成系统瘫痪。\n\n#### newFixedThreadPool\n\n　　该方法创建一个指定工作线程数量的线程池。每当提交一个任务就创建一个工作线程，如果工作线程数量达到线程池初始的最大数，则将提交的任务存入到池队列中。\n优点：具有线程池提高程序效率和节省创建线程时所耗的开销。\n缺点：在线程池空闲时，即线程池中没有可运行任务时，它不会释放工作线程，还会占用一定的系统资源。\n\n#### newSingleThreadExecutor\n\n　　该方法创建一个单线程化的 Executor，即只创建唯一的工作者线程来执行任务，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO,优先级)执行。如果这个线程异常结束，会有另一个取代它，保证顺序执行。\n单工作线程最大的特点是可保证顺序地执行各个任务，并且在任意给定的时间不会有多个线程是活动的。\n\n#### newScheduleThreadPool\n\n　　该方法创建一个定长的线程池，而且支持定时的以及周期性的任务执行，支持定时及周期性任务执行。\n\n> FixedThreadPool、SingleThreadPool：使用的是无界队列（LinkedBlockingQueue），当任务堆积很多时，会占用大量内存，最终导致OOM。ChachedTheadPool：可以无限创建线程（Integer.MAX_VALUE），任务过多时会导致创建线程达到操作系统上线或者发生OOM。ScheduledThreadPool、SingleThreadScheduledPool：使用的是DelayedWorkQueue队列，实质上也是一种无界队列，会导致OOM。\n\n## 问题\n\n### 为什么java的线程池当核心线程满了以后,先往blockingQueue中存任务,queue满了以后\n\n　　起到一个缓冲的作用。最大线程数这个参数更像是无奈之举，在最坏的情况下做最后的努力，去新建线程去帮助消化任务。但是这种情况可能存在丢任务的情况。\n","slug":"java-thread-线程池","published":1,"updated":"2025-04-28T08:41:48.396Z","_id":"cm9s3f40n0034bfg42z1u6wyi","comments":1,"layout":"post","photos":[],"content":"<h1>线程池</h1>\n<h2 id=\"线程池\">线程池</h2>\n<ol>\n<li>Executor 接口：<br>\n声明了 execute(Runnable runnable)方法，执行任务代码</li>\n<li>ExecutorService 接口：<br>\n继承 Executor 接口，声明方法：submit、invokeAll、invokeAny 以及 shutDown 等</li>\n<li>AbstractExecutorService 抽象类：<br>\n实现 ExecutorService 接口，基本实现 ExecutorService 中声明的所有方法</li>\n<li>ScheduledExecutorService 接口：<br>\n继承 ExecutorService 接口，声明定时执行任务方法</li>\n<li>ThreadPoolExecutor 类：<br>\n继承类 AbstractExecutorService，实现 execute、submit、shutdown、shutdownNow 方法</li>\n<li>ScheduledThreadPoolExecutor 类：<br>\n继承 ThreadPoolExecutor 类，实现 ScheduledExecutorService 接口并实现其中的方法</li>\n<li>Executors 类：<br>\n提供快速创建线程池的方法</li>\n</ol>\n<h2 id=\"Executor-框架与线程池\">Executor 框架与线程池</h2>\n<p>Executor 框架包括：线程池，Executor，Executors，ExecutorService，CompletionService，Future，Callable 等</p>\n<p>Executor 接口中之定义了一个方法 execute（Runnable command），该方法接收一个 Runable 实例，它用来执行一个任务</p>\n<p>ExecutorService 接口继承自 Executor 接口，它提供了更丰富的实现多线程的方法，比如</p>\n<ol>\n<li>submit()方法可以返回Future对象，可以调用isDone()方法查询Future是否已完成，当任务完成时，它具有一个结果，可以通过get()方法获取到该结果，Future提供了cancel()方法用来取消执行pending中的任务。</li>\n<li>shutdown()方法允许之前已经提交的任务执行完毕之后再挂起关闭，shutdownNow()方法则阻止正在等待的任务启动，并尝试停止之前正在执行的任务。</li>\n</ol>\n<p><strong>多线程的缺点：</strong></p>\n<ul>\n<li>处理任务的线程创建和销毁都非常耗时并消耗资源。</li>\n<li>多线程之间的切换也会非常耗时并消耗资源。<br>\n<strong>解决方法：采用线程池</strong></li>\n<li>使用时线程已存在，消除了线程创建的时耗</li>\n<li>通过设置线程数目，防止资源不足</li>\n</ul>\n<h3 id=\"ThreadPoolExecutor-的全参构造函数参数\">ThreadPoolExecutor 的全参构造函数参数</h3>\n<p>在 Java 中创建线程池常用的类是 ThreadPoolExecutor，该类的全参构造函数如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">ThreadPoolExecutor</span><span class=\"params\">(<span class=\"type\">int</span> corePoolSize,</span></span><br><span class=\"line\"><span class=\"params\">                          <span class=\"type\">int</span> maximumPoolSize,</span></span><br><span class=\"line\"><span class=\"params\">                          <span class=\"type\">long</span> keepAliveTime,</span></span><br><span class=\"line\"><span class=\"params\">                          TimeUnit unit,</span></span><br><span class=\"line\"><span class=\"params\">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class=\"line\"><span class=\"params\">                          ThreadFactory threadFactory,</span></span><br><span class=\"line\"><span class=\"params\">                          RejectedExecutionHandler handler)</span> &#123;</span><br></pre></td></tr></table></figure>\n<p>参数介绍：</p>\n<ul>\n<li>\n<p>​<code>corePoolSize</code>​：线程池中核心线程数的最大值</p>\n</li>\n<li>\n<p>​<code>maximumPoolSize</code>​：线程池中能拥有最多线程数</p>\n</li>\n<li>\n<p>​<code>workQueue</code>​：用于缓存任务的阻塞队列，对于不同的应用场景我们可能会采取不同的排队策略，这就需要不同类型的阻塞队列，在线程池中常用的阻塞队列有以下 2 种：</p>\n<ul>\n<li>​<code>SynchronousQueue&lt;Runnable&gt;</code>​：此队列中不缓存任何一个任务。向线程池提交任务时，如果没有空闲线程来运行任务，则入列操作会阻塞。当有线程来获取任务时，出列操作会唤醒执行入列操作的线程。从这个特性来看，<code>SynchronousQueue</code>​ 是一个无界队列，因此当使用 <code>SynchronousQueue</code>​ 作为线程池的阻塞队列时，参数 <code>maximumPoolSizes</code>​ 没有任何作用。</li>\n<li>​<code>LinkedBlockingQueue&lt;Runnable&gt;</code>​：顾名思义是用链表实现的队列，可以是有界的，也可以是无界的，但在 <code>Executors</code>​ 中默认使用无界的。</li>\n</ul>\n</li>\n<li>\n<p>​<code>keepAliveTime</code>​：表示空闲线程的存活时间。</p>\n</li>\n<li>\n<p>​<code>unit</code>​：表示 <code>keepAliveTime</code>​ 的单位。</p>\n</li>\n<li>\n<p>​<code>handler</code>​：表示当 <code>workQueue</code>​ 已满，且池中的线程数达到 <code>maximumPoolSize</code>​ 时，线程池拒绝添加新任务时采取的策略。一般可以采取以下四种取值。</p>\n<ol>\n<li>如果没有空闲的线程执行该任务且当前运行的线程数少于 <code>corePoolSize</code>​，则添加新的线程执行该任务。</li>\n<li>如果没有空闲的线程执行该任务且当前的线程数等于 <code>corePoolSize</code>​ 同时<strong>阻塞队列未满</strong>，则将任务入队列，而不添加新的线程。</li>\n<li>如果没有空闲的线程执行该任务且阻塞队列已满同时池中的线程数小于 <code>maximumPoolSize</code>​，则创建新的线程执行任务。</li>\n<li>如果没有空闲的线程执行该任务且阻塞队列已满同时池中的线程数等于 <code>maximumPoolSize</code>​，则根据构造函数中的 <code>handler</code>​ 指定的拒绝策略来拒绝新的任务。</li>\n</ol>\n</li>\n<li>\n<p>​<code>threadFactory</code>​：指定创建线程的工厂</p>\n</li>\n</ul>\n<h3 id=\"四种线程池拒绝策略\">四种线程池拒绝策略</h3>\n<h4 id=\"ThreadPoolExecutor-AbortPolicy-​\"><code>ThreadPoolExecutor.AbortPolicy()</code>​</h4>\n<p>抛出 <code>RejectedExecutionException</code>​</p>\n<h4 id=\"ThreadPoolExecutor-CallerRunsPolicy-​\"><code>ThreadPoolExecutor.CallerRunsPolicy()</code>​</h4>\n<p>由向线程池提交任务的线程来执行该任务</p>\n<h4 id=\"ThreadPoolExecutor-DiscardOldestPolicy-​\"><code>ThreadPoolExecutor.DiscardOldestPolicy()</code>​</h4>\n<p>抛弃最旧的任务（最先提交而没有得到执行的任务）</p>\n<h4 id=\"ThreadPoolExecutor-DiscardPolicy-​\"><code>ThreadPoolExecutor.DiscardPolicy()</code>​</h4>\n<p>抛弃当前的任务</p>\n<h3 id=\"阻塞队列\">阻塞队列</h3>\n<ul>\n<li>​<code>ArrayBlockingQueue</code>​：基于数组的阻塞队列实现，在ArrayBlockingQueue内部，维护了一个定长的数组，以便缓存队列中的数据对象，其内部没实现读写分离，也就意味着生产和消费者不能完全并行。长度是需要定义的，可以指定先进先出或者先进后出，因为长度是需要定义的，所以也叫有界队列，在很多场合非常适合使用。</li>\n<li>​<code>LinkedBlockingQueue</code>​：基于链表的阻塞队列，同ArrayBlockingQueue类似，其内部也维持着一个数据缓冲队列（该队列由一个链表构成），LinkedBlockingQueue之所以能够高效地处理并发数据，是因为其内部实现采用分离锁（读写分离两个锁），从而实现生产者和消费者操作完全并行运行。需要注意一下，它是一个无界队列。</li>\n<li>​<code>SynchronousQueue</code>​：一种没有缓冲的队列，生产者产生的数据直接会被消费者获取并且立刻消费。</li>\n<li>​<code>PriorityBlockingQueue</code>​：基于优先级别的阻塞队列（优先级的判断通过构造函数传入的Compator对象来决定，也就是说传入队列的对象必须实现Comparable接口），在实现PriorityBlockingQueue时，内部控制线程同步的锁采用的是公平锁，需要注意的是它也是一个无界的队列。</li>\n<li>​<code>DelayQueue</code>​：带有延迟时间的Queue，其中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素。DelayQueue中的元素必须先实现Delayed接口，DelayQueue是一个没有大小限制的队列，应用场景很多，比如对缓存超时的数据进行移除、任务超时处理、空闲连接的关闭等等</li>\n</ul>\n<p>​<img src=\"/assets/image-20230519215732-zz9jpqo.png\" alt=\"image\">​</p>\n<h3 id=\"四种常用线程池（ExecutorService的实现类）\">四种常用线程池（ExecutorService的实现类）</h3>\n<p>ThreadPoolExecutor 构造函数的参数很多，使用起来很麻烦，为了方便的创建线程池，JavaSE 中又定义了 Executors 类，Eexcutors 类提供了四个创建线程池的方法，分别如下</p>\n<h4 id=\"newCachedThreadPool\">newCachedThreadPool</h4>\n<p>该方法创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。<br>\n此类型线程池特点是：</p>\n<ol>\n<li>.工作线程的创建数量几乎没有限制(其实也有限制的,数目为 Interger. MAX_VALUE)</li>\n<li>空闲的工作线程会自动销毁，有新任务会重新创建</li>\n<li>在使用 CachedThreadPool 时，一定要注意控制任务的数量，否则，由于大量线程同时运行，很有会造成系统瘫痪。</li>\n</ol>\n<h4 id=\"newFixedThreadPool\">newFixedThreadPool</h4>\n<p>该方法创建一个指定工作线程数量的线程池。每当提交一个任务就创建一个工作线程，如果工作线程数量达到线程池初始的最大数，则将提交的任务存入到池队列中。<br>\n优点：具有线程池提高程序效率和节省创建线程时所耗的开销。<br>\n缺点：在线程池空闲时，即线程池中没有可运行任务时，它不会释放工作线程，还会占用一定的系统资源。</p>\n<h4 id=\"newSingleThreadExecutor\">newSingleThreadExecutor</h4>\n<p>该方法创建一个单线程化的 Executor，即只创建唯一的工作者线程来执行任务，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO,优先级)执行。如果这个线程异常结束，会有另一个取代它，保证顺序执行。<br>\n单工作线程最大的特点是可保证顺序地执行各个任务，并且在任意给定的时间不会有多个线程是活动的。</p>\n<h4 id=\"newScheduleThreadPool\">newScheduleThreadPool</h4>\n<p>该方法创建一个定长的线程池，而且支持定时的以及周期性的任务执行，支持定时及周期性任务执行。</p>\n<blockquote>\n<p>FixedThreadPool、SingleThreadPool：使用的是无界队列（LinkedBlockingQueue），当任务堆积很多时，会占用大量内存，最终导致OOM。ChachedTheadPool：可以无限创建线程（Integer.MAX_VALUE），任务过多时会导致创建线程达到操作系统上线或者发生OOM。ScheduledThreadPool、SingleThreadScheduledPool：使用的是DelayedWorkQueue队列，实质上也是一种无界队列，会导致OOM。</p>\n</blockquote>\n<h2 id=\"问题\">问题</h2>\n<h3 id=\"为什么java的线程池当核心线程满了以后-先往blockingQueue中存任务-queue满了以后\">为什么java的线程池当核心线程满了以后,先往blockingQueue中存任务,queue满了以后</h3>\n<p>起到一个缓冲的作用。最大线程数这个参数更像是无奈之举，在最坏的情况下做最后的努力，去新建线程去帮助消化任务。但是这种情况可能存在丢任务的情况。</p>\n","excerpt":"","more":"<h1>线程池</h1>\n<h2 id=\"线程池\">线程池</h2>\n<ol>\n<li>Executor 接口：<br>\n声明了 execute(Runnable runnable)方法，执行任务代码</li>\n<li>ExecutorService 接口：<br>\n继承 Executor 接口，声明方法：submit、invokeAll、invokeAny 以及 shutDown 等</li>\n<li>AbstractExecutorService 抽象类：<br>\n实现 ExecutorService 接口，基本实现 ExecutorService 中声明的所有方法</li>\n<li>ScheduledExecutorService 接口：<br>\n继承 ExecutorService 接口，声明定时执行任务方法</li>\n<li>ThreadPoolExecutor 类：<br>\n继承类 AbstractExecutorService，实现 execute、submit、shutdown、shutdownNow 方法</li>\n<li>ScheduledThreadPoolExecutor 类：<br>\n继承 ThreadPoolExecutor 类，实现 ScheduledExecutorService 接口并实现其中的方法</li>\n<li>Executors 类：<br>\n提供快速创建线程池的方法</li>\n</ol>\n<h2 id=\"Executor-框架与线程池\">Executor 框架与线程池</h2>\n<p>Executor 框架包括：线程池，Executor，Executors，ExecutorService，CompletionService，Future，Callable 等</p>\n<p>Executor 接口中之定义了一个方法 execute（Runnable command），该方法接收一个 Runable 实例，它用来执行一个任务</p>\n<p>ExecutorService 接口继承自 Executor 接口，它提供了更丰富的实现多线程的方法，比如</p>\n<ol>\n<li>submit()方法可以返回Future对象，可以调用isDone()方法查询Future是否已完成，当任务完成时，它具有一个结果，可以通过get()方法获取到该结果，Future提供了cancel()方法用来取消执行pending中的任务。</li>\n<li>shutdown()方法允许之前已经提交的任务执行完毕之后再挂起关闭，shutdownNow()方法则阻止正在等待的任务启动，并尝试停止之前正在执行的任务。</li>\n</ol>\n<p><strong>多线程的缺点：</strong></p>\n<ul>\n<li>处理任务的线程创建和销毁都非常耗时并消耗资源。</li>\n<li>多线程之间的切换也会非常耗时并消耗资源。<br>\n<strong>解决方法：采用线程池</strong></li>\n<li>使用时线程已存在，消除了线程创建的时耗</li>\n<li>通过设置线程数目，防止资源不足</li>\n</ul>\n<h3 id=\"ThreadPoolExecutor-的全参构造函数参数\">ThreadPoolExecutor 的全参构造函数参数</h3>\n<p>在 Java 中创建线程池常用的类是 ThreadPoolExecutor，该类的全参构造函数如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">ThreadPoolExecutor</span><span class=\"params\">(<span class=\"type\">int</span> corePoolSize,</span></span><br><span class=\"line\"><span class=\"params\">                          <span class=\"type\">int</span> maximumPoolSize,</span></span><br><span class=\"line\"><span class=\"params\">                          <span class=\"type\">long</span> keepAliveTime,</span></span><br><span class=\"line\"><span class=\"params\">                          TimeUnit unit,</span></span><br><span class=\"line\"><span class=\"params\">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class=\"line\"><span class=\"params\">                          ThreadFactory threadFactory,</span></span><br><span class=\"line\"><span class=\"params\">                          RejectedExecutionHandler handler)</span> &#123;</span><br></pre></td></tr></table></figure>\n<p>参数介绍：</p>\n<ul>\n<li>\n<p>​<code>corePoolSize</code>​：线程池中核心线程数的最大值</p>\n</li>\n<li>\n<p>​<code>maximumPoolSize</code>​：线程池中能拥有最多线程数</p>\n</li>\n<li>\n<p>​<code>workQueue</code>​：用于缓存任务的阻塞队列，对于不同的应用场景我们可能会采取不同的排队策略，这就需要不同类型的阻塞队列，在线程池中常用的阻塞队列有以下 2 种：</p>\n<ul>\n<li>​<code>SynchronousQueue&lt;Runnable&gt;</code>​：此队列中不缓存任何一个任务。向线程池提交任务时，如果没有空闲线程来运行任务，则入列操作会阻塞。当有线程来获取任务时，出列操作会唤醒执行入列操作的线程。从这个特性来看，<code>SynchronousQueue</code>​ 是一个无界队列，因此当使用 <code>SynchronousQueue</code>​ 作为线程池的阻塞队列时，参数 <code>maximumPoolSizes</code>​ 没有任何作用。</li>\n<li>​<code>LinkedBlockingQueue&lt;Runnable&gt;</code>​：顾名思义是用链表实现的队列，可以是有界的，也可以是无界的，但在 <code>Executors</code>​ 中默认使用无界的。</li>\n</ul>\n</li>\n<li>\n<p>​<code>keepAliveTime</code>​：表示空闲线程的存活时间。</p>\n</li>\n<li>\n<p>​<code>unit</code>​：表示 <code>keepAliveTime</code>​ 的单位。</p>\n</li>\n<li>\n<p>​<code>handler</code>​：表示当 <code>workQueue</code>​ 已满，且池中的线程数达到 <code>maximumPoolSize</code>​ 时，线程池拒绝添加新任务时采取的策略。一般可以采取以下四种取值。</p>\n<ol>\n<li>如果没有空闲的线程执行该任务且当前运行的线程数少于 <code>corePoolSize</code>​，则添加新的线程执行该任务。</li>\n<li>如果没有空闲的线程执行该任务且当前的线程数等于 <code>corePoolSize</code>​ 同时<strong>阻塞队列未满</strong>，则将任务入队列，而不添加新的线程。</li>\n<li>如果没有空闲的线程执行该任务且阻塞队列已满同时池中的线程数小于 <code>maximumPoolSize</code>​，则创建新的线程执行任务。</li>\n<li>如果没有空闲的线程执行该任务且阻塞队列已满同时池中的线程数等于 <code>maximumPoolSize</code>​，则根据构造函数中的 <code>handler</code>​ 指定的拒绝策略来拒绝新的任务。</li>\n</ol>\n</li>\n<li>\n<p>​<code>threadFactory</code>​：指定创建线程的工厂</p>\n</li>\n</ul>\n<h3 id=\"四种线程池拒绝策略\">四种线程池拒绝策略</h3>\n<h4 id=\"ThreadPoolExecutor-AbortPolicy-​\"><code>ThreadPoolExecutor.AbortPolicy()</code>​</h4>\n<p>抛出 <code>RejectedExecutionException</code>​</p>\n<h4 id=\"ThreadPoolExecutor-CallerRunsPolicy-​\"><code>ThreadPoolExecutor.CallerRunsPolicy()</code>​</h4>\n<p>由向线程池提交任务的线程来执行该任务</p>\n<h4 id=\"ThreadPoolExecutor-DiscardOldestPolicy-​\"><code>ThreadPoolExecutor.DiscardOldestPolicy()</code>​</h4>\n<p>抛弃最旧的任务（最先提交而没有得到执行的任务）</p>\n<h4 id=\"ThreadPoolExecutor-DiscardPolicy-​\"><code>ThreadPoolExecutor.DiscardPolicy()</code>​</h4>\n<p>抛弃当前的任务</p>\n<h3 id=\"阻塞队列\">阻塞队列</h3>\n<ul>\n<li>​<code>ArrayBlockingQueue</code>​：基于数组的阻塞队列实现，在ArrayBlockingQueue内部，维护了一个定长的数组，以便缓存队列中的数据对象，其内部没实现读写分离，也就意味着生产和消费者不能完全并行。长度是需要定义的，可以指定先进先出或者先进后出，因为长度是需要定义的，所以也叫有界队列，在很多场合非常适合使用。</li>\n<li>​<code>LinkedBlockingQueue</code>​：基于链表的阻塞队列，同ArrayBlockingQueue类似，其内部也维持着一个数据缓冲队列（该队列由一个链表构成），LinkedBlockingQueue之所以能够高效地处理并发数据，是因为其内部实现采用分离锁（读写分离两个锁），从而实现生产者和消费者操作完全并行运行。需要注意一下，它是一个无界队列。</li>\n<li>​<code>SynchronousQueue</code>​：一种没有缓冲的队列，生产者产生的数据直接会被消费者获取并且立刻消费。</li>\n<li>​<code>PriorityBlockingQueue</code>​：基于优先级别的阻塞队列（优先级的判断通过构造函数传入的Compator对象来决定，也就是说传入队列的对象必须实现Comparable接口），在实现PriorityBlockingQueue时，内部控制线程同步的锁采用的是公平锁，需要注意的是它也是一个无界的队列。</li>\n<li>​<code>DelayQueue</code>​：带有延迟时间的Queue，其中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素。DelayQueue中的元素必须先实现Delayed接口，DelayQueue是一个没有大小限制的队列，应用场景很多，比如对缓存超时的数据进行移除、任务超时处理、空闲连接的关闭等等</li>\n</ul>\n<p>​<img src=\"/assets/image-20230519215732-zz9jpqo.png\" alt=\"image\">​</p>\n<h3 id=\"四种常用线程池（ExecutorService的实现类）\">四种常用线程池（ExecutorService的实现类）</h3>\n<p>ThreadPoolExecutor 构造函数的参数很多，使用起来很麻烦，为了方便的创建线程池，JavaSE 中又定义了 Executors 类，Eexcutors 类提供了四个创建线程池的方法，分别如下</p>\n<h4 id=\"newCachedThreadPool\">newCachedThreadPool</h4>\n<p>该方法创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。<br>\n此类型线程池特点是：</p>\n<ol>\n<li>.工作线程的创建数量几乎没有限制(其实也有限制的,数目为 Interger. MAX_VALUE)</li>\n<li>空闲的工作线程会自动销毁，有新任务会重新创建</li>\n<li>在使用 CachedThreadPool 时，一定要注意控制任务的数量，否则，由于大量线程同时运行，很有会造成系统瘫痪。</li>\n</ol>\n<h4 id=\"newFixedThreadPool\">newFixedThreadPool</h4>\n<p>该方法创建一个指定工作线程数量的线程池。每当提交一个任务就创建一个工作线程，如果工作线程数量达到线程池初始的最大数，则将提交的任务存入到池队列中。<br>\n优点：具有线程池提高程序效率和节省创建线程时所耗的开销。<br>\n缺点：在线程池空闲时，即线程池中没有可运行任务时，它不会释放工作线程，还会占用一定的系统资源。</p>\n<h4 id=\"newSingleThreadExecutor\">newSingleThreadExecutor</h4>\n<p>该方法创建一个单线程化的 Executor，即只创建唯一的工作者线程来执行任务，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO,优先级)执行。如果这个线程异常结束，会有另一个取代它，保证顺序执行。<br>\n单工作线程最大的特点是可保证顺序地执行各个任务，并且在任意给定的时间不会有多个线程是活动的。</p>\n<h4 id=\"newScheduleThreadPool\">newScheduleThreadPool</h4>\n<p>该方法创建一个定长的线程池，而且支持定时的以及周期性的任务执行，支持定时及周期性任务执行。</p>\n<blockquote>\n<p>FixedThreadPool、SingleThreadPool：使用的是无界队列（LinkedBlockingQueue），当任务堆积很多时，会占用大量内存，最终导致OOM。ChachedTheadPool：可以无限创建线程（Integer.MAX_VALUE），任务过多时会导致创建线程达到操作系统上线或者发生OOM。ScheduledThreadPool、SingleThreadScheduledPool：使用的是DelayedWorkQueue队列，实质上也是一种无界队列，会导致OOM。</p>\n</blockquote>\n<h2 id=\"问题\">问题</h2>\n<h3 id=\"为什么java的线程池当核心线程满了以后-先往blockingQueue中存任务-queue满了以后\">为什么java的线程池当核心线程满了以后,先往blockingQueue中存任务,queue满了以后</h3>\n<p>起到一个缓冲的作用。最大线程数这个参数更像是无奈之举，在最坏的情况下做最后的努力，去新建线程去帮助消化任务。但是这种情况可能存在丢任务的情况。</p>\n"},{"title":"并发处理","date":"2023-05-14T14:53:28.000Z","lastmod":"2023-05-14T14:33:08.000Z","_content":"\n# 并发处理 \n\n---\n\n## 多线程特性\n\n- 原子性\n  - 一个或多个操作要么全部执行并且执行过程中不会被任何因素打断，要么就不执行。\n- 可见性\n  - 当多个线程同时访问一个变量时，一个线程修改了这个变量，其他线程能够立即看见修改的值。单线程不存在可见性问题。\n- 有序型\n  - 程序的执行按照代码的先后顺序执行\n\n## 对象的发布和逸出\n\n### 发布\n\n> \"发布( Publish)\"一个对象的意思是指,使对象能够在当前作用域之外的代码中使用\n\n1. 一个指向该对象的引用保存到其他代码可以访问的地方\n\n```java\npublic class Person(){\n    private String name;\n    private int age;\n}\n\npublic class Record{\n    Person p;\n}\n\n```\n\n2. 在某一个非私有的方法中返回该引用\n\n```java\npublic class Person(){\n    private String name;\n    private int age;\n\n    public Person get(){\n        return new Person();\n    }\n}\n```\n\n3. 将引用传递到其他类的方法中\n\n```java\npublic class Person(){\n    private String name;\n    private int age;\n}\n\npublic class Record{\n    private void getPersonMessage(Person p){\n        .....\n    }\n}\n```\n\n### 逸出\n\n> 当某个不应该发布的对象被发布时,这种情况就被称为逸出( Escape).\n\n1. 内部的可变状态逸出\n\n```java\nclass UnsafeStates{\n    private String[] states = {\"AK\",\"AL\",...};\n    public String[] getStates(){\n        return states;\n    }\n}\n//数组states本事私有的变量，但是以public公有的方式发布出去，导致states已经逸出了它所在的作用域，任何调用者都能修改这个数组的内容\n```\n\n2. 隐式地使用this引用导致逸出\n\n```java\npublic class ThisEscape{\n    public ThisEscape(EventSource source){\n        source.registerListener(\n            new EventListener(){\n                public void onEvent(Event e){\n                    dosomething(e);\n                }\n            })\n        //在这里count初始化为1\n        count = 1;\n    }\n}\n//当ThisEscape发布EventListener时，也隐含地发布了ThisEscape实例本身。因为在这个内部类的实例中包含了对ThisEscape实例的隐含引用。\n//this逸出会导致ThisEscape也发布出去，也就是ThisEscape还没有构建完成就发布出去，也就是count=1;这一句还没执行就发布了ThisEscape对象，如果要使用count时,很有可能会出现对象不一致的状态\n```\n\n　　**使用工厂方法来防止this引用在构造函数过程中逸出**\n\n```java\npublic class SafeListener{\n    private final EventListener listener;\n    private SafeListener(){\n        listener = new EventListener(){\n            public void onEvent(Event e){\n                dosomething(e);\n            }\n        };\n    }\n    public static SafeListener newInstance(EventSource source){\n        SafeListener safe = new SafeListener();\n        source.registerListener(safe.listener);\n        return safe;\n    }\n}\n//保证在对象为构造完成之前，是不会发布该对象\n```\n\n## 线程封闭\n\n1. Ad-hoc线程封闭。\n\n> 维护线程封闭性的职责完全由程序实现承担，可用性不高。\n\n　　Ad-hoc 线程封闭下的一个特例适用于 volatile 变量。 只要确保 volatile 变量仅从单个线程写入，就可以安全地对共享 volatile 变量执读 - 改 - 写操作。\n\n2. 栈封闭。\n\n　　局部变量，无并发问题，在项目中使用最多，简单说就是局部变量，方法的变量都拷贝到线程的堆栈中，只有这个线程能访问到。尽量少使用全局变量（变量不是常量）\n\n3. ThreadLocal类。\n\n## 原子类\n\n　　Java 的 java.util.concurrent.atomic 包里面提供了很多可以进行原子操作的类，分为以下四类：\n\n- 原子更新基本类型：AtomicInteger、AtomicBoolean、AtomicLong\n- 原子更新数组：AtomicIntegerArray、AtomicLongArray\n- 原子更新引用：AtomicReference、AtomicStampedReference 等\n- 原子更新属性：AtomicIntegerFieldUpdater、AtomicLongFieldUpdater\n\n　　提供这些原子类的目的就是为了解决基本类型操作的非原子性导致在多线程并发情况下引发的问题。\n\n### 非原子问题演示\n\n　　i++并不是原子操作\n\n```java\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class AtomicClass {\n    static int n = 0;\n    public static void main(String[] args) throws InterruptedException {\n        int j = 0;\n        while(j<100){\n            n = 0;\n            Thread t1 = new Thread(){\n                public void run(){\n                    for(int i=0; i<1000; i++){\n                        n++;\n                    }\n                }\n            };\n            Thread t2 = new Thread(){\n                public void run(){\n                    for(int i=0; i<1000; i++){\n                        n++;\n                    }\n                }\n            };\n            t1.start();\n            t2.start();\n            t1.join();\n            t2.join();\n            System.out.println(\"n的最终值是：\"+n);\n            j++;\n        }\n\n    }\n}\n```\n\n　　结果不一定全是 2000\n\n### 非原子问题的原子解决\n\n```java\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class AtomicClass {\n    static AtomicInteger n;\n    public static void main(String[] args) throws InterruptedException {\n        int j = 0;\n        while(j<100){\n            n = new AtomicInteger(0);\n            Thread t1 = new Thread(){\n                public void run(){\n                    for(int i=0; i<1000; i++){\n                        n.getAndIncrement();\n                    }\n                }\n            };\n            Thread t2 = new Thread(){\n                public void run(){\n                    for(int i=0; i<1000; i++){\n                        n.getAndIncrement();\n                    }\n                }\n            };\n            t1.start();\n            t2.start();\n            t1.join();\n            t2.join();\n            System.out.println(\"n的最终值是：\"+n);\n            j++;\n        }\n\n    }\n}\n```\n\n　　**原理**\n\n![1-10.png](/assets/net-img-1582875462202-61de3608-d606-44f6-b8d0-c82da3a7acd8-20221030135541-a1152vd.png)\n\n### CAS 的 ABA 问题\n\n　　当前内存的值一开始是 A，被另外一个线程先改为 B 然后再改为 A，那么当前线程访问的时候发现是 A，则认为它没有被其他线程访问过。在某些场景下这样是存在错误风险的。如下图：\n\n![1-11.png](/assets/net-img-1582875470139-ea71ffbe-3cbd-44d8-8560-1e72b3a4bab4-20221030135541-hkuw6hs.png)\n\n### AtomicStampedReference 解决 ABA 问题\n\n```\nAtomicStampedReference(初始值，时间戳)：构造函数设置初始值和时间戳\ngetStamp：获取时间戳\ngetReference：获取预期值\ncompareAndSet(预期值，更新值，预期时间戳，更新时间戳)：实现CAS时间戳和预期值对比\n```\n\n```java\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.atomic.AtomicStampedReference;\n\npublic class AtomicClass {\n    static AtomicStampedReference<Integer> n;\n    public static void main(String[] args) throws InterruptedException {\n        int j = 0;\n        while(j<100){\n            n = new AtomicStampedReference<Integer>(0,0);\n            Thread t1 = new Thread(){\n                public void run(){\n                    for(int i=0; i<1000; i++){\n                        int stamp;\n                        Integer reference;\n                        do{\n                            stamp = n.getStamp();\n                            reference = n.getReference();\n                        } while(!n.compareAndSet(reference, reference+1, stamp, stamp+1));\n                    }\n                }\n            };\n            Thread t2 = new Thread(){\n                public void run(){\n                    for(int i=0; i<1000; i++){\n                        int stamp;\n                        Integer reference;\n                        do{\n                            stamp = n.getStamp();\n                            reference = n.getReference();\n\n                        } while(!n.compareAndSet(reference, reference+1, stamp, stamp+1));\n                    }\n                }\n            };\n            t1.start();\n            t2.start();\n            t1.join();\n            t2.join();\n            System.out.println(\"n的最终值是：\"+n.getReference());\n            j++;\n        }\n\n    }\n}\n```\n\n　　**注意：采用 AtomicStampedReference 会降低性能，慎用。**\n\n　　‍\n","source":"_posts/java/thread/并发处理.md","raw":"---\ntitle: 并发处理 \ndate: 2023-05-14T22:53:28Z\nlastmod: 2023-05-14T22:33:08Z\n---\n\n# 并发处理 \n\n---\n\n## 多线程特性\n\n- 原子性\n  - 一个或多个操作要么全部执行并且执行过程中不会被任何因素打断，要么就不执行。\n- 可见性\n  - 当多个线程同时访问一个变量时，一个线程修改了这个变量，其他线程能够立即看见修改的值。单线程不存在可见性问题。\n- 有序型\n  - 程序的执行按照代码的先后顺序执行\n\n## 对象的发布和逸出\n\n### 发布\n\n> \"发布( Publish)\"一个对象的意思是指,使对象能够在当前作用域之外的代码中使用\n\n1. 一个指向该对象的引用保存到其他代码可以访问的地方\n\n```java\npublic class Person(){\n    private String name;\n    private int age;\n}\n\npublic class Record{\n    Person p;\n}\n\n```\n\n2. 在某一个非私有的方法中返回该引用\n\n```java\npublic class Person(){\n    private String name;\n    private int age;\n\n    public Person get(){\n        return new Person();\n    }\n}\n```\n\n3. 将引用传递到其他类的方法中\n\n```java\npublic class Person(){\n    private String name;\n    private int age;\n}\n\npublic class Record{\n    private void getPersonMessage(Person p){\n        .....\n    }\n}\n```\n\n### 逸出\n\n> 当某个不应该发布的对象被发布时,这种情况就被称为逸出( Escape).\n\n1. 内部的可变状态逸出\n\n```java\nclass UnsafeStates{\n    private String[] states = {\"AK\",\"AL\",...};\n    public String[] getStates(){\n        return states;\n    }\n}\n//数组states本事私有的变量，但是以public公有的方式发布出去，导致states已经逸出了它所在的作用域，任何调用者都能修改这个数组的内容\n```\n\n2. 隐式地使用this引用导致逸出\n\n```java\npublic class ThisEscape{\n    public ThisEscape(EventSource source){\n        source.registerListener(\n            new EventListener(){\n                public void onEvent(Event e){\n                    dosomething(e);\n                }\n            })\n        //在这里count初始化为1\n        count = 1;\n    }\n}\n//当ThisEscape发布EventListener时，也隐含地发布了ThisEscape实例本身。因为在这个内部类的实例中包含了对ThisEscape实例的隐含引用。\n//this逸出会导致ThisEscape也发布出去，也就是ThisEscape还没有构建完成就发布出去，也就是count=1;这一句还没执行就发布了ThisEscape对象，如果要使用count时,很有可能会出现对象不一致的状态\n```\n\n　　**使用工厂方法来防止this引用在构造函数过程中逸出**\n\n```java\npublic class SafeListener{\n    private final EventListener listener;\n    private SafeListener(){\n        listener = new EventListener(){\n            public void onEvent(Event e){\n                dosomething(e);\n            }\n        };\n    }\n    public static SafeListener newInstance(EventSource source){\n        SafeListener safe = new SafeListener();\n        source.registerListener(safe.listener);\n        return safe;\n    }\n}\n//保证在对象为构造完成之前，是不会发布该对象\n```\n\n## 线程封闭\n\n1. Ad-hoc线程封闭。\n\n> 维护线程封闭性的职责完全由程序实现承担，可用性不高。\n\n　　Ad-hoc 线程封闭下的一个特例适用于 volatile 变量。 只要确保 volatile 变量仅从单个线程写入，就可以安全地对共享 volatile 变量执读 - 改 - 写操作。\n\n2. 栈封闭。\n\n　　局部变量，无并发问题，在项目中使用最多，简单说就是局部变量，方法的变量都拷贝到线程的堆栈中，只有这个线程能访问到。尽量少使用全局变量（变量不是常量）\n\n3. ThreadLocal类。\n\n## 原子类\n\n　　Java 的 java.util.concurrent.atomic 包里面提供了很多可以进行原子操作的类，分为以下四类：\n\n- 原子更新基本类型：AtomicInteger、AtomicBoolean、AtomicLong\n- 原子更新数组：AtomicIntegerArray、AtomicLongArray\n- 原子更新引用：AtomicReference、AtomicStampedReference 等\n- 原子更新属性：AtomicIntegerFieldUpdater、AtomicLongFieldUpdater\n\n　　提供这些原子类的目的就是为了解决基本类型操作的非原子性导致在多线程并发情况下引发的问题。\n\n### 非原子问题演示\n\n　　i++并不是原子操作\n\n```java\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class AtomicClass {\n    static int n = 0;\n    public static void main(String[] args) throws InterruptedException {\n        int j = 0;\n        while(j<100){\n            n = 0;\n            Thread t1 = new Thread(){\n                public void run(){\n                    for(int i=0; i<1000; i++){\n                        n++;\n                    }\n                }\n            };\n            Thread t2 = new Thread(){\n                public void run(){\n                    for(int i=0; i<1000; i++){\n                        n++;\n                    }\n                }\n            };\n            t1.start();\n            t2.start();\n            t1.join();\n            t2.join();\n            System.out.println(\"n的最终值是：\"+n);\n            j++;\n        }\n\n    }\n}\n```\n\n　　结果不一定全是 2000\n\n### 非原子问题的原子解决\n\n```java\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class AtomicClass {\n    static AtomicInteger n;\n    public static void main(String[] args) throws InterruptedException {\n        int j = 0;\n        while(j<100){\n            n = new AtomicInteger(0);\n            Thread t1 = new Thread(){\n                public void run(){\n                    for(int i=0; i<1000; i++){\n                        n.getAndIncrement();\n                    }\n                }\n            };\n            Thread t2 = new Thread(){\n                public void run(){\n                    for(int i=0; i<1000; i++){\n                        n.getAndIncrement();\n                    }\n                }\n            };\n            t1.start();\n            t2.start();\n            t1.join();\n            t2.join();\n            System.out.println(\"n的最终值是：\"+n);\n            j++;\n        }\n\n    }\n}\n```\n\n　　**原理**\n\n![1-10.png](/assets/net-img-1582875462202-61de3608-d606-44f6-b8d0-c82da3a7acd8-20221030135541-a1152vd.png)\n\n### CAS 的 ABA 问题\n\n　　当前内存的值一开始是 A，被另外一个线程先改为 B 然后再改为 A，那么当前线程访问的时候发现是 A，则认为它没有被其他线程访问过。在某些场景下这样是存在错误风险的。如下图：\n\n![1-11.png](/assets/net-img-1582875470139-ea71ffbe-3cbd-44d8-8560-1e72b3a4bab4-20221030135541-hkuw6hs.png)\n\n### AtomicStampedReference 解决 ABA 问题\n\n```\nAtomicStampedReference(初始值，时间戳)：构造函数设置初始值和时间戳\ngetStamp：获取时间戳\ngetReference：获取预期值\ncompareAndSet(预期值，更新值，预期时间戳，更新时间戳)：实现CAS时间戳和预期值对比\n```\n\n```java\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.atomic.AtomicStampedReference;\n\npublic class AtomicClass {\n    static AtomicStampedReference<Integer> n;\n    public static void main(String[] args) throws InterruptedException {\n        int j = 0;\n        while(j<100){\n            n = new AtomicStampedReference<Integer>(0,0);\n            Thread t1 = new Thread(){\n                public void run(){\n                    for(int i=0; i<1000; i++){\n                        int stamp;\n                        Integer reference;\n                        do{\n                            stamp = n.getStamp();\n                            reference = n.getReference();\n                        } while(!n.compareAndSet(reference, reference+1, stamp, stamp+1));\n                    }\n                }\n            };\n            Thread t2 = new Thread(){\n                public void run(){\n                    for(int i=0; i<1000; i++){\n                        int stamp;\n                        Integer reference;\n                        do{\n                            stamp = n.getStamp();\n                            reference = n.getReference();\n\n                        } while(!n.compareAndSet(reference, reference+1, stamp, stamp+1));\n                    }\n                }\n            };\n            t1.start();\n            t2.start();\n            t1.join();\n            t2.join();\n            System.out.println(\"n的最终值是：\"+n.getReference());\n            j++;\n        }\n\n    }\n}\n```\n\n　　**注意：采用 AtomicStampedReference 会降低性能，慎用。**\n\n　　‍\n","slug":"java-thread-并发处理","published":1,"updated":"2025-04-28T08:41:48.395Z","_id":"cm9s3f40o0035bfg4bcv4fem0","comments":1,"layout":"post","photos":[],"content":"<h1>并发处理</h1>\n<hr>\n<h2 id=\"多线程特性\">多线程特性</h2>\n<ul>\n<li>原子性\n<ul>\n<li>一个或多个操作要么全部执行并且执行过程中不会被任何因素打断，要么就不执行。</li>\n</ul>\n</li>\n<li>可见性\n<ul>\n<li>当多个线程同时访问一个变量时，一个线程修改了这个变量，其他线程能够立即看见修改的值。单线程不存在可见性问题。</li>\n</ul>\n</li>\n<li>有序型\n<ul>\n<li>程序的执行按照代码的先后顺序执行</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"对象的发布和逸出\">对象的发布和逸出</h2>\n<h3 id=\"发布\">发布</h3>\n<blockquote>\n<p>&quot;发布( Publish)&quot;一个对象的意思是指,使对象能够在当前作用域之外的代码中使用</p>\n</blockquote>\n<ol>\n<li>一个指向该对象的引用保存到其他代码可以访问的地方</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Person</span>()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> age;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Record</span>&#123;</span><br><span class=\"line\">    Person p;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>在某一个非私有的方法中返回该引用</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Person</span>()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> age;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Person <span class=\"title function_\">get</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Person</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>将引用传递到其他类的方法中</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Person</span>()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> age;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Record</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">getPersonMessage</span><span class=\"params\">(Person p)</span>&#123;</span><br><span class=\"line\">        .....</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"逸出\">逸出</h3>\n<blockquote>\n<p>当某个不应该发布的对象被发布时,这种情况就被称为逸出( Escape).</p>\n</blockquote>\n<ol>\n<li>内部的可变状态逸出</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">UnsafeStates</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String[] states = &#123;<span class=\"string\">&quot;AK&quot;</span>,<span class=\"string\">&quot;AL&quot;</span>,...&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String[] getStates()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> states;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//数组states本事私有的变量，但是以public公有的方式发布出去，导致states已经逸出了它所在的作用域，任何调用者都能修改这个数组的内容</span></span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>隐式地使用this引用导致逸出</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ThisEscape</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">ThisEscape</span><span class=\"params\">(EventSource source)</span>&#123;</span><br><span class=\"line\">        source.registerListener(</span><br><span class=\"line\">            <span class=\"keyword\">new</span> <span class=\"title class_\">EventListener</span>()&#123;</span><br><span class=\"line\">                <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onEvent</span><span class=\"params\">(Event e)</span>&#123;</span><br><span class=\"line\">                    dosomething(e);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        <span class=\"comment\">//在这里count初始化为1</span></span><br><span class=\"line\">        count = <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//当ThisEscape发布EventListener时，也隐含地发布了ThisEscape实例本身。因为在这个内部类的实例中包含了对ThisEscape实例的隐含引用。</span></span><br><span class=\"line\"><span class=\"comment\">//this逸出会导致ThisEscape也发布出去，也就是ThisEscape还没有构建完成就发布出去，也就是count=1;这一句还没执行就发布了ThisEscape对象，如果要使用count时,很有可能会出现对象不一致的状态</span></span><br></pre></td></tr></table></figure>\n<p><strong>使用工厂方法来防止this引用在构造函数过程中逸出</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SafeListener</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> EventListener listener;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">SafeListener</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        listener = <span class=\"keyword\">new</span> <span class=\"title class_\">EventListener</span>()&#123;</span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onEvent</span><span class=\"params\">(Event e)</span>&#123;</span><br><span class=\"line\">                dosomething(e);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> SafeListener <span class=\"title function_\">newInstance</span><span class=\"params\">(EventSource source)</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">SafeListener</span> <span class=\"variable\">safe</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SafeListener</span>();</span><br><span class=\"line\">        source.registerListener(safe.listener);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> safe;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//保证在对象为构造完成之前，是不会发布该对象</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"线程封闭\">线程封闭</h2>\n<ol>\n<li>Ad-hoc线程封闭。</li>\n</ol>\n<blockquote>\n<p>维护线程封闭性的职责完全由程序实现承担，可用性不高。</p>\n</blockquote>\n<p>Ad-hoc 线程封闭下的一个特例适用于 volatile 变量。 只要确保 volatile 变量仅从单个线程写入，就可以安全地对共享 volatile 变量执读 - 改 - 写操作。</p>\n<ol start=\"2\">\n<li>栈封闭。</li>\n</ol>\n<p>局部变量，无并发问题，在项目中使用最多，简单说就是局部变量，方法的变量都拷贝到线程的堆栈中，只有这个线程能访问到。尽量少使用全局变量（变量不是常量）</p>\n<ol start=\"3\">\n<li>ThreadLocal类。</li>\n</ol>\n<h2 id=\"原子类\">原子类</h2>\n<p>Java 的 java.util.concurrent.atomic 包里面提供了很多可以进行原子操作的类，分为以下四类：</p>\n<ul>\n<li>原子更新基本类型：AtomicInteger、AtomicBoolean、AtomicLong</li>\n<li>原子更新数组：AtomicIntegerArray、AtomicLongArray</li>\n<li>原子更新引用：AtomicReference、AtomicStampedReference 等</li>\n<li>原子更新属性：AtomicIntegerFieldUpdater、AtomicLongFieldUpdater</li>\n</ul>\n<p>提供这些原子类的目的就是为了解决基本类型操作的非原子性导致在多线程并发情况下引发的问题。</p>\n<h3 id=\"非原子问题演示\">非原子问题演示</h3>\n<p>i++并不是原子操作</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AtomicClass</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(j&lt;<span class=\"number\">100</span>)&#123;</span><br><span class=\"line\">            n = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"type\">Thread</span> <span class=\"variable\">t1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>()&#123;</span><br><span class=\"line\">                <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">1000</span>; i++)&#123;</span><br><span class=\"line\">                        n++;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">            <span class=\"type\">Thread</span> <span class=\"variable\">t2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>()&#123;</span><br><span class=\"line\">                <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">1000</span>; i++)&#123;</span><br><span class=\"line\">                        n++;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">            t1.start();</span><br><span class=\"line\">            t2.start();</span><br><span class=\"line\">            t1.join();</span><br><span class=\"line\">            t2.join();</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;n的最终值是：&quot;</span>+n);</span><br><span class=\"line\">            j++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>结果不一定全是 2000</p>\n<h3 id=\"非原子问题的原子解决\">非原子问题的原子解决</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AtomicClass</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> AtomicInteger n;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(j&lt;<span class=\"number\">100</span>)&#123;</span><br><span class=\"line\">            n = <span class=\"keyword\">new</span> <span class=\"title class_\">AtomicInteger</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">            <span class=\"type\">Thread</span> <span class=\"variable\">t1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>()&#123;</span><br><span class=\"line\">                <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">1000</span>; i++)&#123;</span><br><span class=\"line\">                        n.getAndIncrement();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">            <span class=\"type\">Thread</span> <span class=\"variable\">t2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>()&#123;</span><br><span class=\"line\">                <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">1000</span>; i++)&#123;</span><br><span class=\"line\">                        n.getAndIncrement();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">            t1.start();</span><br><span class=\"line\">            t2.start();</span><br><span class=\"line\">            t1.join();</span><br><span class=\"line\">            t2.join();</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;n的最终值是：&quot;</span>+n);</span><br><span class=\"line\">            j++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>原理</strong></p>\n<p><img src=\"/assets/net-img-1582875462202-61de3608-d606-44f6-b8d0-c82da3a7acd8-20221030135541-a1152vd.png\" alt=\"1-10.png\"></p>\n<h3 id=\"CAS-的-ABA-问题\">CAS 的 ABA 问题</h3>\n<p>当前内存的值一开始是 A，被另外一个线程先改为 B 然后再改为 A，那么当前线程访问的时候发现是 A，则认为它没有被其他线程访问过。在某些场景下这样是存在错误风险的。如下图：</p>\n<p><img src=\"/assets/net-img-1582875470139-ea71ffbe-3cbd-44d8-8560-1e72b3a4bab4-20221030135541-hkuw6hs.png\" alt=\"1-11.png\"></p>\n<h3 id=\"AtomicStampedReference-解决-ABA-问题\">AtomicStampedReference 解决 ABA 问题</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AtomicStampedReference(初始值，时间戳)：构造函数设置初始值和时间戳</span><br><span class=\"line\">getStamp：获取时间戳</span><br><span class=\"line\">getReference：获取预期值</span><br><span class=\"line\">compareAndSet(预期值，更新值，预期时间戳，更新时间戳)：实现CAS时间戳和预期值对比</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.atomic.AtomicStampedReference;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AtomicClass</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> AtomicStampedReference&lt;Integer&gt; n;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(j&lt;<span class=\"number\">100</span>)&#123;</span><br><span class=\"line\">            n = <span class=\"keyword\">new</span> <span class=\"title class_\">AtomicStampedReference</span>&lt;Integer&gt;(<span class=\"number\">0</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\">            <span class=\"type\">Thread</span> <span class=\"variable\">t1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>()&#123;</span><br><span class=\"line\">                <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">1000</span>; i++)&#123;</span><br><span class=\"line\">                        <span class=\"type\">int</span> stamp;</span><br><span class=\"line\">                        Integer reference;</span><br><span class=\"line\">                        <span class=\"keyword\">do</span>&#123;</span><br><span class=\"line\">                            stamp = n.getStamp();</span><br><span class=\"line\">                            reference = n.getReference();</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">while</span>(!n.compareAndSet(reference, reference+<span class=\"number\">1</span>, stamp, stamp+<span class=\"number\">1</span>));</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">            <span class=\"type\">Thread</span> <span class=\"variable\">t2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>()&#123;</span><br><span class=\"line\">                <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">1000</span>; i++)&#123;</span><br><span class=\"line\">                        <span class=\"type\">int</span> stamp;</span><br><span class=\"line\">                        Integer reference;</span><br><span class=\"line\">                        <span class=\"keyword\">do</span>&#123;</span><br><span class=\"line\">                            stamp = n.getStamp();</span><br><span class=\"line\">                            reference = n.getReference();</span><br><span class=\"line\"></span><br><span class=\"line\">                        &#125; <span class=\"keyword\">while</span>(!n.compareAndSet(reference, reference+<span class=\"number\">1</span>, stamp, stamp+<span class=\"number\">1</span>));</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">            t1.start();</span><br><span class=\"line\">            t2.start();</span><br><span class=\"line\">            t1.join();</span><br><span class=\"line\">            t2.join();</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;n的最终值是：&quot;</span>+n.getReference());</span><br><span class=\"line\">            j++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>注意：采用 AtomicStampedReference 会降低性能，慎用。</strong></p>\n<p>‍</p>\n","excerpt":"","more":"<h1>并发处理</h1>\n<hr>\n<h2 id=\"多线程特性\">多线程特性</h2>\n<ul>\n<li>原子性\n<ul>\n<li>一个或多个操作要么全部执行并且执行过程中不会被任何因素打断，要么就不执行。</li>\n</ul>\n</li>\n<li>可见性\n<ul>\n<li>当多个线程同时访问一个变量时，一个线程修改了这个变量，其他线程能够立即看见修改的值。单线程不存在可见性问题。</li>\n</ul>\n</li>\n<li>有序型\n<ul>\n<li>程序的执行按照代码的先后顺序执行</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"对象的发布和逸出\">对象的发布和逸出</h2>\n<h3 id=\"发布\">发布</h3>\n<blockquote>\n<p>&quot;发布( Publish)&quot;一个对象的意思是指,使对象能够在当前作用域之外的代码中使用</p>\n</blockquote>\n<ol>\n<li>一个指向该对象的引用保存到其他代码可以访问的地方</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Person</span>()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> age;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Record</span>&#123;</span><br><span class=\"line\">    Person p;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>在某一个非私有的方法中返回该引用</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Person</span>()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> age;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Person <span class=\"title function_\">get</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Person</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>将引用传递到其他类的方法中</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Person</span>()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> age;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Record</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">getPersonMessage</span><span class=\"params\">(Person p)</span>&#123;</span><br><span class=\"line\">        .....</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"逸出\">逸出</h3>\n<blockquote>\n<p>当某个不应该发布的对象被发布时,这种情况就被称为逸出( Escape).</p>\n</blockquote>\n<ol>\n<li>内部的可变状态逸出</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">UnsafeStates</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String[] states = &#123;<span class=\"string\">&quot;AK&quot;</span>,<span class=\"string\">&quot;AL&quot;</span>,...&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String[] getStates()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> states;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//数组states本事私有的变量，但是以public公有的方式发布出去，导致states已经逸出了它所在的作用域，任何调用者都能修改这个数组的内容</span></span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>隐式地使用this引用导致逸出</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ThisEscape</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">ThisEscape</span><span class=\"params\">(EventSource source)</span>&#123;</span><br><span class=\"line\">        source.registerListener(</span><br><span class=\"line\">            <span class=\"keyword\">new</span> <span class=\"title class_\">EventListener</span>()&#123;</span><br><span class=\"line\">                <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onEvent</span><span class=\"params\">(Event e)</span>&#123;</span><br><span class=\"line\">                    dosomething(e);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        <span class=\"comment\">//在这里count初始化为1</span></span><br><span class=\"line\">        count = <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//当ThisEscape发布EventListener时，也隐含地发布了ThisEscape实例本身。因为在这个内部类的实例中包含了对ThisEscape实例的隐含引用。</span></span><br><span class=\"line\"><span class=\"comment\">//this逸出会导致ThisEscape也发布出去，也就是ThisEscape还没有构建完成就发布出去，也就是count=1;这一句还没执行就发布了ThisEscape对象，如果要使用count时,很有可能会出现对象不一致的状态</span></span><br></pre></td></tr></table></figure>\n<p><strong>使用工厂方法来防止this引用在构造函数过程中逸出</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SafeListener</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> EventListener listener;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">SafeListener</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        listener = <span class=\"keyword\">new</span> <span class=\"title class_\">EventListener</span>()&#123;</span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onEvent</span><span class=\"params\">(Event e)</span>&#123;</span><br><span class=\"line\">                dosomething(e);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> SafeListener <span class=\"title function_\">newInstance</span><span class=\"params\">(EventSource source)</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">SafeListener</span> <span class=\"variable\">safe</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SafeListener</span>();</span><br><span class=\"line\">        source.registerListener(safe.listener);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> safe;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//保证在对象为构造完成之前，是不会发布该对象</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"线程封闭\">线程封闭</h2>\n<ol>\n<li>Ad-hoc线程封闭。</li>\n</ol>\n<blockquote>\n<p>维护线程封闭性的职责完全由程序实现承担，可用性不高。</p>\n</blockquote>\n<p>Ad-hoc 线程封闭下的一个特例适用于 volatile 变量。 只要确保 volatile 变量仅从单个线程写入，就可以安全地对共享 volatile 变量执读 - 改 - 写操作。</p>\n<ol start=\"2\">\n<li>栈封闭。</li>\n</ol>\n<p>局部变量，无并发问题，在项目中使用最多，简单说就是局部变量，方法的变量都拷贝到线程的堆栈中，只有这个线程能访问到。尽量少使用全局变量（变量不是常量）</p>\n<ol start=\"3\">\n<li>ThreadLocal类。</li>\n</ol>\n<h2 id=\"原子类\">原子类</h2>\n<p>Java 的 java.util.concurrent.atomic 包里面提供了很多可以进行原子操作的类，分为以下四类：</p>\n<ul>\n<li>原子更新基本类型：AtomicInteger、AtomicBoolean、AtomicLong</li>\n<li>原子更新数组：AtomicIntegerArray、AtomicLongArray</li>\n<li>原子更新引用：AtomicReference、AtomicStampedReference 等</li>\n<li>原子更新属性：AtomicIntegerFieldUpdater、AtomicLongFieldUpdater</li>\n</ul>\n<p>提供这些原子类的目的就是为了解决基本类型操作的非原子性导致在多线程并发情况下引发的问题。</p>\n<h3 id=\"非原子问题演示\">非原子问题演示</h3>\n<p>i++并不是原子操作</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AtomicClass</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(j&lt;<span class=\"number\">100</span>)&#123;</span><br><span class=\"line\">            n = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"type\">Thread</span> <span class=\"variable\">t1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>()&#123;</span><br><span class=\"line\">                <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">1000</span>; i++)&#123;</span><br><span class=\"line\">                        n++;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">            <span class=\"type\">Thread</span> <span class=\"variable\">t2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>()&#123;</span><br><span class=\"line\">                <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">1000</span>; i++)&#123;</span><br><span class=\"line\">                        n++;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">            t1.start();</span><br><span class=\"line\">            t2.start();</span><br><span class=\"line\">            t1.join();</span><br><span class=\"line\">            t2.join();</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;n的最终值是：&quot;</span>+n);</span><br><span class=\"line\">            j++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>结果不一定全是 2000</p>\n<h3 id=\"非原子问题的原子解决\">非原子问题的原子解决</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AtomicClass</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> AtomicInteger n;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(j&lt;<span class=\"number\">100</span>)&#123;</span><br><span class=\"line\">            n = <span class=\"keyword\">new</span> <span class=\"title class_\">AtomicInteger</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">            <span class=\"type\">Thread</span> <span class=\"variable\">t1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>()&#123;</span><br><span class=\"line\">                <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">1000</span>; i++)&#123;</span><br><span class=\"line\">                        n.getAndIncrement();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">            <span class=\"type\">Thread</span> <span class=\"variable\">t2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>()&#123;</span><br><span class=\"line\">                <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">1000</span>; i++)&#123;</span><br><span class=\"line\">                        n.getAndIncrement();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">            t1.start();</span><br><span class=\"line\">            t2.start();</span><br><span class=\"line\">            t1.join();</span><br><span class=\"line\">            t2.join();</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;n的最终值是：&quot;</span>+n);</span><br><span class=\"line\">            j++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>原理</strong></p>\n<p><img src=\"/assets/net-img-1582875462202-61de3608-d606-44f6-b8d0-c82da3a7acd8-20221030135541-a1152vd.png\" alt=\"1-10.png\"></p>\n<h3 id=\"CAS-的-ABA-问题\">CAS 的 ABA 问题</h3>\n<p>当前内存的值一开始是 A，被另外一个线程先改为 B 然后再改为 A，那么当前线程访问的时候发现是 A，则认为它没有被其他线程访问过。在某些场景下这样是存在错误风险的。如下图：</p>\n<p><img src=\"/assets/net-img-1582875470139-ea71ffbe-3cbd-44d8-8560-1e72b3a4bab4-20221030135541-hkuw6hs.png\" alt=\"1-11.png\"></p>\n<h3 id=\"AtomicStampedReference-解决-ABA-问题\">AtomicStampedReference 解决 ABA 问题</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AtomicStampedReference(初始值，时间戳)：构造函数设置初始值和时间戳</span><br><span class=\"line\">getStamp：获取时间戳</span><br><span class=\"line\">getReference：获取预期值</span><br><span class=\"line\">compareAndSet(预期值，更新值，预期时间戳，更新时间戳)：实现CAS时间戳和预期值对比</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.atomic.AtomicStampedReference;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AtomicClass</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> AtomicStampedReference&lt;Integer&gt; n;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(j&lt;<span class=\"number\">100</span>)&#123;</span><br><span class=\"line\">            n = <span class=\"keyword\">new</span> <span class=\"title class_\">AtomicStampedReference</span>&lt;Integer&gt;(<span class=\"number\">0</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\">            <span class=\"type\">Thread</span> <span class=\"variable\">t1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>()&#123;</span><br><span class=\"line\">                <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">1000</span>; i++)&#123;</span><br><span class=\"line\">                        <span class=\"type\">int</span> stamp;</span><br><span class=\"line\">                        Integer reference;</span><br><span class=\"line\">                        <span class=\"keyword\">do</span>&#123;</span><br><span class=\"line\">                            stamp = n.getStamp();</span><br><span class=\"line\">                            reference = n.getReference();</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">while</span>(!n.compareAndSet(reference, reference+<span class=\"number\">1</span>, stamp, stamp+<span class=\"number\">1</span>));</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">            <span class=\"type\">Thread</span> <span class=\"variable\">t2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>()&#123;</span><br><span class=\"line\">                <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">1000</span>; i++)&#123;</span><br><span class=\"line\">                        <span class=\"type\">int</span> stamp;</span><br><span class=\"line\">                        Integer reference;</span><br><span class=\"line\">                        <span class=\"keyword\">do</span>&#123;</span><br><span class=\"line\">                            stamp = n.getStamp();</span><br><span class=\"line\">                            reference = n.getReference();</span><br><span class=\"line\"></span><br><span class=\"line\">                        &#125; <span class=\"keyword\">while</span>(!n.compareAndSet(reference, reference+<span class=\"number\">1</span>, stamp, stamp+<span class=\"number\">1</span>));</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">            t1.start();</span><br><span class=\"line\">            t2.start();</span><br><span class=\"line\">            t1.join();</span><br><span class=\"line\">            t2.join();</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;n的最终值是：&quot;</span>+n.getReference());</span><br><span class=\"line\">            j++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>注意：采用 AtomicStampedReference 会降低性能，慎用。</strong></p>\n<p>‍</p>\n"},{"title":"线程间通讯","date":"2023-05-14T14:53:28.000Z","lastmod":"2023-05-14T14:41:00.000Z","_content":"\n# 线程间通讯\n\n## 线程通信\n\n### 线程间通信常用方式\n\n1. 休眠唤醒\n   1. object 的 wait，notify，notifyAll\n   2. Condition 的 await，signal，signalAll\n2. CountDownLatch：用于某个线程 A 等待若干个其他线程执行完之后，它才执行\n   - CountDownLatch 这个类能够使一个线程等待其他线程完成各自的工作后再执行。\n   - CountDownLatch 是通过一个计数器来实现的，计数器的初始值为线程的数量。  \n  ![1-8.png](/assets/net-img-1582875399701-d03e5b25-a1c9-498e-85d6-18f86f41e38f-20221030135517-a6hu6sv.png)\n\n　　每当一个线程完成了自己的任务后，计数器的值就会减 1。当计数器值到达 0 时，它表示所有的线程已经完成了任务，然后在闭锁上等待的线程就可以恢复执行任务。\n1. CyclicBarrier：一组线程等待至某个状态之后再全部同时执行\n\n- CyclicBarrier 实现让一组线程等待至某个状态之后再全部同时执行。\n- CyclicBarrier 底层是 ReentrantLock 和 Condition 实现\n\n4. Semaphore：用于控制对某组资源的访问权限\n\n　　**Object 和 Condition 休眠唤醒区别**\n\n1. object wait()必须在 synchronized（同步锁）下使用，\n2. object wait()必须要通过 Nodify()方法进行唤醒\n3. condition await() 必须和 Lock（互斥锁/共享锁）配合使用\n4. condition await() 必须通过 signal() 方法进行唤醒\n\n　　**sleep 和 wait 区别**\n\n||wait|sleep|\n| ----------| -----------------------------------------------------------------------------| ----------------------------------------------------|\n|同步|只能在同步上下文中调用 wait 方法，否则会抛出 llegalMonitorstateException 异常|不需要在同步方法或同步代码块调用|\n|作用对象|wait 方法定义在 Object 类中，作用于对象本身|sleep 方法定义在 java.lang.thread 中，作用于当前线程|\n|释放锁资源|是|否|\n|唤醒条件|其他线程调用对象的 notify()或者 notifyAll()方法|超时或调用 Interrupt()方法体|\n|方法属性|wait 是实例方法|sleep 是静态方法|\n\n　　**wait 和 notify 区别**\n\n* wait 和 notify 都是 Object 中的方法\n* wait 和 notify 执行前线程都必须获得对象锁\n* wait 的作用是使当前线程进行等待\n* notify 的作用是通知其他等待当前线程的对象锁的线程\n\n## Volatile 关键字\n\n### 非原子性的64位操作\n\n　　非Volatile修饰的64位变量（double和long类型），JVM允许将64位的读操作和写操作分为两个32位的操作，如果这两个操作在不同线程执行，可能就会导致数据丢失。在多线程中使用共享且可变的long和double类型变量，必须使用Volatile修饰或加锁，否则会有线程安全问题。\n\n### 原理\n\n　　Java把处理器多级抽象化为JMM，及线程私有化的工作内存和线程共有的主内存，每个线程从主内村拷贝所需数据到自己的工作内存处理，在重新写回主内存。volatile原理就是当线程修改volatile修饰的变量时，要立即写入内存，当线程读取被volatile修饰的变量时，要立即到主存中读取，保证可见性。\n\n### 作用\n\n> 一个共享变量（类的成员变量、类的静态成员变量）被 volatile 修饰之后，那么就具备了两层语义：\n\n* 保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。（注意：不保证原子性）\n* 禁止进行指令重排序。（保证变量所在行的有序性）\n\n  * 当程序执行到 volatile 变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；\n  * 在进行指令优化时，不能将在对 volatile 变量访问的语句放在其后面执行，也不能把 volatile 变量后面的语句放到其前面执行\n\n### 内存屏障\n\n　　**MESI CPU缓存一致性协议**  \n屏障两边的指令不可重排  \n​![image.png](//assets/net-img-1615619423077-dea312ee-787e-4a28-b723-199f76a214f7-20221030135542-mx20k3e.png)  \n​![image.png](//assets/net-img-1615619453470-bdab6e23-1385-4538-9c91-ceefcd05aa27-20221030135542-vyoxljv.png)**应用场景**\n\n　　基于 volatile 的作用，使用 volatile 必须满足以下两个条件：\n\n* 对变量的写操作不依赖于当前值\n* 该变量没有包含在具有其他变量的不变式中\n* 在访问变量时不需要加锁  \n  **常见应用场景如下：**   \n  状态量标记：\n\n```java\nvolatile boolean flag = false;\n \nwhile(!flag){\n    doSomething();\n}\n \npublic void setFlag() {\n    flag = true;\n}\n\n\nvolatile boolean inited = false;\n//线程1:\ncontext = loadContext(); \ninited = true;           \n \n//线程2:\nwhile(!inited ){\nsleep()\n}\ndoSomethingwithconfig(context);\n```\n\n　　双重校验：\n\n```java\nclass Singleton{\n    private volatile static Singleton instance = null;\n \n    private Singleton() {\n \n    }\n \n    public static Singleton getInstance() {\n        if(instance==null) {\n            synchronized (Singleton.class) {\n                if(instance==null)\n                    instance = new Singleton();\n            }\n        }\n        return instance;\n    }\n}\n```\n\n### 局限\n\n　　Volatile修饰变量只能保证可见性，不能保证原子性\n\n　　‍\n","source":"_posts/java/thread/线程间通讯.md","raw":"---\ntitle: 线程间通讯\ndate: 2023-05-14T22:53:28Z\nlastmod: 2023-05-14T22:41:00Z\n---\n\n# 线程间通讯\n\n## 线程通信\n\n### 线程间通信常用方式\n\n1. 休眠唤醒\n   1. object 的 wait，notify，notifyAll\n   2. Condition 的 await，signal，signalAll\n2. CountDownLatch：用于某个线程 A 等待若干个其他线程执行完之后，它才执行\n   - CountDownLatch 这个类能够使一个线程等待其他线程完成各自的工作后再执行。\n   - CountDownLatch 是通过一个计数器来实现的，计数器的初始值为线程的数量。  \n  ![1-8.png](/assets/net-img-1582875399701-d03e5b25-a1c9-498e-85d6-18f86f41e38f-20221030135517-a6hu6sv.png)\n\n　　每当一个线程完成了自己的任务后，计数器的值就会减 1。当计数器值到达 0 时，它表示所有的线程已经完成了任务，然后在闭锁上等待的线程就可以恢复执行任务。\n1. CyclicBarrier：一组线程等待至某个状态之后再全部同时执行\n\n- CyclicBarrier 实现让一组线程等待至某个状态之后再全部同时执行。\n- CyclicBarrier 底层是 ReentrantLock 和 Condition 实现\n\n4. Semaphore：用于控制对某组资源的访问权限\n\n　　**Object 和 Condition 休眠唤醒区别**\n\n1. object wait()必须在 synchronized（同步锁）下使用，\n2. object wait()必须要通过 Nodify()方法进行唤醒\n3. condition await() 必须和 Lock（互斥锁/共享锁）配合使用\n4. condition await() 必须通过 signal() 方法进行唤醒\n\n　　**sleep 和 wait 区别**\n\n||wait|sleep|\n| ----------| -----------------------------------------------------------------------------| ----------------------------------------------------|\n|同步|只能在同步上下文中调用 wait 方法，否则会抛出 llegalMonitorstateException 异常|不需要在同步方法或同步代码块调用|\n|作用对象|wait 方法定义在 Object 类中，作用于对象本身|sleep 方法定义在 java.lang.thread 中，作用于当前线程|\n|释放锁资源|是|否|\n|唤醒条件|其他线程调用对象的 notify()或者 notifyAll()方法|超时或调用 Interrupt()方法体|\n|方法属性|wait 是实例方法|sleep 是静态方法|\n\n　　**wait 和 notify 区别**\n\n* wait 和 notify 都是 Object 中的方法\n* wait 和 notify 执行前线程都必须获得对象锁\n* wait 的作用是使当前线程进行等待\n* notify 的作用是通知其他等待当前线程的对象锁的线程\n\n## Volatile 关键字\n\n### 非原子性的64位操作\n\n　　非Volatile修饰的64位变量（double和long类型），JVM允许将64位的读操作和写操作分为两个32位的操作，如果这两个操作在不同线程执行，可能就会导致数据丢失。在多线程中使用共享且可变的long和double类型变量，必须使用Volatile修饰或加锁，否则会有线程安全问题。\n\n### 原理\n\n　　Java把处理器多级抽象化为JMM，及线程私有化的工作内存和线程共有的主内存，每个线程从主内村拷贝所需数据到自己的工作内存处理，在重新写回主内存。volatile原理就是当线程修改volatile修饰的变量时，要立即写入内存，当线程读取被volatile修饰的变量时，要立即到主存中读取，保证可见性。\n\n### 作用\n\n> 一个共享变量（类的成员变量、类的静态成员变量）被 volatile 修饰之后，那么就具备了两层语义：\n\n* 保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。（注意：不保证原子性）\n* 禁止进行指令重排序。（保证变量所在行的有序性）\n\n  * 当程序执行到 volatile 变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；\n  * 在进行指令优化时，不能将在对 volatile 变量访问的语句放在其后面执行，也不能把 volatile 变量后面的语句放到其前面执行\n\n### 内存屏障\n\n　　**MESI CPU缓存一致性协议**  \n屏障两边的指令不可重排  \n​![image.png](//assets/net-img-1615619423077-dea312ee-787e-4a28-b723-199f76a214f7-20221030135542-mx20k3e.png)  \n​![image.png](//assets/net-img-1615619453470-bdab6e23-1385-4538-9c91-ceefcd05aa27-20221030135542-vyoxljv.png)**应用场景**\n\n　　基于 volatile 的作用，使用 volatile 必须满足以下两个条件：\n\n* 对变量的写操作不依赖于当前值\n* 该变量没有包含在具有其他变量的不变式中\n* 在访问变量时不需要加锁  \n  **常见应用场景如下：**   \n  状态量标记：\n\n```java\nvolatile boolean flag = false;\n \nwhile(!flag){\n    doSomething();\n}\n \npublic void setFlag() {\n    flag = true;\n}\n\n\nvolatile boolean inited = false;\n//线程1:\ncontext = loadContext(); \ninited = true;           \n \n//线程2:\nwhile(!inited ){\nsleep()\n}\ndoSomethingwithconfig(context);\n```\n\n　　双重校验：\n\n```java\nclass Singleton{\n    private volatile static Singleton instance = null;\n \n    private Singleton() {\n \n    }\n \n    public static Singleton getInstance() {\n        if(instance==null) {\n            synchronized (Singleton.class) {\n                if(instance==null)\n                    instance = new Singleton();\n            }\n        }\n        return instance;\n    }\n}\n```\n\n### 局限\n\n　　Volatile修饰变量只能保证可见性，不能保证原子性\n\n　　‍\n","slug":"java-thread-线程间通讯","published":1,"updated":"2025-04-28T08:41:48.397Z","_id":"cm9s3f40p0036bfg4eao7bjij","comments":1,"layout":"post","photos":[],"content":"<h1>线程间通讯</h1>\n<h2 id=\"线程通信\">线程通信</h2>\n<h3 id=\"线程间通信常用方式\">线程间通信常用方式</h3>\n<ol>\n<li>休眠唤醒\n<ol>\n<li>object 的 wait，notify，notifyAll</li>\n<li>Condition 的 await，signal，signalAll</li>\n</ol>\n</li>\n<li>CountDownLatch：用于某个线程 A 等待若干个其他线程执行完之后，它才执行\n<ul>\n<li>CountDownLatch 这个类能够使一个线程等待其他线程完成各自的工作后再执行。</li>\n<li>CountDownLatch 是通过一个计数器来实现的，计数器的初始值为线程的数量。<br>\n<img src=\"/assets/net-img-1582875399701-d03e5b25-a1c9-498e-85d6-18f86f41e38f-20221030135517-a6hu6sv.png\" alt=\"1-8.png\"></li>\n</ul>\n</li>\n</ol>\n<p>每当一个线程完成了自己的任务后，计数器的值就会减 1。当计数器值到达 0 时，它表示所有的线程已经完成了任务，然后在闭锁上等待的线程就可以恢复执行任务。</p>\n<ol>\n<li>CyclicBarrier：一组线程等待至某个状态之后再全部同时执行</li>\n</ol>\n<ul>\n<li>CyclicBarrier 实现让一组线程等待至某个状态之后再全部同时执行。</li>\n<li>CyclicBarrier 底层是 ReentrantLock 和 Condition 实现</li>\n</ul>\n<ol start=\"4\">\n<li>Semaphore：用于控制对某组资源的访问权限</li>\n</ol>\n<p><strong>Object 和 Condition 休眠唤醒区别</strong></p>\n<ol>\n<li>object wait()必须在 synchronized（同步锁）下使用，</li>\n<li>object wait()必须要通过 Nodify()方法进行唤醒</li>\n<li>condition await() 必须和 Lock（互斥锁/共享锁）配合使用</li>\n<li>condition await() 必须通过 signal() 方法进行唤醒</li>\n</ol>\n<p><strong>sleep 和 wait 区别</strong></p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>wait</th>\n<th>sleep</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>同步</td>\n<td>只能在同步上下文中调用 wait 方法，否则会抛出 llegalMonitorstateException 异常</td>\n<td>不需要在同步方法或同步代码块调用</td>\n</tr>\n<tr>\n<td>作用对象</td>\n<td>wait 方法定义在 Object 类中，作用于对象本身</td>\n<td>sleep 方法定义在 java.lang.thread 中，作用于当前线程</td>\n</tr>\n<tr>\n<td>释放锁资源</td>\n<td>是</td>\n<td>否</td>\n</tr>\n<tr>\n<td>唤醒条件</td>\n<td>其他线程调用对象的 notify()或者 notifyAll()方法</td>\n<td>超时或调用 Interrupt()方法体</td>\n</tr>\n<tr>\n<td>方法属性</td>\n<td>wait 是实例方法</td>\n<td>sleep 是静态方法</td>\n</tr>\n</tbody>\n</table>\n<p><strong>wait 和 notify 区别</strong></p>\n<ul>\n<li>wait 和 notify 都是 Object 中的方法</li>\n<li>wait 和 notify 执行前线程都必须获得对象锁</li>\n<li>wait 的作用是使当前线程进行等待</li>\n<li>notify 的作用是通知其他等待当前线程的对象锁的线程</li>\n</ul>\n<h2 id=\"Volatile-关键字\">Volatile 关键字</h2>\n<h3 id=\"非原子性的64位操作\">非原子性的64位操作</h3>\n<p>非Volatile修饰的64位变量（double和long类型），JVM允许将64位的读操作和写操作分为两个32位的操作，如果这两个操作在不同线程执行，可能就会导致数据丢失。在多线程中使用共享且可变的long和double类型变量，必须使用Volatile修饰或加锁，否则会有线程安全问题。</p>\n<h3 id=\"原理\">原理</h3>\n<p>Java把处理器多级抽象化为JMM，及线程私有化的工作内存和线程共有的主内存，每个线程从主内村拷贝所需数据到自己的工作内存处理，在重新写回主内存。volatile原理就是当线程修改volatile修饰的变量时，要立即写入内存，当线程读取被volatile修饰的变量时，要立即到主存中读取，保证可见性。</p>\n<h3 id=\"作用\">作用</h3>\n<blockquote>\n<p>一个共享变量（类的成员变量、类的静态成员变量）被 volatile 修饰之后，那么就具备了两层语义：</p>\n</blockquote>\n<ul>\n<li>\n<p>保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。（注意：不保证原子性）</p>\n</li>\n<li>\n<p>禁止进行指令重排序。（保证变量所在行的有序性）</p>\n<ul>\n<li>当程序执行到 volatile 变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；</li>\n<li>在进行指令优化时，不能将在对 volatile 变量访问的语句放在其后面执行，也不能把 volatile 变量后面的语句放到其前面执行</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"内存屏障\">内存屏障</h3>\n<p><strong>MESI CPU缓存一致性协议</strong><br>\n屏障两边的指令不可重排<br>\n​<img src=\"//assets/net-img-1615619423077-dea312ee-787e-4a28-b723-199f76a214f7-20221030135542-mx20k3e.png\" alt=\"image.png\"><br>\n​<img src=\"//assets/net-img-1615619453470-bdab6e23-1385-4538-9c91-ceefcd05aa27-20221030135542-vyoxljv.png\" alt=\"image.png\"><strong>应用场景</strong></p>\n<p>基于 volatile 的作用，使用 volatile 必须满足以下两个条件：</p>\n<ul>\n<li>对变量的写操作不依赖于当前值</li>\n<li>该变量没有包含在具有其他变量的不变式中</li>\n<li>在访问变量时不需要加锁<br>\n<strong>常见应用场景如下：</strong><br>\n状态量标记：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">volatile</span> <span class=\"type\">boolean</span> <span class=\"variable\">flag</span> <span class=\"operator\">=</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">while</span>(!flag)&#123;</span><br><span class=\"line\">    doSomething();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setFlag</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    flag = <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">volatile</span> <span class=\"type\">boolean</span> <span class=\"variable\">inited</span> <span class=\"operator\">=</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"><span class=\"comment\">//线程1:</span></span><br><span class=\"line\">context = loadContext(); </span><br><span class=\"line\">inited = <span class=\"literal\">true</span>;           </span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">//线程2:</span></span><br><span class=\"line\"><span class=\"keyword\">while</span>(!inited )&#123;</span><br><span class=\"line\">sleep()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">doSomethingwithconfig(context);</span><br></pre></td></tr></table></figure>\n<p>双重校验：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">static</span> <span class=\"type\">Singleton</span> <span class=\"variable\">instance</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">Singleton</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(instance==<span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (Singleton.class) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(instance==<span class=\"literal\">null</span>)</span><br><span class=\"line\">                    instance = <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"局限\">局限</h3>\n<p>Volatile修饰变量只能保证可见性，不能保证原子性</p>\n<p>‍</p>\n","excerpt":"","more":"<h1>线程间通讯</h1>\n<h2 id=\"线程通信\">线程通信</h2>\n<h3 id=\"线程间通信常用方式\">线程间通信常用方式</h3>\n<ol>\n<li>休眠唤醒\n<ol>\n<li>object 的 wait，notify，notifyAll</li>\n<li>Condition 的 await，signal，signalAll</li>\n</ol>\n</li>\n<li>CountDownLatch：用于某个线程 A 等待若干个其他线程执行完之后，它才执行\n<ul>\n<li>CountDownLatch 这个类能够使一个线程等待其他线程完成各自的工作后再执行。</li>\n<li>CountDownLatch 是通过一个计数器来实现的，计数器的初始值为线程的数量。<br>\n<img src=\"/assets/net-img-1582875399701-d03e5b25-a1c9-498e-85d6-18f86f41e38f-20221030135517-a6hu6sv.png\" alt=\"1-8.png\"></li>\n</ul>\n</li>\n</ol>\n<p>每当一个线程完成了自己的任务后，计数器的值就会减 1。当计数器值到达 0 时，它表示所有的线程已经完成了任务，然后在闭锁上等待的线程就可以恢复执行任务。</p>\n<ol>\n<li>CyclicBarrier：一组线程等待至某个状态之后再全部同时执行</li>\n</ol>\n<ul>\n<li>CyclicBarrier 实现让一组线程等待至某个状态之后再全部同时执行。</li>\n<li>CyclicBarrier 底层是 ReentrantLock 和 Condition 实现</li>\n</ul>\n<ol start=\"4\">\n<li>Semaphore：用于控制对某组资源的访问权限</li>\n</ol>\n<p><strong>Object 和 Condition 休眠唤醒区别</strong></p>\n<ol>\n<li>object wait()必须在 synchronized（同步锁）下使用，</li>\n<li>object wait()必须要通过 Nodify()方法进行唤醒</li>\n<li>condition await() 必须和 Lock（互斥锁/共享锁）配合使用</li>\n<li>condition await() 必须通过 signal() 方法进行唤醒</li>\n</ol>\n<p><strong>sleep 和 wait 区别</strong></p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>wait</th>\n<th>sleep</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>同步</td>\n<td>只能在同步上下文中调用 wait 方法，否则会抛出 llegalMonitorstateException 异常</td>\n<td>不需要在同步方法或同步代码块调用</td>\n</tr>\n<tr>\n<td>作用对象</td>\n<td>wait 方法定义在 Object 类中，作用于对象本身</td>\n<td>sleep 方法定义在 java.lang.thread 中，作用于当前线程</td>\n</tr>\n<tr>\n<td>释放锁资源</td>\n<td>是</td>\n<td>否</td>\n</tr>\n<tr>\n<td>唤醒条件</td>\n<td>其他线程调用对象的 notify()或者 notifyAll()方法</td>\n<td>超时或调用 Interrupt()方法体</td>\n</tr>\n<tr>\n<td>方法属性</td>\n<td>wait 是实例方法</td>\n<td>sleep 是静态方法</td>\n</tr>\n</tbody>\n</table>\n<p><strong>wait 和 notify 区别</strong></p>\n<ul>\n<li>wait 和 notify 都是 Object 中的方法</li>\n<li>wait 和 notify 执行前线程都必须获得对象锁</li>\n<li>wait 的作用是使当前线程进行等待</li>\n<li>notify 的作用是通知其他等待当前线程的对象锁的线程</li>\n</ul>\n<h2 id=\"Volatile-关键字\">Volatile 关键字</h2>\n<h3 id=\"非原子性的64位操作\">非原子性的64位操作</h3>\n<p>非Volatile修饰的64位变量（double和long类型），JVM允许将64位的读操作和写操作分为两个32位的操作，如果这两个操作在不同线程执行，可能就会导致数据丢失。在多线程中使用共享且可变的long和double类型变量，必须使用Volatile修饰或加锁，否则会有线程安全问题。</p>\n<h3 id=\"原理\">原理</h3>\n<p>Java把处理器多级抽象化为JMM，及线程私有化的工作内存和线程共有的主内存，每个线程从主内村拷贝所需数据到自己的工作内存处理，在重新写回主内存。volatile原理就是当线程修改volatile修饰的变量时，要立即写入内存，当线程读取被volatile修饰的变量时，要立即到主存中读取，保证可见性。</p>\n<h3 id=\"作用\">作用</h3>\n<blockquote>\n<p>一个共享变量（类的成员变量、类的静态成员变量）被 volatile 修饰之后，那么就具备了两层语义：</p>\n</blockquote>\n<ul>\n<li>\n<p>保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。（注意：不保证原子性）</p>\n</li>\n<li>\n<p>禁止进行指令重排序。（保证变量所在行的有序性）</p>\n<ul>\n<li>当程序执行到 volatile 变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；</li>\n<li>在进行指令优化时，不能将在对 volatile 变量访问的语句放在其后面执行，也不能把 volatile 变量后面的语句放到其前面执行</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"内存屏障\">内存屏障</h3>\n<p><strong>MESI CPU缓存一致性协议</strong><br>\n屏障两边的指令不可重排<br>\n​<img src=\"//assets/net-img-1615619423077-dea312ee-787e-4a28-b723-199f76a214f7-20221030135542-mx20k3e.png\" alt=\"image.png\"><br>\n​<img src=\"//assets/net-img-1615619453470-bdab6e23-1385-4538-9c91-ceefcd05aa27-20221030135542-vyoxljv.png\" alt=\"image.png\"><strong>应用场景</strong></p>\n<p>基于 volatile 的作用，使用 volatile 必须满足以下两个条件：</p>\n<ul>\n<li>对变量的写操作不依赖于当前值</li>\n<li>该变量没有包含在具有其他变量的不变式中</li>\n<li>在访问变量时不需要加锁<br>\n<strong>常见应用场景如下：</strong><br>\n状态量标记：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">volatile</span> <span class=\"type\">boolean</span> <span class=\"variable\">flag</span> <span class=\"operator\">=</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">while</span>(!flag)&#123;</span><br><span class=\"line\">    doSomething();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setFlag</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    flag = <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">volatile</span> <span class=\"type\">boolean</span> <span class=\"variable\">inited</span> <span class=\"operator\">=</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"><span class=\"comment\">//线程1:</span></span><br><span class=\"line\">context = loadContext(); </span><br><span class=\"line\">inited = <span class=\"literal\">true</span>;           </span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">//线程2:</span></span><br><span class=\"line\"><span class=\"keyword\">while</span>(!inited )&#123;</span><br><span class=\"line\">sleep()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">doSomethingwithconfig(context);</span><br></pre></td></tr></table></figure>\n<p>双重校验：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">static</span> <span class=\"type\">Singleton</span> <span class=\"variable\">instance</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">Singleton</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(instance==<span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (Singleton.class) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(instance==<span class=\"literal\">null</span>)</span><br><span class=\"line\">                    instance = <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"局限\">局限</h3>\n<p>Volatile修饰变量只能保证可见性，不能保证原子性</p>\n<p>‍</p>\n"},{"title":"WSL安装kali","date":"2025-05-01T08:57:07.000Z","lastmod":"2025-05-01T08:57:07.000Z","_content":"# WSL安装kali\n## 安装\n\n安装的非C盘位置\n\n```powershell\nwsl --install -d kali-linux --name kali --location E:\\Hyper\\kali\\\n```\n\n## 修改软件源\n\n```bash\nsed -i \"s@http://http.kali.org/kali@https://mirrors.tuna.tsinghua.edu.cn/kali@g\" /etc/apt/sources.list\n```\n\n## 安装图形化功能\n\n```bash\nsudo apt install -y kali-win-kex\n```\n\n## 从Windows终端中启动界面\n\n```powershell\nwsl -d kali kex --esm --wtstart -s\n```\n\n","source":"_posts/20250501/1.md","raw":"---\ntitle: WSL安装kali\ndate: 2025-05-01 16:57:07\nlastmod: 2025-05-01 16:57:07\ntags: [WSL,Kali]\ncategory: WSL\n---\n# WSL安装kali\n## 安装\n\n安装的非C盘位置\n\n```powershell\nwsl --install -d kali-linux --name kali --location E:\\Hyper\\kali\\\n```\n\n## 修改软件源\n\n```bash\nsed -i \"s@http://http.kali.org/kali@https://mirrors.tuna.tsinghua.edu.cn/kali@g\" /etc/apt/sources.list\n```\n\n## 安装图形化功能\n\n```bash\nsudo apt install -y kali-win-kex\n```\n\n## 从Windows终端中启动界面\n\n```powershell\nwsl -d kali kex --esm --wtstart -s\n```\n\n","slug":"20250501-1","published":1,"updated":"2025-05-01T09:02:07.672Z","comments":1,"layout":"post","photos":[],"_id":"cma56nfvk0000isjj1wo3gapa","content":"<h1>WSL安装kali</h1>\n<h2 id=\"安装\">安装</h2>\n<p>安装的非C盘位置</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsl <span class=\"literal\">--install</span> <span class=\"literal\">-d</span> kali<span class=\"literal\">-linux</span> <span class=\"literal\">--name</span> kali <span class=\"literal\">--location</span> E:\\Hyper\\kali\\</span><br></pre></td></tr></table></figure>\n<h2 id=\"修改软件源\">修改软件源</h2>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sed -i <span class=\"string\">&quot;s@http://http.kali.org/kali@https://mirrors.tuna.tsinghua.edu.cn/kali@g&quot;</span> /etc/apt/sources.list</span><br></pre></td></tr></table></figure>\n<h2 id=\"安装图形化功能\">安装图形化功能</h2>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sudo</span> apt install -y kali-win-kex</span><br></pre></td></tr></table></figure>\n<h2 id=\"从Windows终端中启动界面\">从Windows终端中启动界面</h2>\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsl <span class=\"literal\">-d</span> kali kex <span class=\"literal\">--esm</span> <span class=\"literal\">--wtstart</span> <span class=\"literal\">-s</span></span><br></pre></td></tr></table></figure>\n","excerpt":"","more":"<h1>WSL安装kali</h1>\n<h2 id=\"安装\">安装</h2>\n<p>安装的非C盘位置</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsl <span class=\"literal\">--install</span> <span class=\"literal\">-d</span> kali<span class=\"literal\">-linux</span> <span class=\"literal\">--name</span> kali <span class=\"literal\">--location</span> E:\\Hyper\\kali\\</span><br></pre></td></tr></table></figure>\n<h2 id=\"修改软件源\">修改软件源</h2>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sed -i <span class=\"string\">&quot;s@http://http.kali.org/kali@https://mirrors.tuna.tsinghua.edu.cn/kali@g&quot;</span> /etc/apt/sources.list</span><br></pre></td></tr></table></figure>\n<h2 id=\"安装图形化功能\">安装图形化功能</h2>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sudo</span> apt install -y kali-win-kex</span><br></pre></td></tr></table></figure>\n<h2 id=\"从Windows终端中启动界面\">从Windows终端中启动界面</h2>\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wsl <span class=\"literal\">-d</span> kali kex <span class=\"literal\">--esm</span> <span class=\"literal\">--wtstart</span> <span class=\"literal\">-s</span></span><br></pre></td></tr></table></figure>\n"},{"title":"spring-logback 常用配置","date":"2025-05-01T08:57:07.000Z","lastmod":"2025-05-01T08:57:07.000Z","_content":"\n```xml\n<!-- 级别从高到低 OFF 、 FATAL 、 ERROR 、 WARN 、 INFO 、 DEBUG 、 TRACE 、 ALL -->\n<!-- 日志输出规则 根据当前ROOT 级别，日志输出时，级别高于root默认的级别时 会输出 -->\n<!-- 以下 每个配置的 filter 是过滤掉输出文件里面，会出现高级别文件，依然出现低级别的日志信息，通过filter 过滤只记录本级别的日志 -->\n<!-- scan 当此属性设置为true时，配置文件如果发生改变，将会被重新加载，默认值为true。 -->\n<!-- scanPeriod 设置监测配置文件是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒。当scan为true时，此属性生效。默认的时间间隔为1分钟。 -->\n<!-- debug 当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false。 -->\n<configuration scan=\"true\" scanPeriod=\"60 seconds\" debug=\"false\">\n  <!-- 动态日志级别 -->\n  <!--  <jmxConfigurator/>-->\n  <!-- 定义日志文件 输出位置 -->\n\n  <property name=\"log.path\" value=\"${catalina.base}/logs/\"/>\n  <!-- 日志最大的历史 30天 -->\n  <property name=\"maxHistory\" value=\"30\"/>\n  <!-- 设置日志输出格式 -->\n  <property name=\"CONSOLE_LOG_PATTERN\"\n    value=\"%d{yyyy-MM-dd HH:mm:ss.SSS} %highlight(${LOG_LEVEL_PATTERN:-%5p}) %magenta(${PID:-}) [%X{RequestId}] [%yellow(%thread)] [%cyan(%logger{50} - %method:%line)] - %highlight(%msg%n)\"/>\n  <property name=\"LOG_PATTERN\"\n    value=\"%d{yyyy-MM-dd HH:mm:ss.SSS} ${LOG_LEVEL_PATTERN:-%5p} ${PID:-} [%X{RequestId}] [%thread] [%logger{50} - %method:%line] - %msg%n\"/>\n\n  <!-- ConsoleAppender 控制台输出日志 -->\n  <appender name=\"console\" class=\"ch.qos.logback.core.ConsoleAppender\">\n    <!--此日志appender是为开发使用，只配置最底级别，控制台输出的日志级别是大于或等于此级别的日志信息-->\n\n    <encoder>\n      <pattern>${CONSOLE_LOG_PATTERN}</pattern>\n      <charset>UTF-8</charset>\n    </encoder>\n  </appender>\n\n  <!-- ERROR级别日志 -->\n  <!-- 滚动记录文件，先将日志记录到指定文件，当符合某个条件时，将日志记录到其他文件 RollingFileAppender -->\n  <appender name=\"ERROR\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\">\n    <!--记录的日志文件的路径及文件名-->\n    <file>${log.path}/error.log</file>\n    <!-- 过滤器，只记录WARN级别的日志 -->\n    <!-- 果日志级别等于配置级别，过滤器会根据onMath 和 onMismatch接收或拒绝日志。 -->\n    <filter class=\"ch.qos.logback.classic.filter.LevelFilter\">\n      <!-- 设置过滤级别 -->\n      <level>ERROR</level>\n      <!-- 用于配置符合过滤条件的操作 -->\n      <onMatch>ACCEPT</onMatch>\n      <!-- 用于配置不符合过滤条件的操作 -->\n      <onMismatch>DENY</onMismatch>\n    </filter>\n    <!-- 最常用的滚动策略，它根据时间来制定滚动策略.既负责滚动也负责出发滚动 -->\n    <!--日志记录器的滚动策略，按日期，按大小记录-->\n    <rollingPolicy class=\"ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy\">\n      <fileNamePattern>${log.path}/error/error-%d{yyyy-MM-dd}.%i.log.gz</fileNamePattern>\n      <maxFileSize>10MB</maxFileSize>\n      <totalSizeCap>1GB</totalSizeCap>\n      <maxHistory>10</maxHistory>\n      <cleanHistoryOnStart>true</cleanHistoryOnStart>\n    </rollingPolicy>\n    <encoder>\n      <pattern>${LOG_PATTERN}</pattern>\n      <charset>UTF-8</charset>\n    </encoder>\n  </appender>\n\n  <!-- INFO级别日志 appender -->\n  <appender name=\"INFO\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\">\n    <!--记录的日志文件的路径及文件名-->\n    <file>${log.path}/info.log</file>\n    <filter class=\"ch.qos.logback.classic.filter.LevelFilter\">\n      <level>INFO</level>\n      <onMatch>ACCEPT</onMatch>\n      <onMismatch>DENY</onMismatch>\n    </filter>\n    <!--日志记录器的滚动策略，按日期，按大小记录-->\n    <rollingPolicy class=\"ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy\">\n      <fileNamePattern>${log.path}/info/info-%d{yyyy-MM-dd}.%i.log.gz</fileNamePattern>\n      <maxFileSize>10MB</maxFileSize>\n      <totalSizeCap>1GB</totalSizeCap>\n      <maxHistory>10</maxHistory>\n      <cleanHistoryOnStart>true</cleanHistoryOnStart>\n    </rollingPolicy>\n    <encoder>\n      <pattern>${LOG_PATTERN}</pattern>\n      <charset>UTF-8</charset>\n    </encoder>\n  </appender>\n  <!-- WARN级别日志 appender -->\n  <appender name=\"WARN\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\">\n    <!--记录的日志文件的路径及文件名-->\n    <file>${log.path}/warn.log</file>\n    <filter class=\"ch.qos.logback.classic.filter.LevelFilter\">\n      <level>WARN</level>\n      <onMatch>ACCEPT</onMatch>\n      <onMismatch>DENY</onMismatch>\n    </filter>\n    <!--日志记录器的滚动策略，按日期，按大小记录-->\n    <rollingPolicy class=\"ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy\">\n      <fileNamePattern>${log.path}/warn/warn-%d{yyyy-MM-dd}.%i.log.gz</fileNamePattern>\n      <maxFileSize>10MB</maxFileSize>\n      <totalSizeCap>1GB</totalSizeCap>\n      <maxHistory>10</maxHistory>\n      <cleanHistoryOnStart>true</cleanHistoryOnStart>\n    </rollingPolicy>\n    <encoder>\n      <pattern>${LOG_PATTERN}</pattern>\n      <charset>UTF-8</charset>\n    </encoder>\n  </appender>\n  <!-- DEBUG级别日志 appender -->\n  <appender name=\"DEBUG\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\">\n    <!--记录的日志文件的路径及文件名-->\n    <file>${log.path}/DEBUG.log</file>\n    <filter class=\"ch.qos.logback.classic.filter.LevelFilter\">\n      <level>DEBUG</level>\n      <onMatch>ACCEPT</onMatch>\n      <onMismatch>DENY</onMismatch>\n    </filter>\n    <!--日志记录器的滚动策略，按日期，按大小记录-->\n    <rollingPolicy class=\"ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy\">\n      <fileNamePattern>${log.path}/debug/debug-%d{yyyy-MM-dd}.%i.log.gz</fileNamePattern>\n      <maxFileSize>10MB</maxFileSize>\n      <totalSizeCap>1GB</totalSizeCap>\n      <maxHistory>10</maxHistory>\n      <cleanHistoryOnStart>true</cleanHistoryOnStart>\n    </rollingPolicy>\n    <encoder>\n      <pattern>${LOG_PATTERN}</pattern>\n      <charset>UTF-8</charset>\n    </encoder>\n  </appender>\n  <!-- TRACE级别日志 appender -->\n  <appender name=\"TRACE\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\">\n    <!--记录的日志文件的路径及文件名-->\n    <file>${log.path}/TRACE.log</file>\n    <filter class=\"ch.qos.logback.classic.filter.LevelFilter\">\n      <level>TRACE</level>\n      <onMatch>ACCEPT</onMatch>\n      <onMismatch>DENY</onMismatch>\n    </filter>\n    <!--日志记录器的滚动策略，按日期，按大小记录-->\n    <rollingPolicy class=\"ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy\">\n      <fileNamePattern>${log.path}/trace/trace-%d{yyyy-MM-dd}.%i.log.gz</fileNamePattern>\n      <maxFileSize>10MB</maxFileSize>\n      <totalSizeCap>1GB</totalSizeCap>\n      <maxHistory>10</maxHistory>\n      <cleanHistoryOnStart>true</cleanHistoryOnStart>\n    </rollingPolicy>\n\n    <encoder>\n      <pattern>${LOG_PATTERN}</pattern>\n      <charset>UTF-8</charset>\n    </encoder>\n  </appender>\n\n      <!-- 记录sql -->\n    <appender name=\"SQL\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\">\n        <File>${logPath}sql.log</File>\n        <rollingPolicy class=\"ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy\">\n             <fileNamePattern>${log.path}/SQL/sql-%d{yyyy-MM-dd}.%i.log.gz</fileNamePattern>\n             <maxFileSize>10MB</maxFileSize>\n             <totalSizeCap>1GB</totalSizeCap>\n             <maxHistory>10</maxHistory>\n             <cleanHistoryOnStart>true</cleanHistoryOnStart>\n        </rollingPolicy>\n        <encoder>\n            <pattern>${pattern}</pattern>\n            <charset>UTF-8</charset>\n        </encoder>\n    </appender>\n  <!--\n    <logger>用来设置某一个包或者具体的某一个类的日志打印级别、\n    以及指定<appender>。<logger>仅有一个name属性，\n    一个可选的level和一个可选的addtivity属性。\n    name:用来指定受此logger约束的某一个包或者具体的某一个类。\n    level:用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF，\n          还有一个特俗值INHERITED或者同义词NULL，代表强制执行上级的级别。\n          如果未设置此属性，那么当前logger将会继承上级的级别。\n    addtivity:是否向上级logger传递打印信息。默认是true。\n    <logger name=\"org.springframework.web\" level=\"info\"/>\n    <logger name=\"org.springframework.scheduling.annotation.ScheduledAnnotationBeanPostProcessor\" level=\"INFO\"/>\n  -->\n\n  <!--\n      使用mybatis的时候，sql语句是debug下才会打印，而这里我们只配置了info，所以想要查看sql语句的话，有以下两种操作：\n      第一种把<root level=\"info\">改成<root level=\"DEBUG\">这样就会打印sql，不过这样日志那边会出现很多其他消息\n      第二种就是单独给dao下目录配置debug模式，代码如下，这样配置sql语句会打印，其他还是正常info级别：\n      【logging.level.org.mybatis=debug logging.level.dao=debug】\n   -->\n\n  <!--\n      root节点是必选节点，用来指定最基础的日志输出级别，只有一个level属性\n      level:用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF，\n      不能设置为INHERITED或者同义词NULL。默认是DEBUG\n      可以包含零个或多个元素，标识这个appender将会添加到这个logger。\n  -->\n  <!-- 4  最终的策略：\n                   基本策略(root级) + 根据profile在启动时, logger标签中定制化package日志级别(优先级高于上面的root级)-->\n  <!-- root级别 DEBUG -->\n  <root>\n    <!-- 打印debug级别日志及以上级别日志 -->\n    <level value=\"INFO\"/>\n    <!-- 控制台输出 -->\n    <appender-ref ref=\"console\"/>\n    <!-- 文件输出 -->\n    <appender-ref ref=\"ERROR\"/>\n    <appender-ref ref=\"WARN\"/>\n    <appender-ref ref=\"INFO\"/>\n  </root>\n\n  <logger name=\"org.hibernate.type.descriptor.sql.BasicBinder\" level=\"TRACE\"/>\n<!--  <logger name=\"org.hibernate.type.descriptor.sql.BasicExtractor\" level=\"TRACE\"/>-->\n  <logger name=\"org.hibernate.engine.QueryParameters\" level=\"DEBUG\"/>\n  <logger name=\"org.hibernate.engine.query.HQLQueryPlan\" level=\"DEBUG\"/>\n  <logger name=\"org.hibernate.SQL\" level=\"DEBUG\"/>\n  <!-- 生产环境, 指定某包日志为warn级 -->\n  <logger name=\"org.springframework.jdbc.core.JdbcTemplate\" level=\"TRACE\"/>\n  <!-- 特定某个类打印info日志, 比如application启动成功后的提示语 -->\n</configuration>\n```","source":"_posts/20250501/3.md","raw":"---\ntitle: spring-logback 常用配置\ndate: 2025-05-01 16:57:07\nlastmod: 2025-05-01 16:57:07\ntags: [logback,log]\ncategory: Java\n---\n\n```xml\n<!-- 级别从高到低 OFF 、 FATAL 、 ERROR 、 WARN 、 INFO 、 DEBUG 、 TRACE 、 ALL -->\n<!-- 日志输出规则 根据当前ROOT 级别，日志输出时，级别高于root默认的级别时 会输出 -->\n<!-- 以下 每个配置的 filter 是过滤掉输出文件里面，会出现高级别文件，依然出现低级别的日志信息，通过filter 过滤只记录本级别的日志 -->\n<!-- scan 当此属性设置为true时，配置文件如果发生改变，将会被重新加载，默认值为true。 -->\n<!-- scanPeriod 设置监测配置文件是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒。当scan为true时，此属性生效。默认的时间间隔为1分钟。 -->\n<!-- debug 当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false。 -->\n<configuration scan=\"true\" scanPeriod=\"60 seconds\" debug=\"false\">\n  <!-- 动态日志级别 -->\n  <!--  <jmxConfigurator/>-->\n  <!-- 定义日志文件 输出位置 -->\n\n  <property name=\"log.path\" value=\"${catalina.base}/logs/\"/>\n  <!-- 日志最大的历史 30天 -->\n  <property name=\"maxHistory\" value=\"30\"/>\n  <!-- 设置日志输出格式 -->\n  <property name=\"CONSOLE_LOG_PATTERN\"\n    value=\"%d{yyyy-MM-dd HH:mm:ss.SSS} %highlight(${LOG_LEVEL_PATTERN:-%5p}) %magenta(${PID:-}) [%X{RequestId}] [%yellow(%thread)] [%cyan(%logger{50} - %method:%line)] - %highlight(%msg%n)\"/>\n  <property name=\"LOG_PATTERN\"\n    value=\"%d{yyyy-MM-dd HH:mm:ss.SSS} ${LOG_LEVEL_PATTERN:-%5p} ${PID:-} [%X{RequestId}] [%thread] [%logger{50} - %method:%line] - %msg%n\"/>\n\n  <!-- ConsoleAppender 控制台输出日志 -->\n  <appender name=\"console\" class=\"ch.qos.logback.core.ConsoleAppender\">\n    <!--此日志appender是为开发使用，只配置最底级别，控制台输出的日志级别是大于或等于此级别的日志信息-->\n\n    <encoder>\n      <pattern>${CONSOLE_LOG_PATTERN}</pattern>\n      <charset>UTF-8</charset>\n    </encoder>\n  </appender>\n\n  <!-- ERROR级别日志 -->\n  <!-- 滚动记录文件，先将日志记录到指定文件，当符合某个条件时，将日志记录到其他文件 RollingFileAppender -->\n  <appender name=\"ERROR\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\">\n    <!--记录的日志文件的路径及文件名-->\n    <file>${log.path}/error.log</file>\n    <!-- 过滤器，只记录WARN级别的日志 -->\n    <!-- 果日志级别等于配置级别，过滤器会根据onMath 和 onMismatch接收或拒绝日志。 -->\n    <filter class=\"ch.qos.logback.classic.filter.LevelFilter\">\n      <!-- 设置过滤级别 -->\n      <level>ERROR</level>\n      <!-- 用于配置符合过滤条件的操作 -->\n      <onMatch>ACCEPT</onMatch>\n      <!-- 用于配置不符合过滤条件的操作 -->\n      <onMismatch>DENY</onMismatch>\n    </filter>\n    <!-- 最常用的滚动策略，它根据时间来制定滚动策略.既负责滚动也负责出发滚动 -->\n    <!--日志记录器的滚动策略，按日期，按大小记录-->\n    <rollingPolicy class=\"ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy\">\n      <fileNamePattern>${log.path}/error/error-%d{yyyy-MM-dd}.%i.log.gz</fileNamePattern>\n      <maxFileSize>10MB</maxFileSize>\n      <totalSizeCap>1GB</totalSizeCap>\n      <maxHistory>10</maxHistory>\n      <cleanHistoryOnStart>true</cleanHistoryOnStart>\n    </rollingPolicy>\n    <encoder>\n      <pattern>${LOG_PATTERN}</pattern>\n      <charset>UTF-8</charset>\n    </encoder>\n  </appender>\n\n  <!-- INFO级别日志 appender -->\n  <appender name=\"INFO\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\">\n    <!--记录的日志文件的路径及文件名-->\n    <file>${log.path}/info.log</file>\n    <filter class=\"ch.qos.logback.classic.filter.LevelFilter\">\n      <level>INFO</level>\n      <onMatch>ACCEPT</onMatch>\n      <onMismatch>DENY</onMismatch>\n    </filter>\n    <!--日志记录器的滚动策略，按日期，按大小记录-->\n    <rollingPolicy class=\"ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy\">\n      <fileNamePattern>${log.path}/info/info-%d{yyyy-MM-dd}.%i.log.gz</fileNamePattern>\n      <maxFileSize>10MB</maxFileSize>\n      <totalSizeCap>1GB</totalSizeCap>\n      <maxHistory>10</maxHistory>\n      <cleanHistoryOnStart>true</cleanHistoryOnStart>\n    </rollingPolicy>\n    <encoder>\n      <pattern>${LOG_PATTERN}</pattern>\n      <charset>UTF-8</charset>\n    </encoder>\n  </appender>\n  <!-- WARN级别日志 appender -->\n  <appender name=\"WARN\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\">\n    <!--记录的日志文件的路径及文件名-->\n    <file>${log.path}/warn.log</file>\n    <filter class=\"ch.qos.logback.classic.filter.LevelFilter\">\n      <level>WARN</level>\n      <onMatch>ACCEPT</onMatch>\n      <onMismatch>DENY</onMismatch>\n    </filter>\n    <!--日志记录器的滚动策略，按日期，按大小记录-->\n    <rollingPolicy class=\"ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy\">\n      <fileNamePattern>${log.path}/warn/warn-%d{yyyy-MM-dd}.%i.log.gz</fileNamePattern>\n      <maxFileSize>10MB</maxFileSize>\n      <totalSizeCap>1GB</totalSizeCap>\n      <maxHistory>10</maxHistory>\n      <cleanHistoryOnStart>true</cleanHistoryOnStart>\n    </rollingPolicy>\n    <encoder>\n      <pattern>${LOG_PATTERN}</pattern>\n      <charset>UTF-8</charset>\n    </encoder>\n  </appender>\n  <!-- DEBUG级别日志 appender -->\n  <appender name=\"DEBUG\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\">\n    <!--记录的日志文件的路径及文件名-->\n    <file>${log.path}/DEBUG.log</file>\n    <filter class=\"ch.qos.logback.classic.filter.LevelFilter\">\n      <level>DEBUG</level>\n      <onMatch>ACCEPT</onMatch>\n      <onMismatch>DENY</onMismatch>\n    </filter>\n    <!--日志记录器的滚动策略，按日期，按大小记录-->\n    <rollingPolicy class=\"ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy\">\n      <fileNamePattern>${log.path}/debug/debug-%d{yyyy-MM-dd}.%i.log.gz</fileNamePattern>\n      <maxFileSize>10MB</maxFileSize>\n      <totalSizeCap>1GB</totalSizeCap>\n      <maxHistory>10</maxHistory>\n      <cleanHistoryOnStart>true</cleanHistoryOnStart>\n    </rollingPolicy>\n    <encoder>\n      <pattern>${LOG_PATTERN}</pattern>\n      <charset>UTF-8</charset>\n    </encoder>\n  </appender>\n  <!-- TRACE级别日志 appender -->\n  <appender name=\"TRACE\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\">\n    <!--记录的日志文件的路径及文件名-->\n    <file>${log.path}/TRACE.log</file>\n    <filter class=\"ch.qos.logback.classic.filter.LevelFilter\">\n      <level>TRACE</level>\n      <onMatch>ACCEPT</onMatch>\n      <onMismatch>DENY</onMismatch>\n    </filter>\n    <!--日志记录器的滚动策略，按日期，按大小记录-->\n    <rollingPolicy class=\"ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy\">\n      <fileNamePattern>${log.path}/trace/trace-%d{yyyy-MM-dd}.%i.log.gz</fileNamePattern>\n      <maxFileSize>10MB</maxFileSize>\n      <totalSizeCap>1GB</totalSizeCap>\n      <maxHistory>10</maxHistory>\n      <cleanHistoryOnStart>true</cleanHistoryOnStart>\n    </rollingPolicy>\n\n    <encoder>\n      <pattern>${LOG_PATTERN}</pattern>\n      <charset>UTF-8</charset>\n    </encoder>\n  </appender>\n\n      <!-- 记录sql -->\n    <appender name=\"SQL\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\">\n        <File>${logPath}sql.log</File>\n        <rollingPolicy class=\"ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy\">\n             <fileNamePattern>${log.path}/SQL/sql-%d{yyyy-MM-dd}.%i.log.gz</fileNamePattern>\n             <maxFileSize>10MB</maxFileSize>\n             <totalSizeCap>1GB</totalSizeCap>\n             <maxHistory>10</maxHistory>\n             <cleanHistoryOnStart>true</cleanHistoryOnStart>\n        </rollingPolicy>\n        <encoder>\n            <pattern>${pattern}</pattern>\n            <charset>UTF-8</charset>\n        </encoder>\n    </appender>\n  <!--\n    <logger>用来设置某一个包或者具体的某一个类的日志打印级别、\n    以及指定<appender>。<logger>仅有一个name属性，\n    一个可选的level和一个可选的addtivity属性。\n    name:用来指定受此logger约束的某一个包或者具体的某一个类。\n    level:用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF，\n          还有一个特俗值INHERITED或者同义词NULL，代表强制执行上级的级别。\n          如果未设置此属性，那么当前logger将会继承上级的级别。\n    addtivity:是否向上级logger传递打印信息。默认是true。\n    <logger name=\"org.springframework.web\" level=\"info\"/>\n    <logger name=\"org.springframework.scheduling.annotation.ScheduledAnnotationBeanPostProcessor\" level=\"INFO\"/>\n  -->\n\n  <!--\n      使用mybatis的时候，sql语句是debug下才会打印，而这里我们只配置了info，所以想要查看sql语句的话，有以下两种操作：\n      第一种把<root level=\"info\">改成<root level=\"DEBUG\">这样就会打印sql，不过这样日志那边会出现很多其他消息\n      第二种就是单独给dao下目录配置debug模式，代码如下，这样配置sql语句会打印，其他还是正常info级别：\n      【logging.level.org.mybatis=debug logging.level.dao=debug】\n   -->\n\n  <!--\n      root节点是必选节点，用来指定最基础的日志输出级别，只有一个level属性\n      level:用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF，\n      不能设置为INHERITED或者同义词NULL。默认是DEBUG\n      可以包含零个或多个元素，标识这个appender将会添加到这个logger。\n  -->\n  <!-- 4  最终的策略：\n                   基本策略(root级) + 根据profile在启动时, logger标签中定制化package日志级别(优先级高于上面的root级)-->\n  <!-- root级别 DEBUG -->\n  <root>\n    <!-- 打印debug级别日志及以上级别日志 -->\n    <level value=\"INFO\"/>\n    <!-- 控制台输出 -->\n    <appender-ref ref=\"console\"/>\n    <!-- 文件输出 -->\n    <appender-ref ref=\"ERROR\"/>\n    <appender-ref ref=\"WARN\"/>\n    <appender-ref ref=\"INFO\"/>\n  </root>\n\n  <logger name=\"org.hibernate.type.descriptor.sql.BasicBinder\" level=\"TRACE\"/>\n<!--  <logger name=\"org.hibernate.type.descriptor.sql.BasicExtractor\" level=\"TRACE\"/>-->\n  <logger name=\"org.hibernate.engine.QueryParameters\" level=\"DEBUG\"/>\n  <logger name=\"org.hibernate.engine.query.HQLQueryPlan\" level=\"DEBUG\"/>\n  <logger name=\"org.hibernate.SQL\" level=\"DEBUG\"/>\n  <!-- 生产环境, 指定某包日志为warn级 -->\n  <logger name=\"org.springframework.jdbc.core.JdbcTemplate\" level=\"TRACE\"/>\n  <!-- 特定某个类打印info日志, 比如application启动成功后的提示语 -->\n</configuration>\n```","slug":"20250501-3","published":1,"updated":"2025-05-01T09:29:50.778Z","comments":1,"layout":"post","photos":[],"_id":"cma56nfvn0001isjj99f3c6ak","content":"<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 级别从高到低 OFF 、 FATAL 、 ERROR 、 WARN 、 INFO 、 DEBUG 、 TRACE 、 ALL --&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 日志输出规则 根据当前ROOT 级别，日志输出时，级别高于root默认的级别时 会输出 --&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 以下 每个配置的 filter 是过滤掉输出文件里面，会出现高级别文件，依然出现低级别的日志信息，通过filter 过滤只记录本级别的日志 --&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- scan 当此属性设置为true时，配置文件如果发生改变，将会被重新加载，默认值为true。 --&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- scanPeriod 设置监测配置文件是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒。当scan为true时，此属性生效。默认的时间间隔为1分钟。 --&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- debug 当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false。 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">configuration</span> <span class=\"attr\">scan</span>=<span class=\"string\">&quot;true&quot;</span> <span class=\"attr\">scanPeriod</span>=<span class=\"string\">&quot;60 seconds&quot;</span> <span class=\"attr\">debug</span>=<span class=\"string\">&quot;false&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"comment\">&lt;!-- 动态日志级别 --&gt;</span></span><br><span class=\"line\">  <span class=\"comment\">&lt;!--  &lt;jmxConfigurator/&gt;--&gt;</span></span><br><span class=\"line\">  <span class=\"comment\">&lt;!-- 定义日志文件 输出位置 --&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;log.path&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;$&#123;catalina.base&#125;/logs/&quot;</span>/&gt;</span></span><br><span class=\"line\">  <span class=\"comment\">&lt;!-- 日志最大的历史 30天 --&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;maxHistory&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;30&quot;</span>/&gt;</span></span><br><span class=\"line\">  <span class=\"comment\">&lt;!-- 设置日志输出格式 --&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;CONSOLE_LOG_PATTERN&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">value</span>=<span class=\"string\">&quot;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; %highlight($&#123;LOG_LEVEL_PATTERN:-%5p&#125;) %magenta($&#123;PID:-&#125;) [%X&#123;RequestId&#125;] [%yellow(%thread)] [%cyan(%logger&#123;50&#125; - %method:%line)] - %highlight(%msg%n)&quot;</span>/&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;LOG_PATTERN&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">value</span>=<span class=\"string\">&quot;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; $&#123;LOG_LEVEL_PATTERN:-%5p&#125; $&#123;PID:-&#125; [%X&#123;RequestId&#125;] [%thread] [%logger&#123;50&#125; - %method:%line] - %msg%n&quot;</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">&lt;!-- ConsoleAppender 控制台输出日志 --&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">appender</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;console&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--此日志appender是为开发使用，只配置最底级别，控制台输出的日志级别是大于或等于此级别的日志信息--&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">encoder</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">pattern</span>&gt;</span>$&#123;CONSOLE_LOG_PATTERN&#125;<span class=\"tag\">&lt;/<span class=\"name\">pattern</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">charset</span>&gt;</span>UTF-8<span class=\"tag\">&lt;/<span class=\"name\">charset</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">encoder</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">appender</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">&lt;!-- ERROR级别日志 --&gt;</span></span><br><span class=\"line\">  <span class=\"comment\">&lt;!-- 滚动记录文件，先将日志记录到指定文件，当符合某个条件时，将日志记录到其他文件 RollingFileAppender --&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">appender</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;ERROR&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--记录的日志文件的路径及文件名--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">file</span>&gt;</span>$&#123;log.path&#125;/error.log<span class=\"tag\">&lt;/<span class=\"name\">file</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 过滤器，只记录WARN级别的日志 --&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 果日志级别等于配置级别，过滤器会根据onMath 和 onMismatch接收或拒绝日志。 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">filter</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;ch.qos.logback.classic.filter.LevelFilter&quot;</span>&gt;</span></span><br><span class=\"line\">      <span class=\"comment\">&lt;!-- 设置过滤级别 --&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">level</span>&gt;</span>ERROR<span class=\"tag\">&lt;/<span class=\"name\">level</span>&gt;</span></span><br><span class=\"line\">      <span class=\"comment\">&lt;!-- 用于配置符合过滤条件的操作 --&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">onMatch</span>&gt;</span>ACCEPT<span class=\"tag\">&lt;/<span class=\"name\">onMatch</span>&gt;</span></span><br><span class=\"line\">      <span class=\"comment\">&lt;!-- 用于配置不符合过滤条件的操作 --&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">onMismatch</span>&gt;</span>DENY<span class=\"tag\">&lt;/<span class=\"name\">onMismatch</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">filter</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 最常用的滚动策略，它根据时间来制定滚动策略.既负责滚动也负责出发滚动 --&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--日志记录器的滚动策略，按日期，按大小记录--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rollingPolicy</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy&quot;</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">fileNamePattern</span>&gt;</span>$&#123;log.path&#125;/error/error-%d&#123;yyyy-MM-dd&#125;.%i.log.gz<span class=\"tag\">&lt;/<span class=\"name\">fileNamePattern</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">maxFileSize</span>&gt;</span>10MB<span class=\"tag\">&lt;/<span class=\"name\">maxFileSize</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">totalSizeCap</span>&gt;</span>1GB<span class=\"tag\">&lt;/<span class=\"name\">totalSizeCap</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">maxHistory</span>&gt;</span>10<span class=\"tag\">&lt;/<span class=\"name\">maxHistory</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">cleanHistoryOnStart</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">cleanHistoryOnStart</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">rollingPolicy</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">encoder</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">pattern</span>&gt;</span>$&#123;LOG_PATTERN&#125;<span class=\"tag\">&lt;/<span class=\"name\">pattern</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">charset</span>&gt;</span>UTF-8<span class=\"tag\">&lt;/<span class=\"name\">charset</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">encoder</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">appender</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">&lt;!-- INFO级别日志 appender --&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">appender</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;INFO&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--记录的日志文件的路径及文件名--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">file</span>&gt;</span>$&#123;log.path&#125;/info.log<span class=\"tag\">&lt;/<span class=\"name\">file</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">filter</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;ch.qos.logback.classic.filter.LevelFilter&quot;</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">level</span>&gt;</span>INFO<span class=\"tag\">&lt;/<span class=\"name\">level</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">onMatch</span>&gt;</span>ACCEPT<span class=\"tag\">&lt;/<span class=\"name\">onMatch</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">onMismatch</span>&gt;</span>DENY<span class=\"tag\">&lt;/<span class=\"name\">onMismatch</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">filter</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--日志记录器的滚动策略，按日期，按大小记录--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rollingPolicy</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy&quot;</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">fileNamePattern</span>&gt;</span>$&#123;log.path&#125;/info/info-%d&#123;yyyy-MM-dd&#125;.%i.log.gz<span class=\"tag\">&lt;/<span class=\"name\">fileNamePattern</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">maxFileSize</span>&gt;</span>10MB<span class=\"tag\">&lt;/<span class=\"name\">maxFileSize</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">totalSizeCap</span>&gt;</span>1GB<span class=\"tag\">&lt;/<span class=\"name\">totalSizeCap</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">maxHistory</span>&gt;</span>10<span class=\"tag\">&lt;/<span class=\"name\">maxHistory</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">cleanHistoryOnStart</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">cleanHistoryOnStart</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">rollingPolicy</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">encoder</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">pattern</span>&gt;</span>$&#123;LOG_PATTERN&#125;<span class=\"tag\">&lt;/<span class=\"name\">pattern</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">charset</span>&gt;</span>UTF-8<span class=\"tag\">&lt;/<span class=\"name\">charset</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">encoder</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">appender</span>&gt;</span></span><br><span class=\"line\">  <span class=\"comment\">&lt;!-- WARN级别日志 appender --&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">appender</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;WARN&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--记录的日志文件的路径及文件名--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">file</span>&gt;</span>$&#123;log.path&#125;/warn.log<span class=\"tag\">&lt;/<span class=\"name\">file</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">filter</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;ch.qos.logback.classic.filter.LevelFilter&quot;</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">level</span>&gt;</span>WARN<span class=\"tag\">&lt;/<span class=\"name\">level</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">onMatch</span>&gt;</span>ACCEPT<span class=\"tag\">&lt;/<span class=\"name\">onMatch</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">onMismatch</span>&gt;</span>DENY<span class=\"tag\">&lt;/<span class=\"name\">onMismatch</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">filter</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--日志记录器的滚动策略，按日期，按大小记录--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rollingPolicy</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy&quot;</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">fileNamePattern</span>&gt;</span>$&#123;log.path&#125;/warn/warn-%d&#123;yyyy-MM-dd&#125;.%i.log.gz<span class=\"tag\">&lt;/<span class=\"name\">fileNamePattern</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">maxFileSize</span>&gt;</span>10MB<span class=\"tag\">&lt;/<span class=\"name\">maxFileSize</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">totalSizeCap</span>&gt;</span>1GB<span class=\"tag\">&lt;/<span class=\"name\">totalSizeCap</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">maxHistory</span>&gt;</span>10<span class=\"tag\">&lt;/<span class=\"name\">maxHistory</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">cleanHistoryOnStart</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">cleanHistoryOnStart</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">rollingPolicy</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">encoder</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">pattern</span>&gt;</span>$&#123;LOG_PATTERN&#125;<span class=\"tag\">&lt;/<span class=\"name\">pattern</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">charset</span>&gt;</span>UTF-8<span class=\"tag\">&lt;/<span class=\"name\">charset</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">encoder</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">appender</span>&gt;</span></span><br><span class=\"line\">  <span class=\"comment\">&lt;!-- DEBUG级别日志 appender --&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">appender</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;DEBUG&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--记录的日志文件的路径及文件名--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">file</span>&gt;</span>$&#123;log.path&#125;/DEBUG.log<span class=\"tag\">&lt;/<span class=\"name\">file</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">filter</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;ch.qos.logback.classic.filter.LevelFilter&quot;</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">level</span>&gt;</span>DEBUG<span class=\"tag\">&lt;/<span class=\"name\">level</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">onMatch</span>&gt;</span>ACCEPT<span class=\"tag\">&lt;/<span class=\"name\">onMatch</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">onMismatch</span>&gt;</span>DENY<span class=\"tag\">&lt;/<span class=\"name\">onMismatch</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">filter</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--日志记录器的滚动策略，按日期，按大小记录--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rollingPolicy</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy&quot;</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">fileNamePattern</span>&gt;</span>$&#123;log.path&#125;/debug/debug-%d&#123;yyyy-MM-dd&#125;.%i.log.gz<span class=\"tag\">&lt;/<span class=\"name\">fileNamePattern</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">maxFileSize</span>&gt;</span>10MB<span class=\"tag\">&lt;/<span class=\"name\">maxFileSize</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">totalSizeCap</span>&gt;</span>1GB<span class=\"tag\">&lt;/<span class=\"name\">totalSizeCap</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">maxHistory</span>&gt;</span>10<span class=\"tag\">&lt;/<span class=\"name\">maxHistory</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">cleanHistoryOnStart</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">cleanHistoryOnStart</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">rollingPolicy</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">encoder</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">pattern</span>&gt;</span>$&#123;LOG_PATTERN&#125;<span class=\"tag\">&lt;/<span class=\"name\">pattern</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">charset</span>&gt;</span>UTF-8<span class=\"tag\">&lt;/<span class=\"name\">charset</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">encoder</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">appender</span>&gt;</span></span><br><span class=\"line\">  <span class=\"comment\">&lt;!-- TRACE级别日志 appender --&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">appender</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;TRACE&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--记录的日志文件的路径及文件名--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">file</span>&gt;</span>$&#123;log.path&#125;/TRACE.log<span class=\"tag\">&lt;/<span class=\"name\">file</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">filter</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;ch.qos.logback.classic.filter.LevelFilter&quot;</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">level</span>&gt;</span>TRACE<span class=\"tag\">&lt;/<span class=\"name\">level</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">onMatch</span>&gt;</span>ACCEPT<span class=\"tag\">&lt;/<span class=\"name\">onMatch</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">onMismatch</span>&gt;</span>DENY<span class=\"tag\">&lt;/<span class=\"name\">onMismatch</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">filter</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--日志记录器的滚动策略，按日期，按大小记录--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rollingPolicy</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy&quot;</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">fileNamePattern</span>&gt;</span>$&#123;log.path&#125;/trace/trace-%d&#123;yyyy-MM-dd&#125;.%i.log.gz<span class=\"tag\">&lt;/<span class=\"name\">fileNamePattern</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">maxFileSize</span>&gt;</span>10MB<span class=\"tag\">&lt;/<span class=\"name\">maxFileSize</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">totalSizeCap</span>&gt;</span>1GB<span class=\"tag\">&lt;/<span class=\"name\">totalSizeCap</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">maxHistory</span>&gt;</span>10<span class=\"tag\">&lt;/<span class=\"name\">maxHistory</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">cleanHistoryOnStart</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">cleanHistoryOnStart</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">rollingPolicy</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">encoder</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">pattern</span>&gt;</span>$&#123;LOG_PATTERN&#125;<span class=\"tag\">&lt;/<span class=\"name\">pattern</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">charset</span>&gt;</span>UTF-8<span class=\"tag\">&lt;/<span class=\"name\">charset</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">encoder</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">appender</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">&lt;!-- 记录sql --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">appender</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;SQL&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">File</span>&gt;</span>$&#123;logPath&#125;sql.log<span class=\"tag\">&lt;/<span class=\"name\">File</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">rollingPolicy</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy&quot;</span>&gt;</span></span><br><span class=\"line\">             <span class=\"tag\">&lt;<span class=\"name\">fileNamePattern</span>&gt;</span>$&#123;log.path&#125;/SQL/sql-%d&#123;yyyy-MM-dd&#125;.%i.log.gz<span class=\"tag\">&lt;/<span class=\"name\">fileNamePattern</span>&gt;</span></span><br><span class=\"line\">             <span class=\"tag\">&lt;<span class=\"name\">maxFileSize</span>&gt;</span>10MB<span class=\"tag\">&lt;/<span class=\"name\">maxFileSize</span>&gt;</span></span><br><span class=\"line\">             <span class=\"tag\">&lt;<span class=\"name\">totalSizeCap</span>&gt;</span>1GB<span class=\"tag\">&lt;/<span class=\"name\">totalSizeCap</span>&gt;</span></span><br><span class=\"line\">             <span class=\"tag\">&lt;<span class=\"name\">maxHistory</span>&gt;</span>10<span class=\"tag\">&lt;/<span class=\"name\">maxHistory</span>&gt;</span></span><br><span class=\"line\">             <span class=\"tag\">&lt;<span class=\"name\">cleanHistoryOnStart</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">cleanHistoryOnStart</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">rollingPolicy</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">encoder</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">pattern</span>&gt;</span>$&#123;pattern&#125;<span class=\"tag\">&lt;/<span class=\"name\">pattern</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">charset</span>&gt;</span>UTF-8<span class=\"tag\">&lt;/<span class=\"name\">charset</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">encoder</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">appender</span>&gt;</span></span><br><span class=\"line\">  <span class=\"comment\">&lt;!--</span></span><br><span class=\"line\"><span class=\"comment\">    &lt;logger&gt;用来设置某一个包或者具体的某一个类的日志打印级别、</span></span><br><span class=\"line\"><span class=\"comment\">    以及指定&lt;appender&gt;。&lt;logger&gt;仅有一个name属性，</span></span><br><span class=\"line\"><span class=\"comment\">    一个可选的level和一个可选的addtivity属性。</span></span><br><span class=\"line\"><span class=\"comment\">    name:用来指定受此logger约束的某一个包或者具体的某一个类。</span></span><br><span class=\"line\"><span class=\"comment\">    level:用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF，</span></span><br><span class=\"line\"><span class=\"comment\">          还有一个特俗值INHERITED或者同义词NULL，代表强制执行上级的级别。</span></span><br><span class=\"line\"><span class=\"comment\">          如果未设置此属性，那么当前logger将会继承上级的级别。</span></span><br><span class=\"line\"><span class=\"comment\">    addtivity:是否向上级logger传递打印信息。默认是true。</span></span><br><span class=\"line\"><span class=\"comment\">    &lt;logger name=&quot;org.springframework.web&quot; level=&quot;info&quot;/&gt;</span></span><br><span class=\"line\"><span class=\"comment\">    &lt;logger name=&quot;org.springframework.scheduling.annotation.ScheduledAnnotationBeanPostProcessor&quot; level=&quot;INFO&quot;/&gt;</span></span><br><span class=\"line\"><span class=\"comment\">  --&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">&lt;!--</span></span><br><span class=\"line\"><span class=\"comment\">      使用mybatis的时候，sql语句是debug下才会打印，而这里我们只配置了info，所以想要查看sql语句的话，有以下两种操作：</span></span><br><span class=\"line\"><span class=\"comment\">      第一种把&lt;root level=&quot;info&quot;&gt;改成&lt;root level=&quot;DEBUG&quot;&gt;这样就会打印sql，不过这样日志那边会出现很多其他消息</span></span><br><span class=\"line\"><span class=\"comment\">      第二种就是单独给dao下目录配置debug模式，代码如下，这样配置sql语句会打印，其他还是正常info级别：</span></span><br><span class=\"line\"><span class=\"comment\">      【logging.level.org.mybatis=debug logging.level.dao=debug】</span></span><br><span class=\"line\"><span class=\"comment\">   --&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">&lt;!--</span></span><br><span class=\"line\"><span class=\"comment\">      root节点是必选节点，用来指定最基础的日志输出级别，只有一个level属性</span></span><br><span class=\"line\"><span class=\"comment\">      level:用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF，</span></span><br><span class=\"line\"><span class=\"comment\">      不能设置为INHERITED或者同义词NULL。默认是DEBUG</span></span><br><span class=\"line\"><span class=\"comment\">      可以包含零个或多个元素，标识这个appender将会添加到这个logger。</span></span><br><span class=\"line\"><span class=\"comment\">  --&gt;</span></span><br><span class=\"line\">  <span class=\"comment\">&lt;!-- 4  最终的策略：</span></span><br><span class=\"line\"><span class=\"comment\">                   基本策略(root级) + 根据profile在启动时, logger标签中定制化package日志级别(优先级高于上面的root级)--&gt;</span></span><br><span class=\"line\">  <span class=\"comment\">&lt;!-- root级别 DEBUG --&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">root</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 打印debug级别日志及以上级别日志 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">level</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;INFO&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 控制台输出 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">appender-ref</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;console&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 文件输出 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">appender-ref</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;ERROR&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">appender-ref</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;WARN&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">appender-ref</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;INFO&quot;</span>/&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">root</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">logger</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;org.hibernate.type.descriptor.sql.BasicBinder&quot;</span> <span class=\"attr\">level</span>=<span class=\"string\">&quot;TRACE&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!--  &lt;logger name=&quot;org.hibernate.type.descriptor.sql.BasicExtractor&quot; level=&quot;TRACE&quot;/&gt;--&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">logger</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;org.hibernate.engine.QueryParameters&quot;</span> <span class=\"attr\">level</span>=<span class=\"string\">&quot;DEBUG&quot;</span>/&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">logger</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;org.hibernate.engine.query.HQLQueryPlan&quot;</span> <span class=\"attr\">level</span>=<span class=\"string\">&quot;DEBUG&quot;</span>/&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">logger</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;org.hibernate.SQL&quot;</span> <span class=\"attr\">level</span>=<span class=\"string\">&quot;DEBUG&quot;</span>/&gt;</span></span><br><span class=\"line\">  <span class=\"comment\">&lt;!-- 生产环境, 指定某包日志为warn级 --&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">logger</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;org.springframework.jdbc.core.JdbcTemplate&quot;</span> <span class=\"attr\">level</span>=<span class=\"string\">&quot;TRACE&quot;</span>/&gt;</span></span><br><span class=\"line\">  <span class=\"comment\">&lt;!-- 特定某个类打印info日志, 比如application启动成功后的提示语 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>","excerpt":"","more":"<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 级别从高到低 OFF 、 FATAL 、 ERROR 、 WARN 、 INFO 、 DEBUG 、 TRACE 、 ALL --&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 日志输出规则 根据当前ROOT 级别，日志输出时，级别高于root默认的级别时 会输出 --&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 以下 每个配置的 filter 是过滤掉输出文件里面，会出现高级别文件，依然出现低级别的日志信息，通过filter 过滤只记录本级别的日志 --&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- scan 当此属性设置为true时，配置文件如果发生改变，将会被重新加载，默认值为true。 --&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- scanPeriod 设置监测配置文件是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒。当scan为true时，此属性生效。默认的时间间隔为1分钟。 --&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- debug 当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false。 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">configuration</span> <span class=\"attr\">scan</span>=<span class=\"string\">&quot;true&quot;</span> <span class=\"attr\">scanPeriod</span>=<span class=\"string\">&quot;60 seconds&quot;</span> <span class=\"attr\">debug</span>=<span class=\"string\">&quot;false&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"comment\">&lt;!-- 动态日志级别 --&gt;</span></span><br><span class=\"line\">  <span class=\"comment\">&lt;!--  &lt;jmxConfigurator/&gt;--&gt;</span></span><br><span class=\"line\">  <span class=\"comment\">&lt;!-- 定义日志文件 输出位置 --&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;log.path&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;$&#123;catalina.base&#125;/logs/&quot;</span>/&gt;</span></span><br><span class=\"line\">  <span class=\"comment\">&lt;!-- 日志最大的历史 30天 --&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;maxHistory&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;30&quot;</span>/&gt;</span></span><br><span class=\"line\">  <span class=\"comment\">&lt;!-- 设置日志输出格式 --&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;CONSOLE_LOG_PATTERN&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">value</span>=<span class=\"string\">&quot;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; %highlight($&#123;LOG_LEVEL_PATTERN:-%5p&#125;) %magenta($&#123;PID:-&#125;) [%X&#123;RequestId&#125;] [%yellow(%thread)] [%cyan(%logger&#123;50&#125; - %method:%line)] - %highlight(%msg%n)&quot;</span>/&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;LOG_PATTERN&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">value</span>=<span class=\"string\">&quot;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; $&#123;LOG_LEVEL_PATTERN:-%5p&#125; $&#123;PID:-&#125; [%X&#123;RequestId&#125;] [%thread] [%logger&#123;50&#125; - %method:%line] - %msg%n&quot;</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">&lt;!-- ConsoleAppender 控制台输出日志 --&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">appender</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;console&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--此日志appender是为开发使用，只配置最底级别，控制台输出的日志级别是大于或等于此级别的日志信息--&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">encoder</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">pattern</span>&gt;</span>$&#123;CONSOLE_LOG_PATTERN&#125;<span class=\"tag\">&lt;/<span class=\"name\">pattern</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">charset</span>&gt;</span>UTF-8<span class=\"tag\">&lt;/<span class=\"name\">charset</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">encoder</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">appender</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">&lt;!-- ERROR级别日志 --&gt;</span></span><br><span class=\"line\">  <span class=\"comment\">&lt;!-- 滚动记录文件，先将日志记录到指定文件，当符合某个条件时，将日志记录到其他文件 RollingFileAppender --&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">appender</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;ERROR&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--记录的日志文件的路径及文件名--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">file</span>&gt;</span>$&#123;log.path&#125;/error.log<span class=\"tag\">&lt;/<span class=\"name\">file</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 过滤器，只记录WARN级别的日志 --&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 果日志级别等于配置级别，过滤器会根据onMath 和 onMismatch接收或拒绝日志。 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">filter</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;ch.qos.logback.classic.filter.LevelFilter&quot;</span>&gt;</span></span><br><span class=\"line\">      <span class=\"comment\">&lt;!-- 设置过滤级别 --&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">level</span>&gt;</span>ERROR<span class=\"tag\">&lt;/<span class=\"name\">level</span>&gt;</span></span><br><span class=\"line\">      <span class=\"comment\">&lt;!-- 用于配置符合过滤条件的操作 --&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">onMatch</span>&gt;</span>ACCEPT<span class=\"tag\">&lt;/<span class=\"name\">onMatch</span>&gt;</span></span><br><span class=\"line\">      <span class=\"comment\">&lt;!-- 用于配置不符合过滤条件的操作 --&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">onMismatch</span>&gt;</span>DENY<span class=\"tag\">&lt;/<span class=\"name\">onMismatch</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">filter</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 最常用的滚动策略，它根据时间来制定滚动策略.既负责滚动也负责出发滚动 --&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--日志记录器的滚动策略，按日期，按大小记录--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rollingPolicy</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy&quot;</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">fileNamePattern</span>&gt;</span>$&#123;log.path&#125;/error/error-%d&#123;yyyy-MM-dd&#125;.%i.log.gz<span class=\"tag\">&lt;/<span class=\"name\">fileNamePattern</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">maxFileSize</span>&gt;</span>10MB<span class=\"tag\">&lt;/<span class=\"name\">maxFileSize</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">totalSizeCap</span>&gt;</span>1GB<span class=\"tag\">&lt;/<span class=\"name\">totalSizeCap</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">maxHistory</span>&gt;</span>10<span class=\"tag\">&lt;/<span class=\"name\">maxHistory</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">cleanHistoryOnStart</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">cleanHistoryOnStart</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">rollingPolicy</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">encoder</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">pattern</span>&gt;</span>$&#123;LOG_PATTERN&#125;<span class=\"tag\">&lt;/<span class=\"name\">pattern</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">charset</span>&gt;</span>UTF-8<span class=\"tag\">&lt;/<span class=\"name\">charset</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">encoder</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">appender</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">&lt;!-- INFO级别日志 appender --&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">appender</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;INFO&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--记录的日志文件的路径及文件名--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">file</span>&gt;</span>$&#123;log.path&#125;/info.log<span class=\"tag\">&lt;/<span class=\"name\">file</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">filter</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;ch.qos.logback.classic.filter.LevelFilter&quot;</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">level</span>&gt;</span>INFO<span class=\"tag\">&lt;/<span class=\"name\">level</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">onMatch</span>&gt;</span>ACCEPT<span class=\"tag\">&lt;/<span class=\"name\">onMatch</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">onMismatch</span>&gt;</span>DENY<span class=\"tag\">&lt;/<span class=\"name\">onMismatch</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">filter</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--日志记录器的滚动策略，按日期，按大小记录--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rollingPolicy</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy&quot;</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">fileNamePattern</span>&gt;</span>$&#123;log.path&#125;/info/info-%d&#123;yyyy-MM-dd&#125;.%i.log.gz<span class=\"tag\">&lt;/<span class=\"name\">fileNamePattern</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">maxFileSize</span>&gt;</span>10MB<span class=\"tag\">&lt;/<span class=\"name\">maxFileSize</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">totalSizeCap</span>&gt;</span>1GB<span class=\"tag\">&lt;/<span class=\"name\">totalSizeCap</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">maxHistory</span>&gt;</span>10<span class=\"tag\">&lt;/<span class=\"name\">maxHistory</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">cleanHistoryOnStart</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">cleanHistoryOnStart</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">rollingPolicy</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">encoder</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">pattern</span>&gt;</span>$&#123;LOG_PATTERN&#125;<span class=\"tag\">&lt;/<span class=\"name\">pattern</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">charset</span>&gt;</span>UTF-8<span class=\"tag\">&lt;/<span class=\"name\">charset</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">encoder</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">appender</span>&gt;</span></span><br><span class=\"line\">  <span class=\"comment\">&lt;!-- WARN级别日志 appender --&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">appender</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;WARN&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--记录的日志文件的路径及文件名--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">file</span>&gt;</span>$&#123;log.path&#125;/warn.log<span class=\"tag\">&lt;/<span class=\"name\">file</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">filter</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;ch.qos.logback.classic.filter.LevelFilter&quot;</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">level</span>&gt;</span>WARN<span class=\"tag\">&lt;/<span class=\"name\">level</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">onMatch</span>&gt;</span>ACCEPT<span class=\"tag\">&lt;/<span class=\"name\">onMatch</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">onMismatch</span>&gt;</span>DENY<span class=\"tag\">&lt;/<span class=\"name\">onMismatch</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">filter</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--日志记录器的滚动策略，按日期，按大小记录--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rollingPolicy</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy&quot;</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">fileNamePattern</span>&gt;</span>$&#123;log.path&#125;/warn/warn-%d&#123;yyyy-MM-dd&#125;.%i.log.gz<span class=\"tag\">&lt;/<span class=\"name\">fileNamePattern</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">maxFileSize</span>&gt;</span>10MB<span class=\"tag\">&lt;/<span class=\"name\">maxFileSize</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">totalSizeCap</span>&gt;</span>1GB<span class=\"tag\">&lt;/<span class=\"name\">totalSizeCap</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">maxHistory</span>&gt;</span>10<span class=\"tag\">&lt;/<span class=\"name\">maxHistory</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">cleanHistoryOnStart</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">cleanHistoryOnStart</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">rollingPolicy</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">encoder</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">pattern</span>&gt;</span>$&#123;LOG_PATTERN&#125;<span class=\"tag\">&lt;/<span class=\"name\">pattern</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">charset</span>&gt;</span>UTF-8<span class=\"tag\">&lt;/<span class=\"name\">charset</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">encoder</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">appender</span>&gt;</span></span><br><span class=\"line\">  <span class=\"comment\">&lt;!-- DEBUG级别日志 appender --&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">appender</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;DEBUG&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--记录的日志文件的路径及文件名--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">file</span>&gt;</span>$&#123;log.path&#125;/DEBUG.log<span class=\"tag\">&lt;/<span class=\"name\">file</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">filter</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;ch.qos.logback.classic.filter.LevelFilter&quot;</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">level</span>&gt;</span>DEBUG<span class=\"tag\">&lt;/<span class=\"name\">level</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">onMatch</span>&gt;</span>ACCEPT<span class=\"tag\">&lt;/<span class=\"name\">onMatch</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">onMismatch</span>&gt;</span>DENY<span class=\"tag\">&lt;/<span class=\"name\">onMismatch</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">filter</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--日志记录器的滚动策略，按日期，按大小记录--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rollingPolicy</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy&quot;</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">fileNamePattern</span>&gt;</span>$&#123;log.path&#125;/debug/debug-%d&#123;yyyy-MM-dd&#125;.%i.log.gz<span class=\"tag\">&lt;/<span class=\"name\">fileNamePattern</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">maxFileSize</span>&gt;</span>10MB<span class=\"tag\">&lt;/<span class=\"name\">maxFileSize</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">totalSizeCap</span>&gt;</span>1GB<span class=\"tag\">&lt;/<span class=\"name\">totalSizeCap</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">maxHistory</span>&gt;</span>10<span class=\"tag\">&lt;/<span class=\"name\">maxHistory</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">cleanHistoryOnStart</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">cleanHistoryOnStart</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">rollingPolicy</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">encoder</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">pattern</span>&gt;</span>$&#123;LOG_PATTERN&#125;<span class=\"tag\">&lt;/<span class=\"name\">pattern</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">charset</span>&gt;</span>UTF-8<span class=\"tag\">&lt;/<span class=\"name\">charset</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">encoder</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">appender</span>&gt;</span></span><br><span class=\"line\">  <span class=\"comment\">&lt;!-- TRACE级别日志 appender --&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">appender</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;TRACE&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--记录的日志文件的路径及文件名--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">file</span>&gt;</span>$&#123;log.path&#125;/TRACE.log<span class=\"tag\">&lt;/<span class=\"name\">file</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">filter</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;ch.qos.logback.classic.filter.LevelFilter&quot;</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">level</span>&gt;</span>TRACE<span class=\"tag\">&lt;/<span class=\"name\">level</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">onMatch</span>&gt;</span>ACCEPT<span class=\"tag\">&lt;/<span class=\"name\">onMatch</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">onMismatch</span>&gt;</span>DENY<span class=\"tag\">&lt;/<span class=\"name\">onMismatch</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">filter</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--日志记录器的滚动策略，按日期，按大小记录--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">rollingPolicy</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy&quot;</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">fileNamePattern</span>&gt;</span>$&#123;log.path&#125;/trace/trace-%d&#123;yyyy-MM-dd&#125;.%i.log.gz<span class=\"tag\">&lt;/<span class=\"name\">fileNamePattern</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">maxFileSize</span>&gt;</span>10MB<span class=\"tag\">&lt;/<span class=\"name\">maxFileSize</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">totalSizeCap</span>&gt;</span>1GB<span class=\"tag\">&lt;/<span class=\"name\">totalSizeCap</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">maxHistory</span>&gt;</span>10<span class=\"tag\">&lt;/<span class=\"name\">maxHistory</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">cleanHistoryOnStart</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">cleanHistoryOnStart</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">rollingPolicy</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">encoder</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">pattern</span>&gt;</span>$&#123;LOG_PATTERN&#125;<span class=\"tag\">&lt;/<span class=\"name\">pattern</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">charset</span>&gt;</span>UTF-8<span class=\"tag\">&lt;/<span class=\"name\">charset</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">encoder</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">appender</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">&lt;!-- 记录sql --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">appender</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;SQL&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">File</span>&gt;</span>$&#123;logPath&#125;sql.log<span class=\"tag\">&lt;/<span class=\"name\">File</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">rollingPolicy</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy&quot;</span>&gt;</span></span><br><span class=\"line\">             <span class=\"tag\">&lt;<span class=\"name\">fileNamePattern</span>&gt;</span>$&#123;log.path&#125;/SQL/sql-%d&#123;yyyy-MM-dd&#125;.%i.log.gz<span class=\"tag\">&lt;/<span class=\"name\">fileNamePattern</span>&gt;</span></span><br><span class=\"line\">             <span class=\"tag\">&lt;<span class=\"name\">maxFileSize</span>&gt;</span>10MB<span class=\"tag\">&lt;/<span class=\"name\">maxFileSize</span>&gt;</span></span><br><span class=\"line\">             <span class=\"tag\">&lt;<span class=\"name\">totalSizeCap</span>&gt;</span>1GB<span class=\"tag\">&lt;/<span class=\"name\">totalSizeCap</span>&gt;</span></span><br><span class=\"line\">             <span class=\"tag\">&lt;<span class=\"name\">maxHistory</span>&gt;</span>10<span class=\"tag\">&lt;/<span class=\"name\">maxHistory</span>&gt;</span></span><br><span class=\"line\">             <span class=\"tag\">&lt;<span class=\"name\">cleanHistoryOnStart</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">cleanHistoryOnStart</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">rollingPolicy</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">encoder</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">pattern</span>&gt;</span>$&#123;pattern&#125;<span class=\"tag\">&lt;/<span class=\"name\">pattern</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">charset</span>&gt;</span>UTF-8<span class=\"tag\">&lt;/<span class=\"name\">charset</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">encoder</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">appender</span>&gt;</span></span><br><span class=\"line\">  <span class=\"comment\">&lt;!--</span></span><br><span class=\"line\"><span class=\"comment\">    &lt;logger&gt;用来设置某一个包或者具体的某一个类的日志打印级别、</span></span><br><span class=\"line\"><span class=\"comment\">    以及指定&lt;appender&gt;。&lt;logger&gt;仅有一个name属性，</span></span><br><span class=\"line\"><span class=\"comment\">    一个可选的level和一个可选的addtivity属性。</span></span><br><span class=\"line\"><span class=\"comment\">    name:用来指定受此logger约束的某一个包或者具体的某一个类。</span></span><br><span class=\"line\"><span class=\"comment\">    level:用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF，</span></span><br><span class=\"line\"><span class=\"comment\">          还有一个特俗值INHERITED或者同义词NULL，代表强制执行上级的级别。</span></span><br><span class=\"line\"><span class=\"comment\">          如果未设置此属性，那么当前logger将会继承上级的级别。</span></span><br><span class=\"line\"><span class=\"comment\">    addtivity:是否向上级logger传递打印信息。默认是true。</span></span><br><span class=\"line\"><span class=\"comment\">    &lt;logger name=&quot;org.springframework.web&quot; level=&quot;info&quot;/&gt;</span></span><br><span class=\"line\"><span class=\"comment\">    &lt;logger name=&quot;org.springframework.scheduling.annotation.ScheduledAnnotationBeanPostProcessor&quot; level=&quot;INFO&quot;/&gt;</span></span><br><span class=\"line\"><span class=\"comment\">  --&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">&lt;!--</span></span><br><span class=\"line\"><span class=\"comment\">      使用mybatis的时候，sql语句是debug下才会打印，而这里我们只配置了info，所以想要查看sql语句的话，有以下两种操作：</span></span><br><span class=\"line\"><span class=\"comment\">      第一种把&lt;root level=&quot;info&quot;&gt;改成&lt;root level=&quot;DEBUG&quot;&gt;这样就会打印sql，不过这样日志那边会出现很多其他消息</span></span><br><span class=\"line\"><span class=\"comment\">      第二种就是单独给dao下目录配置debug模式，代码如下，这样配置sql语句会打印，其他还是正常info级别：</span></span><br><span class=\"line\"><span class=\"comment\">      【logging.level.org.mybatis=debug logging.level.dao=debug】</span></span><br><span class=\"line\"><span class=\"comment\">   --&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">&lt;!--</span></span><br><span class=\"line\"><span class=\"comment\">      root节点是必选节点，用来指定最基础的日志输出级别，只有一个level属性</span></span><br><span class=\"line\"><span class=\"comment\">      level:用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF，</span></span><br><span class=\"line\"><span class=\"comment\">      不能设置为INHERITED或者同义词NULL。默认是DEBUG</span></span><br><span class=\"line\"><span class=\"comment\">      可以包含零个或多个元素，标识这个appender将会添加到这个logger。</span></span><br><span class=\"line\"><span class=\"comment\">  --&gt;</span></span><br><span class=\"line\">  <span class=\"comment\">&lt;!-- 4  最终的策略：</span></span><br><span class=\"line\"><span class=\"comment\">                   基本策略(root级) + 根据profile在启动时, logger标签中定制化package日志级别(优先级高于上面的root级)--&gt;</span></span><br><span class=\"line\">  <span class=\"comment\">&lt;!-- root级别 DEBUG --&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">root</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 打印debug级别日志及以上级别日志 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">level</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;INFO&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 控制台输出 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">appender-ref</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;console&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 文件输出 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">appender-ref</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;ERROR&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">appender-ref</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;WARN&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">appender-ref</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;INFO&quot;</span>/&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">root</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">logger</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;org.hibernate.type.descriptor.sql.BasicBinder&quot;</span> <span class=\"attr\">level</span>=<span class=\"string\">&quot;TRACE&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!--  &lt;logger name=&quot;org.hibernate.type.descriptor.sql.BasicExtractor&quot; level=&quot;TRACE&quot;/&gt;--&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">logger</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;org.hibernate.engine.QueryParameters&quot;</span> <span class=\"attr\">level</span>=<span class=\"string\">&quot;DEBUG&quot;</span>/&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">logger</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;org.hibernate.engine.query.HQLQueryPlan&quot;</span> <span class=\"attr\">level</span>=<span class=\"string\">&quot;DEBUG&quot;</span>/&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">logger</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;org.hibernate.SQL&quot;</span> <span class=\"attr\">level</span>=<span class=\"string\">&quot;DEBUG&quot;</span>/&gt;</span></span><br><span class=\"line\">  <span class=\"comment\">&lt;!-- 生产环境, 指定某包日志为warn级 --&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">logger</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;org.springframework.jdbc.core.JdbcTemplate&quot;</span> <span class=\"attr\">level</span>=<span class=\"string\">&quot;TRACE&quot;</span>/&gt;</span></span><br><span class=\"line\">  <span class=\"comment\">&lt;!-- 特定某个类打印info日志, 比如application启动成功后的提示语 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>"},{"title":"Redis 编译安装","date":"2025-05-01T08:57:07.000Z","lastmod":"2025-05-01T08:57:07.000Z","_content":"#  Redis 编译安装\n## 编译\n\n```bash\nwget http://download.redis.io/releases/redis-5.0.14.tar.gz\nwget https://download.redis.io/releases/redis-6.2.7.tar.gz\ntar xzf redis-5.0.14.tar.gz\ncd redis-5.0.14\nmake MALLOC=libc\n```\n\n### redis-server 配置\n\n在`redis.conf`将`daemonize no`改为`daemonize yes`\n\n### 远程访问 redis\n\n搜索`redis.conf`把 `bind 127.0.0.1` 全部注释掉\n\n### 修改 redis 数据库个数\n\n修改`redis.conf` 中的 database\n**Redis集群模式下不存在切换数据库，都是db0**\n\n## Redis-cluster集群\n\n> redis5 部署集群不需要redis-trib.rb\n\n### 集群节点复制\n\n> Redis-Cluster集群中，可以给每一个主节点添加从节点，主节点和从节点直接遵循主从模型的特性。\n> 当用户需要处理更多读请求的时候，添加从节点可以扩展系统的读性能。\n\n### 故障转移\n\n> Redis集群的主节点内置了类似Redis Sentinel的节点故障检测和自动故障转移功能，当集群中的某个主节点下线时，集群中的其他在线主节点会注意到这一点，并对已下线的主节点进行故障转移。\n> 集群进行故障转移的方法和Redis Sentinel进行故障转移的方法基本一样，不同的是，在集群里面，故障转移是由集群中其他在线的主节点负责进行的，所以集群不必另外使用Redis Sentinel。\n\n### 集群分片策略\n\n> Redis-cluster分片策略，是用来解决key存储位置的。\n> 集群将整个数据库分为16384个槽位slot，所有key-value数据都存储在这些slot中的某一个上。一个slot槽位可以存放多个数据，key的槽位计算公式为：slot_number=crc16(key)%16384，其中crc16为16位的循环冗余校验和函数。\n> 集群中的每个主节点都可以处理0个至16383个槽，当16384个槽都有某个节点在负责处理时，集群进入上线状态，并开始处理客户端发送的数据命令请求。\n\n### 集群redirect转向\n\n> 由于Redis集群无中心节点，请求会随机发给任意主节点；\n> 主节点只会处理自己负责槽位的命令请求，其它槽位的命令请求，该主节点会返回客户端一个转向错误；\n> 客户端根据错误中包含的地址和端口重新向正确的负责的主节点发起命令请求。\n\n### 集群搭建\n\n#### 配置文件案例\n\n```bash\n# redis.conf文件示例\nbind 0.0.0.0\nport 7001\ndaemonize yes\npidfile /var/run/redis_7001.pid\ndir \"./\" # node.conf文件保存路径\nlogfile \"/var/log/redis/7001/redis.log\"\nappendonly yes # 持久化\n\n# appendfsync always     #每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度\n# appendfsync everysec  #每秒钟同步一次，显示地将多个写命令同步到硬盘\n# appendfsync no      #让操作系统决定何时进行同步\n\nappendfsync always\n\ncluster-enabled yes\ncluster-config-file nodes-7001.conf # 该文件中包含集群信息\n```\n\n> 注意：在哪个目录下执行启动命令，则node.conf（cluster-config）文件就会在该目录下创建\n\n#### 创建集群\n\n> 启动大于三个的奇数redis服务\n\n```bash\nredis-cli --cluster create ip:7001 ip:7002 127.0.0.1:7003 ip:7004 127.0.0.1:7005 127.0.0.1:7006 --cluster-replicas 1 \n# --cluster-replicas 1  表示主从配置比，1表示的是1:1，前三个是主，后三个是从\n```\n\n#### 查询集群信息\n\n#### \n\n> 注意：查询集群信息需要加上-c参数\n\n```bash\nredis-cli -c -h 127.0.0.1 -p 7001 cluster nodes\n```\n\n参数说明：\n\n* -c：表示以集群方式连接惹redis\n* -h：指定IP地址\n* -p：指定端口\n* cluster nodes：查询集群节点信息\n* cluster info：查询集群状态信息\n\n```bash\n另一种查询方法\n/redis-cli --cluster check 127.0.0.1:7001\n```\n\n### 集群管理\n\n#### 添加新主节点\n\n```bash\nredis-cli --cluster add-node new_host:new_port existing_host:existing_port --cluster-master-id node_id \n```\n\n#### hash槽重新分配\n\n添加完新节点后，需要对新添加的主节点进行hash槽重新分配，这样该主节点才能存储数据，redis共有16384个槽。\n\n```bash\nredis-cli --cluster reshard host:port --cluster-from node_id --cluster-to node_id --cluster-slots <args> --cluster-yes \n```\n\n#### 添加新从节点\n\n```bash\nredis-cli --cluster add-node new_host:new_port existing_host:existing_port --cluster-slave --cluster-master-id node_id \n```\n\n#### 删除节点\n\n```bash\nredis-cli --cluster  del-node host:port node_id\n```\n\n### 注意事项\n\n> 若是登录的是集群中的节点，需要加上-c参数；否则不用加该参数a","source":"_posts/20250501/2.md","raw":"---\ntitle: Redis 编译安装\ndate: 2025-05-01 16:57:07\nlastmod: 2025-05-01 16:57:07\ntags: [Redis,Linux]\ncategory: Redis\n---\n#  Redis 编译安装\n## 编译\n\n```bash\nwget http://download.redis.io/releases/redis-5.0.14.tar.gz\nwget https://download.redis.io/releases/redis-6.2.7.tar.gz\ntar xzf redis-5.0.14.tar.gz\ncd redis-5.0.14\nmake MALLOC=libc\n```\n\n### redis-server 配置\n\n在`redis.conf`将`daemonize no`改为`daemonize yes`\n\n### 远程访问 redis\n\n搜索`redis.conf`把 `bind 127.0.0.1` 全部注释掉\n\n### 修改 redis 数据库个数\n\n修改`redis.conf` 中的 database\n**Redis集群模式下不存在切换数据库，都是db0**\n\n## Redis-cluster集群\n\n> redis5 部署集群不需要redis-trib.rb\n\n### 集群节点复制\n\n> Redis-Cluster集群中，可以给每一个主节点添加从节点，主节点和从节点直接遵循主从模型的特性。\n> 当用户需要处理更多读请求的时候，添加从节点可以扩展系统的读性能。\n\n### 故障转移\n\n> Redis集群的主节点内置了类似Redis Sentinel的节点故障检测和自动故障转移功能，当集群中的某个主节点下线时，集群中的其他在线主节点会注意到这一点，并对已下线的主节点进行故障转移。\n> 集群进行故障转移的方法和Redis Sentinel进行故障转移的方法基本一样，不同的是，在集群里面，故障转移是由集群中其他在线的主节点负责进行的，所以集群不必另外使用Redis Sentinel。\n\n### 集群分片策略\n\n> Redis-cluster分片策略，是用来解决key存储位置的。\n> 集群将整个数据库分为16384个槽位slot，所有key-value数据都存储在这些slot中的某一个上。一个slot槽位可以存放多个数据，key的槽位计算公式为：slot_number=crc16(key)%16384，其中crc16为16位的循环冗余校验和函数。\n> 集群中的每个主节点都可以处理0个至16383个槽，当16384个槽都有某个节点在负责处理时，集群进入上线状态，并开始处理客户端发送的数据命令请求。\n\n### 集群redirect转向\n\n> 由于Redis集群无中心节点，请求会随机发给任意主节点；\n> 主节点只会处理自己负责槽位的命令请求，其它槽位的命令请求，该主节点会返回客户端一个转向错误；\n> 客户端根据错误中包含的地址和端口重新向正确的负责的主节点发起命令请求。\n\n### 集群搭建\n\n#### 配置文件案例\n\n```bash\n# redis.conf文件示例\nbind 0.0.0.0\nport 7001\ndaemonize yes\npidfile /var/run/redis_7001.pid\ndir \"./\" # node.conf文件保存路径\nlogfile \"/var/log/redis/7001/redis.log\"\nappendonly yes # 持久化\n\n# appendfsync always     #每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度\n# appendfsync everysec  #每秒钟同步一次，显示地将多个写命令同步到硬盘\n# appendfsync no      #让操作系统决定何时进行同步\n\nappendfsync always\n\ncluster-enabled yes\ncluster-config-file nodes-7001.conf # 该文件中包含集群信息\n```\n\n> 注意：在哪个目录下执行启动命令，则node.conf（cluster-config）文件就会在该目录下创建\n\n#### 创建集群\n\n> 启动大于三个的奇数redis服务\n\n```bash\nredis-cli --cluster create ip:7001 ip:7002 127.0.0.1:7003 ip:7004 127.0.0.1:7005 127.0.0.1:7006 --cluster-replicas 1 \n# --cluster-replicas 1  表示主从配置比，1表示的是1:1，前三个是主，后三个是从\n```\n\n#### 查询集群信息\n\n#### \n\n> 注意：查询集群信息需要加上-c参数\n\n```bash\nredis-cli -c -h 127.0.0.1 -p 7001 cluster nodes\n```\n\n参数说明：\n\n* -c：表示以集群方式连接惹redis\n* -h：指定IP地址\n* -p：指定端口\n* cluster nodes：查询集群节点信息\n* cluster info：查询集群状态信息\n\n```bash\n另一种查询方法\n/redis-cli --cluster check 127.0.0.1:7001\n```\n\n### 集群管理\n\n#### 添加新主节点\n\n```bash\nredis-cli --cluster add-node new_host:new_port existing_host:existing_port --cluster-master-id node_id \n```\n\n#### hash槽重新分配\n\n添加完新节点后，需要对新添加的主节点进行hash槽重新分配，这样该主节点才能存储数据，redis共有16384个槽。\n\n```bash\nredis-cli --cluster reshard host:port --cluster-from node_id --cluster-to node_id --cluster-slots <args> --cluster-yes \n```\n\n#### 添加新从节点\n\n```bash\nredis-cli --cluster add-node new_host:new_port existing_host:existing_port --cluster-slave --cluster-master-id node_id \n```\n\n#### 删除节点\n\n```bash\nredis-cli --cluster  del-node host:port node_id\n```\n\n### 注意事项\n\n> 若是登录的是集群中的节点，需要加上-c参数；否则不用加该参数a","slug":"20250501-2","published":1,"updated":"2025-05-01T09:12:14.022Z","comments":1,"layout":"post","photos":[],"_id":"cma56nfvs0004isjj2ege7b7j","content":"<h1>Redis 编译安装</h1>\n<h2 id=\"编译\">编译</h2>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget http://download.redis.io/releases/redis-5.0.14.tar.gz</span><br><span class=\"line\">wget https://download.redis.io/releases/redis-6.2.7.tar.gz</span><br><span class=\"line\">tar xzf redis-5.0.14.tar.gz</span><br><span class=\"line\"><span class=\"built_in\">cd</span> redis-5.0.14</span><br><span class=\"line\">make MALLOC=libc</span><br></pre></td></tr></table></figure>\n<h3 id=\"redis-server-配置\">redis-server 配置</h3>\n<p>在<code>redis.conf</code>将<code>daemonize no</code>改为<code>daemonize yes</code></p>\n<h3 id=\"远程访问-redis\">远程访问 redis</h3>\n<p>搜索<code>redis.conf</code>把 <code>bind 127.0.0.1</code> 全部注释掉</p>\n<h3 id=\"修改-redis-数据库个数\">修改 redis 数据库个数</h3>\n<p>修改<code>redis.conf</code> 中的 database<br>\n<strong>Redis集群模式下不存在切换数据库，都是db0</strong></p>\n<h2 id=\"Redis-cluster集群\">Redis-cluster集群</h2>\n<blockquote>\n<p>redis5 部署集群不需要redis-trib.rb</p>\n</blockquote>\n<h3 id=\"集群节点复制\">集群节点复制</h3>\n<blockquote>\n<p>Redis-Cluster集群中，可以给每一个主节点添加从节点，主节点和从节点直接遵循主从模型的特性。<br>\n当用户需要处理更多读请求的时候，添加从节点可以扩展系统的读性能。</p>\n</blockquote>\n<h3 id=\"故障转移\">故障转移</h3>\n<blockquote>\n<p>Redis集群的主节点内置了类似Redis Sentinel的节点故障检测和自动故障转移功能，当集群中的某个主节点下线时，集群中的其他在线主节点会注意到这一点，并对已下线的主节点进行故障转移。<br>\n集群进行故障转移的方法和Redis Sentinel进行故障转移的方法基本一样，不同的是，在集群里面，故障转移是由集群中其他在线的主节点负责进行的，所以集群不必另外使用Redis Sentinel。</p>\n</blockquote>\n<h3 id=\"集群分片策略\">集群分片策略</h3>\n<blockquote>\n<p>Redis-cluster分片策略，是用来解决key存储位置的。<br>\n集群将整个数据库分为16384个槽位slot，所有key-value数据都存储在这些slot中的某一个上。一个slot槽位可以存放多个数据，key的槽位计算公式为：slot_number=crc16(key)%16384，其中crc16为16位的循环冗余校验和函数。<br>\n集群中的每个主节点都可以处理0个至16383个槽，当16384个槽都有某个节点在负责处理时，集群进入上线状态，并开始处理客户端发送的数据命令请求。</p>\n</blockquote>\n<h3 id=\"集群redirect转向\">集群redirect转向</h3>\n<blockquote>\n<p>由于Redis集群无中心节点，请求会随机发给任意主节点；<br>\n主节点只会处理自己负责槽位的命令请求，其它槽位的命令请求，该主节点会返回客户端一个转向错误；<br>\n客户端根据错误中包含的地址和端口重新向正确的负责的主节点发起命令请求。</p>\n</blockquote>\n<h3 id=\"集群搭建\">集群搭建</h3>\n<h4 id=\"配置文件案例\">配置文件案例</h4>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># redis.conf文件示例</span></span><br><span class=\"line\"><span class=\"built_in\">bind</span> 0.0.0.0</span><br><span class=\"line\">port 7001</span><br><span class=\"line\">daemonize <span class=\"built_in\">yes</span></span><br><span class=\"line\">pidfile /var/run/redis_7001.pid</span><br><span class=\"line\"><span class=\"built_in\">dir</span> <span class=\"string\">&quot;./&quot;</span> <span class=\"comment\"># node.conf文件保存路径</span></span><br><span class=\"line\">logfile <span class=\"string\">&quot;/var/log/redis/7001/redis.log&quot;</span></span><br><span class=\"line\">appendonly <span class=\"built_in\">yes</span> <span class=\"comment\"># 持久化</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># appendfsync always     #每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度</span></span><br><span class=\"line\"><span class=\"comment\"># appendfsync everysec  #每秒钟同步一次，显示地将多个写命令同步到硬盘</span></span><br><span class=\"line\"><span class=\"comment\"># appendfsync no      #让操作系统决定何时进行同步</span></span><br><span class=\"line\"></span><br><span class=\"line\">appendfsync always</span><br><span class=\"line\"></span><br><span class=\"line\">cluster-enabled <span class=\"built_in\">yes</span></span><br><span class=\"line\">cluster-config-file nodes-7001.conf <span class=\"comment\"># 该文件中包含集群信息</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>注意：在哪个目录下执行启动命令，则node.conf（cluster-config）文件就会在该目录下创建</p>\n</blockquote>\n<h4 id=\"创建集群\">创建集群</h4>\n<blockquote>\n<p>启动大于三个的奇数redis服务</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis-cli --cluster create ip:7001 ip:7002 127.0.0.1:7003 ip:7004 127.0.0.1:7005 127.0.0.1:7006 --cluster-replicas 1 </span><br><span class=\"line\"><span class=\"comment\"># --cluster-replicas 1  表示主从配置比，1表示的是1:1，前三个是主，后三个是从</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"查询集群信息\">查询集群信息</h4>\n<h4 id=\"\"></h4>\n<blockquote>\n<p>注意：查询集群信息需要加上-c参数</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis-cli -c -h 127.0.0.1 -p 7001 cluster nodes</span><br></pre></td></tr></table></figure>\n<p>参数说明：</p>\n<ul>\n<li>-c：表示以集群方式连接惹redis</li>\n<li>-h：指定IP地址</li>\n<li>-p：指定端口</li>\n<li>cluster nodes：查询集群节点信息</li>\n<li>cluster info：查询集群状态信息</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">另一种查询方法</span><br><span class=\"line\">/redis-cli --cluster check 127.0.0.1:7001</span><br></pre></td></tr></table></figure>\n<h3 id=\"集群管理\">集群管理</h3>\n<h4 id=\"添加新主节点\">添加新主节点</h4>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis-cli --cluster add-node new_host:new_port existing_host:existing_port --cluster-master-id node_id </span><br></pre></td></tr></table></figure>\n<h4 id=\"hash槽重新分配\">hash槽重新分配</h4>\n<p>添加完新节点后，需要对新添加的主节点进行hash槽重新分配，这样该主节点才能存储数据，redis共有16384个槽。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis-cli --cluster reshard host:port --cluster-from node_id --cluster-to node_id --cluster-slots &lt;args&gt; --cluster-yes </span><br></pre></td></tr></table></figure>\n<h4 id=\"添加新从节点\">添加新从节点</h4>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis-cli --cluster add-node new_host:new_port existing_host:existing_port --cluster-slave --cluster-master-id node_id </span><br></pre></td></tr></table></figure>\n<h4 id=\"删除节点\">删除节点</h4>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis-cli --cluster  del-node host:port node_id</span><br></pre></td></tr></table></figure>\n<h3 id=\"注意事项\">注意事项</h3>\n<blockquote>\n<p>若是登录的是集群中的节点，需要加上-c参数；否则不用加该参数a</p>\n</blockquote>\n","excerpt":"","more":"<h1>Redis 编译安装</h1>\n<h2 id=\"编译\">编译</h2>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget http://download.redis.io/releases/redis-5.0.14.tar.gz</span><br><span class=\"line\">wget https://download.redis.io/releases/redis-6.2.7.tar.gz</span><br><span class=\"line\">tar xzf redis-5.0.14.tar.gz</span><br><span class=\"line\"><span class=\"built_in\">cd</span> redis-5.0.14</span><br><span class=\"line\">make MALLOC=libc</span><br></pre></td></tr></table></figure>\n<h3 id=\"redis-server-配置\">redis-server 配置</h3>\n<p>在<code>redis.conf</code>将<code>daemonize no</code>改为<code>daemonize yes</code></p>\n<h3 id=\"远程访问-redis\">远程访问 redis</h3>\n<p>搜索<code>redis.conf</code>把 <code>bind 127.0.0.1</code> 全部注释掉</p>\n<h3 id=\"修改-redis-数据库个数\">修改 redis 数据库个数</h3>\n<p>修改<code>redis.conf</code> 中的 database<br>\n<strong>Redis集群模式下不存在切换数据库，都是db0</strong></p>\n<h2 id=\"Redis-cluster集群\">Redis-cluster集群</h2>\n<blockquote>\n<p>redis5 部署集群不需要redis-trib.rb</p>\n</blockquote>\n<h3 id=\"集群节点复制\">集群节点复制</h3>\n<blockquote>\n<p>Redis-Cluster集群中，可以给每一个主节点添加从节点，主节点和从节点直接遵循主从模型的特性。<br>\n当用户需要处理更多读请求的时候，添加从节点可以扩展系统的读性能。</p>\n</blockquote>\n<h3 id=\"故障转移\">故障转移</h3>\n<blockquote>\n<p>Redis集群的主节点内置了类似Redis Sentinel的节点故障检测和自动故障转移功能，当集群中的某个主节点下线时，集群中的其他在线主节点会注意到这一点，并对已下线的主节点进行故障转移。<br>\n集群进行故障转移的方法和Redis Sentinel进行故障转移的方法基本一样，不同的是，在集群里面，故障转移是由集群中其他在线的主节点负责进行的，所以集群不必另外使用Redis Sentinel。</p>\n</blockquote>\n<h3 id=\"集群分片策略\">集群分片策略</h3>\n<blockquote>\n<p>Redis-cluster分片策略，是用来解决key存储位置的。<br>\n集群将整个数据库分为16384个槽位slot，所有key-value数据都存储在这些slot中的某一个上。一个slot槽位可以存放多个数据，key的槽位计算公式为：slot_number=crc16(key)%16384，其中crc16为16位的循环冗余校验和函数。<br>\n集群中的每个主节点都可以处理0个至16383个槽，当16384个槽都有某个节点在负责处理时，集群进入上线状态，并开始处理客户端发送的数据命令请求。</p>\n</blockquote>\n<h3 id=\"集群redirect转向\">集群redirect转向</h3>\n<blockquote>\n<p>由于Redis集群无中心节点，请求会随机发给任意主节点；<br>\n主节点只会处理自己负责槽位的命令请求，其它槽位的命令请求，该主节点会返回客户端一个转向错误；<br>\n客户端根据错误中包含的地址和端口重新向正确的负责的主节点发起命令请求。</p>\n</blockquote>\n<h3 id=\"集群搭建\">集群搭建</h3>\n<h4 id=\"配置文件案例\">配置文件案例</h4>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># redis.conf文件示例</span></span><br><span class=\"line\"><span class=\"built_in\">bind</span> 0.0.0.0</span><br><span class=\"line\">port 7001</span><br><span class=\"line\">daemonize <span class=\"built_in\">yes</span></span><br><span class=\"line\">pidfile /var/run/redis_7001.pid</span><br><span class=\"line\"><span class=\"built_in\">dir</span> <span class=\"string\">&quot;./&quot;</span> <span class=\"comment\"># node.conf文件保存路径</span></span><br><span class=\"line\">logfile <span class=\"string\">&quot;/var/log/redis/7001/redis.log&quot;</span></span><br><span class=\"line\">appendonly <span class=\"built_in\">yes</span> <span class=\"comment\"># 持久化</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># appendfsync always     #每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度</span></span><br><span class=\"line\"><span class=\"comment\"># appendfsync everysec  #每秒钟同步一次，显示地将多个写命令同步到硬盘</span></span><br><span class=\"line\"><span class=\"comment\"># appendfsync no      #让操作系统决定何时进行同步</span></span><br><span class=\"line\"></span><br><span class=\"line\">appendfsync always</span><br><span class=\"line\"></span><br><span class=\"line\">cluster-enabled <span class=\"built_in\">yes</span></span><br><span class=\"line\">cluster-config-file nodes-7001.conf <span class=\"comment\"># 该文件中包含集群信息</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>注意：在哪个目录下执行启动命令，则node.conf（cluster-config）文件就会在该目录下创建</p>\n</blockquote>\n<h4 id=\"创建集群\">创建集群</h4>\n<blockquote>\n<p>启动大于三个的奇数redis服务</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis-cli --cluster create ip:7001 ip:7002 127.0.0.1:7003 ip:7004 127.0.0.1:7005 127.0.0.1:7006 --cluster-replicas 1 </span><br><span class=\"line\"><span class=\"comment\"># --cluster-replicas 1  表示主从配置比，1表示的是1:1，前三个是主，后三个是从</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"查询集群信息\">查询集群信息</h4>\n<h4 id=\"\"></h4>\n<blockquote>\n<p>注意：查询集群信息需要加上-c参数</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis-cli -c -h 127.0.0.1 -p 7001 cluster nodes</span><br></pre></td></tr></table></figure>\n<p>参数说明：</p>\n<ul>\n<li>-c：表示以集群方式连接惹redis</li>\n<li>-h：指定IP地址</li>\n<li>-p：指定端口</li>\n<li>cluster nodes：查询集群节点信息</li>\n<li>cluster info：查询集群状态信息</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">另一种查询方法</span><br><span class=\"line\">/redis-cli --cluster check 127.0.0.1:7001</span><br></pre></td></tr></table></figure>\n<h3 id=\"集群管理\">集群管理</h3>\n<h4 id=\"添加新主节点\">添加新主节点</h4>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis-cli --cluster add-node new_host:new_port existing_host:existing_port --cluster-master-id node_id </span><br></pre></td></tr></table></figure>\n<h4 id=\"hash槽重新分配\">hash槽重新分配</h4>\n<p>添加完新节点后，需要对新添加的主节点进行hash槽重新分配，这样该主节点才能存储数据，redis共有16384个槽。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis-cli --cluster reshard host:port --cluster-from node_id --cluster-to node_id --cluster-slots &lt;args&gt; --cluster-yes </span><br></pre></td></tr></table></figure>\n<h4 id=\"添加新从节点\">添加新从节点</h4>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis-cli --cluster add-node new_host:new_port existing_host:existing_port --cluster-slave --cluster-master-id node_id </span><br></pre></td></tr></table></figure>\n<h4 id=\"删除节点\">删除节点</h4>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">redis-cli --cluster  del-node host:port node_id</span><br></pre></td></tr></table></figure>\n<h3 id=\"注意事项\">注意事项</h3>\n<blockquote>\n<p>若是登录的是集群中的节点，需要加上-c参数；否则不用加该参数a</p>\n</blockquote>\n"},{"title":"js 代码片段","date":"2025-05-01T08:57:07.000Z","lastmod":"2025-05-01T08:57:07.000Z","_content":"\n```js\nFunction.prototype.__constructor_back = Function.prototype.constructor ;\nFunction.prototype.constructor = function() {\n  if(arguments && typeof arguments[0]==='string'){\n    //alert(\"new function: \"+ arguments[0]);\n    if( \"debugger\" === arguments[0]){\n      //arguments[0]=\"consoLe.Log(\\\"anti debugger\\\");\";\n      //arguments[0]=\";\";\n      return\n    }\n  }\n  return Function.prototype.__constructor_back.apply(this,arguments);\n}\n```","source":"_posts/20250501/4.md","raw":"---\ntitle: js 代码片段\ndate: 2025-05-01 16:57:07\nlastmod: 2025-05-01 16:57:07\ntags: [Javascript]\ncategory: Javascript\n---\n\n```js\nFunction.prototype.__constructor_back = Function.prototype.constructor ;\nFunction.prototype.constructor = function() {\n  if(arguments && typeof arguments[0]==='string'){\n    //alert(\"new function: \"+ arguments[0]);\n    if( \"debugger\" === arguments[0]){\n      //arguments[0]=\"consoLe.Log(\\\"anti debugger\\\");\";\n      //arguments[0]=\";\";\n      return\n    }\n  }\n  return Function.prototype.__constructor_back.apply(this,arguments);\n}\n```","slug":"20250501-4","published":1,"updated":"2025-05-01T09:31:37.986Z","comments":1,"layout":"post","photos":[],"_id":"cma56nfvs0005isjj2cea5i9y","content":"<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Function</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">__constructor_back</span> = <span class=\"title class_\">Function</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">constructor</span> ;</span><br><span class=\"line\"><span class=\"title class_\">Function</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">constructor</span> = <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(<span class=\"variable language_\">arguments</span> &amp;&amp; <span class=\"keyword\">typeof</span> <span class=\"variable language_\">arguments</span>[<span class=\"number\">0</span>]===<span class=\"string\">&#x27;string&#x27;</span>)&#123;</span><br><span class=\"line\">    <span class=\"comment\">//alert(&quot;new function: &quot;+ arguments[0]);</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>( <span class=\"string\">&quot;debugger&quot;</span> === <span class=\"variable language_\">arguments</span>[<span class=\"number\">0</span>])&#123;</span><br><span class=\"line\">      <span class=\"comment\">//arguments[0]=&quot;consoLe.Log(\\&quot;anti debugger\\&quot;);&quot;;</span></span><br><span class=\"line\">      <span class=\"comment\">//arguments[0]=&quot;;&quot;;</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title class_\">Function</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">__constructor_back</span>.<span class=\"title function_\">apply</span>(<span class=\"variable language_\">this</span>,<span class=\"variable language_\">arguments</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","excerpt":"","more":"<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Function</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">__constructor_back</span> = <span class=\"title class_\">Function</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">constructor</span> ;</span><br><span class=\"line\"><span class=\"title class_\">Function</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">constructor</span> = <span class=\"keyword\">function</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(<span class=\"variable language_\">arguments</span> &amp;&amp; <span class=\"keyword\">typeof</span> <span class=\"variable language_\">arguments</span>[<span class=\"number\">0</span>]===<span class=\"string\">&#x27;string&#x27;</span>)&#123;</span><br><span class=\"line\">    <span class=\"comment\">//alert(&quot;new function: &quot;+ arguments[0]);</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>( <span class=\"string\">&quot;debugger&quot;</span> === <span class=\"variable language_\">arguments</span>[<span class=\"number\">0</span>])&#123;</span><br><span class=\"line\">      <span class=\"comment\">//arguments[0]=&quot;consoLe.Log(\\&quot;anti debugger\\&quot;);&quot;;</span></span><br><span class=\"line\">      <span class=\"comment\">//arguments[0]=&quot;;&quot;;</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title class_\">Function</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">__constructor_back</span>.<span class=\"title function_\">apply</span>(<span class=\"variable language_\">this</span>,<span class=\"variable language_\">arguments</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"EMQX K3s 安装","date":"2025-05-01T08:57:07.000Z","lastmod":"2025-05-01T08:57:07.000Z","_content":"\n\n\n# 从零开始建立 EMQX MQTT 服务器的 K8S 集群\n\n<iframe src=\"/widgets/metadata/\" data-src=\"/widgets/metadata/\" data-subtype=\"widget\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" style=\"height: 441px;\"></iframe>\n\n---\n\n* 从零开始建立 EMQX MQTT 服务器的 K8S 集群 - www.emqx.com\n* [https://www.emqx.com/zh/blog/emqx-mqtt-broker-k8s-cluster](https://www.emqx.com/zh/blog/emqx-mqtt-broker-k8s-cluster)\n* 本文将从零开始部署一个 EMQX MQTT 服务器的 K8S 集群，并分析部署中的细节与技巧，方便用户在实际部署中灵活使用。\n* 2024-06-28 10:42:05\n\n---\n\n　　EMQX Team 提供了 Helm chart 方便用户在 kubernetes 集群上一键部署 EMQX [MQTT 服务器](https://www.emqx.com/zh/products/emqx), 这是 EMQX Team 最推荐的在 kubernetes 或 k3s 集群上部署 EMQX MQTT 服务器的方法。 本文将使用手写 yaml 文件的方法从零开始部署一个 EMQX MQTT 服务器的 K8S 集群, 分析部署中的细节与技巧，方便用户在实际部署中灵活使用。\n\n　　阅读本文需要用户了解 kubernetes 的基本概念，并有一个可操作的 kubernetes 集群。\n\n## 在 K8S 上部署单个 EMQX MQTT服务器节点\n\n### 使用 Pod 直接部署 EMQX Broker\n\n　　在Kubernetes中，最小的管理元素不是一个个独立的容器，而是 [Pod](https://kubernetes.io/zh/docs/concepts/workloads/pods/pod-overview/)，Pod 是 Kubernetes 应用程序的基本执行单元，即它是 Kubernetes 对象模型中创建或部署的最小和最简单的单元。Pod 表示在 [集群](https://kubernetes.io/zh-cn/docs/reference/glossary/?all=true#term-cluster) 上运行的进程。\n\n　　EMQX Broker 在 [docker hub](https://hub.docker.com/r/emqx/emqx) 上提供了镜像, 因此可以很方便的在单个的 pod 上部署 EMQX Broker，使用 `kubectl run`​ 命令创建一个运行着 EMQX Broker 的 Pod：\n\n```\n$ kubectl run emqx --image=emqx/emqx:v4.1-rc.1  --generator=run-pod/v1\npod/emqx created\n```\n\n　　查看 EMQX Broker 的状态：\n\n```\n$ kubectl get pods -o wide\nNAME   READY   STATUS    RESTARTS   AGE\nemqx   1/1     Running   0          3m13s\n\n$ kubectl exec emqx -- emqx_ctl status\nNode 'emqx@192.168.77.108' is started\nemqx 4.1-rc.1 is running\n```\n\n　　删除 Pod：\n\n```\n$ kubectl delete pods emqx\npod \"emqx\" deleted\n```\n\n　　Pod 并不是被设计成一个持久化的资源，它不会在调度失败，节点崩溃，或者其他回收中（比如因为资源的缺乏，或者其他的维护中）幸存下来，因此，还需要一个控制器来管理 Pod。\n\n### 使用 Deoloyment 部署 Pod\n\n　　[Deployment](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/) 为 Pod 和 ReplicaSet 提供了一个声明式定义（declarative）方法，用来替代以前的[ReplicationController](https://www.kubernetes.org.cn/replication-controller-kubernetes) 来方便的管理应用。典型的应用场景包括：\n\n* 定义Deployment来创建Pod和ReplicaSet\n* 滚动升级和回滚应用\n* 扩容和缩容\n* 暂停和继续Deployment\n\n　　使用 Deployment 部署一个 EMQX Broker Pod：\n\n* 定义 Deployment：\n\n  ```\n  $ cat deployment.yaml\n\n  apiVersion: apps/v1\n  kind: Deployment\n  metadata:\n    name: emqx-deployment\n    labels:\n      app: emqx\n  spec:\n    replicas: 1\n    selector:\n      matchLabels:\n        app: emqx\n    template:\n      metadata:\n        labels:\n          app: emqx\n      spec:\n        containers:\n        - name: emqx\n          image: emqx/emqx:v4.1-rc.1\n          ports:\n          - name: mqtt\n            containerPort: 1883\n          - name: mqttssl\n            containerPort: 8883\n          - name: mgmt\n            containerPort: 8081\n          - name: ws\n            containerPort: 8083\n          - name: wss\n            containerPort: 8084\n          - name: dashboard\n            containerPort: 18083\n  ```\n* 部署 Deployment：\n\n  ```\n  $  kubectl apply -f deployment.yaml\n  deployment.apps/emqx-deployment created\n  ```\n* 查看部署情况：\n\n  ```\n  $ kubectl get deployment\n  NAME                              READY   UP-TO-DATE   AVAILABLE   AGE\n  deployment.apps/emqx-deployment   3/3     3            3           74s\n\n  $ kubectl get pods\n  NAME                                  READY   STATUS    RESTARTS   AGE\n  pod/emqx-deployment-7c44dbd68-8j77l   1/1     Running   0          74s\n\n  $ kubectl exec pod/emqx-deployment-7c44dbd68-8j77l -- emqx_ctl status\n  Node 'emqx-deployment-7c44dbd68-8j77l@192.168.77.117' is started\n  emqx 4.1-rc.1 is running\n  ```\n* 尝试手动删除 Pod\n\n  ```\n  $ kubectl delete pods emqx-deployment-7c44dbd68-8j77l\n  pod \"emqx-deployment-7c44dbd68-8j77l\" deleted\n\n  $ kubectl get pods\n  NAME                              READY   STATUS    RESTARTS   AGE\n  emqx-deployment-68fcb4bfd6-2nhh6   1/1     Running   0          59s\n  ```\n\n  输出结果表明成功用 Deployment 部署了 EMQX Broker Pod，即使是此 Pod 被意外终止，Deployment 也会重新创建一个新的 Pod。\n\n### 使用 Services 公开 EMQX Broker Pod 服务\n\n　　Kubernetes [Pods](https://kubernetes.io/docs/concepts/workloads/pods/) 是有生命周期的。他们可以被创建，而且销毁不会再启动。 如果使用 [Deployment](https://kubernetes.io/docs/concepts/workloads/controllers/deployment/) 来运行应用程序，则它可以动态创建和销毁 Pod。\n\n　　每个 Pod 都有自己的 IP 地址，但是在 Deployment 中，在同一时刻运行的 Pod 集合可能与稍后运行该应用程序的 Pod 集合不同。\n\n　　这导致了一个问题：如果使用 EMQX Broker Pod 为 **MQTT 客户端**提供服务，那么客户端应该如何如何找出并跟踪要连接的 IP 地址，以便客户端使用 EMQX Broker 服务呢？\n\n　　答案是：Service\n\n　　Service 是将运行在一组 [Pods](https://kubernetes.io/docs/concepts/workloads/pods/) 上的应用程序公开为网络服务的抽象方法。\n\n　　使用 Service 将 EMQX Broker Pod 公开为网络服务：\n\n* 定义 Service：\n\n  ```\n  $cat service.yaml\n\n  apiVersion: v1\n  kind: Service\n  metadata:\n    name: emqx-service\n  spec:\n    selector:\n      app: emqx\n    ports:\n      - name: mqtt\n        port: 1883\n        protocol: TCP\n        targetPort: mqtt\n      - name: mqttssl\n        port: 8883\n        protocol: TCP\n        targetPort: mqttssl\n      - name: mgmt\n        port: 8081\n        protocol: TCP\n        targetPort: mgmt\n      - name: ws\n        port: 8083\n        protocol: TCP\n        targetPort: ws\n      - name: wss\n        port: 8084\n        protocol: TCP\n        targetPort: wss\n      - name: dashboard\n        port: 18083\n        protocol: TCP\n        targetPort: dashboard\n  ```\n* 部署 Service：\n\n  ```\n  $ kubectl apply -f service.yaml\n  service/emqx-service created\n  ```\n* 查看部署情况\n\n  ```\n  $ kubectl get svc\n  NAME           TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)                                        AGE\n  emqx-service   ClusterIP   10.96.54.205   <none>        1883/TCP,8883/TCP,8081/TCP,8083/TCP,8084/TCP,18083/TCP   58s\n  ```\n* 使用 Service 提供的 IP 查看 EMQX Broker 的 API\n\n  ```\n  $ curl 10.96.54.205:8081/status\n  Node emqx-deployment-68fcb4bfd6-2nhh6@192.168.77.120 is started\n  emqx is running\n  ```\n\n　　至此，单个 EMQX Broker 节点在 kubernetes 上部署完毕，通过 Deployment 管理 EMQX Broker Pod，通过 Service 将 EMQX Broker 服务暴露出去。\n\n## 通过 kubernetes 自动集群 EMQX MQTT 服务器\n\n　　上文中通过 Deployment 部署了单个的 EMQX Broker Pod，通过 Deployment 扩展 Pod 的数量是极为方便的，执行 `kubectl scale deployment ${deployment_name} --replicas ${numer}`​ 命令即可扩展 Pod 的数量，下面将 EMQX Broker Pod 扩展为 3 个：\n\n```\n$ kubectl scale deployment emqx-deployment --replicas 3\ndeployment.apps/emqx-deployment scaled\n\n$ kubectl get pods\nNAME                               READY   STATUS    RESTARTS   AGE\nemqx-deployment-68fcb4bfd6-2nhh6   1/1     Running   0          18m\nemqx-deployment-68fcb4bfd6-mpvch   1/1     Running   0          6s\nemqx-deployment-68fcb4bfd6-mx55q   1/1     Running   0          6s\n\n$ kubectl exec emqx-deployment-68fcb4bfd6-2nhh6 -- emqx_ctl status\nNode 'emqx-deployment-68fcb4bfd6-2nhh6@192.168.77.120' is started\nemqx 4.1-rc.1 is running\n\n$ kubectl exec emqx-deployment-68fcb4bfd6-2nhh6 -- emqx_ctl cluster status\nCluster status: #{running_nodes =>\n                      ['emqx-deployment-68fcb4bfd6-2nhh6@192.168.77.120'],\n                  stopped_nodes => []}\n```\n\n　　可以看到 EMQX Broker Pod 的数量被扩展为 3 个，但是每个 Pod 都是独立的，并没有集群，接下来尝试通过 kubernetes 自动集群 EMQX Broker Pod。\n\n### 修改 EMQX Broker 的配置\n\n　　查看 EMQX Broker 文档中关于[自动集群](https://docs.emqx.com/zh/emqx/latest/deploy/cluster/introduction.html)的内容，可以看到需要修改 EMQX Broker 的配置：\n\n```\ncluster.discovery = kubernetes\ncluster.kubernetes.apiserver = http://10.110.111.204:8080\ncluster.kubernetes.service_name = ekka\ncluster.kubernetes.address_type = ip\ncluster.kubernetes.app_name = ekka\n```\n\n　　其中 `cluster.kubernetes.apiserver`​ 为 kubernetes apiserver 的地址，可以通过 `kubectl cluster-info`​ 命令获取，`cluster.kubernetes.service_name`​ 为上文中 Service 的 name， `cluster.kubernetes.app_name`​ 为 EMQX Broker 的 `node.name`​ 中 `@`​ 符号之前的部分，所以还需要将集群中 EMQX Broker 设置为统一的 `node.name`​ 的前缀。\n\n　　EMQX Broker 的 docker 镜像提供了通过环境变量修改配置的功能，具体可以查看 [docker hub](https://hub.docker.com/r/emqx/emqx) 或 [Github](https://github.com/emqx/emqx-rel/blob/master/deploy/docker/README.md)。\n\n* 修改 Deployment 的 yaml 文件，增加环境变量：\n\n  ```\n  $ cat deployment.yaml\n\n  apiVersion: apps/v1\n  kind: Deployment\n  metadata:\n    name: emqx-deployment\n    labels:\n      app: emqx\n  spec:\n    replicas: 3\n    selector:\n      matchLabels:\n        app: emqx\n    template:\n      metadata:\n        labels:\n          app: emqx\n      spec:\n        containers:\n        - name: emqx\n          image: emqx/emqx:v4.1-rc.1\n          ports:\n          - name: mqtt\n            containerPort: 1883\n          - name: mqttssl\n            containerPort: 8883\n          - name: mgmt\n            containerPort: 8081\n          - name: ws\n            containerPort: 8083\n          - name: wss\n            containerPort: 8084\n          - name: dashboard\n            containerPort: 18083\n          env:\n          - name: EMQX_NAME\n            value: emqx\n          - name: EMQX_CLUSTER__DISCOVERY\n            value: k8s\n          - name: EMQX_CLUSTER__K8S__APP_NAME\n            value: emqx\n          - name: EMQX_CLUSTER__K8S__SERVICE_NAME\n            value: emqx-service\n          - name: EMQX_CLUSTER__K8S__APISERVER\n            value: \"https://kubernetes.default.svc:443\"\n          - name: EMQX_CLUSTER__K8S__NAMESPACE\n            value: default\n  ```\n\n  > 因为 ``kubectl scale deployment ${deployment_name} --replicas ${numer}`命令不会修改 yaml 文件，所以修改 yaml 时需要设置`​spec.replicas: 3` 。\n  >\n  > Pod 中内建 kubernetes 的 DNS 规则，所以 `https://kubernetes.default.svc:443`​ 会被解析为 kubernetes apiserver  的地址。\n  >\n* 删除之前的 Deployment，重新部署：\n\n  ```\n  $ kubectl delete deployment emqx-deployment\n  deployment.apps \"emqx-deployment\" deleted\n\n  $ kubectl apply -f deployment.yaml\n  deployment.apps/emqx-deployment created\n  ```\n\n### 赋予 Pod 访问 kubernetes apiserver 的权限\n\n　　上文部署 Deployment 之后，查看 EMQX Broker 的状态，可以看到 EMQX Broker 虽然成功启动了，但是依然没有集群成功，查看 EMQX Broker Pod 的 log：\n\n```\n$ kubectl get pods\nNAME                               READY   STATUS    RESTARTS   AGE\nemqx-deployment-5c8cfc4d75-67lmt   1/1     Running   0          5s\nemqx-deployment-5c8cfc4d75-r6jgb   1/1     Running   0          5s\nemqx-deployment-5c8cfc4d75-wv2hj   1/1     Running   0          5s\n\n$ kubectl exec emqx-deployment-5c8cfc4d75-67lmt -- emqx_ctl status\nNode 'emqx@192.168.87.150' is started\nemqx 4.1-rc.1 is running\n\n$ kubectl exec emqx-deployment-5c8cfc4d75-67lmt -- emqx_ctl cluster status\nCluster status: #{running_nodes => ['emqx@192.168.87.150'],\n                  stopped_nodes => []}\n\n$ kubectl logs emqx-deployment-76f6895c46-4684f\n\n···\n(emqx@192.168.87.150)1> 2020-05-20 01:48:39.726 [error] Ekka(AutoCluster): Discovery error: {403,\n                                     \"{\\\"kind\\\":\\\"Status\\\",\\\"apiVersion\\\":\\\"v1\\\",\\\"metadata\\\":{},\\\"status\\\":\\\"Failure\\\",\\\"message\\\":\\\"endpoints \\\\\\\"emqx-service\\\\\\\" is forbidden: User \\\\\\\"system:serviceaccount:default:default\\\\\\\" cannot get resource \\\\\\\"endpoints\\\\\\\" in API group \\\\\\\"\\\\\\\" in the namespace \\\\\\\"default\\\\\\\"\\\",\\\"reason\\\":\\\"Forbidden\\\",\\\"details\\\":{\\\"name\\\":\\\"emqx-service\\\",\\\"kind\\\":\\\"endpoints\\\"},\\\"code\\\":403}\\n\"}\n···\n```\n\n　　Pod 因为权限问题在访问 kubernetes apiserver 的时候被拒绝，返回 HTTP 403，所以集群失败。\n\n　　普通 Pod 是无法访问 kubernetes apiserver 的，解决这个问题有两种方法，一种是开放 kubernetes apiserver 的 http 接口，但是这种方法存在一定的安全隐患，另外一种是通过 ServiceAccount、Role 和 RoleBinding 配置 RBAC 鉴权。\n\n* 定义  ServiceAccount、Role 和 RoleBinding：\n\n  ```\n  $ cat rbac.yaml\n\n  apiVersion: v1\n  kind: ServiceAccount\n  metadata:\n    namespace: default\n    name: emqx\n  ---\n  kind: Role\n  apiVersion: rbac.authorization.kubernetes.io/v1beta1\n  metadata:\n    namespace: default\n    name: emqx\n  rules:\n  - apiGroups:\n    - \"\"\n    resources:\n    - endpoints \n    verbs: \n    - get\n    - watch\n    - list\n  ---\n  kind: RoleBinding\n  apiVersion: rbac.authorization.kubernetes.io/v1beta1\n  metadata:\n    namespace: default\n    name: emqx\n  subjects:\n    - kind: ServiceAccount\n      name: emqx\n      namespace: default\n  roleRef:\n    kind: Role\n    name: emqx\n    apiGroup: rbac.authorization.kubernetes.io\n  ```\n* 部署相应的资源：\n\n  ```\n  $ kubectl apply -f rbac.yaml\n  serviceaccount/emqx created\n  role.rbac.authorization.kubernetes.io/emqx created\n  rolebinding.rbac.authorization.kubernetes.io/emqx created\n  ```\n* 修改 Deployment 的 yaml 文件，增加 `spec.template.spec.serviceAccountName`​，并重新部署：\n\n  ```\n  $cat deployment.yaml\n\n  apiVersion: apps/v1\n  kind: Deployment\n  metadata:\n    name: emqx-deployment\n    labels:\n      app: emqx\n  spec:\n    replicas: 3\n    selector:\n      matchLabels:\n        app: emqx\n    template:\n      metadata:\n        labels:\n          app: emqx\n      spec:\n        serviceAccountName: emqx\n        containers:\n        - name: emqx\n          image: emqx/emqx:v4.1-rc.1\n          ports:\n          - name: mqtt\n            containerPort: 1883\n          - name: mqttssl\n            containerPort: 8883\n          - name: mgmt\n            containerPort: 8081\n          - name: ws\n            containerPort: 8083\n          - name: wss\n            containerPort: 8084\n          - name: dashboard\n            containerPort: 18083\n          env:\n          - name: EMQX_NAME\n            value: emqx\n          - name: EMQX_CLUSTER__DISCOVERY\n            value: kubernetes\n          - name: EMQX_CLUSTER__K8S__APP_NAME\n            value: emqx\n          - name: EMQX_CLUSTER__K8S__SERVICE_NAME\n            value: emqx-service\n          - name: EMQX_CLUSTER__K8S__APISERVER\n            value: \"https://kubernetes.default.svc:443\"\n          - name: EMQX_CLUSTER__K8S__NAMESPACE\n            value: default\n\n  $ kubectl delete deployment emqx-deployment\n  deployment.apps \"emqx-deployment\" deleted\n\n  $ kubectl apply -f deployment.yaml\n  deployment.apps/emqx-deployment created\n  ```\n* 查看状态：\n\n  ```\n  $ kubectl get pods\n  NAME                              READY   STATUS    RESTARTS   AGE\n  emqx-deployment-6b854486c-dhd7p   1/1     Running   0          10s\n  emqx-deployment-6b854486c-psv2r   1/1     Running   0          10s\n  emqx-deployment-6b854486c-tdzld   1/1     Running   0          10s\n\n  $ kubectl exec emqx-deployment-6b854486c-dhd7p  -- emqx_ctl status\n  Node 'emqx@192.168.77.92' is started\n  emqx 4.1-rc.1 is running\n\n  $ kubectl exec emqx-deployment-6b854486c-dhd7p  -- emqx_ctl cluster status\n  Cluster status: #{running_nodes =>\n                        ['emqx@192.168.77.115','emqx@192.168.77.92',\n                         'emqx@192.168.87.157'],\n                    stopped_nodes => []}\n  ```\n* 中止一个 Pod：\n\n  ```\n  $ kubectl delete pods emqx-deployment-6b854486c-dhd7p\n  pod \"emqx-deployment-6b854486c-dhd7p\" deleted\n\n  $ kubectl get pods\n  NAME                              READY   STATUS    RESTARTS   AGE\n  emqx-deployment-6b854486c-846v7   1/1     Running   0          56s\n  emqx-deployment-6b854486c-psv2r   1/1     Running   0          3m50s\n  emqx-deployment-6b854486c-tdzld   1/1     Running   0          3m50s\n\n  $ kubectl exec emqx-deployment-6b854486c-846v7 -- emqx_ctl cluster status\n  Cluster status: #{running_nodes =>\n                        ['emqx@192.168.77.115','emqx@192.168.77.84',\n                         'emqx@192.168.87.157'],\n                    stopped_nodes => ['emqx@192.168.77.92']}\n  ```\n\n  输出结果表明 EMQX Broker 会正确的显示已经停掉的 Pod，并将 Deployment 新建的 Pod 加入集群。\n\n　　至此，EMQX Broker 在 kubernetes 上成功建立集群。\n\n## 持久化 EMQX Broker 集群\n\n　　上文中使用的 Deployment 来管理 Pod，但是 Pod 的网络是不停变动的，而且当 Pod 被销毁重建时，储存在 EMQX Broker 的数据和配置也就随之消失了，这在生产中是不能接受的，接下来尝试把 EMQX Broker 的集群持久化，即使 Pod 被销毁重建，EMQX Broker 的数据依然可以保存下来。\n\n### ConfigMap\n\n　　[ConfigMap](https://kubernetes.io/zh-cn/docs/concepts/configuration/configmap/) 是 configMap 是一种 API 对象，用来将非机密性的数据保存到健值对中。使用时可以用作环境变量、命令行参数或者存储卷中的配置文件。\n\n　　ConfigMap 将您的环境配置信息和 [容器镜像](https://kubernetes.io/docs/concepts/overview/#why-containers) 解耦，便于应用配置的修改。\n\n> ConfigMap 并不提供保密或者加密功能。如果你想存储的数据是机密的，请使用 [Secret](https://kubernetes.io/docs/concepts/configuration/secret/) ，或者使用其他第三方工具来保证你的数据的私密性，而不是用 ConfigMap。\n\n　　接下来使用 ConfigMap 记录 EMQX Broker 的配置，并将它们以环境变量的方式导入到 Deployment 中。\n\n* 定义 Configmap，并部署：\n\n  ```\n  $cat configmap.yaml\n\n  apiVersion: v1\n  kind: ConfigMap\n  metadata:\n    name: emqx-config\n  data:\n    EMQX_CLUSTER__K8S__ADDRESS_TYPE: \"hostname\"\n    EMQX_CLUSTER__K8S__APISERVER: \"https://kubernetes.default.svc:443\"\n    EMQX_CLUSTER__K8S__SUFFIX: \"svc.cluster.local\"\n\n  $ kubectl apply -f configmap.yaml\n  configmap/emqx-config created\n  ```\n* 配置 Deployment 来使用 Configmap\n\n  ```\n  $cat deployment.yaml\n\n  apiVersion: apps/v1\n  kind: Deployment\n  metadata:\n    name: emqx-deployment\n    labels:\n      app: emqx\n  spec:\n    replicas: 3\n    selector:\n      matchLabels:\n        app: emqx\n    template:\n      metadata:\n        labels:\n          app: emqx\n      spec:\n        serviceAccountName: emqx\n        containers:\n        - name: emqx\n          image: emqx/emqx:v4.1-rc.1\n          ports:\n          - name: mqtt\n            containerPort: 1883\n          - name: mqttssl\n            containerPort: 8883\n          - name: mgmt\n            containerPort: 8081\n          - name: ws\n            containerPort: 8083\n          - name: wss\n            containerPort: 8084\n          - name: dashboard\n            containerPort: 18083\n          envFrom:\n            - configMapRef:\n                name: emqx-config\n  ```\n* 重新部署 Deployment，查看状态\n\n  ```\n  $ kubectl delete -f deployment.yaml\n  deployment.apps \"emqx-deployment\" deleted\n\n  $ kubectl apply -f deployment.yaml\n  deployment.apps/emqx-deployment created\n\n  $ kubectl get pods\n  NAME                               READY   STATUS    RESTARTS   AGE\n  emqx-deployment-5c7696b5d7-k9lzj   1/1     Running   0          3s\n  emqx-deployment-5c7696b5d7-mdwkt   1/1     Running   0          3s\n  emqx-deployment-5c7696b5d7-z57z7   1/1     Running   0          3s\n\n  $ kubectl exec emqx-deployment-5c7696b5d7-k9lzj -- emqx_ctl status\n  Node 'emqx@192.168.87.149' is started\n  emqx 4.1-rc.1 is running\n\n  $ kubectl exec emqx-deployment-5c7696b5d7-k9lzj -- emqx_ctl cluster status\n  Cluster status: #{running_nodes =>\n                        ['emqx@192.168.77.106','emqx@192.168.77.107',\n                         'emqx@192.168.87.149'],\n                    stopped_nodes => []}\n  ```\n\n　　EMQX Broker 的配置文件已经解耦到 Configmap 中了，如果有需要，可以自由的配置一个或多个 Configmap，并把它们作为环境变量或是文件引入到 Pod 内。\n\n### StatefulSet\n\n　　[StatefulSet](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/statefulset/) 是为了解决有状态服务的问题（对应 Deployments 和 ReplicaSets 是为无状态服务而设计），其应用场景包括\n\n* 稳定的持久化存储，即 Pod 重新调度后还是能访问到相同的持久化数据，基于 PVC 来实现\n* 稳定的网络标志，即 Pod 重新调度后其 PodName 和 HostName 不变，基于 Headless Service（即没有Cluster IP的Service）来实现\n* 有序部署，有序扩展，即 Pod 是有顺序的，在部署或者扩展的时候要依据定义的顺序依次依次进行（即从0到N-1，在下一个Pod运行之前所有之前的 Pod 必须都是 Running 和 Ready 状态），基于 init containers 来实现\n* 有序收缩，有序删除（即从N-1到0）\n\n　　从上面的应用场景可以发现，StatefulSet由以下几个部分组成：\n\n* 用于定义网络标志（DNS domain）的 Headless Service\n* 用于创建 PersistentVolumes 的 volumeClaimTemplates\n* 定义具体应用的 StatefulSet\n\n　　StatefulSet 中每个 Pod 的 DNS 格式为 `statefulSetName-{0..N-1}.serviceName.namespace.svc.cluster.local`​ ，其中\n\n* ​`serviceName`​ 为 Headless Service 的名字\n* ​`0..N-1`​ 为 Pod 所在的序号，从 0 开始到 N-1\n* ​`statefulSetName`​ 为StatefulSet的名字\n* ​`namespace`​ 为服务所在的 namespace，Headless Servic 和 StatefulSet 必须在相同的 namespace\n* ​`.cluster.local`​ 为 Cluster Domain\n\n　　接下来使用 StatefulSet 代替 Deployment 来管理 Pod。\n\n* 删除 Deployment：\n\n  ```\n  $ kubectl delete deployment emqx-deployment\n  deployment.apps \"emqx-deployment\" deleted\n  ```\n* 定义 StatefulSet：\n\n  ```\n  $cat statefulset.yaml\n\n  apiVersion: apps/v1\n  kind: StatefulSet\n  metadata:\n    name: emqx-statefulset\n    labels:\n      app: emqx\n  spec:\n    serviceName: emqx-headless\n    updateStrategy:\n      type: RollingUpdate\n    replicas: 3\n    selector:\n      matchLabels:\n        app: emqx\n    template:\n      metadata:\n        labels:\n          app: emqx\n      spec:\n        serviceAccountName: emqx\n        containers:\n        - name: emqx\n          image: emqx/emqx:v4.1-rc.1\n          ports:\n          - name: mqtt\n            containerPort: 1883\n          - name: mqttssl\n            containerPort: 8883\n          - name: mgmt\n            containerPort: 8081\n          - name: ws\n            containerPort: 8083\n          - name: wss\n            containerPort: 8084\n          - name: dashboard\n            containerPort: 18083\n          envFrom:\n            - configMapRef:\n                name: emqx-config\n  ```\n\n  注意，StatefulSet 需要 Headless Service 来实现稳定的网络标志，因此需要再定义一个 Service\n\n  ```\n  $cat headless.yaml\n\n  apiVersion: v1\n  kind: Service\n  metadata:\n    name: emqx-headless\n  spec:\n    type: ClusterIP\n    clusterIP: None\n    selector:\n      app: emqx\n    ports:\n    - name: mqtt\n      port: 1883\n      protocol: TCP\n      targetPort: 1883\n    - name: mqttssl\n      port: 8883\n      protocol: TCP\n      targetPort: 8883\n    - name: mgmt\n      port: 8081\n      protocol: TCP\n      targetPort: 8081\n    - name: websocket\n      port: 8083\n      protocol: TCP\n      targetPort: 8083\n    - name: wss\n      port: 8084\n      protocol: TCP\n      targetPort: 8084\n    - name: dashboard\n      port: 18083\n      protocol: TCP\n      targetPort: 18083\n  ```\n\n  因为 Headless Service 并不需要 IP，所以配置了 `clusterIP: None`​ 。\n* 部署相应的资源：\n\n  ```\n  $ kubectl apply -f headless-service.yaml\n  service/emqx-headless created\n\n  $ kubectl apply -f statefulset.yaml\n  statefulset.apps/emqx-deployment created\n\n  $ kubectl get pods\n  NAME                               READY   STATUS    RESTARTS   AGE\n  emqx-statefulset-0                 1/1     Running   0          2m59s\n  emqx-statefulset-1                 1/1     Running   0          2m57s\n  emqx-statefulset-2                 1/1     Running   0          2m54s\n\n  $ kubectl exec emqx-statefulset-0 -- emqx_ctl cluster status\n  Cluster status: #{running_nodes =>\n                        ['emqx@192.168.77.105','emqx@192.168.87.153',\n                         'emqx@192.168.87.155'],\n                    stopped_nodes => []}\n  ```\n* 更新 Configmap：  \n  StatefulSet 提供了稳定的网络标志，EMQX Broker 支持使用 hostname 和 dns 规则来代提 IP 实现集群，以 hostname 为例，需要修改 `emqx.conf`​：\n\n  ```\n  cluster.kubernetes.address_type = hostname\n  cluster.kubernetes.suffix = \"svc.cluster.local\"\n  ```\n\n  kubernetes 集群中 Pod 的 DNS 规则可以由用户自定义，EMQX Broker 提供了  `cluster.kubernetes.suffix`​ 方便用户匹配自定的 DNS 规则，本文使用默认的 DNS 规则：`statefulSetName-{0..N-1}.serviceName.namespace.svc.cluster.local`​ ，DNS 规则中的 serviceName 为 StatefulSet 使用的 Headless Service，所以还需要将 `cluster.kubernetes.service_name`​  修改为 Headless Service Name。  \n  将配置项转为环境变量，需要在 Configmap 中配置：\n\n  ```\n  EMQX_CLUSTER__K8S__ADDRESS_TYPE: \"hostname\"\n  EMQX_CLUSTER__K8S__SUFFIX: \"svc.cluster.local\"\n  EMQX_CLUSTER__K8S__SERVICE_NAME: emqx-headless\n  ```\n\n  Configmap 提供了热更新功能，执行 `$ kubectl edit configmap emqx-config`​ 来热更新 Configmap。\n* 重新部署 StatefulSet：  \n  Configmap 更新之后 Pod 并不会重启，需要我们手动更新 StatefulSet\n\n  ```\n  $ kubectl delete statefulset emqx-statefulset\n  statefulset.apps \"emqx-statefulset\" deleted\n\n  $ kubectl apply -f statefulset.yaml\n  statefulset.apps/emqx-statefulset created\n\n  $ kubectl get pods\n  NAME                 READY   STATUS    RESTARTS   AGE\n  emqx-statefulset-0   1/1     Running   0          115s\n  emqx-statefulset-1   1/1     Running   0          112s\n  emqx-statefulset-2   1/1     Running   0          110s\n\n  $ kubectl exec emqx-statefulset-2 -- emqx_ctl cluster status\n  Cluster status: #{running_nodes =>\n                        ['emqx@emqx-statefulset-0.emqx-headless.default.svc.cluster.local',\n                         'emqx@emqx-statefulset-1.emqx-headless.default.svc.cluster.local',\n                         'emqx@emqx-statefulset-2.emqx-headless.default.svc.cluster.local'],\n                    stopped_nodes => []}\n  ```\n\n  可以看到新的 EMQX Broker 集群已经成功的建立起来了。\n* 中止一个 Pod：  \n  StatefulSet 中的 Pod 重新调度后其 PodName 和 HostName 不变，下面来尝试一下：\n\n  ```\n  $ kubectl get pods\n  kuNAME                 READY   STATUS    RESTARTS   AGE\n  emqx-statefulset-0   1/1     Running   0          6m20s\n  emqx-statefulset-1   1/1     Running   0          6m17s\n  emqx-statefulset-2   1/1     Running   0          6m15s\n\n  $ kubectl delete pod emqx-statefulset-0\n  pod \"emqx-statefulset-0\" deleted\n\n  $ kubectl get pods\n  NAME                 READY   STATUS    RESTARTS   AGE\n  emqx-statefulset-0   1/1     Running   0          27s\n  emqx-statefulset-1   1/1     Running   0          9m45s\n  emqx-statefulset-2   1/1     Running   0          9m43s\n\n  $ kubectl exec emqx-statefulset-2 -- emqx_ctl cluster status\n  Cluster status: #{running_nodes =>\n                        ['emqx@emqx-statefulset-0.emqx-headless.default.svc.cluster.local',\n                         'emqx@emqx-statefulset-1.emqx-headless.default.svc.cluster.local',\n                         'emqx@emqx-statefulset-2.emqx-headless.default.svc.cluster.local'],\n                    stopped_nodes => []}\n  ```\n\n  跟预期的一样，StatefulSet 重新调度了一个具有相同网络标志的 Pod，Pod 中的 EMQX Broker 也成功的加入了集群。\n\n## StorageClasses、PersistentVolume 和 PersistentVolumeClaim\n\n　　PersistentVolume（PV）是由管理员设置的存储，它是群集的一部分。就像节点是集群中的资源一样，PV 也是集群中的资源。 PV 是 Volume 之类的卷插件，但具有独立于使用 PV 的 Pod 的生命周期。此 API  对象包含存储实现的细节，即 NFS、iSCSI 或特定于云供应商的存储系统。\n\n　　PersistentVolumeClaim（PVC）是用户存储的请求。它与 Pod 相似。Pod 消耗节点资源，PVC 消耗 PV 资源。Pod 可以请求特定级别的资源（CPU 和内存）。声明可以请求特定的大小和访问模式（例如，可以以读/写一次或 只读多次模式挂载）。\n\n　　StorageClass 为管理员提供了描述存储 \"class（类）\" 的方法。 不同的 class  可能会映射到不同的服务质量等级或备份策略，或由群集管理员确定的任意策略。 Kubernetes 本身不清楚各种 class  代表的什么。这个概念在其他存储系统中有时被称为“配置文件”。\n\n　　在部署 EMQX Broker 的时候，可以预先创建好 PV 或 StorageClass，然后利用 PVC 将 EMQX Broker 的 `/opt/emqx/data/mnesia`​ 目录挂载出来，当Pods被重新调度之后，EMQX 会从 `/opt/emqx/data/mnesia`​ 目录中获取数据并恢复，从而实现 EMQX Broker 的持久化。\n\n* 定义 StatefulSet\n\n  ```\n  $cat statefulset.yaml\n\n  apiVersion: apps/v1\n  kind: StatefulSet\n  metadata:\n    name: emqx-statefulset\n    labels:\n      app: emqx\n  spec:\n    replicas: 3\n    serviceName: emqx-headless\n    updateStrategy:\n      type: RollingUpdate\n    selector:\n      matchLabels:\n        app: emqx\n    template:\n      metadata:\n        labels:\n          app: emqx\n      spec:\n        volumes:\n        - name: emqx-data\n          persistentVolumeClaim:\n            claimName: emqx-pvc\n        serviceAccountName: emqx\n        containers:\n        - name: emqx\n          image: emqx/emqx:v4.1-rc.1\n          ports:\n          - name: mqtt\n            containerPort: 1883\n          - name: mqttssl\n            containerPort: 8883\n          - name: mgmt\n            containerPort: 8081\n          - name: ws\n            containerPort: 8083\n          - name: wss\n            containerPort: 8084\n          - name: dashboard\n            containerPort: 18083\n          envFrom:\n            - configMapRef:\n                name: emqx-config\n          volumeMounts:\n          - name: emqx-data\n            mountPath: \"/opt/emqx/data/mnesia\"\n    volumeClaimTemplates:\n    - metadata:\n        name: emqx-pvc\n        annotations:\n          volume.alpha.kubernetes.io/storage-class: manual\n      spec:\n        accessModes: [ \"ReadWriteOnce\" ]\n        resources:\n          requests:\n            storage: 1Gi\n  ```\n\n  该文件首先通过 `volumeClaimTemplates`​ 指定了使用 StorageClass 的 name 为 manual 的存储类创建名称为 emqx-pvc 的 PVC 资源，PVC 资源的读写模式为 `ReadWriteOnce`​，需要 1Gi 的空间，然后将此 PVC 定义为 name 为 emqx-data 的 volumes，并将此 volumes 挂载在 Pod 中的 `/opt/emqx/data/mnesia`​  目录下。\n* 部署资源：  \n  部署 StatefulSet 之前，需要用户或 kubernetes 集群管理员自行创建存储类。\n\n  ```\n  $ kubectl apply -f statefulset.yaml\n  statefulset.apps/emqx-statefulset created\n\n  $ kubectl get pods\n  NAME                 READY   STATUS    RESTARTS   AGE\n  emqx-statefulset-0   1/1     Running   0          27s\n  emqx-statefulset-1   1/1     Running   0          9m45s\n  emqx-statefulset-2   1/1     Running   0          9m43s\n\n  $ kubectl get pvc\n  NAME                                 STATUS    VOLUME                                 CAPACITY   ACCESS MODES   STORAGECLASS   AGE\n  emqx-data-emqx-statefulset-0   Bound     pvc-8094cd75-adb5-11e9-80cc-0697b59e8064   1Gi        RWO            gp2            2m11s\n  emqx-data-emqx-statefulset-0   Bound     pvc-9325441d-adb5-11e9-80cc-0697b59e8064   1Gi        RWO            gp2            99s\n  emqx-data-emqx-statefulset-0   Bound     pvc-ad425e9d-adb5-11e9-80cc-0697b59e8064   1Gi        RWO            gp2            56s\n  ```\n\n  输出结果表明该 PVC 的状态为 Bound，PVC 存储已经成功的建立了，当 Pod 被重新调度时，EMQX Broker 会读取挂载到 PVC 中的数据，从而实现持久化。\n\n　　EMQX Broker 在 kubernetes 上建立持久化的集群就完成了，本文略过了部分细节，部署的过程也是偏向简单的 Demo，用户可以自行阅读 [kubernetes 文档](https://kubernetes.io/zh-cn/docs/home/) 与  EMQX Team 提供的 [Helm chart 源码](https://github.com/emqx/emqx-rel/tree/master/deploy/charts/emqx) 来继续深入研究，当然也欢迎在 Github 贡献 issue、pull requests 以及 start。\n\n\n\n```yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: emqx-deployment\n  labels:\n    app: emqx\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: emqx\n  template:\n    metadata:\n      labels:\n        app: emqx\n    spec:\n      containers:\n      - name: emqx\n        image: emqx/emqx:5.7\n        ports:\n        - name: mqtt\n          containerPort: 1883\n        - name: mqttssl\n          containerPort: 8883\n        - name: mgmt\n          containerPort: 8081\n        - name: ws\n          containerPort: 8083\n        - name: wss\n          containerPort: 8084\n        - name: dashboard\n          containerPort: 18083\n\n```\n","source":"_posts/20250501/5.md","raw":"---\ntitle: EMQX K3s 安装\ndate: 2025-05-01 16:57:07\nlastmod: 2025-05-01 16:57:07\ntags: [K3S,EMQX]\ncategory: K3S\n---\n\n\n\n# 从零开始建立 EMQX MQTT 服务器的 K8S 集群\n\n<iframe src=\"/widgets/metadata/\" data-src=\"/widgets/metadata/\" data-subtype=\"widget\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" style=\"height: 441px;\"></iframe>\n\n---\n\n* 从零开始建立 EMQX MQTT 服务器的 K8S 集群 - www.emqx.com\n* [https://www.emqx.com/zh/blog/emqx-mqtt-broker-k8s-cluster](https://www.emqx.com/zh/blog/emqx-mqtt-broker-k8s-cluster)\n* 本文将从零开始部署一个 EMQX MQTT 服务器的 K8S 集群，并分析部署中的细节与技巧，方便用户在实际部署中灵活使用。\n* 2024-06-28 10:42:05\n\n---\n\n　　EMQX Team 提供了 Helm chart 方便用户在 kubernetes 集群上一键部署 EMQX [MQTT 服务器](https://www.emqx.com/zh/products/emqx), 这是 EMQX Team 最推荐的在 kubernetes 或 k3s 集群上部署 EMQX MQTT 服务器的方法。 本文将使用手写 yaml 文件的方法从零开始部署一个 EMQX MQTT 服务器的 K8S 集群, 分析部署中的细节与技巧，方便用户在实际部署中灵活使用。\n\n　　阅读本文需要用户了解 kubernetes 的基本概念，并有一个可操作的 kubernetes 集群。\n\n## 在 K8S 上部署单个 EMQX MQTT服务器节点\n\n### 使用 Pod 直接部署 EMQX Broker\n\n　　在Kubernetes中，最小的管理元素不是一个个独立的容器，而是 [Pod](https://kubernetes.io/zh/docs/concepts/workloads/pods/pod-overview/)，Pod 是 Kubernetes 应用程序的基本执行单元，即它是 Kubernetes 对象模型中创建或部署的最小和最简单的单元。Pod 表示在 [集群](https://kubernetes.io/zh-cn/docs/reference/glossary/?all=true#term-cluster) 上运行的进程。\n\n　　EMQX Broker 在 [docker hub](https://hub.docker.com/r/emqx/emqx) 上提供了镜像, 因此可以很方便的在单个的 pod 上部署 EMQX Broker，使用 `kubectl run`​ 命令创建一个运行着 EMQX Broker 的 Pod：\n\n```\n$ kubectl run emqx --image=emqx/emqx:v4.1-rc.1  --generator=run-pod/v1\npod/emqx created\n```\n\n　　查看 EMQX Broker 的状态：\n\n```\n$ kubectl get pods -o wide\nNAME   READY   STATUS    RESTARTS   AGE\nemqx   1/1     Running   0          3m13s\n\n$ kubectl exec emqx -- emqx_ctl status\nNode 'emqx@192.168.77.108' is started\nemqx 4.1-rc.1 is running\n```\n\n　　删除 Pod：\n\n```\n$ kubectl delete pods emqx\npod \"emqx\" deleted\n```\n\n　　Pod 并不是被设计成一个持久化的资源，它不会在调度失败，节点崩溃，或者其他回收中（比如因为资源的缺乏，或者其他的维护中）幸存下来，因此，还需要一个控制器来管理 Pod。\n\n### 使用 Deoloyment 部署 Pod\n\n　　[Deployment](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/) 为 Pod 和 ReplicaSet 提供了一个声明式定义（declarative）方法，用来替代以前的[ReplicationController](https://www.kubernetes.org.cn/replication-controller-kubernetes) 来方便的管理应用。典型的应用场景包括：\n\n* 定义Deployment来创建Pod和ReplicaSet\n* 滚动升级和回滚应用\n* 扩容和缩容\n* 暂停和继续Deployment\n\n　　使用 Deployment 部署一个 EMQX Broker Pod：\n\n* 定义 Deployment：\n\n  ```\n  $ cat deployment.yaml\n\n  apiVersion: apps/v1\n  kind: Deployment\n  metadata:\n    name: emqx-deployment\n    labels:\n      app: emqx\n  spec:\n    replicas: 1\n    selector:\n      matchLabels:\n        app: emqx\n    template:\n      metadata:\n        labels:\n          app: emqx\n      spec:\n        containers:\n        - name: emqx\n          image: emqx/emqx:v4.1-rc.1\n          ports:\n          - name: mqtt\n            containerPort: 1883\n          - name: mqttssl\n            containerPort: 8883\n          - name: mgmt\n            containerPort: 8081\n          - name: ws\n            containerPort: 8083\n          - name: wss\n            containerPort: 8084\n          - name: dashboard\n            containerPort: 18083\n  ```\n* 部署 Deployment：\n\n  ```\n  $  kubectl apply -f deployment.yaml\n  deployment.apps/emqx-deployment created\n  ```\n* 查看部署情况：\n\n  ```\n  $ kubectl get deployment\n  NAME                              READY   UP-TO-DATE   AVAILABLE   AGE\n  deployment.apps/emqx-deployment   3/3     3            3           74s\n\n  $ kubectl get pods\n  NAME                                  READY   STATUS    RESTARTS   AGE\n  pod/emqx-deployment-7c44dbd68-8j77l   1/1     Running   0          74s\n\n  $ kubectl exec pod/emqx-deployment-7c44dbd68-8j77l -- emqx_ctl status\n  Node 'emqx-deployment-7c44dbd68-8j77l@192.168.77.117' is started\n  emqx 4.1-rc.1 is running\n  ```\n* 尝试手动删除 Pod\n\n  ```\n  $ kubectl delete pods emqx-deployment-7c44dbd68-8j77l\n  pod \"emqx-deployment-7c44dbd68-8j77l\" deleted\n\n  $ kubectl get pods\n  NAME                              READY   STATUS    RESTARTS   AGE\n  emqx-deployment-68fcb4bfd6-2nhh6   1/1     Running   0          59s\n  ```\n\n  输出结果表明成功用 Deployment 部署了 EMQX Broker Pod，即使是此 Pod 被意外终止，Deployment 也会重新创建一个新的 Pod。\n\n### 使用 Services 公开 EMQX Broker Pod 服务\n\n　　Kubernetes [Pods](https://kubernetes.io/docs/concepts/workloads/pods/) 是有生命周期的。他们可以被创建，而且销毁不会再启动。 如果使用 [Deployment](https://kubernetes.io/docs/concepts/workloads/controllers/deployment/) 来运行应用程序，则它可以动态创建和销毁 Pod。\n\n　　每个 Pod 都有自己的 IP 地址，但是在 Deployment 中，在同一时刻运行的 Pod 集合可能与稍后运行该应用程序的 Pod 集合不同。\n\n　　这导致了一个问题：如果使用 EMQX Broker Pod 为 **MQTT 客户端**提供服务，那么客户端应该如何如何找出并跟踪要连接的 IP 地址，以便客户端使用 EMQX Broker 服务呢？\n\n　　答案是：Service\n\n　　Service 是将运行在一组 [Pods](https://kubernetes.io/docs/concepts/workloads/pods/) 上的应用程序公开为网络服务的抽象方法。\n\n　　使用 Service 将 EMQX Broker Pod 公开为网络服务：\n\n* 定义 Service：\n\n  ```\n  $cat service.yaml\n\n  apiVersion: v1\n  kind: Service\n  metadata:\n    name: emqx-service\n  spec:\n    selector:\n      app: emqx\n    ports:\n      - name: mqtt\n        port: 1883\n        protocol: TCP\n        targetPort: mqtt\n      - name: mqttssl\n        port: 8883\n        protocol: TCP\n        targetPort: mqttssl\n      - name: mgmt\n        port: 8081\n        protocol: TCP\n        targetPort: mgmt\n      - name: ws\n        port: 8083\n        protocol: TCP\n        targetPort: ws\n      - name: wss\n        port: 8084\n        protocol: TCP\n        targetPort: wss\n      - name: dashboard\n        port: 18083\n        protocol: TCP\n        targetPort: dashboard\n  ```\n* 部署 Service：\n\n  ```\n  $ kubectl apply -f service.yaml\n  service/emqx-service created\n  ```\n* 查看部署情况\n\n  ```\n  $ kubectl get svc\n  NAME           TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)                                        AGE\n  emqx-service   ClusterIP   10.96.54.205   <none>        1883/TCP,8883/TCP,8081/TCP,8083/TCP,8084/TCP,18083/TCP   58s\n  ```\n* 使用 Service 提供的 IP 查看 EMQX Broker 的 API\n\n  ```\n  $ curl 10.96.54.205:8081/status\n  Node emqx-deployment-68fcb4bfd6-2nhh6@192.168.77.120 is started\n  emqx is running\n  ```\n\n　　至此，单个 EMQX Broker 节点在 kubernetes 上部署完毕，通过 Deployment 管理 EMQX Broker Pod，通过 Service 将 EMQX Broker 服务暴露出去。\n\n## 通过 kubernetes 自动集群 EMQX MQTT 服务器\n\n　　上文中通过 Deployment 部署了单个的 EMQX Broker Pod，通过 Deployment 扩展 Pod 的数量是极为方便的，执行 `kubectl scale deployment ${deployment_name} --replicas ${numer}`​ 命令即可扩展 Pod 的数量，下面将 EMQX Broker Pod 扩展为 3 个：\n\n```\n$ kubectl scale deployment emqx-deployment --replicas 3\ndeployment.apps/emqx-deployment scaled\n\n$ kubectl get pods\nNAME                               READY   STATUS    RESTARTS   AGE\nemqx-deployment-68fcb4bfd6-2nhh6   1/1     Running   0          18m\nemqx-deployment-68fcb4bfd6-mpvch   1/1     Running   0          6s\nemqx-deployment-68fcb4bfd6-mx55q   1/1     Running   0          6s\n\n$ kubectl exec emqx-deployment-68fcb4bfd6-2nhh6 -- emqx_ctl status\nNode 'emqx-deployment-68fcb4bfd6-2nhh6@192.168.77.120' is started\nemqx 4.1-rc.1 is running\n\n$ kubectl exec emqx-deployment-68fcb4bfd6-2nhh6 -- emqx_ctl cluster status\nCluster status: #{running_nodes =>\n                      ['emqx-deployment-68fcb4bfd6-2nhh6@192.168.77.120'],\n                  stopped_nodes => []}\n```\n\n　　可以看到 EMQX Broker Pod 的数量被扩展为 3 个，但是每个 Pod 都是独立的，并没有集群，接下来尝试通过 kubernetes 自动集群 EMQX Broker Pod。\n\n### 修改 EMQX Broker 的配置\n\n　　查看 EMQX Broker 文档中关于[自动集群](https://docs.emqx.com/zh/emqx/latest/deploy/cluster/introduction.html)的内容，可以看到需要修改 EMQX Broker 的配置：\n\n```\ncluster.discovery = kubernetes\ncluster.kubernetes.apiserver = http://10.110.111.204:8080\ncluster.kubernetes.service_name = ekka\ncluster.kubernetes.address_type = ip\ncluster.kubernetes.app_name = ekka\n```\n\n　　其中 `cluster.kubernetes.apiserver`​ 为 kubernetes apiserver 的地址，可以通过 `kubectl cluster-info`​ 命令获取，`cluster.kubernetes.service_name`​ 为上文中 Service 的 name， `cluster.kubernetes.app_name`​ 为 EMQX Broker 的 `node.name`​ 中 `@`​ 符号之前的部分，所以还需要将集群中 EMQX Broker 设置为统一的 `node.name`​ 的前缀。\n\n　　EMQX Broker 的 docker 镜像提供了通过环境变量修改配置的功能，具体可以查看 [docker hub](https://hub.docker.com/r/emqx/emqx) 或 [Github](https://github.com/emqx/emqx-rel/blob/master/deploy/docker/README.md)。\n\n* 修改 Deployment 的 yaml 文件，增加环境变量：\n\n  ```\n  $ cat deployment.yaml\n\n  apiVersion: apps/v1\n  kind: Deployment\n  metadata:\n    name: emqx-deployment\n    labels:\n      app: emqx\n  spec:\n    replicas: 3\n    selector:\n      matchLabels:\n        app: emqx\n    template:\n      metadata:\n        labels:\n          app: emqx\n      spec:\n        containers:\n        - name: emqx\n          image: emqx/emqx:v4.1-rc.1\n          ports:\n          - name: mqtt\n            containerPort: 1883\n          - name: mqttssl\n            containerPort: 8883\n          - name: mgmt\n            containerPort: 8081\n          - name: ws\n            containerPort: 8083\n          - name: wss\n            containerPort: 8084\n          - name: dashboard\n            containerPort: 18083\n          env:\n          - name: EMQX_NAME\n            value: emqx\n          - name: EMQX_CLUSTER__DISCOVERY\n            value: k8s\n          - name: EMQX_CLUSTER__K8S__APP_NAME\n            value: emqx\n          - name: EMQX_CLUSTER__K8S__SERVICE_NAME\n            value: emqx-service\n          - name: EMQX_CLUSTER__K8S__APISERVER\n            value: \"https://kubernetes.default.svc:443\"\n          - name: EMQX_CLUSTER__K8S__NAMESPACE\n            value: default\n  ```\n\n  > 因为 ``kubectl scale deployment ${deployment_name} --replicas ${numer}`命令不会修改 yaml 文件，所以修改 yaml 时需要设置`​spec.replicas: 3` 。\n  >\n  > Pod 中内建 kubernetes 的 DNS 规则，所以 `https://kubernetes.default.svc:443`​ 会被解析为 kubernetes apiserver  的地址。\n  >\n* 删除之前的 Deployment，重新部署：\n\n  ```\n  $ kubectl delete deployment emqx-deployment\n  deployment.apps \"emqx-deployment\" deleted\n\n  $ kubectl apply -f deployment.yaml\n  deployment.apps/emqx-deployment created\n  ```\n\n### 赋予 Pod 访问 kubernetes apiserver 的权限\n\n　　上文部署 Deployment 之后，查看 EMQX Broker 的状态，可以看到 EMQX Broker 虽然成功启动了，但是依然没有集群成功，查看 EMQX Broker Pod 的 log：\n\n```\n$ kubectl get pods\nNAME                               READY   STATUS    RESTARTS   AGE\nemqx-deployment-5c8cfc4d75-67lmt   1/1     Running   0          5s\nemqx-deployment-5c8cfc4d75-r6jgb   1/1     Running   0          5s\nemqx-deployment-5c8cfc4d75-wv2hj   1/1     Running   0          5s\n\n$ kubectl exec emqx-deployment-5c8cfc4d75-67lmt -- emqx_ctl status\nNode 'emqx@192.168.87.150' is started\nemqx 4.1-rc.1 is running\n\n$ kubectl exec emqx-deployment-5c8cfc4d75-67lmt -- emqx_ctl cluster status\nCluster status: #{running_nodes => ['emqx@192.168.87.150'],\n                  stopped_nodes => []}\n\n$ kubectl logs emqx-deployment-76f6895c46-4684f\n\n···\n(emqx@192.168.87.150)1> 2020-05-20 01:48:39.726 [error] Ekka(AutoCluster): Discovery error: {403,\n                                     \"{\\\"kind\\\":\\\"Status\\\",\\\"apiVersion\\\":\\\"v1\\\",\\\"metadata\\\":{},\\\"status\\\":\\\"Failure\\\",\\\"message\\\":\\\"endpoints \\\\\\\"emqx-service\\\\\\\" is forbidden: User \\\\\\\"system:serviceaccount:default:default\\\\\\\" cannot get resource \\\\\\\"endpoints\\\\\\\" in API group \\\\\\\"\\\\\\\" in the namespace \\\\\\\"default\\\\\\\"\\\",\\\"reason\\\":\\\"Forbidden\\\",\\\"details\\\":{\\\"name\\\":\\\"emqx-service\\\",\\\"kind\\\":\\\"endpoints\\\"},\\\"code\\\":403}\\n\"}\n···\n```\n\n　　Pod 因为权限问题在访问 kubernetes apiserver 的时候被拒绝，返回 HTTP 403，所以集群失败。\n\n　　普通 Pod 是无法访问 kubernetes apiserver 的，解决这个问题有两种方法，一种是开放 kubernetes apiserver 的 http 接口，但是这种方法存在一定的安全隐患，另外一种是通过 ServiceAccount、Role 和 RoleBinding 配置 RBAC 鉴权。\n\n* 定义  ServiceAccount、Role 和 RoleBinding：\n\n  ```\n  $ cat rbac.yaml\n\n  apiVersion: v1\n  kind: ServiceAccount\n  metadata:\n    namespace: default\n    name: emqx\n  ---\n  kind: Role\n  apiVersion: rbac.authorization.kubernetes.io/v1beta1\n  metadata:\n    namespace: default\n    name: emqx\n  rules:\n  - apiGroups:\n    - \"\"\n    resources:\n    - endpoints \n    verbs: \n    - get\n    - watch\n    - list\n  ---\n  kind: RoleBinding\n  apiVersion: rbac.authorization.kubernetes.io/v1beta1\n  metadata:\n    namespace: default\n    name: emqx\n  subjects:\n    - kind: ServiceAccount\n      name: emqx\n      namespace: default\n  roleRef:\n    kind: Role\n    name: emqx\n    apiGroup: rbac.authorization.kubernetes.io\n  ```\n* 部署相应的资源：\n\n  ```\n  $ kubectl apply -f rbac.yaml\n  serviceaccount/emqx created\n  role.rbac.authorization.kubernetes.io/emqx created\n  rolebinding.rbac.authorization.kubernetes.io/emqx created\n  ```\n* 修改 Deployment 的 yaml 文件，增加 `spec.template.spec.serviceAccountName`​，并重新部署：\n\n  ```\n  $cat deployment.yaml\n\n  apiVersion: apps/v1\n  kind: Deployment\n  metadata:\n    name: emqx-deployment\n    labels:\n      app: emqx\n  spec:\n    replicas: 3\n    selector:\n      matchLabels:\n        app: emqx\n    template:\n      metadata:\n        labels:\n          app: emqx\n      spec:\n        serviceAccountName: emqx\n        containers:\n        - name: emqx\n          image: emqx/emqx:v4.1-rc.1\n          ports:\n          - name: mqtt\n            containerPort: 1883\n          - name: mqttssl\n            containerPort: 8883\n          - name: mgmt\n            containerPort: 8081\n          - name: ws\n            containerPort: 8083\n          - name: wss\n            containerPort: 8084\n          - name: dashboard\n            containerPort: 18083\n          env:\n          - name: EMQX_NAME\n            value: emqx\n          - name: EMQX_CLUSTER__DISCOVERY\n            value: kubernetes\n          - name: EMQX_CLUSTER__K8S__APP_NAME\n            value: emqx\n          - name: EMQX_CLUSTER__K8S__SERVICE_NAME\n            value: emqx-service\n          - name: EMQX_CLUSTER__K8S__APISERVER\n            value: \"https://kubernetes.default.svc:443\"\n          - name: EMQX_CLUSTER__K8S__NAMESPACE\n            value: default\n\n  $ kubectl delete deployment emqx-deployment\n  deployment.apps \"emqx-deployment\" deleted\n\n  $ kubectl apply -f deployment.yaml\n  deployment.apps/emqx-deployment created\n  ```\n* 查看状态：\n\n  ```\n  $ kubectl get pods\n  NAME                              READY   STATUS    RESTARTS   AGE\n  emqx-deployment-6b854486c-dhd7p   1/1     Running   0          10s\n  emqx-deployment-6b854486c-psv2r   1/1     Running   0          10s\n  emqx-deployment-6b854486c-tdzld   1/1     Running   0          10s\n\n  $ kubectl exec emqx-deployment-6b854486c-dhd7p  -- emqx_ctl status\n  Node 'emqx@192.168.77.92' is started\n  emqx 4.1-rc.1 is running\n\n  $ kubectl exec emqx-deployment-6b854486c-dhd7p  -- emqx_ctl cluster status\n  Cluster status: #{running_nodes =>\n                        ['emqx@192.168.77.115','emqx@192.168.77.92',\n                         'emqx@192.168.87.157'],\n                    stopped_nodes => []}\n  ```\n* 中止一个 Pod：\n\n  ```\n  $ kubectl delete pods emqx-deployment-6b854486c-dhd7p\n  pod \"emqx-deployment-6b854486c-dhd7p\" deleted\n\n  $ kubectl get pods\n  NAME                              READY   STATUS    RESTARTS   AGE\n  emqx-deployment-6b854486c-846v7   1/1     Running   0          56s\n  emqx-deployment-6b854486c-psv2r   1/1     Running   0          3m50s\n  emqx-deployment-6b854486c-tdzld   1/1     Running   0          3m50s\n\n  $ kubectl exec emqx-deployment-6b854486c-846v7 -- emqx_ctl cluster status\n  Cluster status: #{running_nodes =>\n                        ['emqx@192.168.77.115','emqx@192.168.77.84',\n                         'emqx@192.168.87.157'],\n                    stopped_nodes => ['emqx@192.168.77.92']}\n  ```\n\n  输出结果表明 EMQX Broker 会正确的显示已经停掉的 Pod，并将 Deployment 新建的 Pod 加入集群。\n\n　　至此，EMQX Broker 在 kubernetes 上成功建立集群。\n\n## 持久化 EMQX Broker 集群\n\n　　上文中使用的 Deployment 来管理 Pod，但是 Pod 的网络是不停变动的，而且当 Pod 被销毁重建时，储存在 EMQX Broker 的数据和配置也就随之消失了，这在生产中是不能接受的，接下来尝试把 EMQX Broker 的集群持久化，即使 Pod 被销毁重建，EMQX Broker 的数据依然可以保存下来。\n\n### ConfigMap\n\n　　[ConfigMap](https://kubernetes.io/zh-cn/docs/concepts/configuration/configmap/) 是 configMap 是一种 API 对象，用来将非机密性的数据保存到健值对中。使用时可以用作环境变量、命令行参数或者存储卷中的配置文件。\n\n　　ConfigMap 将您的环境配置信息和 [容器镜像](https://kubernetes.io/docs/concepts/overview/#why-containers) 解耦，便于应用配置的修改。\n\n> ConfigMap 并不提供保密或者加密功能。如果你想存储的数据是机密的，请使用 [Secret](https://kubernetes.io/docs/concepts/configuration/secret/) ，或者使用其他第三方工具来保证你的数据的私密性，而不是用 ConfigMap。\n\n　　接下来使用 ConfigMap 记录 EMQX Broker 的配置，并将它们以环境变量的方式导入到 Deployment 中。\n\n* 定义 Configmap，并部署：\n\n  ```\n  $cat configmap.yaml\n\n  apiVersion: v1\n  kind: ConfigMap\n  metadata:\n    name: emqx-config\n  data:\n    EMQX_CLUSTER__K8S__ADDRESS_TYPE: \"hostname\"\n    EMQX_CLUSTER__K8S__APISERVER: \"https://kubernetes.default.svc:443\"\n    EMQX_CLUSTER__K8S__SUFFIX: \"svc.cluster.local\"\n\n  $ kubectl apply -f configmap.yaml\n  configmap/emqx-config created\n  ```\n* 配置 Deployment 来使用 Configmap\n\n  ```\n  $cat deployment.yaml\n\n  apiVersion: apps/v1\n  kind: Deployment\n  metadata:\n    name: emqx-deployment\n    labels:\n      app: emqx\n  spec:\n    replicas: 3\n    selector:\n      matchLabels:\n        app: emqx\n    template:\n      metadata:\n        labels:\n          app: emqx\n      spec:\n        serviceAccountName: emqx\n        containers:\n        - name: emqx\n          image: emqx/emqx:v4.1-rc.1\n          ports:\n          - name: mqtt\n            containerPort: 1883\n          - name: mqttssl\n            containerPort: 8883\n          - name: mgmt\n            containerPort: 8081\n          - name: ws\n            containerPort: 8083\n          - name: wss\n            containerPort: 8084\n          - name: dashboard\n            containerPort: 18083\n          envFrom:\n            - configMapRef:\n                name: emqx-config\n  ```\n* 重新部署 Deployment，查看状态\n\n  ```\n  $ kubectl delete -f deployment.yaml\n  deployment.apps \"emqx-deployment\" deleted\n\n  $ kubectl apply -f deployment.yaml\n  deployment.apps/emqx-deployment created\n\n  $ kubectl get pods\n  NAME                               READY   STATUS    RESTARTS   AGE\n  emqx-deployment-5c7696b5d7-k9lzj   1/1     Running   0          3s\n  emqx-deployment-5c7696b5d7-mdwkt   1/1     Running   0          3s\n  emqx-deployment-5c7696b5d7-z57z7   1/1     Running   0          3s\n\n  $ kubectl exec emqx-deployment-5c7696b5d7-k9lzj -- emqx_ctl status\n  Node 'emqx@192.168.87.149' is started\n  emqx 4.1-rc.1 is running\n\n  $ kubectl exec emqx-deployment-5c7696b5d7-k9lzj -- emqx_ctl cluster status\n  Cluster status: #{running_nodes =>\n                        ['emqx@192.168.77.106','emqx@192.168.77.107',\n                         'emqx@192.168.87.149'],\n                    stopped_nodes => []}\n  ```\n\n　　EMQX Broker 的配置文件已经解耦到 Configmap 中了，如果有需要，可以自由的配置一个或多个 Configmap，并把它们作为环境变量或是文件引入到 Pod 内。\n\n### StatefulSet\n\n　　[StatefulSet](https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/statefulset/) 是为了解决有状态服务的问题（对应 Deployments 和 ReplicaSets 是为无状态服务而设计），其应用场景包括\n\n* 稳定的持久化存储，即 Pod 重新调度后还是能访问到相同的持久化数据，基于 PVC 来实现\n* 稳定的网络标志，即 Pod 重新调度后其 PodName 和 HostName 不变，基于 Headless Service（即没有Cluster IP的Service）来实现\n* 有序部署，有序扩展，即 Pod 是有顺序的，在部署或者扩展的时候要依据定义的顺序依次依次进行（即从0到N-1，在下一个Pod运行之前所有之前的 Pod 必须都是 Running 和 Ready 状态），基于 init containers 来实现\n* 有序收缩，有序删除（即从N-1到0）\n\n　　从上面的应用场景可以发现，StatefulSet由以下几个部分组成：\n\n* 用于定义网络标志（DNS domain）的 Headless Service\n* 用于创建 PersistentVolumes 的 volumeClaimTemplates\n* 定义具体应用的 StatefulSet\n\n　　StatefulSet 中每个 Pod 的 DNS 格式为 `statefulSetName-{0..N-1}.serviceName.namespace.svc.cluster.local`​ ，其中\n\n* ​`serviceName`​ 为 Headless Service 的名字\n* ​`0..N-1`​ 为 Pod 所在的序号，从 0 开始到 N-1\n* ​`statefulSetName`​ 为StatefulSet的名字\n* ​`namespace`​ 为服务所在的 namespace，Headless Servic 和 StatefulSet 必须在相同的 namespace\n* ​`.cluster.local`​ 为 Cluster Domain\n\n　　接下来使用 StatefulSet 代替 Deployment 来管理 Pod。\n\n* 删除 Deployment：\n\n  ```\n  $ kubectl delete deployment emqx-deployment\n  deployment.apps \"emqx-deployment\" deleted\n  ```\n* 定义 StatefulSet：\n\n  ```\n  $cat statefulset.yaml\n\n  apiVersion: apps/v1\n  kind: StatefulSet\n  metadata:\n    name: emqx-statefulset\n    labels:\n      app: emqx\n  spec:\n    serviceName: emqx-headless\n    updateStrategy:\n      type: RollingUpdate\n    replicas: 3\n    selector:\n      matchLabels:\n        app: emqx\n    template:\n      metadata:\n        labels:\n          app: emqx\n      spec:\n        serviceAccountName: emqx\n        containers:\n        - name: emqx\n          image: emqx/emqx:v4.1-rc.1\n          ports:\n          - name: mqtt\n            containerPort: 1883\n          - name: mqttssl\n            containerPort: 8883\n          - name: mgmt\n            containerPort: 8081\n          - name: ws\n            containerPort: 8083\n          - name: wss\n            containerPort: 8084\n          - name: dashboard\n            containerPort: 18083\n          envFrom:\n            - configMapRef:\n                name: emqx-config\n  ```\n\n  注意，StatefulSet 需要 Headless Service 来实现稳定的网络标志，因此需要再定义一个 Service\n\n  ```\n  $cat headless.yaml\n\n  apiVersion: v1\n  kind: Service\n  metadata:\n    name: emqx-headless\n  spec:\n    type: ClusterIP\n    clusterIP: None\n    selector:\n      app: emqx\n    ports:\n    - name: mqtt\n      port: 1883\n      protocol: TCP\n      targetPort: 1883\n    - name: mqttssl\n      port: 8883\n      protocol: TCP\n      targetPort: 8883\n    - name: mgmt\n      port: 8081\n      protocol: TCP\n      targetPort: 8081\n    - name: websocket\n      port: 8083\n      protocol: TCP\n      targetPort: 8083\n    - name: wss\n      port: 8084\n      protocol: TCP\n      targetPort: 8084\n    - name: dashboard\n      port: 18083\n      protocol: TCP\n      targetPort: 18083\n  ```\n\n  因为 Headless Service 并不需要 IP，所以配置了 `clusterIP: None`​ 。\n* 部署相应的资源：\n\n  ```\n  $ kubectl apply -f headless-service.yaml\n  service/emqx-headless created\n\n  $ kubectl apply -f statefulset.yaml\n  statefulset.apps/emqx-deployment created\n\n  $ kubectl get pods\n  NAME                               READY   STATUS    RESTARTS   AGE\n  emqx-statefulset-0                 1/1     Running   0          2m59s\n  emqx-statefulset-1                 1/1     Running   0          2m57s\n  emqx-statefulset-2                 1/1     Running   0          2m54s\n\n  $ kubectl exec emqx-statefulset-0 -- emqx_ctl cluster status\n  Cluster status: #{running_nodes =>\n                        ['emqx@192.168.77.105','emqx@192.168.87.153',\n                         'emqx@192.168.87.155'],\n                    stopped_nodes => []}\n  ```\n* 更新 Configmap：  \n  StatefulSet 提供了稳定的网络标志，EMQX Broker 支持使用 hostname 和 dns 规则来代提 IP 实现集群，以 hostname 为例，需要修改 `emqx.conf`​：\n\n  ```\n  cluster.kubernetes.address_type = hostname\n  cluster.kubernetes.suffix = \"svc.cluster.local\"\n  ```\n\n  kubernetes 集群中 Pod 的 DNS 规则可以由用户自定义，EMQX Broker 提供了  `cluster.kubernetes.suffix`​ 方便用户匹配自定的 DNS 规则，本文使用默认的 DNS 规则：`statefulSetName-{0..N-1}.serviceName.namespace.svc.cluster.local`​ ，DNS 规则中的 serviceName 为 StatefulSet 使用的 Headless Service，所以还需要将 `cluster.kubernetes.service_name`​  修改为 Headless Service Name。  \n  将配置项转为环境变量，需要在 Configmap 中配置：\n\n  ```\n  EMQX_CLUSTER__K8S__ADDRESS_TYPE: \"hostname\"\n  EMQX_CLUSTER__K8S__SUFFIX: \"svc.cluster.local\"\n  EMQX_CLUSTER__K8S__SERVICE_NAME: emqx-headless\n  ```\n\n  Configmap 提供了热更新功能，执行 `$ kubectl edit configmap emqx-config`​ 来热更新 Configmap。\n* 重新部署 StatefulSet：  \n  Configmap 更新之后 Pod 并不会重启，需要我们手动更新 StatefulSet\n\n  ```\n  $ kubectl delete statefulset emqx-statefulset\n  statefulset.apps \"emqx-statefulset\" deleted\n\n  $ kubectl apply -f statefulset.yaml\n  statefulset.apps/emqx-statefulset created\n\n  $ kubectl get pods\n  NAME                 READY   STATUS    RESTARTS   AGE\n  emqx-statefulset-0   1/1     Running   0          115s\n  emqx-statefulset-1   1/1     Running   0          112s\n  emqx-statefulset-2   1/1     Running   0          110s\n\n  $ kubectl exec emqx-statefulset-2 -- emqx_ctl cluster status\n  Cluster status: #{running_nodes =>\n                        ['emqx@emqx-statefulset-0.emqx-headless.default.svc.cluster.local',\n                         'emqx@emqx-statefulset-1.emqx-headless.default.svc.cluster.local',\n                         'emqx@emqx-statefulset-2.emqx-headless.default.svc.cluster.local'],\n                    stopped_nodes => []}\n  ```\n\n  可以看到新的 EMQX Broker 集群已经成功的建立起来了。\n* 中止一个 Pod：  \n  StatefulSet 中的 Pod 重新调度后其 PodName 和 HostName 不变，下面来尝试一下：\n\n  ```\n  $ kubectl get pods\n  kuNAME                 READY   STATUS    RESTARTS   AGE\n  emqx-statefulset-0   1/1     Running   0          6m20s\n  emqx-statefulset-1   1/1     Running   0          6m17s\n  emqx-statefulset-2   1/1     Running   0          6m15s\n\n  $ kubectl delete pod emqx-statefulset-0\n  pod \"emqx-statefulset-0\" deleted\n\n  $ kubectl get pods\n  NAME                 READY   STATUS    RESTARTS   AGE\n  emqx-statefulset-0   1/1     Running   0          27s\n  emqx-statefulset-1   1/1     Running   0          9m45s\n  emqx-statefulset-2   1/1     Running   0          9m43s\n\n  $ kubectl exec emqx-statefulset-2 -- emqx_ctl cluster status\n  Cluster status: #{running_nodes =>\n                        ['emqx@emqx-statefulset-0.emqx-headless.default.svc.cluster.local',\n                         'emqx@emqx-statefulset-1.emqx-headless.default.svc.cluster.local',\n                         'emqx@emqx-statefulset-2.emqx-headless.default.svc.cluster.local'],\n                    stopped_nodes => []}\n  ```\n\n  跟预期的一样，StatefulSet 重新调度了一个具有相同网络标志的 Pod，Pod 中的 EMQX Broker 也成功的加入了集群。\n\n## StorageClasses、PersistentVolume 和 PersistentVolumeClaim\n\n　　PersistentVolume（PV）是由管理员设置的存储，它是群集的一部分。就像节点是集群中的资源一样，PV 也是集群中的资源。 PV 是 Volume 之类的卷插件，但具有独立于使用 PV 的 Pod 的生命周期。此 API  对象包含存储实现的细节，即 NFS、iSCSI 或特定于云供应商的存储系统。\n\n　　PersistentVolumeClaim（PVC）是用户存储的请求。它与 Pod 相似。Pod 消耗节点资源，PVC 消耗 PV 资源。Pod 可以请求特定级别的资源（CPU 和内存）。声明可以请求特定的大小和访问模式（例如，可以以读/写一次或 只读多次模式挂载）。\n\n　　StorageClass 为管理员提供了描述存储 \"class（类）\" 的方法。 不同的 class  可能会映射到不同的服务质量等级或备份策略，或由群集管理员确定的任意策略。 Kubernetes 本身不清楚各种 class  代表的什么。这个概念在其他存储系统中有时被称为“配置文件”。\n\n　　在部署 EMQX Broker 的时候，可以预先创建好 PV 或 StorageClass，然后利用 PVC 将 EMQX Broker 的 `/opt/emqx/data/mnesia`​ 目录挂载出来，当Pods被重新调度之后，EMQX 会从 `/opt/emqx/data/mnesia`​ 目录中获取数据并恢复，从而实现 EMQX Broker 的持久化。\n\n* 定义 StatefulSet\n\n  ```\n  $cat statefulset.yaml\n\n  apiVersion: apps/v1\n  kind: StatefulSet\n  metadata:\n    name: emqx-statefulset\n    labels:\n      app: emqx\n  spec:\n    replicas: 3\n    serviceName: emqx-headless\n    updateStrategy:\n      type: RollingUpdate\n    selector:\n      matchLabels:\n        app: emqx\n    template:\n      metadata:\n        labels:\n          app: emqx\n      spec:\n        volumes:\n        - name: emqx-data\n          persistentVolumeClaim:\n            claimName: emqx-pvc\n        serviceAccountName: emqx\n        containers:\n        - name: emqx\n          image: emqx/emqx:v4.1-rc.1\n          ports:\n          - name: mqtt\n            containerPort: 1883\n          - name: mqttssl\n            containerPort: 8883\n          - name: mgmt\n            containerPort: 8081\n          - name: ws\n            containerPort: 8083\n          - name: wss\n            containerPort: 8084\n          - name: dashboard\n            containerPort: 18083\n          envFrom:\n            - configMapRef:\n                name: emqx-config\n          volumeMounts:\n          - name: emqx-data\n            mountPath: \"/opt/emqx/data/mnesia\"\n    volumeClaimTemplates:\n    - metadata:\n        name: emqx-pvc\n        annotations:\n          volume.alpha.kubernetes.io/storage-class: manual\n      spec:\n        accessModes: [ \"ReadWriteOnce\" ]\n        resources:\n          requests:\n            storage: 1Gi\n  ```\n\n  该文件首先通过 `volumeClaimTemplates`​ 指定了使用 StorageClass 的 name 为 manual 的存储类创建名称为 emqx-pvc 的 PVC 资源，PVC 资源的读写模式为 `ReadWriteOnce`​，需要 1Gi 的空间，然后将此 PVC 定义为 name 为 emqx-data 的 volumes，并将此 volumes 挂载在 Pod 中的 `/opt/emqx/data/mnesia`​  目录下。\n* 部署资源：  \n  部署 StatefulSet 之前，需要用户或 kubernetes 集群管理员自行创建存储类。\n\n  ```\n  $ kubectl apply -f statefulset.yaml\n  statefulset.apps/emqx-statefulset created\n\n  $ kubectl get pods\n  NAME                 READY   STATUS    RESTARTS   AGE\n  emqx-statefulset-0   1/1     Running   0          27s\n  emqx-statefulset-1   1/1     Running   0          9m45s\n  emqx-statefulset-2   1/1     Running   0          9m43s\n\n  $ kubectl get pvc\n  NAME                                 STATUS    VOLUME                                 CAPACITY   ACCESS MODES   STORAGECLASS   AGE\n  emqx-data-emqx-statefulset-0   Bound     pvc-8094cd75-adb5-11e9-80cc-0697b59e8064   1Gi        RWO            gp2            2m11s\n  emqx-data-emqx-statefulset-0   Bound     pvc-9325441d-adb5-11e9-80cc-0697b59e8064   1Gi        RWO            gp2            99s\n  emqx-data-emqx-statefulset-0   Bound     pvc-ad425e9d-adb5-11e9-80cc-0697b59e8064   1Gi        RWO            gp2            56s\n  ```\n\n  输出结果表明该 PVC 的状态为 Bound，PVC 存储已经成功的建立了，当 Pod 被重新调度时，EMQX Broker 会读取挂载到 PVC 中的数据，从而实现持久化。\n\n　　EMQX Broker 在 kubernetes 上建立持久化的集群就完成了，本文略过了部分细节，部署的过程也是偏向简单的 Demo，用户可以自行阅读 [kubernetes 文档](https://kubernetes.io/zh-cn/docs/home/) 与  EMQX Team 提供的 [Helm chart 源码](https://github.com/emqx/emqx-rel/tree/master/deploy/charts/emqx) 来继续深入研究，当然也欢迎在 Github 贡献 issue、pull requests 以及 start。\n\n\n\n```yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: emqx-deployment\n  labels:\n    app: emqx\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: emqx\n  template:\n    metadata:\n      labels:\n        app: emqx\n    spec:\n      containers:\n      - name: emqx\n        image: emqx/emqx:5.7\n        ports:\n        - name: mqtt\n          containerPort: 1883\n        - name: mqttssl\n          containerPort: 8883\n        - name: mgmt\n          containerPort: 8081\n        - name: ws\n          containerPort: 8083\n        - name: wss\n          containerPort: 8084\n        - name: dashboard\n          containerPort: 18083\n\n```\n","slug":"20250501-5","published":1,"updated":"2025-05-01T09:38:56.124Z","comments":1,"layout":"post","photos":[],"_id":"cma56nfvt0006isjjfwyu6rwf","content":"<h1>从零开始建立 EMQX MQTT 服务器的 K8S 集群</h1>\n<iframe src=\"/widgets/metadata/\" data-src=\"/widgets/metadata/\" data-subtype=\"widget\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" style=\"height: 441px;\"></iframe>\n<hr>\n<ul>\n<li>从零开始建立 EMQX MQTT 服务器的 K8S 集群 - <a href=\"http://www.emqx.com\">www.emqx.com</a></li>\n<li><a href=\"https://www.emqx.com/zh/blog/emqx-mqtt-broker-k8s-cluster\">https://www.emqx.com/zh/blog/emqx-mqtt-broker-k8s-cluster</a></li>\n<li>本文将从零开始部署一个 EMQX MQTT 服务器的 K8S 集群，并分析部署中的细节与技巧，方便用户在实际部署中灵活使用。</li>\n<li>2024-06-28 10:42:05</li>\n</ul>\n<hr>\n<p>EMQX Team 提供了 Helm chart 方便用户在 kubernetes 集群上一键部署 EMQX <a href=\"https://www.emqx.com/zh/products/emqx\">MQTT 服务器</a>, 这是 EMQX Team 最推荐的在 kubernetes 或 k3s 集群上部署 EMQX MQTT 服务器的方法。 本文将使用手写 yaml 文件的方法从零开始部署一个 EMQX MQTT 服务器的 K8S 集群, 分析部署中的细节与技巧，方便用户在实际部署中灵活使用。</p>\n<p>阅读本文需要用户了解 kubernetes 的基本概念，并有一个可操作的 kubernetes 集群。</p>\n<h2 id=\"在-K8S-上部署单个-EMQX-MQTT服务器节点\">在 K8S 上部署单个 EMQX MQTT服务器节点</h2>\n<h3 id=\"使用-Pod-直接部署-EMQX-Broker\">使用 Pod 直接部署 EMQX Broker</h3>\n<p>在Kubernetes中，最小的管理元素不是一个个独立的容器，而是 <a href=\"https://kubernetes.io/zh/docs/concepts/workloads/pods/pod-overview/\">Pod</a>，Pod 是 Kubernetes 应用程序的基本执行单元，即它是 Kubernetes 对象模型中创建或部署的最小和最简单的单元。Pod 表示在 <a href=\"https://kubernetes.io/zh-cn/docs/reference/glossary/?all=true#term-cluster\">集群</a> 上运行的进程。</p>\n<p>EMQX Broker 在 <a href=\"https://hub.docker.com/r/emqx/emqx\">docker hub</a> 上提供了镜像, 因此可以很方便的在单个的 pod 上部署 EMQX Broker，使用 <code>kubectl run</code>​ 命令创建一个运行着 EMQX Broker 的 Pod：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ kubectl run emqx --image=emqx/emqx:v4.1-rc.1  --generator=run-pod/v1</span><br><span class=\"line\">pod/emqx created</span><br></pre></td></tr></table></figure>\n<p>查看 EMQX Broker 的状态：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ kubectl get pods -o wide</span><br><span class=\"line\">NAME   READY   STATUS    RESTARTS   AGE</span><br><span class=\"line\">emqx   1/1     Running   0          3m13s</span><br><span class=\"line\"></span><br><span class=\"line\">$ kubectl exec emqx -- emqx_ctl status</span><br><span class=\"line\">Node &#x27;emqx@192.168.77.108&#x27; is started</span><br><span class=\"line\">emqx 4.1-rc.1 is running</span><br></pre></td></tr></table></figure>\n<p>删除 Pod：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ kubectl delete pods emqx</span><br><span class=\"line\">pod &quot;emqx&quot; deleted</span><br></pre></td></tr></table></figure>\n<p>Pod 并不是被设计成一个持久化的资源，它不会在调度失败，节点崩溃，或者其他回收中（比如因为资源的缺乏，或者其他的维护中）幸存下来，因此，还需要一个控制器来管理 Pod。</p>\n<h3 id=\"使用-Deoloyment-部署-Pod\">使用 Deoloyment 部署 Pod</h3>\n<p><a href=\"https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/\">Deployment</a> 为 Pod 和 ReplicaSet 提供了一个声明式定义（declarative）方法，用来替代以前的<a href=\"https://www.kubernetes.org.cn/replication-controller-kubernetes\">ReplicationController</a> 来方便的管理应用。典型的应用场景包括：</p>\n<ul>\n<li>定义Deployment来创建Pod和ReplicaSet</li>\n<li>滚动升级和回滚应用</li>\n<li>扩容和缩容</li>\n<li>暂停和继续Deployment</li>\n</ul>\n<p>使用 Deployment 部署一个 EMQX Broker Pod：</p>\n<ul>\n<li>\n<p>定义 Deployment：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cat deployment.yaml</span><br><span class=\"line\"></span><br><span class=\"line\">apiVersion: apps/v1</span><br><span class=\"line\">kind: Deployment</span><br><span class=\"line\">metadata:</span><br><span class=\"line\">  name: emqx-deployment</span><br><span class=\"line\">  labels:</span><br><span class=\"line\">    app: emqx</span><br><span class=\"line\">spec:</span><br><span class=\"line\">  replicas: 1</span><br><span class=\"line\">  selector:</span><br><span class=\"line\">    matchLabels:</span><br><span class=\"line\">      app: emqx</span><br><span class=\"line\">  template:</span><br><span class=\"line\">    metadata:</span><br><span class=\"line\">      labels:</span><br><span class=\"line\">        app: emqx</span><br><span class=\"line\">    spec:</span><br><span class=\"line\">      containers:</span><br><span class=\"line\">      - name: emqx</span><br><span class=\"line\">        image: emqx/emqx:v4.1-rc.1</span><br><span class=\"line\">        ports:</span><br><span class=\"line\">        - name: mqtt</span><br><span class=\"line\">          containerPort: 1883</span><br><span class=\"line\">        - name: mqttssl</span><br><span class=\"line\">          containerPort: 8883</span><br><span class=\"line\">        - name: mgmt</span><br><span class=\"line\">          containerPort: 8081</span><br><span class=\"line\">        - name: ws</span><br><span class=\"line\">          containerPort: 8083</span><br><span class=\"line\">        - name: wss</span><br><span class=\"line\">          containerPort: 8084</span><br><span class=\"line\">        - name: dashboard</span><br><span class=\"line\">          containerPort: 18083</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>部署 Deployment：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$  kubectl apply -f deployment.yaml</span><br><span class=\"line\">deployment.apps/emqx-deployment created</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>查看部署情况：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ kubectl get deployment</span><br><span class=\"line\">NAME                              READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class=\"line\">deployment.apps/emqx-deployment   3/3     3            3           74s</span><br><span class=\"line\"></span><br><span class=\"line\">$ kubectl get pods</span><br><span class=\"line\">NAME                                  READY   STATUS    RESTARTS   AGE</span><br><span class=\"line\">pod/emqx-deployment-7c44dbd68-8j77l   1/1     Running   0          74s</span><br><span class=\"line\"></span><br><span class=\"line\">$ kubectl exec pod/emqx-deployment-7c44dbd68-8j77l -- emqx_ctl status</span><br><span class=\"line\">Node &#x27;emqx-deployment-7c44dbd68-8j77l@192.168.77.117&#x27; is started</span><br><span class=\"line\">emqx 4.1-rc.1 is running</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>尝试手动删除 Pod</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ kubectl delete pods emqx-deployment-7c44dbd68-8j77l</span><br><span class=\"line\">pod &quot;emqx-deployment-7c44dbd68-8j77l&quot; deleted</span><br><span class=\"line\"></span><br><span class=\"line\">$ kubectl get pods</span><br><span class=\"line\">NAME                              READY   STATUS    RESTARTS   AGE</span><br><span class=\"line\">emqx-deployment-68fcb4bfd6-2nhh6   1/1     Running   0          59s</span><br></pre></td></tr></table></figure>\n<p>输出结果表明成功用 Deployment 部署了 EMQX Broker Pod，即使是此 Pod 被意外终止，Deployment 也会重新创建一个新的 Pod。</p>\n</li>\n</ul>\n<h3 id=\"使用-Services-公开-EMQX-Broker-Pod-服务\">使用 Services 公开 EMQX Broker Pod 服务</h3>\n<p>Kubernetes <a href=\"https://kubernetes.io/docs/concepts/workloads/pods/\">Pods</a> 是有生命周期的。他们可以被创建，而且销毁不会再启动。 如果使用 <a href=\"https://kubernetes.io/docs/concepts/workloads/controllers/deployment/\">Deployment</a> 来运行应用程序，则它可以动态创建和销毁 Pod。</p>\n<p>每个 Pod 都有自己的 IP 地址，但是在 Deployment 中，在同一时刻运行的 Pod 集合可能与稍后运行该应用程序的 Pod 集合不同。</p>\n<p>这导致了一个问题：如果使用 EMQX Broker Pod 为 <strong>MQTT 客户端</strong>提供服务，那么客户端应该如何如何找出并跟踪要连接的 IP 地址，以便客户端使用 EMQX Broker 服务呢？</p>\n<p>答案是：Service</p>\n<p>Service 是将运行在一组 <a href=\"https://kubernetes.io/docs/concepts/workloads/pods/\">Pods</a> 上的应用程序公开为网络服务的抽象方法。</p>\n<p>使用 Service 将 EMQX Broker Pod 公开为网络服务：</p>\n<ul>\n<li>\n<p>定义 Service：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$cat service.yaml</span><br><span class=\"line\"></span><br><span class=\"line\">apiVersion: v1</span><br><span class=\"line\">kind: Service</span><br><span class=\"line\">metadata:</span><br><span class=\"line\">  name: emqx-service</span><br><span class=\"line\">spec:</span><br><span class=\"line\">  selector:</span><br><span class=\"line\">    app: emqx</span><br><span class=\"line\">  ports:</span><br><span class=\"line\">    - name: mqtt</span><br><span class=\"line\">      port: 1883</span><br><span class=\"line\">      protocol: TCP</span><br><span class=\"line\">      targetPort: mqtt</span><br><span class=\"line\">    - name: mqttssl</span><br><span class=\"line\">      port: 8883</span><br><span class=\"line\">      protocol: TCP</span><br><span class=\"line\">      targetPort: mqttssl</span><br><span class=\"line\">    - name: mgmt</span><br><span class=\"line\">      port: 8081</span><br><span class=\"line\">      protocol: TCP</span><br><span class=\"line\">      targetPort: mgmt</span><br><span class=\"line\">    - name: ws</span><br><span class=\"line\">      port: 8083</span><br><span class=\"line\">      protocol: TCP</span><br><span class=\"line\">      targetPort: ws</span><br><span class=\"line\">    - name: wss</span><br><span class=\"line\">      port: 8084</span><br><span class=\"line\">      protocol: TCP</span><br><span class=\"line\">      targetPort: wss</span><br><span class=\"line\">    - name: dashboard</span><br><span class=\"line\">      port: 18083</span><br><span class=\"line\">      protocol: TCP</span><br><span class=\"line\">      targetPort: dashboard</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>部署 Service：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ kubectl apply -f service.yaml</span><br><span class=\"line\">service/emqx-service created</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>查看部署情况</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ kubectl get svc</span><br><span class=\"line\">NAME           TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)                                        AGE</span><br><span class=\"line\">emqx-service   ClusterIP   10.96.54.205   &lt;none&gt;        1883/TCP,8883/TCP,8081/TCP,8083/TCP,8084/TCP,18083/TCP   58s</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>使用 Service 提供的 IP 查看 EMQX Broker 的 API</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ curl 10.96.54.205:8081/status</span><br><span class=\"line\">Node emqx-deployment-68fcb4bfd6-2nhh6@192.168.77.120 is started</span><br><span class=\"line\">emqx is running</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>至此，单个 EMQX Broker 节点在 kubernetes 上部署完毕，通过 Deployment 管理 EMQX Broker Pod，通过 Service 将 EMQX Broker 服务暴露出去。</p>\n<h2 id=\"通过-kubernetes-自动集群-EMQX-MQTT-服务器\">通过 kubernetes 自动集群 EMQX MQTT 服务器</h2>\n<p>上文中通过 Deployment 部署了单个的 EMQX Broker Pod，通过 Deployment 扩展 Pod 的数量是极为方便的，执行 <code>kubectl scale deployment $&#123;deployment_name&#125; --replicas $&#123;numer&#125;</code>​ 命令即可扩展 Pod 的数量，下面将 EMQX Broker Pod 扩展为 3 个：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ kubectl scale deployment emqx-deployment --replicas 3</span><br><span class=\"line\">deployment.apps/emqx-deployment scaled</span><br><span class=\"line\"></span><br><span class=\"line\">$ kubectl get pods</span><br><span class=\"line\">NAME                               READY   STATUS    RESTARTS   AGE</span><br><span class=\"line\">emqx-deployment-68fcb4bfd6-2nhh6   1/1     Running   0          18m</span><br><span class=\"line\">emqx-deployment-68fcb4bfd6-mpvch   1/1     Running   0          6s</span><br><span class=\"line\">emqx-deployment-68fcb4bfd6-mx55q   1/1     Running   0          6s</span><br><span class=\"line\"></span><br><span class=\"line\">$ kubectl exec emqx-deployment-68fcb4bfd6-2nhh6 -- emqx_ctl status</span><br><span class=\"line\">Node &#x27;emqx-deployment-68fcb4bfd6-2nhh6@192.168.77.120&#x27; is started</span><br><span class=\"line\">emqx 4.1-rc.1 is running</span><br><span class=\"line\"></span><br><span class=\"line\">$ kubectl exec emqx-deployment-68fcb4bfd6-2nhh6 -- emqx_ctl cluster status</span><br><span class=\"line\">Cluster status: #&#123;running_nodes =&gt;</span><br><span class=\"line\">                      [&#x27;emqx-deployment-68fcb4bfd6-2nhh6@192.168.77.120&#x27;],</span><br><span class=\"line\">                  stopped_nodes =&gt; []&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到 EMQX Broker Pod 的数量被扩展为 3 个，但是每个 Pod 都是独立的，并没有集群，接下来尝试通过 kubernetes 自动集群 EMQX Broker Pod。</p>\n<h3 id=\"修改-EMQX-Broker-的配置\">修改 EMQX Broker 的配置</h3>\n<p>查看 EMQX Broker 文档中关于<a href=\"https://docs.emqx.com/zh/emqx/latest/deploy/cluster/introduction.html\">自动集群</a>的内容，可以看到需要修改 EMQX Broker 的配置：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cluster.discovery = kubernetes</span><br><span class=\"line\">cluster.kubernetes.apiserver = http://10.110.111.204:8080</span><br><span class=\"line\">cluster.kubernetes.service_name = ekka</span><br><span class=\"line\">cluster.kubernetes.address_type = ip</span><br><span class=\"line\">cluster.kubernetes.app_name = ekka</span><br></pre></td></tr></table></figure>\n<p>其中 <code>cluster.kubernetes.apiserver</code>​ 为 kubernetes apiserver 的地址，可以通过 <code>kubectl cluster-info</code>​ 命令获取，<code>cluster.kubernetes.service_name</code>​ 为上文中 Service 的 name， <code>cluster.kubernetes.app_name</code>​ 为 EMQX Broker 的 <code>node.name</code>​ 中 <code>@</code>​ 符号之前的部分，所以还需要将集群中 EMQX Broker 设置为统一的 <code>node.name</code>​ 的前缀。</p>\n<p>EMQX Broker 的 docker 镜像提供了通过环境变量修改配置的功能，具体可以查看 <a href=\"https://hub.docker.com/r/emqx/emqx\">docker hub</a> 或 <a href=\"https://github.com/emqx/emqx-rel/blob/master/deploy/docker/README.md\">Github</a>。</p>\n<ul>\n<li>\n<p>修改 Deployment 的 yaml 文件，增加环境变量：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cat deployment.yaml</span><br><span class=\"line\"></span><br><span class=\"line\">apiVersion: apps/v1</span><br><span class=\"line\">kind: Deployment</span><br><span class=\"line\">metadata:</span><br><span class=\"line\">  name: emqx-deployment</span><br><span class=\"line\">  labels:</span><br><span class=\"line\">    app: emqx</span><br><span class=\"line\">spec:</span><br><span class=\"line\">  replicas: 3</span><br><span class=\"line\">  selector:</span><br><span class=\"line\">    matchLabels:</span><br><span class=\"line\">      app: emqx</span><br><span class=\"line\">  template:</span><br><span class=\"line\">    metadata:</span><br><span class=\"line\">      labels:</span><br><span class=\"line\">        app: emqx</span><br><span class=\"line\">    spec:</span><br><span class=\"line\">      containers:</span><br><span class=\"line\">      - name: emqx</span><br><span class=\"line\">        image: emqx/emqx:v4.1-rc.1</span><br><span class=\"line\">        ports:</span><br><span class=\"line\">        - name: mqtt</span><br><span class=\"line\">          containerPort: 1883</span><br><span class=\"line\">        - name: mqttssl</span><br><span class=\"line\">          containerPort: 8883</span><br><span class=\"line\">        - name: mgmt</span><br><span class=\"line\">          containerPort: 8081</span><br><span class=\"line\">        - name: ws</span><br><span class=\"line\">          containerPort: 8083</span><br><span class=\"line\">        - name: wss</span><br><span class=\"line\">          containerPort: 8084</span><br><span class=\"line\">        - name: dashboard</span><br><span class=\"line\">          containerPort: 18083</span><br><span class=\"line\">        env:</span><br><span class=\"line\">        - name: EMQX_NAME</span><br><span class=\"line\">          value: emqx</span><br><span class=\"line\">        - name: EMQX_CLUSTER__DISCOVERY</span><br><span class=\"line\">          value: k8s</span><br><span class=\"line\">        - name: EMQX_CLUSTER__K8S__APP_NAME</span><br><span class=\"line\">          value: emqx</span><br><span class=\"line\">        - name: EMQX_CLUSTER__K8S__SERVICE_NAME</span><br><span class=\"line\">          value: emqx-service</span><br><span class=\"line\">        - name: EMQX_CLUSTER__K8S__APISERVER</span><br><span class=\"line\">          value: &quot;https://kubernetes.default.svc:443&quot;</span><br><span class=\"line\">        - name: EMQX_CLUSTER__K8S__NAMESPACE</span><br><span class=\"line\">          value: default</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>因为 ``kubectl scale deployment ${deployment_name} --replicas ${numer}<code>命令不会修改 yaml 文件，所以修改 yaml 时需要设置</code>​spec.replicas: 3` 。</p>\n<p>Pod 中内建 kubernetes 的 DNS 规则，所以 <code>https://kubernetes.default.svc:443</code>​ 会被解析为 kubernetes apiserver  的地址。</p>\n</blockquote>\n</li>\n<li>\n<p>删除之前的 Deployment，重新部署：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ kubectl delete deployment emqx-deployment</span><br><span class=\"line\">deployment.apps &quot;emqx-deployment&quot; deleted</span><br><span class=\"line\"></span><br><span class=\"line\">$ kubectl apply -f deployment.yaml</span><br><span class=\"line\">deployment.apps/emqx-deployment created</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"赋予-Pod-访问-kubernetes-apiserver-的权限\">赋予 Pod 访问 kubernetes apiserver 的权限</h3>\n<p>上文部署 Deployment 之后，查看 EMQX Broker 的状态，可以看到 EMQX Broker 虽然成功启动了，但是依然没有集群成功，查看 EMQX Broker Pod 的 log：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ kubectl get pods</span><br><span class=\"line\">NAME                               READY   STATUS    RESTARTS   AGE</span><br><span class=\"line\">emqx-deployment-5c8cfc4d75-67lmt   1/1     Running   0          5s</span><br><span class=\"line\">emqx-deployment-5c8cfc4d75-r6jgb   1/1     Running   0          5s</span><br><span class=\"line\">emqx-deployment-5c8cfc4d75-wv2hj   1/1     Running   0          5s</span><br><span class=\"line\"></span><br><span class=\"line\">$ kubectl exec emqx-deployment-5c8cfc4d75-67lmt -- emqx_ctl status</span><br><span class=\"line\">Node &#x27;emqx@192.168.87.150&#x27; is started</span><br><span class=\"line\">emqx 4.1-rc.1 is running</span><br><span class=\"line\"></span><br><span class=\"line\">$ kubectl exec emqx-deployment-5c8cfc4d75-67lmt -- emqx_ctl cluster status</span><br><span class=\"line\">Cluster status: #&#123;running_nodes =&gt; [&#x27;emqx@192.168.87.150&#x27;],</span><br><span class=\"line\">                  stopped_nodes =&gt; []&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">$ kubectl logs emqx-deployment-76f6895c46-4684f</span><br><span class=\"line\"></span><br><span class=\"line\">···</span><br><span class=\"line\">(emqx@192.168.87.150)1&gt; 2020-05-20 01:48:39.726 [error] Ekka(AutoCluster): Discovery error: &#123;403,</span><br><span class=\"line\">                                     &quot;&#123;\\&quot;kind\\&quot;:\\&quot;Status\\&quot;,\\&quot;apiVersion\\&quot;:\\&quot;v1\\&quot;,\\&quot;metadata\\&quot;:&#123;&#125;,\\&quot;status\\&quot;:\\&quot;Failure\\&quot;,\\&quot;message\\&quot;:\\&quot;endpoints \\\\\\&quot;emqx-service\\\\\\&quot; is forbidden: User \\\\\\&quot;system:serviceaccount:default:default\\\\\\&quot; cannot get resource \\\\\\&quot;endpoints\\\\\\&quot; in API group \\\\\\&quot;\\\\\\&quot; in the namespace \\\\\\&quot;default\\\\\\&quot;\\&quot;,\\&quot;reason\\&quot;:\\&quot;Forbidden\\&quot;,\\&quot;details\\&quot;:&#123;\\&quot;name\\&quot;:\\&quot;emqx-service\\&quot;,\\&quot;kind\\&quot;:\\&quot;endpoints\\&quot;&#125;,\\&quot;code\\&quot;:403&#125;\\n&quot;&#125;</span><br><span class=\"line\">···</span><br></pre></td></tr></table></figure>\n<p>Pod 因为权限问题在访问 kubernetes apiserver 的时候被拒绝，返回 HTTP 403，所以集群失败。</p>\n<p>普通 Pod 是无法访问 kubernetes apiserver 的，解决这个问题有两种方法，一种是开放 kubernetes apiserver 的 http 接口，但是这种方法存在一定的安全隐患，另外一种是通过 ServiceAccount、Role 和 RoleBinding 配置 RBAC 鉴权。</p>\n<ul>\n<li>\n<p>定义  ServiceAccount、Role 和 RoleBinding：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cat rbac.yaml</span><br><span class=\"line\"></span><br><span class=\"line\">apiVersion: v1</span><br><span class=\"line\">kind: ServiceAccount</span><br><span class=\"line\">metadata:</span><br><span class=\"line\">  namespace: default</span><br><span class=\"line\">  name: emqx</span><br><span class=\"line\">---</span><br><span class=\"line\">kind: Role</span><br><span class=\"line\">apiVersion: rbac.authorization.kubernetes.io/v1beta1</span><br><span class=\"line\">metadata:</span><br><span class=\"line\">  namespace: default</span><br><span class=\"line\">  name: emqx</span><br><span class=\"line\">rules:</span><br><span class=\"line\">- apiGroups:</span><br><span class=\"line\">  - &quot;&quot;</span><br><span class=\"line\">  resources:</span><br><span class=\"line\">  - endpoints </span><br><span class=\"line\">  verbs: </span><br><span class=\"line\">  - get</span><br><span class=\"line\">  - watch</span><br><span class=\"line\">  - list</span><br><span class=\"line\">---</span><br><span class=\"line\">kind: RoleBinding</span><br><span class=\"line\">apiVersion: rbac.authorization.kubernetes.io/v1beta1</span><br><span class=\"line\">metadata:</span><br><span class=\"line\">  namespace: default</span><br><span class=\"line\">  name: emqx</span><br><span class=\"line\">subjects:</span><br><span class=\"line\">  - kind: ServiceAccount</span><br><span class=\"line\">    name: emqx</span><br><span class=\"line\">    namespace: default</span><br><span class=\"line\">roleRef:</span><br><span class=\"line\">  kind: Role</span><br><span class=\"line\">  name: emqx</span><br><span class=\"line\">  apiGroup: rbac.authorization.kubernetes.io</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>部署相应的资源：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ kubectl apply -f rbac.yaml</span><br><span class=\"line\">serviceaccount/emqx created</span><br><span class=\"line\">role.rbac.authorization.kubernetes.io/emqx created</span><br><span class=\"line\">rolebinding.rbac.authorization.kubernetes.io/emqx created</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>修改 Deployment 的 yaml 文件，增加 <code>spec.template.spec.serviceAccountName</code>​，并重新部署：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$cat deployment.yaml</span><br><span class=\"line\"></span><br><span class=\"line\">apiVersion: apps/v1</span><br><span class=\"line\">kind: Deployment</span><br><span class=\"line\">metadata:</span><br><span class=\"line\">  name: emqx-deployment</span><br><span class=\"line\">  labels:</span><br><span class=\"line\">    app: emqx</span><br><span class=\"line\">spec:</span><br><span class=\"line\">  replicas: 3</span><br><span class=\"line\">  selector:</span><br><span class=\"line\">    matchLabels:</span><br><span class=\"line\">      app: emqx</span><br><span class=\"line\">  template:</span><br><span class=\"line\">    metadata:</span><br><span class=\"line\">      labels:</span><br><span class=\"line\">        app: emqx</span><br><span class=\"line\">    spec:</span><br><span class=\"line\">      serviceAccountName: emqx</span><br><span class=\"line\">      containers:</span><br><span class=\"line\">      - name: emqx</span><br><span class=\"line\">        image: emqx/emqx:v4.1-rc.1</span><br><span class=\"line\">        ports:</span><br><span class=\"line\">        - name: mqtt</span><br><span class=\"line\">          containerPort: 1883</span><br><span class=\"line\">        - name: mqttssl</span><br><span class=\"line\">          containerPort: 8883</span><br><span class=\"line\">        - name: mgmt</span><br><span class=\"line\">          containerPort: 8081</span><br><span class=\"line\">        - name: ws</span><br><span class=\"line\">          containerPort: 8083</span><br><span class=\"line\">        - name: wss</span><br><span class=\"line\">          containerPort: 8084</span><br><span class=\"line\">        - name: dashboard</span><br><span class=\"line\">          containerPort: 18083</span><br><span class=\"line\">        env:</span><br><span class=\"line\">        - name: EMQX_NAME</span><br><span class=\"line\">          value: emqx</span><br><span class=\"line\">        - name: EMQX_CLUSTER__DISCOVERY</span><br><span class=\"line\">          value: kubernetes</span><br><span class=\"line\">        - name: EMQX_CLUSTER__K8S__APP_NAME</span><br><span class=\"line\">          value: emqx</span><br><span class=\"line\">        - name: EMQX_CLUSTER__K8S__SERVICE_NAME</span><br><span class=\"line\">          value: emqx-service</span><br><span class=\"line\">        - name: EMQX_CLUSTER__K8S__APISERVER</span><br><span class=\"line\">          value: &quot;https://kubernetes.default.svc:443&quot;</span><br><span class=\"line\">        - name: EMQX_CLUSTER__K8S__NAMESPACE</span><br><span class=\"line\">          value: default</span><br><span class=\"line\"></span><br><span class=\"line\">$ kubectl delete deployment emqx-deployment</span><br><span class=\"line\">deployment.apps &quot;emqx-deployment&quot; deleted</span><br><span class=\"line\"></span><br><span class=\"line\">$ kubectl apply -f deployment.yaml</span><br><span class=\"line\">deployment.apps/emqx-deployment created</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>查看状态：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ kubectl get pods</span><br><span class=\"line\">NAME                              READY   STATUS    RESTARTS   AGE</span><br><span class=\"line\">emqx-deployment-6b854486c-dhd7p   1/1     Running   0          10s</span><br><span class=\"line\">emqx-deployment-6b854486c-psv2r   1/1     Running   0          10s</span><br><span class=\"line\">emqx-deployment-6b854486c-tdzld   1/1     Running   0          10s</span><br><span class=\"line\"></span><br><span class=\"line\">$ kubectl exec emqx-deployment-6b854486c-dhd7p  -- emqx_ctl status</span><br><span class=\"line\">Node &#x27;emqx@192.168.77.92&#x27; is started</span><br><span class=\"line\">emqx 4.1-rc.1 is running</span><br><span class=\"line\"></span><br><span class=\"line\">$ kubectl exec emqx-deployment-6b854486c-dhd7p  -- emqx_ctl cluster status</span><br><span class=\"line\">Cluster status: #&#123;running_nodes =&gt;</span><br><span class=\"line\">                      [&#x27;emqx@192.168.77.115&#x27;,&#x27;emqx@192.168.77.92&#x27;,</span><br><span class=\"line\">                       &#x27;emqx@192.168.87.157&#x27;],</span><br><span class=\"line\">                  stopped_nodes =&gt; []&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>中止一个 Pod：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ kubectl delete pods emqx-deployment-6b854486c-dhd7p</span><br><span class=\"line\">pod &quot;emqx-deployment-6b854486c-dhd7p&quot; deleted</span><br><span class=\"line\"></span><br><span class=\"line\">$ kubectl get pods</span><br><span class=\"line\">NAME                              READY   STATUS    RESTARTS   AGE</span><br><span class=\"line\">emqx-deployment-6b854486c-846v7   1/1     Running   0          56s</span><br><span class=\"line\">emqx-deployment-6b854486c-psv2r   1/1     Running   0          3m50s</span><br><span class=\"line\">emqx-deployment-6b854486c-tdzld   1/1     Running   0          3m50s</span><br><span class=\"line\"></span><br><span class=\"line\">$ kubectl exec emqx-deployment-6b854486c-846v7 -- emqx_ctl cluster status</span><br><span class=\"line\">Cluster status: #&#123;running_nodes =&gt;</span><br><span class=\"line\">                      [&#x27;emqx@192.168.77.115&#x27;,&#x27;emqx@192.168.77.84&#x27;,</span><br><span class=\"line\">                       &#x27;emqx@192.168.87.157&#x27;],</span><br><span class=\"line\">                  stopped_nodes =&gt; [&#x27;emqx@192.168.77.92&#x27;]&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果表明 EMQX Broker 会正确的显示已经停掉的 Pod，并将 Deployment 新建的 Pod 加入集群。</p>\n</li>\n</ul>\n<p>至此，EMQX Broker 在 kubernetes 上成功建立集群。</p>\n<h2 id=\"持久化-EMQX-Broker-集群\">持久化 EMQX Broker 集群</h2>\n<p>上文中使用的 Deployment 来管理 Pod，但是 Pod 的网络是不停变动的，而且当 Pod 被销毁重建时，储存在 EMQX Broker 的数据和配置也就随之消失了，这在生产中是不能接受的，接下来尝试把 EMQX Broker 的集群持久化，即使 Pod 被销毁重建，EMQX Broker 的数据依然可以保存下来。</p>\n<h3 id=\"ConfigMap\">ConfigMap</h3>\n<p><a href=\"https://kubernetes.io/zh-cn/docs/concepts/configuration/configmap/\">ConfigMap</a> 是 configMap 是一种 API 对象，用来将非机密性的数据保存到健值对中。使用时可以用作环境变量、命令行参数或者存储卷中的配置文件。</p>\n<p>ConfigMap 将您的环境配置信息和 <a href=\"https://kubernetes.io/docs/concepts/overview/#why-containers\">容器镜像</a> 解耦，便于应用配置的修改。</p>\n<blockquote>\n<p>ConfigMap 并不提供保密或者加密功能。如果你想存储的数据是机密的，请使用 <a href=\"https://kubernetes.io/docs/concepts/configuration/secret/\">Secret</a> ，或者使用其他第三方工具来保证你的数据的私密性，而不是用 ConfigMap。</p>\n</blockquote>\n<p>接下来使用 ConfigMap 记录 EMQX Broker 的配置，并将它们以环境变量的方式导入到 Deployment 中。</p>\n<ul>\n<li>\n<p>定义 Configmap，并部署：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$cat configmap.yaml</span><br><span class=\"line\"></span><br><span class=\"line\">apiVersion: v1</span><br><span class=\"line\">kind: ConfigMap</span><br><span class=\"line\">metadata:</span><br><span class=\"line\">  name: emqx-config</span><br><span class=\"line\">data:</span><br><span class=\"line\">  EMQX_CLUSTER__K8S__ADDRESS_TYPE: &quot;hostname&quot;</span><br><span class=\"line\">  EMQX_CLUSTER__K8S__APISERVER: &quot;https://kubernetes.default.svc:443&quot;</span><br><span class=\"line\">  EMQX_CLUSTER__K8S__SUFFIX: &quot;svc.cluster.local&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">$ kubectl apply -f configmap.yaml</span><br><span class=\"line\">configmap/emqx-config created</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>配置 Deployment 来使用 Configmap</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$cat deployment.yaml</span><br><span class=\"line\"></span><br><span class=\"line\">apiVersion: apps/v1</span><br><span class=\"line\">kind: Deployment</span><br><span class=\"line\">metadata:</span><br><span class=\"line\">  name: emqx-deployment</span><br><span class=\"line\">  labels:</span><br><span class=\"line\">    app: emqx</span><br><span class=\"line\">spec:</span><br><span class=\"line\">  replicas: 3</span><br><span class=\"line\">  selector:</span><br><span class=\"line\">    matchLabels:</span><br><span class=\"line\">      app: emqx</span><br><span class=\"line\">  template:</span><br><span class=\"line\">    metadata:</span><br><span class=\"line\">      labels:</span><br><span class=\"line\">        app: emqx</span><br><span class=\"line\">    spec:</span><br><span class=\"line\">      serviceAccountName: emqx</span><br><span class=\"line\">      containers:</span><br><span class=\"line\">      - name: emqx</span><br><span class=\"line\">        image: emqx/emqx:v4.1-rc.1</span><br><span class=\"line\">        ports:</span><br><span class=\"line\">        - name: mqtt</span><br><span class=\"line\">          containerPort: 1883</span><br><span class=\"line\">        - name: mqttssl</span><br><span class=\"line\">          containerPort: 8883</span><br><span class=\"line\">        - name: mgmt</span><br><span class=\"line\">          containerPort: 8081</span><br><span class=\"line\">        - name: ws</span><br><span class=\"line\">          containerPort: 8083</span><br><span class=\"line\">        - name: wss</span><br><span class=\"line\">          containerPort: 8084</span><br><span class=\"line\">        - name: dashboard</span><br><span class=\"line\">          containerPort: 18083</span><br><span class=\"line\">        envFrom:</span><br><span class=\"line\">          - configMapRef:</span><br><span class=\"line\">              name: emqx-config</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>重新部署 Deployment，查看状态</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ kubectl delete -f deployment.yaml</span><br><span class=\"line\">deployment.apps &quot;emqx-deployment&quot; deleted</span><br><span class=\"line\"></span><br><span class=\"line\">$ kubectl apply -f deployment.yaml</span><br><span class=\"line\">deployment.apps/emqx-deployment created</span><br><span class=\"line\"></span><br><span class=\"line\">$ kubectl get pods</span><br><span class=\"line\">NAME                               READY   STATUS    RESTARTS   AGE</span><br><span class=\"line\">emqx-deployment-5c7696b5d7-k9lzj   1/1     Running   0          3s</span><br><span class=\"line\">emqx-deployment-5c7696b5d7-mdwkt   1/1     Running   0          3s</span><br><span class=\"line\">emqx-deployment-5c7696b5d7-z57z7   1/1     Running   0          3s</span><br><span class=\"line\"></span><br><span class=\"line\">$ kubectl exec emqx-deployment-5c7696b5d7-k9lzj -- emqx_ctl status</span><br><span class=\"line\">Node &#x27;emqx@192.168.87.149&#x27; is started</span><br><span class=\"line\">emqx 4.1-rc.1 is running</span><br><span class=\"line\"></span><br><span class=\"line\">$ kubectl exec emqx-deployment-5c7696b5d7-k9lzj -- emqx_ctl cluster status</span><br><span class=\"line\">Cluster status: #&#123;running_nodes =&gt;</span><br><span class=\"line\">                      [&#x27;emqx@192.168.77.106&#x27;,&#x27;emqx@192.168.77.107&#x27;,</span><br><span class=\"line\">                       &#x27;emqx@192.168.87.149&#x27;],</span><br><span class=\"line\">                  stopped_nodes =&gt; []&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>EMQX Broker 的配置文件已经解耦到 Configmap 中了，如果有需要，可以自由的配置一个或多个 Configmap，并把它们作为环境变量或是文件引入到 Pod 内。</p>\n<h3 id=\"StatefulSet\">StatefulSet</h3>\n<p><a href=\"https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/statefulset/\">StatefulSet</a> 是为了解决有状态服务的问题（对应 Deployments 和 ReplicaSets 是为无状态服务而设计），其应用场景包括</p>\n<ul>\n<li>稳定的持久化存储，即 Pod 重新调度后还是能访问到相同的持久化数据，基于 PVC 来实现</li>\n<li>稳定的网络标志，即 Pod 重新调度后其 PodName 和 HostName 不变，基于 Headless Service（即没有Cluster IP的Service）来实现</li>\n<li>有序部署，有序扩展，即 Pod 是有顺序的，在部署或者扩展的时候要依据定义的顺序依次依次进行（即从0到N-1，在下一个Pod运行之前所有之前的 Pod 必须都是 Running 和 Ready 状态），基于 init containers 来实现</li>\n<li>有序收缩，有序删除（即从N-1到0）</li>\n</ul>\n<p>从上面的应用场景可以发现，StatefulSet由以下几个部分组成：</p>\n<ul>\n<li>用于定义网络标志（DNS domain）的 Headless Service</li>\n<li>用于创建 PersistentVolumes 的 volumeClaimTemplates</li>\n<li>定义具体应用的 StatefulSet</li>\n</ul>\n<p>StatefulSet 中每个 Pod 的 DNS 格式为 <code>statefulSetName-&#123;0..N-1&#125;.serviceName.namespace.svc.cluster.local</code>​ ，其中</p>\n<ul>\n<li>​<code>serviceName</code>​ 为 Headless Service 的名字</li>\n<li>​<code>0..N-1</code>​ 为 Pod 所在的序号，从 0 开始到 N-1</li>\n<li>​<code>statefulSetName</code>​ 为StatefulSet的名字</li>\n<li>​<code>namespace</code>​ 为服务所在的 namespace，Headless Servic 和 StatefulSet 必须在相同的 namespace</li>\n<li>​<code>.cluster.local</code>​ 为 Cluster Domain</li>\n</ul>\n<p>接下来使用 StatefulSet 代替 Deployment 来管理 Pod。</p>\n<ul>\n<li>\n<p>删除 Deployment：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ kubectl delete deployment emqx-deployment</span><br><span class=\"line\">deployment.apps &quot;emqx-deployment&quot; deleted</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>定义 StatefulSet：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$cat statefulset.yaml</span><br><span class=\"line\"></span><br><span class=\"line\">apiVersion: apps/v1</span><br><span class=\"line\">kind: StatefulSet</span><br><span class=\"line\">metadata:</span><br><span class=\"line\">  name: emqx-statefulset</span><br><span class=\"line\">  labels:</span><br><span class=\"line\">    app: emqx</span><br><span class=\"line\">spec:</span><br><span class=\"line\">  serviceName: emqx-headless</span><br><span class=\"line\">  updateStrategy:</span><br><span class=\"line\">    type: RollingUpdate</span><br><span class=\"line\">  replicas: 3</span><br><span class=\"line\">  selector:</span><br><span class=\"line\">    matchLabels:</span><br><span class=\"line\">      app: emqx</span><br><span class=\"line\">  template:</span><br><span class=\"line\">    metadata:</span><br><span class=\"line\">      labels:</span><br><span class=\"line\">        app: emqx</span><br><span class=\"line\">    spec:</span><br><span class=\"line\">      serviceAccountName: emqx</span><br><span class=\"line\">      containers:</span><br><span class=\"line\">      - name: emqx</span><br><span class=\"line\">        image: emqx/emqx:v4.1-rc.1</span><br><span class=\"line\">        ports:</span><br><span class=\"line\">        - name: mqtt</span><br><span class=\"line\">          containerPort: 1883</span><br><span class=\"line\">        - name: mqttssl</span><br><span class=\"line\">          containerPort: 8883</span><br><span class=\"line\">        - name: mgmt</span><br><span class=\"line\">          containerPort: 8081</span><br><span class=\"line\">        - name: ws</span><br><span class=\"line\">          containerPort: 8083</span><br><span class=\"line\">        - name: wss</span><br><span class=\"line\">          containerPort: 8084</span><br><span class=\"line\">        - name: dashboard</span><br><span class=\"line\">          containerPort: 18083</span><br><span class=\"line\">        envFrom:</span><br><span class=\"line\">          - configMapRef:</span><br><span class=\"line\">              name: emqx-config</span><br></pre></td></tr></table></figure>\n<p>注意，StatefulSet 需要 Headless Service 来实现稳定的网络标志，因此需要再定义一个 Service</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$cat headless.yaml</span><br><span class=\"line\"></span><br><span class=\"line\">apiVersion: v1</span><br><span class=\"line\">kind: Service</span><br><span class=\"line\">metadata:</span><br><span class=\"line\">  name: emqx-headless</span><br><span class=\"line\">spec:</span><br><span class=\"line\">  type: ClusterIP</span><br><span class=\"line\">  clusterIP: None</span><br><span class=\"line\">  selector:</span><br><span class=\"line\">    app: emqx</span><br><span class=\"line\">  ports:</span><br><span class=\"line\">  - name: mqtt</span><br><span class=\"line\">    port: 1883</span><br><span class=\"line\">    protocol: TCP</span><br><span class=\"line\">    targetPort: 1883</span><br><span class=\"line\">  - name: mqttssl</span><br><span class=\"line\">    port: 8883</span><br><span class=\"line\">    protocol: TCP</span><br><span class=\"line\">    targetPort: 8883</span><br><span class=\"line\">  - name: mgmt</span><br><span class=\"line\">    port: 8081</span><br><span class=\"line\">    protocol: TCP</span><br><span class=\"line\">    targetPort: 8081</span><br><span class=\"line\">  - name: websocket</span><br><span class=\"line\">    port: 8083</span><br><span class=\"line\">    protocol: TCP</span><br><span class=\"line\">    targetPort: 8083</span><br><span class=\"line\">  - name: wss</span><br><span class=\"line\">    port: 8084</span><br><span class=\"line\">    protocol: TCP</span><br><span class=\"line\">    targetPort: 8084</span><br><span class=\"line\">  - name: dashboard</span><br><span class=\"line\">    port: 18083</span><br><span class=\"line\">    protocol: TCP</span><br><span class=\"line\">    targetPort: 18083</span><br></pre></td></tr></table></figure>\n<p>因为 Headless Service 并不需要 IP，所以配置了 <code>clusterIP: None</code>​ 。</p>\n</li>\n<li>\n<p>部署相应的资源：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ kubectl apply -f headless-service.yaml</span><br><span class=\"line\">service/emqx-headless created</span><br><span class=\"line\"></span><br><span class=\"line\">$ kubectl apply -f statefulset.yaml</span><br><span class=\"line\">statefulset.apps/emqx-deployment created</span><br><span class=\"line\"></span><br><span class=\"line\">$ kubectl get pods</span><br><span class=\"line\">NAME                               READY   STATUS    RESTARTS   AGE</span><br><span class=\"line\">emqx-statefulset-0                 1/1     Running   0          2m59s</span><br><span class=\"line\">emqx-statefulset-1                 1/1     Running   0          2m57s</span><br><span class=\"line\">emqx-statefulset-2                 1/1     Running   0          2m54s</span><br><span class=\"line\"></span><br><span class=\"line\">$ kubectl exec emqx-statefulset-0 -- emqx_ctl cluster status</span><br><span class=\"line\">Cluster status: #&#123;running_nodes =&gt;</span><br><span class=\"line\">                      [&#x27;emqx@192.168.77.105&#x27;,&#x27;emqx@192.168.87.153&#x27;,</span><br><span class=\"line\">                       &#x27;emqx@192.168.87.155&#x27;],</span><br><span class=\"line\">                  stopped_nodes =&gt; []&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>更新 Configmap：<br>\nStatefulSet 提供了稳定的网络标志，EMQX Broker 支持使用 hostname 和 dns 规则来代提 IP 实现集群，以 hostname 为例，需要修改 <code>emqx.conf</code>​：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cluster.kubernetes.address_type = hostname</span><br><span class=\"line\">cluster.kubernetes.suffix = &quot;svc.cluster.local&quot;</span><br></pre></td></tr></table></figure>\n<p>kubernetes 集群中 Pod 的 DNS 规则可以由用户自定义，EMQX Broker 提供了  <code>cluster.kubernetes.suffix</code>​ 方便用户匹配自定的 DNS 规则，本文使用默认的 DNS 规则：<code>statefulSetName-&#123;0..N-1&#125;.serviceName.namespace.svc.cluster.local</code>​ ，DNS 规则中的 serviceName 为 StatefulSet 使用的 Headless Service，所以还需要将 <code>cluster.kubernetes.service_name</code>​  修改为 Headless Service Name。<br>\n将配置项转为环境变量，需要在 Configmap 中配置：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EMQX_CLUSTER__K8S__ADDRESS_TYPE: &quot;hostname&quot;</span><br><span class=\"line\">EMQX_CLUSTER__K8S__SUFFIX: &quot;svc.cluster.local&quot;</span><br><span class=\"line\">EMQX_CLUSTER__K8S__SERVICE_NAME: emqx-headless</span><br></pre></td></tr></table></figure>\n<p>Configmap 提供了热更新功能，执行 <code>$ kubectl edit configmap emqx-config</code>​ 来热更新 Configmap。</p>\n</li>\n<li>\n<p>重新部署 StatefulSet：<br>\nConfigmap 更新之后 Pod 并不会重启，需要我们手动更新 StatefulSet</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ kubectl delete statefulset emqx-statefulset</span><br><span class=\"line\">statefulset.apps &quot;emqx-statefulset&quot; deleted</span><br><span class=\"line\"></span><br><span class=\"line\">$ kubectl apply -f statefulset.yaml</span><br><span class=\"line\">statefulset.apps/emqx-statefulset created</span><br><span class=\"line\"></span><br><span class=\"line\">$ kubectl get pods</span><br><span class=\"line\">NAME                 READY   STATUS    RESTARTS   AGE</span><br><span class=\"line\">emqx-statefulset-0   1/1     Running   0          115s</span><br><span class=\"line\">emqx-statefulset-1   1/1     Running   0          112s</span><br><span class=\"line\">emqx-statefulset-2   1/1     Running   0          110s</span><br><span class=\"line\"></span><br><span class=\"line\">$ kubectl exec emqx-statefulset-2 -- emqx_ctl cluster status</span><br><span class=\"line\">Cluster status: #&#123;running_nodes =&gt;</span><br><span class=\"line\">                      [&#x27;emqx@emqx-statefulset-0.emqx-headless.default.svc.cluster.local&#x27;,</span><br><span class=\"line\">                       &#x27;emqx@emqx-statefulset-1.emqx-headless.default.svc.cluster.local&#x27;,</span><br><span class=\"line\">                       &#x27;emqx@emqx-statefulset-2.emqx-headless.default.svc.cluster.local&#x27;],</span><br><span class=\"line\">                  stopped_nodes =&gt; []&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到新的 EMQX Broker 集群已经成功的建立起来了。</p>\n</li>\n<li>\n<p>中止一个 Pod：<br>\nStatefulSet 中的 Pod 重新调度后其 PodName 和 HostName 不变，下面来尝试一下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ kubectl get pods</span><br><span class=\"line\">kuNAME                 READY   STATUS    RESTARTS   AGE</span><br><span class=\"line\">emqx-statefulset-0   1/1     Running   0          6m20s</span><br><span class=\"line\">emqx-statefulset-1   1/1     Running   0          6m17s</span><br><span class=\"line\">emqx-statefulset-2   1/1     Running   0          6m15s</span><br><span class=\"line\"></span><br><span class=\"line\">$ kubectl delete pod emqx-statefulset-0</span><br><span class=\"line\">pod &quot;emqx-statefulset-0&quot; deleted</span><br><span class=\"line\"></span><br><span class=\"line\">$ kubectl get pods</span><br><span class=\"line\">NAME                 READY   STATUS    RESTARTS   AGE</span><br><span class=\"line\">emqx-statefulset-0   1/1     Running   0          27s</span><br><span class=\"line\">emqx-statefulset-1   1/1     Running   0          9m45s</span><br><span class=\"line\">emqx-statefulset-2   1/1     Running   0          9m43s</span><br><span class=\"line\"></span><br><span class=\"line\">$ kubectl exec emqx-statefulset-2 -- emqx_ctl cluster status</span><br><span class=\"line\">Cluster status: #&#123;running_nodes =&gt;</span><br><span class=\"line\">                      [&#x27;emqx@emqx-statefulset-0.emqx-headless.default.svc.cluster.local&#x27;,</span><br><span class=\"line\">                       &#x27;emqx@emqx-statefulset-1.emqx-headless.default.svc.cluster.local&#x27;,</span><br><span class=\"line\">                       &#x27;emqx@emqx-statefulset-2.emqx-headless.default.svc.cluster.local&#x27;],</span><br><span class=\"line\">                  stopped_nodes =&gt; []&#125;</span><br></pre></td></tr></table></figure>\n<p>跟预期的一样，StatefulSet 重新调度了一个具有相同网络标志的 Pod，Pod 中的 EMQX Broker 也成功的加入了集群。</p>\n</li>\n</ul>\n<h2 id=\"StorageClasses、PersistentVolume-和-PersistentVolumeClaim\">StorageClasses、PersistentVolume 和 PersistentVolumeClaim</h2>\n<p>PersistentVolume（PV）是由管理员设置的存储，它是群集的一部分。就像节点是集群中的资源一样，PV 也是集群中的资源。 PV 是 Volume 之类的卷插件，但具有独立于使用 PV 的 Pod 的生命周期。此 API  对象包含存储实现的细节，即 NFS、iSCSI 或特定于云供应商的存储系统。</p>\n<p>PersistentVolumeClaim（PVC）是用户存储的请求。它与 Pod 相似。Pod 消耗节点资源，PVC 消耗 PV 资源。Pod 可以请求特定级别的资源（CPU 和内存）。声明可以请求特定的大小和访问模式（例如，可以以读/写一次或 只读多次模式挂载）。</p>\n<p>StorageClass 为管理员提供了描述存储 “class（类）” 的方法。 不同的 class  可能会映射到不同的服务质量等级或备份策略，或由群集管理员确定的任意策略。 Kubernetes 本身不清楚各种 class  代表的什么。这个概念在其他存储系统中有时被称为“配置文件”。</p>\n<p>在部署 EMQX Broker 的时候，可以预先创建好 PV 或 StorageClass，然后利用 PVC 将 EMQX Broker 的 <code>/opt/emqx/data/mnesia</code>​ 目录挂载出来，当Pods被重新调度之后，EMQX 会从 <code>/opt/emqx/data/mnesia</code>​ 目录中获取数据并恢复，从而实现 EMQX Broker 的持久化。</p>\n<ul>\n<li>\n<p>定义 StatefulSet</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$cat statefulset.yaml</span><br><span class=\"line\"></span><br><span class=\"line\">apiVersion: apps/v1</span><br><span class=\"line\">kind: StatefulSet</span><br><span class=\"line\">metadata:</span><br><span class=\"line\">  name: emqx-statefulset</span><br><span class=\"line\">  labels:</span><br><span class=\"line\">    app: emqx</span><br><span class=\"line\">spec:</span><br><span class=\"line\">  replicas: 3</span><br><span class=\"line\">  serviceName: emqx-headless</span><br><span class=\"line\">  updateStrategy:</span><br><span class=\"line\">    type: RollingUpdate</span><br><span class=\"line\">  selector:</span><br><span class=\"line\">    matchLabels:</span><br><span class=\"line\">      app: emqx</span><br><span class=\"line\">  template:</span><br><span class=\"line\">    metadata:</span><br><span class=\"line\">      labels:</span><br><span class=\"line\">        app: emqx</span><br><span class=\"line\">    spec:</span><br><span class=\"line\">      volumes:</span><br><span class=\"line\">      - name: emqx-data</span><br><span class=\"line\">        persistentVolumeClaim:</span><br><span class=\"line\">          claimName: emqx-pvc</span><br><span class=\"line\">      serviceAccountName: emqx</span><br><span class=\"line\">      containers:</span><br><span class=\"line\">      - name: emqx</span><br><span class=\"line\">        image: emqx/emqx:v4.1-rc.1</span><br><span class=\"line\">        ports:</span><br><span class=\"line\">        - name: mqtt</span><br><span class=\"line\">          containerPort: 1883</span><br><span class=\"line\">        - name: mqttssl</span><br><span class=\"line\">          containerPort: 8883</span><br><span class=\"line\">        - name: mgmt</span><br><span class=\"line\">          containerPort: 8081</span><br><span class=\"line\">        - name: ws</span><br><span class=\"line\">          containerPort: 8083</span><br><span class=\"line\">        - name: wss</span><br><span class=\"line\">          containerPort: 8084</span><br><span class=\"line\">        - name: dashboard</span><br><span class=\"line\">          containerPort: 18083</span><br><span class=\"line\">        envFrom:</span><br><span class=\"line\">          - configMapRef:</span><br><span class=\"line\">              name: emqx-config</span><br><span class=\"line\">        volumeMounts:</span><br><span class=\"line\">        - name: emqx-data</span><br><span class=\"line\">          mountPath: &quot;/opt/emqx/data/mnesia&quot;</span><br><span class=\"line\">  volumeClaimTemplates:</span><br><span class=\"line\">  - metadata:</span><br><span class=\"line\">      name: emqx-pvc</span><br><span class=\"line\">      annotations:</span><br><span class=\"line\">        volume.alpha.kubernetes.io/storage-class: manual</span><br><span class=\"line\">    spec:</span><br><span class=\"line\">      accessModes: [ &quot;ReadWriteOnce&quot; ]</span><br><span class=\"line\">      resources:</span><br><span class=\"line\">        requests:</span><br><span class=\"line\">          storage: 1Gi</span><br></pre></td></tr></table></figure>\n<p>该文件首先通过 <code>volumeClaimTemplates</code>​ 指定了使用 StorageClass 的 name 为 manual 的存储类创建名称为 emqx-pvc 的 PVC 资源，PVC 资源的读写模式为 <code>ReadWriteOnce</code>​，需要 1Gi 的空间，然后将此 PVC 定义为 name 为 emqx-data 的 volumes，并将此 volumes 挂载在 Pod 中的 <code>/opt/emqx/data/mnesia</code>​  目录下。</p>\n</li>\n<li>\n<p>部署资源：<br>\n部署 StatefulSet 之前，需要用户或 kubernetes 集群管理员自行创建存储类。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ kubectl apply -f statefulset.yaml</span><br><span class=\"line\">statefulset.apps/emqx-statefulset created</span><br><span class=\"line\"></span><br><span class=\"line\">$ kubectl get pods</span><br><span class=\"line\">NAME                 READY   STATUS    RESTARTS   AGE</span><br><span class=\"line\">emqx-statefulset-0   1/1     Running   0          27s</span><br><span class=\"line\">emqx-statefulset-1   1/1     Running   0          9m45s</span><br><span class=\"line\">emqx-statefulset-2   1/1     Running   0          9m43s</span><br><span class=\"line\"></span><br><span class=\"line\">$ kubectl get pvc</span><br><span class=\"line\">NAME                                 STATUS    VOLUME                                 CAPACITY   ACCESS MODES   STORAGECLASS   AGE</span><br><span class=\"line\">emqx-data-emqx-statefulset-0   Bound     pvc-8094cd75-adb5-11e9-80cc-0697b59e8064   1Gi        RWO            gp2            2m11s</span><br><span class=\"line\">emqx-data-emqx-statefulset-0   Bound     pvc-9325441d-adb5-11e9-80cc-0697b59e8064   1Gi        RWO            gp2            99s</span><br><span class=\"line\">emqx-data-emqx-statefulset-0   Bound     pvc-ad425e9d-adb5-11e9-80cc-0697b59e8064   1Gi        RWO            gp2            56s</span><br></pre></td></tr></table></figure>\n<p>输出结果表明该 PVC 的状态为 Bound，PVC 存储已经成功的建立了，当 Pod 被重新调度时，EMQX Broker 会读取挂载到 PVC 中的数据，从而实现持久化。</p>\n</li>\n</ul>\n<p>EMQX Broker 在 kubernetes 上建立持久化的集群就完成了，本文略过了部分细节，部署的过程也是偏向简单的 Demo，用户可以自行阅读 <a href=\"https://kubernetes.io/zh-cn/docs/home/\">kubernetes 文档</a> 与  EMQX Team 提供的 <a href=\"https://github.com/emqx/emqx-rel/tree/master/deploy/charts/emqx\">Helm chart 源码</a> 来继续深入研究，当然也欢迎在 Github 贡献 issue、pull requests 以及 start。</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">apps/v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Deployment</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">emqx-deployment</span></span><br><span class=\"line\">  <span class=\"attr\">labels:</span></span><br><span class=\"line\">    <span class=\"attr\">app:</span> <span class=\"string\">emqx</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">replicas:</span> <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span></span><br><span class=\"line\">    <span class=\"attr\">matchLabels:</span></span><br><span class=\"line\">      <span class=\"attr\">app:</span> <span class=\"string\">emqx</span></span><br><span class=\"line\">  <span class=\"attr\">template:</span></span><br><span class=\"line\">    <span class=\"attr\">metadata:</span></span><br><span class=\"line\">      <span class=\"attr\">labels:</span></span><br><span class=\"line\">        <span class=\"attr\">app:</span> <span class=\"string\">emqx</span></span><br><span class=\"line\">    <span class=\"attr\">spec:</span></span><br><span class=\"line\">      <span class=\"attr\">containers:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">emqx</span></span><br><span class=\"line\">        <span class=\"attr\">image:</span> <span class=\"string\">emqx/emqx:5.7</span></span><br><span class=\"line\">        <span class=\"attr\">ports:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">mqtt</span></span><br><span class=\"line\">          <span class=\"attr\">containerPort:</span> <span class=\"number\">1883</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">mqttssl</span></span><br><span class=\"line\">          <span class=\"attr\">containerPort:</span> <span class=\"number\">8883</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">mgmt</span></span><br><span class=\"line\">          <span class=\"attr\">containerPort:</span> <span class=\"number\">8081</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">ws</span></span><br><span class=\"line\">          <span class=\"attr\">containerPort:</span> <span class=\"number\">8083</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">wss</span></span><br><span class=\"line\">          <span class=\"attr\">containerPort:</span> <span class=\"number\">8084</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">dashboard</span></span><br><span class=\"line\">          <span class=\"attr\">containerPort:</span> <span class=\"number\">18083</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n","excerpt":"","more":"<h1>从零开始建立 EMQX MQTT 服务器的 K8S 集群</h1>\n<iframe src=\"/widgets/metadata/\" data-src=\"/widgets/metadata/\" data-subtype=\"widget\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" style=\"height: 441px;\"></iframe>\n<hr>\n<ul>\n<li>从零开始建立 EMQX MQTT 服务器的 K8S 集群 - <a href=\"http://www.emqx.com\">www.emqx.com</a></li>\n<li><a href=\"https://www.emqx.com/zh/blog/emqx-mqtt-broker-k8s-cluster\">https://www.emqx.com/zh/blog/emqx-mqtt-broker-k8s-cluster</a></li>\n<li>本文将从零开始部署一个 EMQX MQTT 服务器的 K8S 集群，并分析部署中的细节与技巧，方便用户在实际部署中灵活使用。</li>\n<li>2024-06-28 10:42:05</li>\n</ul>\n<hr>\n<p>EMQX Team 提供了 Helm chart 方便用户在 kubernetes 集群上一键部署 EMQX <a href=\"https://www.emqx.com/zh/products/emqx\">MQTT 服务器</a>, 这是 EMQX Team 最推荐的在 kubernetes 或 k3s 集群上部署 EMQX MQTT 服务器的方法。 本文将使用手写 yaml 文件的方法从零开始部署一个 EMQX MQTT 服务器的 K8S 集群, 分析部署中的细节与技巧，方便用户在实际部署中灵活使用。</p>\n<p>阅读本文需要用户了解 kubernetes 的基本概念，并有一个可操作的 kubernetes 集群。</p>\n<h2 id=\"在-K8S-上部署单个-EMQX-MQTT服务器节点\">在 K8S 上部署单个 EMQX MQTT服务器节点</h2>\n<h3 id=\"使用-Pod-直接部署-EMQX-Broker\">使用 Pod 直接部署 EMQX Broker</h3>\n<p>在Kubernetes中，最小的管理元素不是一个个独立的容器，而是 <a href=\"https://kubernetes.io/zh/docs/concepts/workloads/pods/pod-overview/\">Pod</a>，Pod 是 Kubernetes 应用程序的基本执行单元，即它是 Kubernetes 对象模型中创建或部署的最小和最简单的单元。Pod 表示在 <a href=\"https://kubernetes.io/zh-cn/docs/reference/glossary/?all=true#term-cluster\">集群</a> 上运行的进程。</p>\n<p>EMQX Broker 在 <a href=\"https://hub.docker.com/r/emqx/emqx\">docker hub</a> 上提供了镜像, 因此可以很方便的在单个的 pod 上部署 EMQX Broker，使用 <code>kubectl run</code>​ 命令创建一个运行着 EMQX Broker 的 Pod：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ kubectl run emqx --image=emqx/emqx:v4.1-rc.1  --generator=run-pod/v1</span><br><span class=\"line\">pod/emqx created</span><br></pre></td></tr></table></figure>\n<p>查看 EMQX Broker 的状态：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ kubectl get pods -o wide</span><br><span class=\"line\">NAME   READY   STATUS    RESTARTS   AGE</span><br><span class=\"line\">emqx   1/1     Running   0          3m13s</span><br><span class=\"line\"></span><br><span class=\"line\">$ kubectl exec emqx -- emqx_ctl status</span><br><span class=\"line\">Node &#x27;emqx@192.168.77.108&#x27; is started</span><br><span class=\"line\">emqx 4.1-rc.1 is running</span><br></pre></td></tr></table></figure>\n<p>删除 Pod：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ kubectl delete pods emqx</span><br><span class=\"line\">pod &quot;emqx&quot; deleted</span><br></pre></td></tr></table></figure>\n<p>Pod 并不是被设计成一个持久化的资源，它不会在调度失败，节点崩溃，或者其他回收中（比如因为资源的缺乏，或者其他的维护中）幸存下来，因此，还需要一个控制器来管理 Pod。</p>\n<h3 id=\"使用-Deoloyment-部署-Pod\">使用 Deoloyment 部署 Pod</h3>\n<p><a href=\"https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/deployment/\">Deployment</a> 为 Pod 和 ReplicaSet 提供了一个声明式定义（declarative）方法，用来替代以前的<a href=\"https://www.kubernetes.org.cn/replication-controller-kubernetes\">ReplicationController</a> 来方便的管理应用。典型的应用场景包括：</p>\n<ul>\n<li>定义Deployment来创建Pod和ReplicaSet</li>\n<li>滚动升级和回滚应用</li>\n<li>扩容和缩容</li>\n<li>暂停和继续Deployment</li>\n</ul>\n<p>使用 Deployment 部署一个 EMQX Broker Pod：</p>\n<ul>\n<li>\n<p>定义 Deployment：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cat deployment.yaml</span><br><span class=\"line\"></span><br><span class=\"line\">apiVersion: apps/v1</span><br><span class=\"line\">kind: Deployment</span><br><span class=\"line\">metadata:</span><br><span class=\"line\">  name: emqx-deployment</span><br><span class=\"line\">  labels:</span><br><span class=\"line\">    app: emqx</span><br><span class=\"line\">spec:</span><br><span class=\"line\">  replicas: 1</span><br><span class=\"line\">  selector:</span><br><span class=\"line\">    matchLabels:</span><br><span class=\"line\">      app: emqx</span><br><span class=\"line\">  template:</span><br><span class=\"line\">    metadata:</span><br><span class=\"line\">      labels:</span><br><span class=\"line\">        app: emqx</span><br><span class=\"line\">    spec:</span><br><span class=\"line\">      containers:</span><br><span class=\"line\">      - name: emqx</span><br><span class=\"line\">        image: emqx/emqx:v4.1-rc.1</span><br><span class=\"line\">        ports:</span><br><span class=\"line\">        - name: mqtt</span><br><span class=\"line\">          containerPort: 1883</span><br><span class=\"line\">        - name: mqttssl</span><br><span class=\"line\">          containerPort: 8883</span><br><span class=\"line\">        - name: mgmt</span><br><span class=\"line\">          containerPort: 8081</span><br><span class=\"line\">        - name: ws</span><br><span class=\"line\">          containerPort: 8083</span><br><span class=\"line\">        - name: wss</span><br><span class=\"line\">          containerPort: 8084</span><br><span class=\"line\">        - name: dashboard</span><br><span class=\"line\">          containerPort: 18083</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>部署 Deployment：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$  kubectl apply -f deployment.yaml</span><br><span class=\"line\">deployment.apps/emqx-deployment created</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>查看部署情况：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ kubectl get deployment</span><br><span class=\"line\">NAME                              READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class=\"line\">deployment.apps/emqx-deployment   3/3     3            3           74s</span><br><span class=\"line\"></span><br><span class=\"line\">$ kubectl get pods</span><br><span class=\"line\">NAME                                  READY   STATUS    RESTARTS   AGE</span><br><span class=\"line\">pod/emqx-deployment-7c44dbd68-8j77l   1/1     Running   0          74s</span><br><span class=\"line\"></span><br><span class=\"line\">$ kubectl exec pod/emqx-deployment-7c44dbd68-8j77l -- emqx_ctl status</span><br><span class=\"line\">Node &#x27;emqx-deployment-7c44dbd68-8j77l@192.168.77.117&#x27; is started</span><br><span class=\"line\">emqx 4.1-rc.1 is running</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>尝试手动删除 Pod</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ kubectl delete pods emqx-deployment-7c44dbd68-8j77l</span><br><span class=\"line\">pod &quot;emqx-deployment-7c44dbd68-8j77l&quot; deleted</span><br><span class=\"line\"></span><br><span class=\"line\">$ kubectl get pods</span><br><span class=\"line\">NAME                              READY   STATUS    RESTARTS   AGE</span><br><span class=\"line\">emqx-deployment-68fcb4bfd6-2nhh6   1/1     Running   0          59s</span><br></pre></td></tr></table></figure>\n<p>输出结果表明成功用 Deployment 部署了 EMQX Broker Pod，即使是此 Pod 被意外终止，Deployment 也会重新创建一个新的 Pod。</p>\n</li>\n</ul>\n<h3 id=\"使用-Services-公开-EMQX-Broker-Pod-服务\">使用 Services 公开 EMQX Broker Pod 服务</h3>\n<p>Kubernetes <a href=\"https://kubernetes.io/docs/concepts/workloads/pods/\">Pods</a> 是有生命周期的。他们可以被创建，而且销毁不会再启动。 如果使用 <a href=\"https://kubernetes.io/docs/concepts/workloads/controllers/deployment/\">Deployment</a> 来运行应用程序，则它可以动态创建和销毁 Pod。</p>\n<p>每个 Pod 都有自己的 IP 地址，但是在 Deployment 中，在同一时刻运行的 Pod 集合可能与稍后运行该应用程序的 Pod 集合不同。</p>\n<p>这导致了一个问题：如果使用 EMQX Broker Pod 为 <strong>MQTT 客户端</strong>提供服务，那么客户端应该如何如何找出并跟踪要连接的 IP 地址，以便客户端使用 EMQX Broker 服务呢？</p>\n<p>答案是：Service</p>\n<p>Service 是将运行在一组 <a href=\"https://kubernetes.io/docs/concepts/workloads/pods/\">Pods</a> 上的应用程序公开为网络服务的抽象方法。</p>\n<p>使用 Service 将 EMQX Broker Pod 公开为网络服务：</p>\n<ul>\n<li>\n<p>定义 Service：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$cat service.yaml</span><br><span class=\"line\"></span><br><span class=\"line\">apiVersion: v1</span><br><span class=\"line\">kind: Service</span><br><span class=\"line\">metadata:</span><br><span class=\"line\">  name: emqx-service</span><br><span class=\"line\">spec:</span><br><span class=\"line\">  selector:</span><br><span class=\"line\">    app: emqx</span><br><span class=\"line\">  ports:</span><br><span class=\"line\">    - name: mqtt</span><br><span class=\"line\">      port: 1883</span><br><span class=\"line\">      protocol: TCP</span><br><span class=\"line\">      targetPort: mqtt</span><br><span class=\"line\">    - name: mqttssl</span><br><span class=\"line\">      port: 8883</span><br><span class=\"line\">      protocol: TCP</span><br><span class=\"line\">      targetPort: mqttssl</span><br><span class=\"line\">    - name: mgmt</span><br><span class=\"line\">      port: 8081</span><br><span class=\"line\">      protocol: TCP</span><br><span class=\"line\">      targetPort: mgmt</span><br><span class=\"line\">    - name: ws</span><br><span class=\"line\">      port: 8083</span><br><span class=\"line\">      protocol: TCP</span><br><span class=\"line\">      targetPort: ws</span><br><span class=\"line\">    - name: wss</span><br><span class=\"line\">      port: 8084</span><br><span class=\"line\">      protocol: TCP</span><br><span class=\"line\">      targetPort: wss</span><br><span class=\"line\">    - name: dashboard</span><br><span class=\"line\">      port: 18083</span><br><span class=\"line\">      protocol: TCP</span><br><span class=\"line\">      targetPort: dashboard</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>部署 Service：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ kubectl apply -f service.yaml</span><br><span class=\"line\">service/emqx-service created</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>查看部署情况</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ kubectl get svc</span><br><span class=\"line\">NAME           TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)                                        AGE</span><br><span class=\"line\">emqx-service   ClusterIP   10.96.54.205   &lt;none&gt;        1883/TCP,8883/TCP,8081/TCP,8083/TCP,8084/TCP,18083/TCP   58s</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>使用 Service 提供的 IP 查看 EMQX Broker 的 API</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ curl 10.96.54.205:8081/status</span><br><span class=\"line\">Node emqx-deployment-68fcb4bfd6-2nhh6@192.168.77.120 is started</span><br><span class=\"line\">emqx is running</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>至此，单个 EMQX Broker 节点在 kubernetes 上部署完毕，通过 Deployment 管理 EMQX Broker Pod，通过 Service 将 EMQX Broker 服务暴露出去。</p>\n<h2 id=\"通过-kubernetes-自动集群-EMQX-MQTT-服务器\">通过 kubernetes 自动集群 EMQX MQTT 服务器</h2>\n<p>上文中通过 Deployment 部署了单个的 EMQX Broker Pod，通过 Deployment 扩展 Pod 的数量是极为方便的，执行 <code>kubectl scale deployment $&#123;deployment_name&#125; --replicas $&#123;numer&#125;</code>​ 命令即可扩展 Pod 的数量，下面将 EMQX Broker Pod 扩展为 3 个：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ kubectl scale deployment emqx-deployment --replicas 3</span><br><span class=\"line\">deployment.apps/emqx-deployment scaled</span><br><span class=\"line\"></span><br><span class=\"line\">$ kubectl get pods</span><br><span class=\"line\">NAME                               READY   STATUS    RESTARTS   AGE</span><br><span class=\"line\">emqx-deployment-68fcb4bfd6-2nhh6   1/1     Running   0          18m</span><br><span class=\"line\">emqx-deployment-68fcb4bfd6-mpvch   1/1     Running   0          6s</span><br><span class=\"line\">emqx-deployment-68fcb4bfd6-mx55q   1/1     Running   0          6s</span><br><span class=\"line\"></span><br><span class=\"line\">$ kubectl exec emqx-deployment-68fcb4bfd6-2nhh6 -- emqx_ctl status</span><br><span class=\"line\">Node &#x27;emqx-deployment-68fcb4bfd6-2nhh6@192.168.77.120&#x27; is started</span><br><span class=\"line\">emqx 4.1-rc.1 is running</span><br><span class=\"line\"></span><br><span class=\"line\">$ kubectl exec emqx-deployment-68fcb4bfd6-2nhh6 -- emqx_ctl cluster status</span><br><span class=\"line\">Cluster status: #&#123;running_nodes =&gt;</span><br><span class=\"line\">                      [&#x27;emqx-deployment-68fcb4bfd6-2nhh6@192.168.77.120&#x27;],</span><br><span class=\"line\">                  stopped_nodes =&gt; []&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到 EMQX Broker Pod 的数量被扩展为 3 个，但是每个 Pod 都是独立的，并没有集群，接下来尝试通过 kubernetes 自动集群 EMQX Broker Pod。</p>\n<h3 id=\"修改-EMQX-Broker-的配置\">修改 EMQX Broker 的配置</h3>\n<p>查看 EMQX Broker 文档中关于<a href=\"https://docs.emqx.com/zh/emqx/latest/deploy/cluster/introduction.html\">自动集群</a>的内容，可以看到需要修改 EMQX Broker 的配置：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cluster.discovery = kubernetes</span><br><span class=\"line\">cluster.kubernetes.apiserver = http://10.110.111.204:8080</span><br><span class=\"line\">cluster.kubernetes.service_name = ekka</span><br><span class=\"line\">cluster.kubernetes.address_type = ip</span><br><span class=\"line\">cluster.kubernetes.app_name = ekka</span><br></pre></td></tr></table></figure>\n<p>其中 <code>cluster.kubernetes.apiserver</code>​ 为 kubernetes apiserver 的地址，可以通过 <code>kubectl cluster-info</code>​ 命令获取，<code>cluster.kubernetes.service_name</code>​ 为上文中 Service 的 name， <code>cluster.kubernetes.app_name</code>​ 为 EMQX Broker 的 <code>node.name</code>​ 中 <code>@</code>​ 符号之前的部分，所以还需要将集群中 EMQX Broker 设置为统一的 <code>node.name</code>​ 的前缀。</p>\n<p>EMQX Broker 的 docker 镜像提供了通过环境变量修改配置的功能，具体可以查看 <a href=\"https://hub.docker.com/r/emqx/emqx\">docker hub</a> 或 <a href=\"https://github.com/emqx/emqx-rel/blob/master/deploy/docker/README.md\">Github</a>。</p>\n<ul>\n<li>\n<p>修改 Deployment 的 yaml 文件，增加环境变量：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cat deployment.yaml</span><br><span class=\"line\"></span><br><span class=\"line\">apiVersion: apps/v1</span><br><span class=\"line\">kind: Deployment</span><br><span class=\"line\">metadata:</span><br><span class=\"line\">  name: emqx-deployment</span><br><span class=\"line\">  labels:</span><br><span class=\"line\">    app: emqx</span><br><span class=\"line\">spec:</span><br><span class=\"line\">  replicas: 3</span><br><span class=\"line\">  selector:</span><br><span class=\"line\">    matchLabels:</span><br><span class=\"line\">      app: emqx</span><br><span class=\"line\">  template:</span><br><span class=\"line\">    metadata:</span><br><span class=\"line\">      labels:</span><br><span class=\"line\">        app: emqx</span><br><span class=\"line\">    spec:</span><br><span class=\"line\">      containers:</span><br><span class=\"line\">      - name: emqx</span><br><span class=\"line\">        image: emqx/emqx:v4.1-rc.1</span><br><span class=\"line\">        ports:</span><br><span class=\"line\">        - name: mqtt</span><br><span class=\"line\">          containerPort: 1883</span><br><span class=\"line\">        - name: mqttssl</span><br><span class=\"line\">          containerPort: 8883</span><br><span class=\"line\">        - name: mgmt</span><br><span class=\"line\">          containerPort: 8081</span><br><span class=\"line\">        - name: ws</span><br><span class=\"line\">          containerPort: 8083</span><br><span class=\"line\">        - name: wss</span><br><span class=\"line\">          containerPort: 8084</span><br><span class=\"line\">        - name: dashboard</span><br><span class=\"line\">          containerPort: 18083</span><br><span class=\"line\">        env:</span><br><span class=\"line\">        - name: EMQX_NAME</span><br><span class=\"line\">          value: emqx</span><br><span class=\"line\">        - name: EMQX_CLUSTER__DISCOVERY</span><br><span class=\"line\">          value: k8s</span><br><span class=\"line\">        - name: EMQX_CLUSTER__K8S__APP_NAME</span><br><span class=\"line\">          value: emqx</span><br><span class=\"line\">        - name: EMQX_CLUSTER__K8S__SERVICE_NAME</span><br><span class=\"line\">          value: emqx-service</span><br><span class=\"line\">        - name: EMQX_CLUSTER__K8S__APISERVER</span><br><span class=\"line\">          value: &quot;https://kubernetes.default.svc:443&quot;</span><br><span class=\"line\">        - name: EMQX_CLUSTER__K8S__NAMESPACE</span><br><span class=\"line\">          value: default</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>因为 ``kubectl scale deployment ${deployment_name} --replicas ${numer}<code>命令不会修改 yaml 文件，所以修改 yaml 时需要设置</code>​spec.replicas: 3` 。</p>\n<p>Pod 中内建 kubernetes 的 DNS 规则，所以 <code>https://kubernetes.default.svc:443</code>​ 会被解析为 kubernetes apiserver  的地址。</p>\n</blockquote>\n</li>\n<li>\n<p>删除之前的 Deployment，重新部署：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ kubectl delete deployment emqx-deployment</span><br><span class=\"line\">deployment.apps &quot;emqx-deployment&quot; deleted</span><br><span class=\"line\"></span><br><span class=\"line\">$ kubectl apply -f deployment.yaml</span><br><span class=\"line\">deployment.apps/emqx-deployment created</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"赋予-Pod-访问-kubernetes-apiserver-的权限\">赋予 Pod 访问 kubernetes apiserver 的权限</h3>\n<p>上文部署 Deployment 之后，查看 EMQX Broker 的状态，可以看到 EMQX Broker 虽然成功启动了，但是依然没有集群成功，查看 EMQX Broker Pod 的 log：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ kubectl get pods</span><br><span class=\"line\">NAME                               READY   STATUS    RESTARTS   AGE</span><br><span class=\"line\">emqx-deployment-5c8cfc4d75-67lmt   1/1     Running   0          5s</span><br><span class=\"line\">emqx-deployment-5c8cfc4d75-r6jgb   1/1     Running   0          5s</span><br><span class=\"line\">emqx-deployment-5c8cfc4d75-wv2hj   1/1     Running   0          5s</span><br><span class=\"line\"></span><br><span class=\"line\">$ kubectl exec emqx-deployment-5c8cfc4d75-67lmt -- emqx_ctl status</span><br><span class=\"line\">Node &#x27;emqx@192.168.87.150&#x27; is started</span><br><span class=\"line\">emqx 4.1-rc.1 is running</span><br><span class=\"line\"></span><br><span class=\"line\">$ kubectl exec emqx-deployment-5c8cfc4d75-67lmt -- emqx_ctl cluster status</span><br><span class=\"line\">Cluster status: #&#123;running_nodes =&gt; [&#x27;emqx@192.168.87.150&#x27;],</span><br><span class=\"line\">                  stopped_nodes =&gt; []&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">$ kubectl logs emqx-deployment-76f6895c46-4684f</span><br><span class=\"line\"></span><br><span class=\"line\">···</span><br><span class=\"line\">(emqx@192.168.87.150)1&gt; 2020-05-20 01:48:39.726 [error] Ekka(AutoCluster): Discovery error: &#123;403,</span><br><span class=\"line\">                                     &quot;&#123;\\&quot;kind\\&quot;:\\&quot;Status\\&quot;,\\&quot;apiVersion\\&quot;:\\&quot;v1\\&quot;,\\&quot;metadata\\&quot;:&#123;&#125;,\\&quot;status\\&quot;:\\&quot;Failure\\&quot;,\\&quot;message\\&quot;:\\&quot;endpoints \\\\\\&quot;emqx-service\\\\\\&quot; is forbidden: User \\\\\\&quot;system:serviceaccount:default:default\\\\\\&quot; cannot get resource \\\\\\&quot;endpoints\\\\\\&quot; in API group \\\\\\&quot;\\\\\\&quot; in the namespace \\\\\\&quot;default\\\\\\&quot;\\&quot;,\\&quot;reason\\&quot;:\\&quot;Forbidden\\&quot;,\\&quot;details\\&quot;:&#123;\\&quot;name\\&quot;:\\&quot;emqx-service\\&quot;,\\&quot;kind\\&quot;:\\&quot;endpoints\\&quot;&#125;,\\&quot;code\\&quot;:403&#125;\\n&quot;&#125;</span><br><span class=\"line\">···</span><br></pre></td></tr></table></figure>\n<p>Pod 因为权限问题在访问 kubernetes apiserver 的时候被拒绝，返回 HTTP 403，所以集群失败。</p>\n<p>普通 Pod 是无法访问 kubernetes apiserver 的，解决这个问题有两种方法，一种是开放 kubernetes apiserver 的 http 接口，但是这种方法存在一定的安全隐患，另外一种是通过 ServiceAccount、Role 和 RoleBinding 配置 RBAC 鉴权。</p>\n<ul>\n<li>\n<p>定义  ServiceAccount、Role 和 RoleBinding：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cat rbac.yaml</span><br><span class=\"line\"></span><br><span class=\"line\">apiVersion: v1</span><br><span class=\"line\">kind: ServiceAccount</span><br><span class=\"line\">metadata:</span><br><span class=\"line\">  namespace: default</span><br><span class=\"line\">  name: emqx</span><br><span class=\"line\">---</span><br><span class=\"line\">kind: Role</span><br><span class=\"line\">apiVersion: rbac.authorization.kubernetes.io/v1beta1</span><br><span class=\"line\">metadata:</span><br><span class=\"line\">  namespace: default</span><br><span class=\"line\">  name: emqx</span><br><span class=\"line\">rules:</span><br><span class=\"line\">- apiGroups:</span><br><span class=\"line\">  - &quot;&quot;</span><br><span class=\"line\">  resources:</span><br><span class=\"line\">  - endpoints </span><br><span class=\"line\">  verbs: </span><br><span class=\"line\">  - get</span><br><span class=\"line\">  - watch</span><br><span class=\"line\">  - list</span><br><span class=\"line\">---</span><br><span class=\"line\">kind: RoleBinding</span><br><span class=\"line\">apiVersion: rbac.authorization.kubernetes.io/v1beta1</span><br><span class=\"line\">metadata:</span><br><span class=\"line\">  namespace: default</span><br><span class=\"line\">  name: emqx</span><br><span class=\"line\">subjects:</span><br><span class=\"line\">  - kind: ServiceAccount</span><br><span class=\"line\">    name: emqx</span><br><span class=\"line\">    namespace: default</span><br><span class=\"line\">roleRef:</span><br><span class=\"line\">  kind: Role</span><br><span class=\"line\">  name: emqx</span><br><span class=\"line\">  apiGroup: rbac.authorization.kubernetes.io</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>部署相应的资源：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ kubectl apply -f rbac.yaml</span><br><span class=\"line\">serviceaccount/emqx created</span><br><span class=\"line\">role.rbac.authorization.kubernetes.io/emqx created</span><br><span class=\"line\">rolebinding.rbac.authorization.kubernetes.io/emqx created</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>修改 Deployment 的 yaml 文件，增加 <code>spec.template.spec.serviceAccountName</code>​，并重新部署：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$cat deployment.yaml</span><br><span class=\"line\"></span><br><span class=\"line\">apiVersion: apps/v1</span><br><span class=\"line\">kind: Deployment</span><br><span class=\"line\">metadata:</span><br><span class=\"line\">  name: emqx-deployment</span><br><span class=\"line\">  labels:</span><br><span class=\"line\">    app: emqx</span><br><span class=\"line\">spec:</span><br><span class=\"line\">  replicas: 3</span><br><span class=\"line\">  selector:</span><br><span class=\"line\">    matchLabels:</span><br><span class=\"line\">      app: emqx</span><br><span class=\"line\">  template:</span><br><span class=\"line\">    metadata:</span><br><span class=\"line\">      labels:</span><br><span class=\"line\">        app: emqx</span><br><span class=\"line\">    spec:</span><br><span class=\"line\">      serviceAccountName: emqx</span><br><span class=\"line\">      containers:</span><br><span class=\"line\">      - name: emqx</span><br><span class=\"line\">        image: emqx/emqx:v4.1-rc.1</span><br><span class=\"line\">        ports:</span><br><span class=\"line\">        - name: mqtt</span><br><span class=\"line\">          containerPort: 1883</span><br><span class=\"line\">        - name: mqttssl</span><br><span class=\"line\">          containerPort: 8883</span><br><span class=\"line\">        - name: mgmt</span><br><span class=\"line\">          containerPort: 8081</span><br><span class=\"line\">        - name: ws</span><br><span class=\"line\">          containerPort: 8083</span><br><span class=\"line\">        - name: wss</span><br><span class=\"line\">          containerPort: 8084</span><br><span class=\"line\">        - name: dashboard</span><br><span class=\"line\">          containerPort: 18083</span><br><span class=\"line\">        env:</span><br><span class=\"line\">        - name: EMQX_NAME</span><br><span class=\"line\">          value: emqx</span><br><span class=\"line\">        - name: EMQX_CLUSTER__DISCOVERY</span><br><span class=\"line\">          value: kubernetes</span><br><span class=\"line\">        - name: EMQX_CLUSTER__K8S__APP_NAME</span><br><span class=\"line\">          value: emqx</span><br><span class=\"line\">        - name: EMQX_CLUSTER__K8S__SERVICE_NAME</span><br><span class=\"line\">          value: emqx-service</span><br><span class=\"line\">        - name: EMQX_CLUSTER__K8S__APISERVER</span><br><span class=\"line\">          value: &quot;https://kubernetes.default.svc:443&quot;</span><br><span class=\"line\">        - name: EMQX_CLUSTER__K8S__NAMESPACE</span><br><span class=\"line\">          value: default</span><br><span class=\"line\"></span><br><span class=\"line\">$ kubectl delete deployment emqx-deployment</span><br><span class=\"line\">deployment.apps &quot;emqx-deployment&quot; deleted</span><br><span class=\"line\"></span><br><span class=\"line\">$ kubectl apply -f deployment.yaml</span><br><span class=\"line\">deployment.apps/emqx-deployment created</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>查看状态：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ kubectl get pods</span><br><span class=\"line\">NAME                              READY   STATUS    RESTARTS   AGE</span><br><span class=\"line\">emqx-deployment-6b854486c-dhd7p   1/1     Running   0          10s</span><br><span class=\"line\">emqx-deployment-6b854486c-psv2r   1/1     Running   0          10s</span><br><span class=\"line\">emqx-deployment-6b854486c-tdzld   1/1     Running   0          10s</span><br><span class=\"line\"></span><br><span class=\"line\">$ kubectl exec emqx-deployment-6b854486c-dhd7p  -- emqx_ctl status</span><br><span class=\"line\">Node &#x27;emqx@192.168.77.92&#x27; is started</span><br><span class=\"line\">emqx 4.1-rc.1 is running</span><br><span class=\"line\"></span><br><span class=\"line\">$ kubectl exec emqx-deployment-6b854486c-dhd7p  -- emqx_ctl cluster status</span><br><span class=\"line\">Cluster status: #&#123;running_nodes =&gt;</span><br><span class=\"line\">                      [&#x27;emqx@192.168.77.115&#x27;,&#x27;emqx@192.168.77.92&#x27;,</span><br><span class=\"line\">                       &#x27;emqx@192.168.87.157&#x27;],</span><br><span class=\"line\">                  stopped_nodes =&gt; []&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>中止一个 Pod：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ kubectl delete pods emqx-deployment-6b854486c-dhd7p</span><br><span class=\"line\">pod &quot;emqx-deployment-6b854486c-dhd7p&quot; deleted</span><br><span class=\"line\"></span><br><span class=\"line\">$ kubectl get pods</span><br><span class=\"line\">NAME                              READY   STATUS    RESTARTS   AGE</span><br><span class=\"line\">emqx-deployment-6b854486c-846v7   1/1     Running   0          56s</span><br><span class=\"line\">emqx-deployment-6b854486c-psv2r   1/1     Running   0          3m50s</span><br><span class=\"line\">emqx-deployment-6b854486c-tdzld   1/1     Running   0          3m50s</span><br><span class=\"line\"></span><br><span class=\"line\">$ kubectl exec emqx-deployment-6b854486c-846v7 -- emqx_ctl cluster status</span><br><span class=\"line\">Cluster status: #&#123;running_nodes =&gt;</span><br><span class=\"line\">                      [&#x27;emqx@192.168.77.115&#x27;,&#x27;emqx@192.168.77.84&#x27;,</span><br><span class=\"line\">                       &#x27;emqx@192.168.87.157&#x27;],</span><br><span class=\"line\">                  stopped_nodes =&gt; [&#x27;emqx@192.168.77.92&#x27;]&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果表明 EMQX Broker 会正确的显示已经停掉的 Pod，并将 Deployment 新建的 Pod 加入集群。</p>\n</li>\n</ul>\n<p>至此，EMQX Broker 在 kubernetes 上成功建立集群。</p>\n<h2 id=\"持久化-EMQX-Broker-集群\">持久化 EMQX Broker 集群</h2>\n<p>上文中使用的 Deployment 来管理 Pod，但是 Pod 的网络是不停变动的，而且当 Pod 被销毁重建时，储存在 EMQX Broker 的数据和配置也就随之消失了，这在生产中是不能接受的，接下来尝试把 EMQX Broker 的集群持久化，即使 Pod 被销毁重建，EMQX Broker 的数据依然可以保存下来。</p>\n<h3 id=\"ConfigMap\">ConfigMap</h3>\n<p><a href=\"https://kubernetes.io/zh-cn/docs/concepts/configuration/configmap/\">ConfigMap</a> 是 configMap 是一种 API 对象，用来将非机密性的数据保存到健值对中。使用时可以用作环境变量、命令行参数或者存储卷中的配置文件。</p>\n<p>ConfigMap 将您的环境配置信息和 <a href=\"https://kubernetes.io/docs/concepts/overview/#why-containers\">容器镜像</a> 解耦，便于应用配置的修改。</p>\n<blockquote>\n<p>ConfigMap 并不提供保密或者加密功能。如果你想存储的数据是机密的，请使用 <a href=\"https://kubernetes.io/docs/concepts/configuration/secret/\">Secret</a> ，或者使用其他第三方工具来保证你的数据的私密性，而不是用 ConfigMap。</p>\n</blockquote>\n<p>接下来使用 ConfigMap 记录 EMQX Broker 的配置，并将它们以环境变量的方式导入到 Deployment 中。</p>\n<ul>\n<li>\n<p>定义 Configmap，并部署：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$cat configmap.yaml</span><br><span class=\"line\"></span><br><span class=\"line\">apiVersion: v1</span><br><span class=\"line\">kind: ConfigMap</span><br><span class=\"line\">metadata:</span><br><span class=\"line\">  name: emqx-config</span><br><span class=\"line\">data:</span><br><span class=\"line\">  EMQX_CLUSTER__K8S__ADDRESS_TYPE: &quot;hostname&quot;</span><br><span class=\"line\">  EMQX_CLUSTER__K8S__APISERVER: &quot;https://kubernetes.default.svc:443&quot;</span><br><span class=\"line\">  EMQX_CLUSTER__K8S__SUFFIX: &quot;svc.cluster.local&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">$ kubectl apply -f configmap.yaml</span><br><span class=\"line\">configmap/emqx-config created</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>配置 Deployment 来使用 Configmap</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$cat deployment.yaml</span><br><span class=\"line\"></span><br><span class=\"line\">apiVersion: apps/v1</span><br><span class=\"line\">kind: Deployment</span><br><span class=\"line\">metadata:</span><br><span class=\"line\">  name: emqx-deployment</span><br><span class=\"line\">  labels:</span><br><span class=\"line\">    app: emqx</span><br><span class=\"line\">spec:</span><br><span class=\"line\">  replicas: 3</span><br><span class=\"line\">  selector:</span><br><span class=\"line\">    matchLabels:</span><br><span class=\"line\">      app: emqx</span><br><span class=\"line\">  template:</span><br><span class=\"line\">    metadata:</span><br><span class=\"line\">      labels:</span><br><span class=\"line\">        app: emqx</span><br><span class=\"line\">    spec:</span><br><span class=\"line\">      serviceAccountName: emqx</span><br><span class=\"line\">      containers:</span><br><span class=\"line\">      - name: emqx</span><br><span class=\"line\">        image: emqx/emqx:v4.1-rc.1</span><br><span class=\"line\">        ports:</span><br><span class=\"line\">        - name: mqtt</span><br><span class=\"line\">          containerPort: 1883</span><br><span class=\"line\">        - name: mqttssl</span><br><span class=\"line\">          containerPort: 8883</span><br><span class=\"line\">        - name: mgmt</span><br><span class=\"line\">          containerPort: 8081</span><br><span class=\"line\">        - name: ws</span><br><span class=\"line\">          containerPort: 8083</span><br><span class=\"line\">        - name: wss</span><br><span class=\"line\">          containerPort: 8084</span><br><span class=\"line\">        - name: dashboard</span><br><span class=\"line\">          containerPort: 18083</span><br><span class=\"line\">        envFrom:</span><br><span class=\"line\">          - configMapRef:</span><br><span class=\"line\">              name: emqx-config</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>重新部署 Deployment，查看状态</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ kubectl delete -f deployment.yaml</span><br><span class=\"line\">deployment.apps &quot;emqx-deployment&quot; deleted</span><br><span class=\"line\"></span><br><span class=\"line\">$ kubectl apply -f deployment.yaml</span><br><span class=\"line\">deployment.apps/emqx-deployment created</span><br><span class=\"line\"></span><br><span class=\"line\">$ kubectl get pods</span><br><span class=\"line\">NAME                               READY   STATUS    RESTARTS   AGE</span><br><span class=\"line\">emqx-deployment-5c7696b5d7-k9lzj   1/1     Running   0          3s</span><br><span class=\"line\">emqx-deployment-5c7696b5d7-mdwkt   1/1     Running   0          3s</span><br><span class=\"line\">emqx-deployment-5c7696b5d7-z57z7   1/1     Running   0          3s</span><br><span class=\"line\"></span><br><span class=\"line\">$ kubectl exec emqx-deployment-5c7696b5d7-k9lzj -- emqx_ctl status</span><br><span class=\"line\">Node &#x27;emqx@192.168.87.149&#x27; is started</span><br><span class=\"line\">emqx 4.1-rc.1 is running</span><br><span class=\"line\"></span><br><span class=\"line\">$ kubectl exec emqx-deployment-5c7696b5d7-k9lzj -- emqx_ctl cluster status</span><br><span class=\"line\">Cluster status: #&#123;running_nodes =&gt;</span><br><span class=\"line\">                      [&#x27;emqx@192.168.77.106&#x27;,&#x27;emqx@192.168.77.107&#x27;,</span><br><span class=\"line\">                       &#x27;emqx@192.168.87.149&#x27;],</span><br><span class=\"line\">                  stopped_nodes =&gt; []&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>EMQX Broker 的配置文件已经解耦到 Configmap 中了，如果有需要，可以自由的配置一个或多个 Configmap，并把它们作为环境变量或是文件引入到 Pod 内。</p>\n<h3 id=\"StatefulSet\">StatefulSet</h3>\n<p><a href=\"https://kubernetes.io/zh-cn/docs/concepts/workloads/controllers/statefulset/\">StatefulSet</a> 是为了解决有状态服务的问题（对应 Deployments 和 ReplicaSets 是为无状态服务而设计），其应用场景包括</p>\n<ul>\n<li>稳定的持久化存储，即 Pod 重新调度后还是能访问到相同的持久化数据，基于 PVC 来实现</li>\n<li>稳定的网络标志，即 Pod 重新调度后其 PodName 和 HostName 不变，基于 Headless Service（即没有Cluster IP的Service）来实现</li>\n<li>有序部署，有序扩展，即 Pod 是有顺序的，在部署或者扩展的时候要依据定义的顺序依次依次进行（即从0到N-1，在下一个Pod运行之前所有之前的 Pod 必须都是 Running 和 Ready 状态），基于 init containers 来实现</li>\n<li>有序收缩，有序删除（即从N-1到0）</li>\n</ul>\n<p>从上面的应用场景可以发现，StatefulSet由以下几个部分组成：</p>\n<ul>\n<li>用于定义网络标志（DNS domain）的 Headless Service</li>\n<li>用于创建 PersistentVolumes 的 volumeClaimTemplates</li>\n<li>定义具体应用的 StatefulSet</li>\n</ul>\n<p>StatefulSet 中每个 Pod 的 DNS 格式为 <code>statefulSetName-&#123;0..N-1&#125;.serviceName.namespace.svc.cluster.local</code>​ ，其中</p>\n<ul>\n<li>​<code>serviceName</code>​ 为 Headless Service 的名字</li>\n<li>​<code>0..N-1</code>​ 为 Pod 所在的序号，从 0 开始到 N-1</li>\n<li>​<code>statefulSetName</code>​ 为StatefulSet的名字</li>\n<li>​<code>namespace</code>​ 为服务所在的 namespace，Headless Servic 和 StatefulSet 必须在相同的 namespace</li>\n<li>​<code>.cluster.local</code>​ 为 Cluster Domain</li>\n</ul>\n<p>接下来使用 StatefulSet 代替 Deployment 来管理 Pod。</p>\n<ul>\n<li>\n<p>删除 Deployment：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ kubectl delete deployment emqx-deployment</span><br><span class=\"line\">deployment.apps &quot;emqx-deployment&quot; deleted</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>定义 StatefulSet：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$cat statefulset.yaml</span><br><span class=\"line\"></span><br><span class=\"line\">apiVersion: apps/v1</span><br><span class=\"line\">kind: StatefulSet</span><br><span class=\"line\">metadata:</span><br><span class=\"line\">  name: emqx-statefulset</span><br><span class=\"line\">  labels:</span><br><span class=\"line\">    app: emqx</span><br><span class=\"line\">spec:</span><br><span class=\"line\">  serviceName: emqx-headless</span><br><span class=\"line\">  updateStrategy:</span><br><span class=\"line\">    type: RollingUpdate</span><br><span class=\"line\">  replicas: 3</span><br><span class=\"line\">  selector:</span><br><span class=\"line\">    matchLabels:</span><br><span class=\"line\">      app: emqx</span><br><span class=\"line\">  template:</span><br><span class=\"line\">    metadata:</span><br><span class=\"line\">      labels:</span><br><span class=\"line\">        app: emqx</span><br><span class=\"line\">    spec:</span><br><span class=\"line\">      serviceAccountName: emqx</span><br><span class=\"line\">      containers:</span><br><span class=\"line\">      - name: emqx</span><br><span class=\"line\">        image: emqx/emqx:v4.1-rc.1</span><br><span class=\"line\">        ports:</span><br><span class=\"line\">        - name: mqtt</span><br><span class=\"line\">          containerPort: 1883</span><br><span class=\"line\">        - name: mqttssl</span><br><span class=\"line\">          containerPort: 8883</span><br><span class=\"line\">        - name: mgmt</span><br><span class=\"line\">          containerPort: 8081</span><br><span class=\"line\">        - name: ws</span><br><span class=\"line\">          containerPort: 8083</span><br><span class=\"line\">        - name: wss</span><br><span class=\"line\">          containerPort: 8084</span><br><span class=\"line\">        - name: dashboard</span><br><span class=\"line\">          containerPort: 18083</span><br><span class=\"line\">        envFrom:</span><br><span class=\"line\">          - configMapRef:</span><br><span class=\"line\">              name: emqx-config</span><br></pre></td></tr></table></figure>\n<p>注意，StatefulSet 需要 Headless Service 来实现稳定的网络标志，因此需要再定义一个 Service</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$cat headless.yaml</span><br><span class=\"line\"></span><br><span class=\"line\">apiVersion: v1</span><br><span class=\"line\">kind: Service</span><br><span class=\"line\">metadata:</span><br><span class=\"line\">  name: emqx-headless</span><br><span class=\"line\">spec:</span><br><span class=\"line\">  type: ClusterIP</span><br><span class=\"line\">  clusterIP: None</span><br><span class=\"line\">  selector:</span><br><span class=\"line\">    app: emqx</span><br><span class=\"line\">  ports:</span><br><span class=\"line\">  - name: mqtt</span><br><span class=\"line\">    port: 1883</span><br><span class=\"line\">    protocol: TCP</span><br><span class=\"line\">    targetPort: 1883</span><br><span class=\"line\">  - name: mqttssl</span><br><span class=\"line\">    port: 8883</span><br><span class=\"line\">    protocol: TCP</span><br><span class=\"line\">    targetPort: 8883</span><br><span class=\"line\">  - name: mgmt</span><br><span class=\"line\">    port: 8081</span><br><span class=\"line\">    protocol: TCP</span><br><span class=\"line\">    targetPort: 8081</span><br><span class=\"line\">  - name: websocket</span><br><span class=\"line\">    port: 8083</span><br><span class=\"line\">    protocol: TCP</span><br><span class=\"line\">    targetPort: 8083</span><br><span class=\"line\">  - name: wss</span><br><span class=\"line\">    port: 8084</span><br><span class=\"line\">    protocol: TCP</span><br><span class=\"line\">    targetPort: 8084</span><br><span class=\"line\">  - name: dashboard</span><br><span class=\"line\">    port: 18083</span><br><span class=\"line\">    protocol: TCP</span><br><span class=\"line\">    targetPort: 18083</span><br></pre></td></tr></table></figure>\n<p>因为 Headless Service 并不需要 IP，所以配置了 <code>clusterIP: None</code>​ 。</p>\n</li>\n<li>\n<p>部署相应的资源：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ kubectl apply -f headless-service.yaml</span><br><span class=\"line\">service/emqx-headless created</span><br><span class=\"line\"></span><br><span class=\"line\">$ kubectl apply -f statefulset.yaml</span><br><span class=\"line\">statefulset.apps/emqx-deployment created</span><br><span class=\"line\"></span><br><span class=\"line\">$ kubectl get pods</span><br><span class=\"line\">NAME                               READY   STATUS    RESTARTS   AGE</span><br><span class=\"line\">emqx-statefulset-0                 1/1     Running   0          2m59s</span><br><span class=\"line\">emqx-statefulset-1                 1/1     Running   0          2m57s</span><br><span class=\"line\">emqx-statefulset-2                 1/1     Running   0          2m54s</span><br><span class=\"line\"></span><br><span class=\"line\">$ kubectl exec emqx-statefulset-0 -- emqx_ctl cluster status</span><br><span class=\"line\">Cluster status: #&#123;running_nodes =&gt;</span><br><span class=\"line\">                      [&#x27;emqx@192.168.77.105&#x27;,&#x27;emqx@192.168.87.153&#x27;,</span><br><span class=\"line\">                       &#x27;emqx@192.168.87.155&#x27;],</span><br><span class=\"line\">                  stopped_nodes =&gt; []&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>更新 Configmap：<br>\nStatefulSet 提供了稳定的网络标志，EMQX Broker 支持使用 hostname 和 dns 规则来代提 IP 实现集群，以 hostname 为例，需要修改 <code>emqx.conf</code>​：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cluster.kubernetes.address_type = hostname</span><br><span class=\"line\">cluster.kubernetes.suffix = &quot;svc.cluster.local&quot;</span><br></pre></td></tr></table></figure>\n<p>kubernetes 集群中 Pod 的 DNS 规则可以由用户自定义，EMQX Broker 提供了  <code>cluster.kubernetes.suffix</code>​ 方便用户匹配自定的 DNS 规则，本文使用默认的 DNS 规则：<code>statefulSetName-&#123;0..N-1&#125;.serviceName.namespace.svc.cluster.local</code>​ ，DNS 规则中的 serviceName 为 StatefulSet 使用的 Headless Service，所以还需要将 <code>cluster.kubernetes.service_name</code>​  修改为 Headless Service Name。<br>\n将配置项转为环境变量，需要在 Configmap 中配置：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EMQX_CLUSTER__K8S__ADDRESS_TYPE: &quot;hostname&quot;</span><br><span class=\"line\">EMQX_CLUSTER__K8S__SUFFIX: &quot;svc.cluster.local&quot;</span><br><span class=\"line\">EMQX_CLUSTER__K8S__SERVICE_NAME: emqx-headless</span><br></pre></td></tr></table></figure>\n<p>Configmap 提供了热更新功能，执行 <code>$ kubectl edit configmap emqx-config</code>​ 来热更新 Configmap。</p>\n</li>\n<li>\n<p>重新部署 StatefulSet：<br>\nConfigmap 更新之后 Pod 并不会重启，需要我们手动更新 StatefulSet</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ kubectl delete statefulset emqx-statefulset</span><br><span class=\"line\">statefulset.apps &quot;emqx-statefulset&quot; deleted</span><br><span class=\"line\"></span><br><span class=\"line\">$ kubectl apply -f statefulset.yaml</span><br><span class=\"line\">statefulset.apps/emqx-statefulset created</span><br><span class=\"line\"></span><br><span class=\"line\">$ kubectl get pods</span><br><span class=\"line\">NAME                 READY   STATUS    RESTARTS   AGE</span><br><span class=\"line\">emqx-statefulset-0   1/1     Running   0          115s</span><br><span class=\"line\">emqx-statefulset-1   1/1     Running   0          112s</span><br><span class=\"line\">emqx-statefulset-2   1/1     Running   0          110s</span><br><span class=\"line\"></span><br><span class=\"line\">$ kubectl exec emqx-statefulset-2 -- emqx_ctl cluster status</span><br><span class=\"line\">Cluster status: #&#123;running_nodes =&gt;</span><br><span class=\"line\">                      [&#x27;emqx@emqx-statefulset-0.emqx-headless.default.svc.cluster.local&#x27;,</span><br><span class=\"line\">                       &#x27;emqx@emqx-statefulset-1.emqx-headless.default.svc.cluster.local&#x27;,</span><br><span class=\"line\">                       &#x27;emqx@emqx-statefulset-2.emqx-headless.default.svc.cluster.local&#x27;],</span><br><span class=\"line\">                  stopped_nodes =&gt; []&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到新的 EMQX Broker 集群已经成功的建立起来了。</p>\n</li>\n<li>\n<p>中止一个 Pod：<br>\nStatefulSet 中的 Pod 重新调度后其 PodName 和 HostName 不变，下面来尝试一下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ kubectl get pods</span><br><span class=\"line\">kuNAME                 READY   STATUS    RESTARTS   AGE</span><br><span class=\"line\">emqx-statefulset-0   1/1     Running   0          6m20s</span><br><span class=\"line\">emqx-statefulset-1   1/1     Running   0          6m17s</span><br><span class=\"line\">emqx-statefulset-2   1/1     Running   0          6m15s</span><br><span class=\"line\"></span><br><span class=\"line\">$ kubectl delete pod emqx-statefulset-0</span><br><span class=\"line\">pod &quot;emqx-statefulset-0&quot; deleted</span><br><span class=\"line\"></span><br><span class=\"line\">$ kubectl get pods</span><br><span class=\"line\">NAME                 READY   STATUS    RESTARTS   AGE</span><br><span class=\"line\">emqx-statefulset-0   1/1     Running   0          27s</span><br><span class=\"line\">emqx-statefulset-1   1/1     Running   0          9m45s</span><br><span class=\"line\">emqx-statefulset-2   1/1     Running   0          9m43s</span><br><span class=\"line\"></span><br><span class=\"line\">$ kubectl exec emqx-statefulset-2 -- emqx_ctl cluster status</span><br><span class=\"line\">Cluster status: #&#123;running_nodes =&gt;</span><br><span class=\"line\">                      [&#x27;emqx@emqx-statefulset-0.emqx-headless.default.svc.cluster.local&#x27;,</span><br><span class=\"line\">                       &#x27;emqx@emqx-statefulset-1.emqx-headless.default.svc.cluster.local&#x27;,</span><br><span class=\"line\">                       &#x27;emqx@emqx-statefulset-2.emqx-headless.default.svc.cluster.local&#x27;],</span><br><span class=\"line\">                  stopped_nodes =&gt; []&#125;</span><br></pre></td></tr></table></figure>\n<p>跟预期的一样，StatefulSet 重新调度了一个具有相同网络标志的 Pod，Pod 中的 EMQX Broker 也成功的加入了集群。</p>\n</li>\n</ul>\n<h2 id=\"StorageClasses、PersistentVolume-和-PersistentVolumeClaim\">StorageClasses、PersistentVolume 和 PersistentVolumeClaim</h2>\n<p>PersistentVolume（PV）是由管理员设置的存储，它是群集的一部分。就像节点是集群中的资源一样，PV 也是集群中的资源。 PV 是 Volume 之类的卷插件，但具有独立于使用 PV 的 Pod 的生命周期。此 API  对象包含存储实现的细节，即 NFS、iSCSI 或特定于云供应商的存储系统。</p>\n<p>PersistentVolumeClaim（PVC）是用户存储的请求。它与 Pod 相似。Pod 消耗节点资源，PVC 消耗 PV 资源。Pod 可以请求特定级别的资源（CPU 和内存）。声明可以请求特定的大小和访问模式（例如，可以以读/写一次或 只读多次模式挂载）。</p>\n<p>StorageClass 为管理员提供了描述存储 “class（类）” 的方法。 不同的 class  可能会映射到不同的服务质量等级或备份策略，或由群集管理员确定的任意策略。 Kubernetes 本身不清楚各种 class  代表的什么。这个概念在其他存储系统中有时被称为“配置文件”。</p>\n<p>在部署 EMQX Broker 的时候，可以预先创建好 PV 或 StorageClass，然后利用 PVC 将 EMQX Broker 的 <code>/opt/emqx/data/mnesia</code>​ 目录挂载出来，当Pods被重新调度之后，EMQX 会从 <code>/opt/emqx/data/mnesia</code>​ 目录中获取数据并恢复，从而实现 EMQX Broker 的持久化。</p>\n<ul>\n<li>\n<p>定义 StatefulSet</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$cat statefulset.yaml</span><br><span class=\"line\"></span><br><span class=\"line\">apiVersion: apps/v1</span><br><span class=\"line\">kind: StatefulSet</span><br><span class=\"line\">metadata:</span><br><span class=\"line\">  name: emqx-statefulset</span><br><span class=\"line\">  labels:</span><br><span class=\"line\">    app: emqx</span><br><span class=\"line\">spec:</span><br><span class=\"line\">  replicas: 3</span><br><span class=\"line\">  serviceName: emqx-headless</span><br><span class=\"line\">  updateStrategy:</span><br><span class=\"line\">    type: RollingUpdate</span><br><span class=\"line\">  selector:</span><br><span class=\"line\">    matchLabels:</span><br><span class=\"line\">      app: emqx</span><br><span class=\"line\">  template:</span><br><span class=\"line\">    metadata:</span><br><span class=\"line\">      labels:</span><br><span class=\"line\">        app: emqx</span><br><span class=\"line\">    spec:</span><br><span class=\"line\">      volumes:</span><br><span class=\"line\">      - name: emqx-data</span><br><span class=\"line\">        persistentVolumeClaim:</span><br><span class=\"line\">          claimName: emqx-pvc</span><br><span class=\"line\">      serviceAccountName: emqx</span><br><span class=\"line\">      containers:</span><br><span class=\"line\">      - name: emqx</span><br><span class=\"line\">        image: emqx/emqx:v4.1-rc.1</span><br><span class=\"line\">        ports:</span><br><span class=\"line\">        - name: mqtt</span><br><span class=\"line\">          containerPort: 1883</span><br><span class=\"line\">        - name: mqttssl</span><br><span class=\"line\">          containerPort: 8883</span><br><span class=\"line\">        - name: mgmt</span><br><span class=\"line\">          containerPort: 8081</span><br><span class=\"line\">        - name: ws</span><br><span class=\"line\">          containerPort: 8083</span><br><span class=\"line\">        - name: wss</span><br><span class=\"line\">          containerPort: 8084</span><br><span class=\"line\">        - name: dashboard</span><br><span class=\"line\">          containerPort: 18083</span><br><span class=\"line\">        envFrom:</span><br><span class=\"line\">          - configMapRef:</span><br><span class=\"line\">              name: emqx-config</span><br><span class=\"line\">        volumeMounts:</span><br><span class=\"line\">        - name: emqx-data</span><br><span class=\"line\">          mountPath: &quot;/opt/emqx/data/mnesia&quot;</span><br><span class=\"line\">  volumeClaimTemplates:</span><br><span class=\"line\">  - metadata:</span><br><span class=\"line\">      name: emqx-pvc</span><br><span class=\"line\">      annotations:</span><br><span class=\"line\">        volume.alpha.kubernetes.io/storage-class: manual</span><br><span class=\"line\">    spec:</span><br><span class=\"line\">      accessModes: [ &quot;ReadWriteOnce&quot; ]</span><br><span class=\"line\">      resources:</span><br><span class=\"line\">        requests:</span><br><span class=\"line\">          storage: 1Gi</span><br></pre></td></tr></table></figure>\n<p>该文件首先通过 <code>volumeClaimTemplates</code>​ 指定了使用 StorageClass 的 name 为 manual 的存储类创建名称为 emqx-pvc 的 PVC 资源，PVC 资源的读写模式为 <code>ReadWriteOnce</code>​，需要 1Gi 的空间，然后将此 PVC 定义为 name 为 emqx-data 的 volumes，并将此 volumes 挂载在 Pod 中的 <code>/opt/emqx/data/mnesia</code>​  目录下。</p>\n</li>\n<li>\n<p>部署资源：<br>\n部署 StatefulSet 之前，需要用户或 kubernetes 集群管理员自行创建存储类。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ kubectl apply -f statefulset.yaml</span><br><span class=\"line\">statefulset.apps/emqx-statefulset created</span><br><span class=\"line\"></span><br><span class=\"line\">$ kubectl get pods</span><br><span class=\"line\">NAME                 READY   STATUS    RESTARTS   AGE</span><br><span class=\"line\">emqx-statefulset-0   1/1     Running   0          27s</span><br><span class=\"line\">emqx-statefulset-1   1/1     Running   0          9m45s</span><br><span class=\"line\">emqx-statefulset-2   1/1     Running   0          9m43s</span><br><span class=\"line\"></span><br><span class=\"line\">$ kubectl get pvc</span><br><span class=\"line\">NAME                                 STATUS    VOLUME                                 CAPACITY   ACCESS MODES   STORAGECLASS   AGE</span><br><span class=\"line\">emqx-data-emqx-statefulset-0   Bound     pvc-8094cd75-adb5-11e9-80cc-0697b59e8064   1Gi        RWO            gp2            2m11s</span><br><span class=\"line\">emqx-data-emqx-statefulset-0   Bound     pvc-9325441d-adb5-11e9-80cc-0697b59e8064   1Gi        RWO            gp2            99s</span><br><span class=\"line\">emqx-data-emqx-statefulset-0   Bound     pvc-ad425e9d-adb5-11e9-80cc-0697b59e8064   1Gi        RWO            gp2            56s</span><br></pre></td></tr></table></figure>\n<p>输出结果表明该 PVC 的状态为 Bound，PVC 存储已经成功的建立了，当 Pod 被重新调度时，EMQX Broker 会读取挂载到 PVC 中的数据，从而实现持久化。</p>\n</li>\n</ul>\n<p>EMQX Broker 在 kubernetes 上建立持久化的集群就完成了，本文略过了部分细节，部署的过程也是偏向简单的 Demo，用户可以自行阅读 <a href=\"https://kubernetes.io/zh-cn/docs/home/\">kubernetes 文档</a> 与  EMQX Team 提供的 <a href=\"https://github.com/emqx/emqx-rel/tree/master/deploy/charts/emqx\">Helm chart 源码</a> 来继续深入研究，当然也欢迎在 Github 贡献 issue、pull requests 以及 start。</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">apps/v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">Deployment</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">emqx-deployment</span></span><br><span class=\"line\">  <span class=\"attr\">labels:</span></span><br><span class=\"line\">    <span class=\"attr\">app:</span> <span class=\"string\">emqx</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">replicas:</span> <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span></span><br><span class=\"line\">    <span class=\"attr\">matchLabels:</span></span><br><span class=\"line\">      <span class=\"attr\">app:</span> <span class=\"string\">emqx</span></span><br><span class=\"line\">  <span class=\"attr\">template:</span></span><br><span class=\"line\">    <span class=\"attr\">metadata:</span></span><br><span class=\"line\">      <span class=\"attr\">labels:</span></span><br><span class=\"line\">        <span class=\"attr\">app:</span> <span class=\"string\">emqx</span></span><br><span class=\"line\">    <span class=\"attr\">spec:</span></span><br><span class=\"line\">      <span class=\"attr\">containers:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">emqx</span></span><br><span class=\"line\">        <span class=\"attr\">image:</span> <span class=\"string\">emqx/emqx:5.7</span></span><br><span class=\"line\">        <span class=\"attr\">ports:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">mqtt</span></span><br><span class=\"line\">          <span class=\"attr\">containerPort:</span> <span class=\"number\">1883</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">mqttssl</span></span><br><span class=\"line\">          <span class=\"attr\">containerPort:</span> <span class=\"number\">8883</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">mgmt</span></span><br><span class=\"line\">          <span class=\"attr\">containerPort:</span> <span class=\"number\">8081</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">ws</span></span><br><span class=\"line\">          <span class=\"attr\">containerPort:</span> <span class=\"number\">8083</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">wss</span></span><br><span class=\"line\">          <span class=\"attr\">containerPort:</span> <span class=\"number\">8084</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">dashboard</span></span><br><span class=\"line\">          <span class=\"attr\">containerPort:</span> <span class=\"number\">18083</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n"},{"title":"Consul 安装","date":"2025-05-01T08:57:07.000Z","lastmod":"2025-05-01T08:57:07.000Z","_content":"Consul 安装\n\n## 服务端启动命令\n\n```shell\nconsul agent -server -bootstrap-expect 1 -data-dir /home/ubuntu/consul/data -ui -config-dir /home/ubuntu/consul/consul.d -bind=172.25.74.176 -client=0.0.0.0\n```","source":"_posts/20250501/6.md","raw":"---\ntitle: Consul 安装\ndate: 2025-05-01 16:57:07\nlastmod: 2025-05-01 16:57:07\ntags: [Consul]\ncategory: Consul\n---\nConsul 安装\n\n## 服务端启动命令\n\n```shell\nconsul agent -server -bootstrap-expect 1 -data-dir /home/ubuntu/consul/data -ui -config-dir /home/ubuntu/consul/consul.d -bind=172.25.74.176 -client=0.0.0.0\n```","slug":"20250501-6","published":1,"updated":"2025-05-01T09:40:45.205Z","comments":1,"layout":"post","photos":[],"_id":"cma56nfvu0009isjjedzadazh","content":"<p>Consul 安装</p>\n<h2 id=\"服务端启动命令\">服务端启动命令</h2>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">consul agent -server -bootstrap-expect 1 -data-dir /home/ubuntu/consul/data -ui -config-dir /home/ubuntu/consul/consul.d -bind=172.25.74.176 -client=0.0.0.0</span><br></pre></td></tr></table></figure>","excerpt":"","more":"<p>Consul 安装</p>\n<h2 id=\"服务端启动命令\">服务端启动命令</h2>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">consul agent -server -bootstrap-expect 1 -data-dir /home/ubuntu/consul/data -ui -config-dir /home/ubuntu/consul/consul.d -bind=172.25.74.176 -client=0.0.0.0</span><br></pre></td></tr></table></figure>"},{"title":"Netty Recycler","date":"2025-05-01T08:57:07.000Z","lastmod":"2025-05-01T08:57:07.000Z","_content":"\n\n\n# Recycler\n\n---\n> 转载          bin的技术小屋              \n> 本系列Netty源码解析文章基于 **4.1.56.Final**版本\n\n## 1. 池化思想的应用\n\n　　在我们日常开发工作中我们经常会遇到各种池化技术的设计思想，比如连接池，内存池，对象池，还有我们在业务开发过程中经常会缓存一些业务计算结果数据这也同样运用到了池化技术的设计思想，我们可以叫它为结果池。\n\n　　池化技术的应用场景就是当一个对象的创建和销毁需要付出比较大的性能开销时，我们就需要将这些重量级对象放在一个池子里管理，当需要时直接从池子里获取避免重复创建和销毁的开销从而达到了复用的效果。\n\n　　比如连接池里面保存管理的都是一些网络连接对象，这些对象创建和销毁的代价比较大。通过连接池将这些重量级的网络连接对象统一管理起来，业务线程可以直接复用，避免了重新创建，释放连接的性能开销以及等待时间。\n\n　　还有我们在日常开发中遇到的一些计算逻辑复杂的业务，我们通常会先从数据库中查询数据，然后经过复杂的计算得到结果，为了避免下次在重复计算，我们会将计算结果放入缓存中，我们可以称做结果池。也是一种池化思想。\n\n　　再比如我们在[《Netty如何高效接收网络数据》](https://link.juejin.cn/?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg2MzU3Mjc3Ng%3D%3D%26mid%3D2247484244%26idx%3D1%26sn%3D831060fc38caa201d69f87305de7f86a%26chksm%3Dce77c513f9004c05b48f849ff99997d6d7252453135ae856a029137b88aa70b8e046013d596e%23rd \"https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&mid=2247484244&idx=1&sn=831060fc38caa201d69f87305de7f86a&chksm=ce77c513f9004c05b48f849ff99997d6d7252453135ae856a029137b88aa70b8e046013d596e#rd\")一文中提到的内存池，为了避免不必要的数据拷贝以及JVM垃圾回收对性能的影响，Netty 选择使用堆外内存存储网络通信数据。在 Netty 申请堆外内存之前，首先会在 JVM 堆中创建一个用于引用 native memory 的引用对象 DirectByteBuffer ，随后会使用 native 方法 `unsafe.allocateMemory`​ 通过底层 `malloc`​ 系统调用申请一块堆外内存。\n\n　　这里就涉及到到两个重要开销：\n\n* 在 JVM 堆中创建对象 DirectByteBuffer ，并为该对象申请分配 JVM 堆内存。\n* 通过 `malloc`​ 系统调用向操作系统申请堆外内存，然后被 DirectByteBuffer 引用。但是堆外内存的申请和释放远比堆内内存申请和释放的开销要大很多。\n\n　　而在 Netty 面对的高并发网络通信场景下，申请堆外内存是一个非常频繁的操作，基于以上提到的两个重要性能开销，这种大量频繁的内存申请释放操作对程序的性能影响是巨大的，所以 Netty 就引入了内存池对内存相关的操作进行统一的管理。\n\n## 2. 对象池简介\n\n　　以上内容的介绍就是池化思想的应用以及它所解决的问题，本文我们的主题是介绍对象池，对象池的引入是为了在需要大量创建对象以及销毁对象的场景下，将对象进行池化以达到复用池中对象，避免大量地重复创建对象以及销毁对象的性能开销，\n\n　　前边我们在提到内存池的时候说到，在 Netty 所要面对的高并发网络通信场景下，需要大量的申请堆外内存用来存储通信数据。在 Netty 中，我们通过 PooledDirectByteBuf 对象来引用堆外内存。所以 Netty 在处理网络 IO 的时候是需要大量频繁的创建 PooledDirectByteBuf 对象。\n\n　　为了避免在高并发的场景下大量的创建对象所引来的性能开销，我们可以引入对象池来池化创建出来的 PooledDirectByteBuf 对象，需要用的时候直接从对象池中获取，用完之后在回收到对象池中。\n\n　　另外这里提前向大家透露一点的是我们下篇文章中即将要介绍的 Netty 发送数据流程涉及到的对象池的应用。我们都知道 Netty 是一个异步事件驱动的高性能网络框架，当在业务线程中处理完业务逻辑准备响应业务结果到客户端的时候，我们会向对应 channel 写入业务结果，此时业务线程会立即返回，这是一个异步的过程。\n\n　　原因是在底层实现中，Netty 会将用户的响应结果数据暂时写入到每个 Channel 特有的一个发送缓冲队列 ChannelOutboundBuffer 中，也就是说这个 ChannelOutboundBuffer 缓存着 Channel 中的待发送数据。最终会通过 flush 方法，将 ChannelOutboundBuffer 中的这些待发送数据写入到底层 Socket 中，从而发送给客户端。\n\n　　而这个发送缓冲队列 ChannelOutboundBuffer 中的队列元素是一个 Entry 类型的，每次的写入操作需要创建一个 Entry 对象来包裹发送数据，并将这个 Entry 对象缓存在发送缓冲队列 ChannelOutboundBuffer 中。\n\n> 这里大家只需要知道 ChannelOutboundBuffer 是个啥，它的大概作用，以及这个缓冲队列缓存的对象是 Entry 类型的就可以了，我们会在下篇文章为大家详细介绍，这里引出只是为了介绍对象池的应用场景。\n\n　　所以Netty在面对海量网络 IO 的场景下，必定会大量频繁地去创建 Entry 对象，那么每一次的网络 IO 都要重新创建这些对象，并且用完又要被垃圾回收掉这样无疑会大量增加 JVM 的负担以及 GC 的时间，这对于最求极致性能的 Netty 来说肯定是不可接受的。\n\n　　基于以上这几种情况，对象池被用来管理那些需要频繁创建使用的对象，在使用完后并不立即将它们释放，而是将它们在对象池中缓存起来，以供后续的应用程序重复使用，从而减少创建对象和释放对象的开销，进而改善应用程序的性能。\n\n　　从另一方面来看，对象池还可以将对象限制在一定的数量内从而可以有效减少应用程序在内存上的开销。\n\n---\n\n　　通过前边关于对象池的简要介绍之后，我想大家现在可能比较好奇这些对象在创建和回收的过程中到底需要哪些开销呢？\n\n　　接下来笔者就为大家介绍下这些开销方面的内容方便大家更加全面清晰地理解对象池。\n\n## 3. 对象在JVM中创建和回收开销\n\n### 3.1 对象的创建开销\n\n　　在 Java 程序中我们可以通过一个 new 关键字来创建对象，而当JVM遇到一条 new 的字节码指令后，会发生什么呢？\n\n1. 首先 JVM 要去检查 new 指令后面的参数也就是创建对象所属的 Java 类是否能够在方法区的常量池中定位到类的符号引用，进而检查这个符号引用所代表的类是否已经加载，解析，初始化过。如果没有，就需要先执行类的加载过程。\n2. 当通过类加载检查之后，就开始为对象分配内存，而对象所需内存大小其实在类加载完成后就已经确定了。JVM要做的事情就是将一块确定大小的内存区域从JVM堆中划分出来。\n\n> 关于如何确定对象所需内存大小，对这方面细节感兴趣的同学可以回看下笔者的[《对象在JVM中的内存布局》](https://link.juejin.cn/?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg2MzU3Mjc3Ng%3D%3D%26mid%3D2247484304%26idx%3D1%26sn%3D54bf0d07e69c5621c145afaece8f50d6%26chksm%3Dce77c5d7f9004cc1249a03dfd0fb12b7d75171f1b87acea1fa44bbb11ca374b6f42a66fa274d%23rd \"https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&mid=2247484304&idx=1&sn=54bf0d07e69c5621c145afaece8f50d6&chksm=ce77c5d7f9004cc1249a03dfd0fb12b7d75171f1b87acea1fa44bbb11ca374b6f42a66fa274d#rd\")这篇文章。\n\n3. 而在为对象划分堆中内存的时候又会根据JVM堆中内存是否规整，从而分为指针碰撞法和空闲列表法。而多线程同时创建对象在JVM中是非常常见的行为，所以在多线程并发创建对象的时候JVM又需要保证划分内存时的线程安全性。JVM需要对划分内存空间的动作进行同步处理（CAS  + 失败重试）。\n4. 而为了避免这种划分内存时的同步锁定，JVM提供了另外一种方式就是每个线程先预先向JVM堆申请一块内存（本地线程分配缓存-TLAB），这样当线程创建对象的时候，先是从自己的TLAB中为对象分配内存，当自己的TLAB用完时，才会去JVM堆中​**同步分配**​。 我们可以通过虚拟机参数`-XX:+UseTLAB`​开启TLAB（默认）。`-XX:-UseTLAB`​关闭TLAB。\n\n> 大家这里需要记住这种利用TLAB的分配方式，因为Netty中的对象池Recycler也是利用这种思想避免多线程获取对象的同步开销。\n\n5. 在为对象分配好内存之后，JVM会将这块内存初始化为零值。这样就可以保证对象中的实例字段不赋初始值就可以直接使用，其值为字段对应数据类型的零值。\n6. 设置对象头。包括设置MarkWord中的对象运行时信息。以及通过类型指针引用关联到类的元数据信息。这些内容我们在[《对象在JVM中的内存布局》](https://link.juejin.cn/?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg2MzU3Mjc3Ng%3D%3D%26mid%3D2247484304%26idx%3D1%26sn%3D54bf0d07e69c5621c145afaece8f50d6%26chksm%3Dce77c5d7f9004cc1249a03dfd0fb12b7d75171f1b87acea1fa44bbb11ca374b6f42a66fa274d%23rd \"https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&mid=2247484304&idx=1&sn=54bf0d07e69c5621c145afaece8f50d6&chksm=ce77c5d7f9004cc1249a03dfd0fb12b7d75171f1b87acea1fa44bbb11ca374b6f42a66fa274d#rd\")一文中都有提到过，大家还记得吗？\n7. 执行构造函数。这样一个真正可用的对象就被创建出来了。\n\n### 3.2 对象的回收开销\n\n* JVM中的垃圾回收器通过可达性分析来探索所有Java存活对象，从GC ROOTS出发边标记边探索所有对象的引用链，以判断对象是否存活。\n* 垃圾回收器在垃圾回收的过程中发生的GC PAUSE也就是STOP THE WORLD。这里详细的垃圾回收过程我们就不展开了，主要是为了指明在对象回收时最主要的两个开销点。\n\n---\n\n　　然而在高并发的网络IO处理场景下，这些单个对象的创建和回收开销会被无限放大，于是Netty引入了一个轻量级的对象池 Recycler 来负责将这些需要频繁创建的对象进行池化，统一分配，回收管理。\n\n　　在为大家详细介绍对象池 Recycler 的实现之前，笔者想先从对象池的使用上先让大家可以直观地感受一下 Recycler 对外提供的功能入口。\n\n## 4. 对象池Recycler的使用\n\n　　这里我们直接看下Netty源码中是如何使用Recycler对象池的，首先我们来看下对象池在 PooledDirectByteBuf 类中是如何使用的。\n\n> 大家这里先不用去管这个PooledDirectByteBuf类是干吗的，只需要明白这个类是会被频繁创建的，我们这里主要是演示对象池的使用。\n\n![image.png](/assets/ec623644e43b4c56bf1110c9cfc74bc8tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-1zakfmq.awebp)\n\n### 4.1 对象池在PooledDirectByteBuf类中的使用\n\n```java\nfinal class PooledDirectByteBuf extends PooledByteBuf<ByteBuffer> {\n    //创建对象池\n    private static final ObjectPool<PooledDirectByteBuf> RECYCLER = ObjectPool.newPool(\n            new ObjectCreator<PooledDirectByteBuf>() {\n        @Override\n        public PooledDirectByteBuf newObject(Handle<PooledDirectByteBuf> handle) {\n            return new PooledDirectByteBuf(handle, 0);\n        }\n    });\n\n    //对象在对象池中的回收句柄\n    private final Handle<PooledByteBuf<T>> recyclerHandle;\n\n    static PooledDirectByteBuf newInstance(int maxCapacity) {\n        //从对象池中获取对象\n        PooledDirectByteBuf buf = RECYCLER.get();\n        buf.reuse(maxCapacity);\n        return buf;\n    }\n  \n    private void recycle() {\n         //回收对象\n        recyclerHandle.recycle(this);\n    }\n\n    ................省略和对象池无关的代码..................\n}\n```\n\n　　前边我们提到在Netty中需要大量频繁的创建PooledDirectByteBuf对象，为了避免在高并发场景下频繁创建对象的开销从而引入了对象池来统一管理PooledDirectByteBuf对象。\n\n　　Netty中每个被池化的对象中都会引用对象池的实例`ObjectPool  RECYCLER `​，这个对象池的实例就是专门用来分配和管理被池化对象的。\n\n　　这里我们创建出来的对象池是专门用来管理PooledDirectByteBuf对象的（通过泛型指定对象池需要管理的具体对象）。泛型类`ObjectPool<T>`​是Netty为对象池设计的一个顶层抽象。对象池的行为功能均定义在这个泛型抽象类中。我们可以通过 ObjectPool#newPool 方法创建指定的对象池。其参数 ObjectCreator 接口用来定义创建池化对象的行为。当对象池中需要创建新对象时，就会调用该接口方法 ObjectCreatornewObject 来创建对象。\n\n　　其中每个池化对象中都会包含一个recyclerHandle，这个recyclerHandle是池化对象在对象池中的句柄。里边封装了和对象池相关的一些行为和信息，recyclerHandle是由对象池在创建对象后传递进来的。\n\n　　当我们需要PooledDirectByteBuf对象时，我们直接通过`RECYCLER.get()`​从PooledDirectByteBuf对象池中获取对象即可。\n\n　　当我们使用完毕后，直接调用PooledDirectByteBuf对象在对象池中的句柄`recyclerHandle.recycle(this) `​把对象回收到对象池中。\n\n### 4.2 对象池在Channel写入缓冲队列中的使用\n\n　　前边提到，每个Channel都会有一个独立的写入缓冲队列ChannelOutboundBuffer，用来暂时存储用户的待发送数据。这样用户可以在调用channel的write方法之后立马返回，实现异步发送流程。\n\n　　在发送数据时，Channel首先会将用户要发送的数据缓存在自己的写缓存队列ChannelOutboundBuffer中。而ChannelOutboundBuffer中的元素类型为Entry。在Netty中会大量频繁的创建Entry对象。所以Entry对象同样也需要被对象池管理起来。\n\n　　在上小节介绍PooledDirectByteBuf对象池的过程中，我想大家已经对对象池的使用套路已经有了大概的了解。这里我们借助Entry对象池将使用步骤总结如下：\n\n#### 创建对象池\n\n```java\n   static final class Entry {\n\n        private static final ObjectPool<Entry> RECYCLER = ObjectPool.newPool(new ObjectCreator<Entry>() {\n            @Override\n            public Entry newObject(Handle<Entry> handle) {\n                return new Entry(handle);\n            }\n        });\n\n        //recyclerHandle用于回收对象\n        private  Handle<Entry> handle;\n      \n        private Entry(Handle<Entry> handle) {\n            this.handle = handle;\n        }\n   }\n```\n\n　　前边我们介绍到每一个要被池化的对象都需要一个静态变量来引用其对应的对象池。\n\n```java\nstatic final ObjectPool<Entry> RECYCLER \n```\n\n　　匿名实现 ObjectCreator 接口来定义对象创建的行为方法。\n\n```java\n    public interface ObjectCreator<T> {\n        T newObject(Handle<T> handle);\n    }\n```\n\n　　通过`ObjectPool#newPool`​ 创建用于管理Entry对象的对象池。\n\n　　在对象池创建对象时，会为池化对象创建其在对象池中的句柄Handler，随后将Handler传入创建好的池化对象中。当对象使用完毕后，我们可以通过Handler来将对象回收至对象池中等待下次继续使用。\n\n#### 从对象池中获取对象\n\n　　由于Entry对象在设计上是被对象池管理的，所以不能对外提供public构造函数，无法在外面直接创建Entry对象。\n\n　　所以池化对象都会提供一个获取对象实例的 static 方法 newInstance。在该方法中通过`RECYCLER.get()`​从对象池中获取对象实例。\n\n```java\n      static Entry newInstance(Object msg, int size, long total, ChannelPromise promise) {\n            Entry entry = RECYCLER.get();\n          \n            .........省略无关代码..............\n\n            return entry;\n        }\n```\n\n#### 使用完毕回收对象\n\n　　池化对象都会提供一个 recycle 方法，当对象使用完毕后，调用该方法将对象回收进对象池中。\n\n```java\n        void recycle() {\n            next = null;\n            bufs = null;\n            buf = null;\n            msg = null;\n            promise = null;\n            progress = 0;\n            total = 0;\n            pendingSize = 0;\n            count = -1;\n            cancelled = false;\n            handle.recycle(this);\n        }\n```\n\n* 清空对象中的所有属性。\n* 通过对象中持有的对象池句柄Handler，将对象回收进对象池中。\n\n---\n\n　　从上边所列举的Netty中使用对象池的例子，我们可以直观的感受到对象池的使用非常简单。无非就是从对象池获取对象，将对象回收至对象池这两个核心步骤。\n\n　　同时我们也注意到池化对象的设计和普通对象是有所不同的，不过，我们只需要遵循本小节中所列举的几个步骤进行设计即可。\n\n## 5. Recycler总体设计\n\n　　Recycler对象池的设计还是比较复杂的但是却很精妙，所以笔者这里继续采用总 - 分 - 总的结构来为大家介绍对象池的设计与实现。\n\n　　一开始我们先不要去追求太过细节的内容，先要从总体上摸清楚对象池的设计架构，以及各个功能模块之间的关联。\n\n　　当我们从整体上理解了对象池的设计架构后，笔者后面会分模块来各个击破它的实现细节。\n\n　　在理清楚各个模块的实现细节之后，笔者将在从细节着手再次将对象池的整体设计架构为大家串联起来。\n\n　　我们按照这个思路先来看一下Recycler对象池的总体架构设计图，从整体直观上来感受下它的设计，以及包含的一些重要模块。\n\n![image.png](/assets/d8bdbd9d79814646999637ffc46281cbtplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-5lz8huo.awebp)\n\n### 5.1 多线程获取对象无锁化设计\n\n　　首先我们从外部整体来看，对象池对于我们来说它就是一个存储对象的池子，当我们需要对象时会从这个池子里直接获取，用完对象时在把对象归还回池子中方便下一次重复使用。\n\n　　但我们俯瞰整个对象池的设计架构时，我们发现整个设计还是比较复杂其中蕴含了不少精妙的细节。\n\n　　对象池中最重要的两个结构分别是 Stack 和 WeakOrderQueue。\n\n　　Stack 中包含一个用数组实现的栈结构（图中绿色部分），这个栈结构正是对象池中真正用于存储池化对象的地方，我们每次从对象池中获取对象都会从这个栈结构中弹出栈顶元素。同样我们每次将使用完的对象归还到对象池中也是将对象压入这个栈结构中。\n\n　　​**这里有一个精妙的设计**​，我们从图中可以看到每个线程都会拥有一个属于自己的Stack。在我们介绍《对象创建的开销》这一小节内容时，提到为了避免多线程并发申请内存时的同步锁定开销，JVM为每个线程预先申请了一块内存（TLAB）,这样当线程创建对象时都是从自己的TLAB中为对象分配内存。从而避免了多线程之间的同步竞争。\n\n　　同样当多线程并发从对象池中获取对象时, 如果整个对象池只有一个Stack结构的话，为了保证多线程获取对象的线程安全性，我们只能同步地来访问这个Stack，这样就为对象池的设计引入了多线程同步竞争的开销。\n\n　　​**为了避免这种不必要的同步竞争，Netty也采用了类似TLAB分配内存的方式，每个线程拥有一个独立Stack，这样当多个线程并发从对象池中获取对象时，都是从自己线程中的Stack中获取，全程无锁化运行。大大提高了多线程从对象池中获取对象的效率**​。\n\n> 这种**多线程并发无锁化**的设计思想，在Netty中比比皆是\n\n### 5.2 Stack的设计\n\n　　从Recycler对象池的整体设计架构图中我们可以看到，Stack的设计主要分为两个重要的部分：\n\n* 一个是我们前边提到的数组实现的栈结构用来存放对象池中的对象，每个线程绑定一个独立的Stack用来存储由**该线程创建出来**并回收到对象池中的对象。\n* 另一个重要的结构是WeakOrderQueue链表，head 指针指向WeakOrderQueue链表的头结点，cursor 指针指向链表的当前节点，prev 指针指向当前节点的前一个节点。WeakOrderQueue链表是用来存储其他线程帮助本线程回收的对象（我们称之为待回收对象）。其中WeakOrderQueue链表中的每一个节点对应一个其他线程，这个其他线程为本线程回收的对象存储在对应的WeakOrderQueue节点中。\n\n> 这里我们先不需要管WeakOrderQueue的具体结构\n\n　　​**那么Stack结构在设计上为什么要引入这个WeakOrderQueue链表呢**​？\n\n　　让我们考虑一种多线程回收对象的场景，我们还是以Recycler对象池的整体设计架构图为例。thread1 为当前线程，剩下的thread2 , thread3 , thread4为其他线程。让我们把视角先聚焦在当前线程上。\n\n> 我们先假设Stack结构中只有一个数组栈，并没有WeakOrderQueue链表。看看这样会产生什么后果？\n\n![image.png](/assets/d4522ab88aca42a4b9c2d633301fcac5tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-idyvok3.awebp)\n\n　　当前线程 thread1 在处理业务逻辑时，创建了一个对象（注意：这个对象是由thread1创建的）如果这是一个单线程处理业务的场景，那么对象会在thread1处理完业务逻辑后被回收至thread1对应的stack1中的数组栈中。当`hread1再次需要创建对象时，会直接从其对应的stack1中的数组栈（图中绿色部分）中直接获取上次回收的对象。\n\n> 由这一点可以看出Stack中的数组栈（绿色部分）存放的是真正被回收的对象，是可以直接被再次获取使用的。\n\n　　但如果这是一个多线程处理业务场景的话，很可能由thread1创建出来的对象，会被交给thread2或者thread3去处理剩下的业务逻辑，那么当thread2或者thread3这些其他线程处理完业务逻辑时，此时对象的释放并不是在thread1中，而是在其他线程中。\n\n　　其他线程现在面对的任务就是要将由thread1创建出来的对象，释放回收至thread1对应的stack1中的数组栈中。如果此时多个其他线程并发的向stack1释放回收对象，势必会导致多线程之前的同步竞争，​**Netty将不得不把Stack结构中的数组栈的访问设计成一个同步过程**​。\n\n　　那么如果此时更不巧的是当前线程thread1又要同时向自己的Stack1获取对象，thread1就只能同步等待，因为此时其他线程正在向Stack1释放对象。\n\n> 本来我们引入对象池的目的就是为了抵消创建对象的开销加快获取对象的速度，减少GC的压力。结果由于Stack的同步访问设计又引入了同步开销。这个同步的开销甚至会比创建对象的开销还要大，那么对象池的引入就变得得不偿失了。\n\n　　**那么Netty该如何化解这种情况呢？答案还是之前反复强调的无锁化设计思想。**\n\n　　既然多线程的回收对象场景，会引入多线程之间的同步锁定开销，那么我们就继续采用无锁化的设计思想，为每个线程（注意：这里指的是非创建对象的线程也就是图中的thead2 , thread3 ....）单独分配一个WeakOrderQueue节点，每个线程在为创建线程回收对象时，会将这些对象暂时存放到自己对应的WeakOrderQueue节点中。\n\n> 注意：存放进WeakOrderQueue中的对象我们称为待回收对象，这些待回收对象并不在Stack结构中的数组栈中，因此并不能被直接获取使用。\n\n　　为了方便后续描述，我们把创建对象的线程称作`创建线程`​（示例中的thread1），将为创建线程回收对象的其他线程称作`回收线程`​（示例中的thread2 , thread3 , thead4 .....）。\n\n　　我们在将视角拉回到创建线程thread1对应的stack1中，​**每个回收线程将待回收对象放入与自己对应的WeakOrderQueue节点中，这样就避免了在多线程回收场景中的同步竞争**​。当所有回收线程都在为stack1回收对象时，这样在stack1中就形成了一个WeakOrderQueue链表。每个回收线程只操作与自己对应的节点。在Stack结构中通过head，prev，cursor将这些WeakOrderQueue节点组成了一个链表。\n\n> 每一个WeakOrderQueue节点对应一个回收线程。\n\n　　而当创建线程thread1再次从自己对应的Stack1中获取对象时，只会从Stack结构的数组栈中获取，因为是单线程操作数组栈，自然是不会存在同步竞争的。\n\n　　当Stack结构中的数组栈没有任何对象时，那么创建线程就会根据 cursor 指针遍历Stack结构中的WeakOrderQueue链表，将当前WeakOrderQueue节点存放的待回收对象​**转移至数组栈中**​。如果WeakOrderQueue链表中也没有任何待回收对象可以转移。那么创建线程在对象池中就直接创建一个对象出来返回。\n\n> 对象池回收对象的一个原则就是对象由谁创建的，最终就要被回收到创建线程对应的Stack结构中的数组栈中。数组栈中存放的才是真正被回收的池化对象，可以直接被取出复用。回收线程只能将待回收对象暂时存放至创建线程对应的Stack结构中的WeakOrderQueue链表中。当数组栈中没有对象时，由创建线程将WeakOrderQueue链表中的待回收对象转移至数组栈中。\n\n　　**正是由于对象池的这种无锁化设计，对象池在多线程获取对象和多线程回收对象的场景下，均是不需要同步的**\n\n　　大家在体会下这张图中蕴含的这种​**无锁化设计思想**​：\n\n![image.png](/assets/0566fc7826064b12bb88082b39c10bd2tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-hkx67f6.awebp)\n\n### 5.3 WeakOrderQueue的设计\n\n　　在我们介绍完对象池在多线程回收对象场景下的设计时，我们再来看下用于回收线程存储待回收对象的WeakOrderQueue是如何设计的？\n\n> 注意：这里的回收线程，待回收对象这些概念是我们站在创建线程的视角提出的**相对**概念。\n\n![image.png](/assets/63f3b4b63fd14b7a84c33c0840bc41e2tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-7eix1tf.awebp)\n\n　　大家一开始可能从WeakOrderQueue字面意思上以为它的结构是一个队列，但实际上从图中我们可以看出WeakOrderQueue的结构其实是一个链表结构。\n\n　　其中包含了链表的头结点 Head，以及链表尾结点指针 Tail。链表中的元素类型为 Link 类型。\n\n　　Link 类型中包含了一个 elements 数组，该数组用来存放回收线程收集的待回收对象。\n\n　　除此之外Link类型中还包含了readIndex用来指示当前elements数组中的读取位置。writeIndex用来指示elements数组的写入位置。elements数组中的容量默认为`16`​，也就是说一个Link节点最多可以存放16个待回收对象。当回收线程收集的待回收对象超过16个时，就会新创建一个Link节点插入到Link链表的尾部。\n\n　　当需要将WeakoOrderQueue节点中所存放的待回收对象回收转移至其对应的Stack结构中的数组栈中时，**创建线程**会遍历当前WeakOrderQueue节点中的Link链表，然后从链表的Head节点开始，将Head节点中包裹的Link链表头结点中存放的待回收对象回收至创建线程对应的Stack中。​**一次最多转移一个Link大小的待回收对象**​（16个）。\n\n　　当Link节点中的待回收对象全部转移至创建线程对应的Stack中时，会立马将这个Link节点从当前WeakOrderQueue节点中的Link链表里删除，随后Head节点向后移动指向下一个Link节点。\n\n> head指针始终指向​**第一个未被转移完毕的Link节点**​，创建线程从head节点处读取转移待回收对象，回收线程从Tail节点处插入待回收对象。​**这样转移操作和插入操作互不影响、没有同步的开销**​。\n\n　　​**注意这里会存在线程可见性的问题**​，也就是说回收线程刚插入的待回收对象，在创建线程转移这些待回收对象时，创建线程可能会**看不到**由回收线程刚刚插入的待回收对象。\n\n　　​**Netty这里为了不引入多线程同步的开销，只会保证待回收对象的最终可见性**​。 因为如果要保证待回收对象的实时可见性，就要插入一些内存屏障指令，执行这些内存屏障指令也是需要开销的。\n\n　　事实上这里也并不需要保证实时可见性，创建线程暂时看不到WeakOrderQueue节点中的待回收对象也是没关系的，大不了就新创建一个对象。​**这里还是遵循无锁化的设计思想**​。\n\n> 维护线程之间操作的原子性，可见性都是需要开销的，我们在日常多线程程序设计中一定要根据业务场景来综合考虑，权衡取舍。尽量遵循我们这里多次强调的​**多线程无锁化设计思想**​。提高多线程的运行效率。避免引入不必要的同步开销。\n\n　　综合以上 Netty Recycler 对象池的设计原理，我们看到多线程从对象池中获取对象，以及多线程回收对象至对象池中，还有创建线程从WeakOrderQueue链表中转移待回收对象到对象池中。这些步骤均是无锁化进行的，没有同步竞争。\n\n　　在理解了对象池的基本设计原理后，下面就该介绍对象池在Netty中的源码实现环节了。\n\n## 6. Recycler对象池的实现\n\n　　在小节《4. 对象池Recycler的使用》中我们介绍了Recycler对象池的两个使用案例：\n\n* 一个是对象池在PooledDirectByteBuf类中的运用。\n* 另一个是对象池在Channel对应的写入缓冲队列ChannelOutboundBuffer中的运用。\n\n　　从这两个案例中，我们看到在设计池化对象时，都需要在池化对象内部持有一个对象池的静态引用从而可以与对象池进行交互，引用类型为 ObjectPool ，ObjectPool 是Netty对象池的顶层设计，其中定义了对象池的行为，以及各种顶层接口。\n\n　　在介绍对象池的整体实现之前，我们先来看下对象池的这个顶层接口设计。\n\n### 6.1 对象池的顶层设计ObjectPool\n\n```java\npublic abstract class ObjectPool<T> {\n\n    ObjectPool() { }\n\n    public abstract T get();\n\n    public interface Handle<T> {\n        void recycle(T self);\n    }\n\n    public interface ObjectCreator<T> {\n        T newObject(Handle<T> handle);\n    }\n\n    ......................省略............\n\n}\n```\n\n　　我们首先看到 ObjecPool 被设计成为一个泛型的抽象类，之所以使用泛型，是因为我们在创建对象池的时候需要指定对象池中被池化对象的类型。\n\n　　比如《4. 对象池Recycler的使用》小节中的这两个案例：\n\n```java\nstatic final class Entry {\n\n    private static final ObjectPool<Entry> RECYCLER\n\n}\n```\n\n```java\nfinal class PooledDirectByteBuf extends PooledByteBuf<ByteBuffer> {\n\n    private static final ObjectPool<PooledDirectByteBuf> RECYCLER\n\n}\n```\n\n　　ObjecPool 定义了从对象池中获取对象的行为：\n\n```java\npublic abstract T get();\n```\n\n　　将池化对象回收至对象池中的行为被定义在 Handler 内部接口中：\n\n```java\n     public interface Handle<T> {\n        void recycle(T self);\n    } \n```\n\n　　Handler是池化对象在对象池中的一个模型，Handler里面包裹了池化对象，并包含了池化对象的一些回收信息，以及池化对象的回收状态。它的默认实现是DefaultHandle，后面我们会详细介绍。\n\n> 我们前边介绍到的Stack结构中的数组栈里边存放的就是DefaultHandle，以及WeakOrderQueue结构里的Link节点中的elements数组里存放的也是DefaultHandle。\n\n　　​**那么为什么要将池化对象的回收行为recycle定义在Handler中，而不是ObejctPool中呢**​？\n\n　　让我们站在业务线程的角度来看，其实业务线程处理的都是对象级别这个维度，并不需要感知到对象池的存在，使用完对象，直接调用对象的回收方法recycle将池化对象回收掉即可。\n\n　　在《4. 对象池Recycler的使用》小节我们介绍过池化对象的设计方法，其中我们提到池化对象中需要引用其在对象池中的Handler，这个Handler会在对象池创建对象的时候传入。池化对象类型中需要定义recycle方法，recycle方法清空池化对象的所有属性，并调用Handler的recycle方法将池化对象回收至对象池中。\n\n```java\nstatic final class Entry {\n\n        void recycle() {\n            next = null;\n            bufs = null;\n            buf = null;\n            msg = null;\n            promise = null;\n            progress = 0;\n            total = 0;\n            pendingSize = 0;\n            count = -1;\n            cancelled = false;\n            handle.recycle(this);\n        }\n\n}\n```\n\n　　ObjectPool 还定义了对象池创建对象的行为接口：\n\n```java\n    public interface ObjectCreator<T> {\n        T newObject(Handle<T> handle);\n    }\n```\n\n　　用户在创建对象池的时候，需要通过`ObjectCreator#newObject`​方法指定对象池创建对象的行为。Handler对象正是通过这个接口传入池化对象中的。\n\n```java\n  static final class Entry {\n\n      private static final ObjectPool<Entry> RECYCLER = ObjectPool.newPool(new ObjectCreator<Entry>() {\n            @Override\n            public Entry newObject(Handle<Entry> handle) {\n                return new Entry(handle);\n            }\n        });\n\n      //Entry对象只能通过对象池获取，不可外部自行创建\n      private Entry(Handle<Entry> handle) {\n            this.handle = handle;\n        }\n\n  }\n```\n\n#### 6.1.1 创建ObjectPool\n\n![image.png](/assets/948ff8d7b81449269cbedf8928f28e59tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-2e3ivzs.awebp)\n\n```java\npublic abstract class ObjectPool<T> {\n\n    public static <T> ObjectPool<T> newPool(final ObjectCreator<T> creator) {\n        return new RecyclerObjectPool<T>(ObjectUtil.checkNotNull(creator, \"creator\"));\n    }\n\n    private static final class RecyclerObjectPool<T> extends ObjectPool<T> {\n        //recycler对象池实例\n        private final Recycler<T> recycler;\n\n        RecyclerObjectPool(final ObjectCreator<T> creator) {\n             recycler = new Recycler<T>() {\n                @Override\n                protected T newObject(Handle<T> handle) {\n                    return creator.newObject(handle);\n                }\n            };\n        }\n\n        @Override\n        public T get() {\n            return recycler.get();\n        }\n    }\n\n}\n```\n\n```java\npublic abstract class Recycler<T> {\n\n    protected abstract T newObject(Handle<T> handle);\n  \n    ........................省略.............\n}\n```\n\n　　调用 `ObjectPool#newPool`​ 创建对象池时，返回的是 RecyclerObjectPool 实例。而**真正的对象池 Recycler** 被包裹在 RecyclerObjectPool 中。\n\n　　对象池Recycler创建对象的行为定义在用户在创建对象池时指定的ObjectCreator 中。\n\n## 7. Recycler对象池属性详解\n\n　　在介绍完对象池的顶层设计之后，接下来我们介绍下Recycler对象池相关的一些重要属性。相信大家在看过前边关于对象池设计原理的介绍之后，现在应该能够比较容易的理解即将介绍的这些属性概念，这里涉及到的属性比较多，笔者把这些属性的介绍放到源码实现之前的目的也是先让大家混个眼熟，先有一个感性的认识，等到介绍源码实现时，笔者还会将涉及到的属性再次拿出来介绍。\n\n![image.png](/assets/f469c168d72b40c6b23accd8ab652a22tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-t5puo5k.awebp)\n\n### 7.1 创建线程，回收线程的Id标识\n\n```java\npublic abstract class Recycler<T> {\n\n    //用于产生池化对象中的回收Id,主要用来标识池化对象被哪个线程回收\n    private static final AtomicInteger ID_GENERATOR = new AtomicInteger(Integer.MIN_VALUE);\n    //用于标识创建池化对象的线程Id 注意这里是static final字段 也就意味着所有的创建线程OWN_THREAD_ID都是相同的\n    //这里主要用来区分创建线程与非创建线程。多个非创建线程拥有各自不同的Id\n    //这里的视角只是针对池化对象来说的：区分创建它的线程，与其他回收线程\n    private static final int OWN_THREAD_ID = ID_GENERATOR.getAndIncrement();\n\n}\n```\n\n* ​`AtomicInteger ID_GENERATOR`​ :对象池中定义了一个 AtomicInteger 类型的Id生成器，主要用于为创建线程以及回收线程创建Id标识，**目的是区分创建线程和回收线程。**\n* ​`int OWN_THREAD_ID`​：在 Recycler 类初始化的时候，会利用ID_GENERATOR 为 OWN_THREAD_ID 字段赋值，从字面意思上我们也可以看出 OWN_THREAD_ID 是用来标识创建线程Id的。这里有一点大家需要注意的是，OWN_THREAD_ID 是一个 static final 字段，这也就意味着所有的Recycler对象池实例中的 OWN_THREAD_ID 都是一样的。\n\n　　这里有的同学可能会有疑问了，在多线程从对象池中获取对象的场景中，创建线程会有很多个（比如下图中的thread1, thread2, thread3.....），既然所有的Recycler 对象池实例中的 OWN_THREAD_ID 都是一样的，那么如何区分不同的创建线程呢？\n\n![image.png](/assets/34f2d54bc3724e51b0c8ad2695f7de95tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-2cym377.awebp)\n\n　　​**事实上在对象池中我们并不需要区分创建线程与创建线程之间的Id**​，因为Netty在设计对象池的时候采用了无锁化设计，创建线程与创建线程之间并不需要交互，每个线程只需要关注自己线程内的对象管理工作即可，所以从一个线程的内部视角来看，只会有一个创建线程就是它自己本身，剩下的线程均是回收线程。​**所以我们对象池的设计中只需要区分创建线程与回收线程就可以了**​，当然每个回收线程的Id是不一样的。\n\n　　回收线程的Id是由其对应的 WeakOrderQueue 节点来分配的，一个 WeakOrderQueue 实例对应一个回收线程Id。\n\n```java\nprivate static final class WeakOrderQueue extends WeakReference<Thread> {\n\n    //回收线程回收Id,每个weakOrderQueue分配一个，同一个stack下的一个回收线程对应一个weakOrderQueue节点\n   private final int id = ID_GENERATOR.getAndIncrement();\n}\n```\n\n### 7.2 对象池中的容量控制\n\n![image.png](/assets/233f28fc503e4dcc9c1e1317a89b71d9tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-vqp6dd1.awebp)\n\n```java\n    //对象池中每个线程对应的Stack中可以存储池化对象的默认初始最大个数 默认为4096个对象 \n    private static final int DEFAULT_INITIAL_MAX_CAPACITY_PER_THREAD = 4 * 1024; // Use 4k instances as default.\n    // 对象池中线程对应的Stack可以存储池化对象默认最大个数 4096\n    private static final int DEFAULT_MAX_CAPACITY_PER_THREAD;\n    // 初始容量 min(DEFAULT_MAX_CAPACITY_PER_THREAD, 256) 初始容量不超过256个\n    private static final int INITIAL_CAPACITY;\n```\n\n　　Recycler 对象池中定义了以上三个属性用于控制对象池中可以池化的对象容量。这些属性对应的初始化逻辑如下：\n\n```java\n    static {\n\n        int maxCapacityPerThread = SystemPropertyUtil.getInt(\"io.netty.recycler.maxCapacityPerThread\",\n                SystemPropertyUtil.getInt(\"io.netty.recycler.maxCapacity\", DEFAULT_INITIAL_MAX_CAPACITY_PER_THREAD));\n        if (maxCapacityPerThread < 0) {\n            maxCapacityPerThread = DEFAULT_INITIAL_MAX_CAPACITY_PER_THREAD;\n        }\n\n        DEFAULT_MAX_CAPACITY_PER_THREAD = maxCapacityPerThread;\n\n        INITIAL_CAPACITY = min(DEFAULT_MAX_CAPACITY_PER_THREAD, 256);\n    }\n```\n\n* ​`DEFAULT_INITIAL_MAX_CAPACITY_PER_THREAD`​：定义每个创建线程对应的Stack结构中的数组栈初始默认的最大容量。默认为4096个。可由JVM启动参数 `-D io.netty.recycler.maxCapacity`​ 指定。\n* ​`DEFAULT_MAX_CAPACITY_PER_THREAD`​：定义每个创建线程对应的Stack结构中的数组栈的最大容量。可由JVM启动参数 `-D io.netty.recycler.maxCapacityPerThread`​ 指定，如无特殊指定，即采用 DEFAULT_INITIAL_MAX_CAPACITY_PER_THREAD 的值，默认为4096个。\n* ​`INITIAL_CAPACITY `​: 定义每个创建线程对应的Stack结构中的数组栈的初始容量。计算公式为`min(DEFAULT_MAX_CAPACITY_PER_THREAD, 256)`​，默认为256个。当池化对象超过256个时，则对对象池进行扩容，但不能超过最大容量 DEFAULT_MAX_CAPACITY_PER_THREAD。\n\n### 7.3 回收线程可回收对象的容量控制\n\n```java\n   //用于计算回收线程可帮助回收的最大容量因子  默认为2  \n    private static final int MAX_SHARED_CAPACITY_FACTOR;\n    //每个回收线程最多可以帮助多少个创建线程回收对象 默认：cpu核数 * 2\n    private static final int MAX_DELAYED_QUEUES_PER_THREAD;\n    //回收线程对应的WeakOrderQueue节点中的Link链表中的节点存储待回收对象的容量 默认为16\n    private static final int LINK_CAPACITY;\n```\n\n　　Recycler 对象池除了对创建线程中的 Stack 容量进行限制外，还需要对回收线程可回收对象的容量进行限制。相关回收容量限制属性初始化逻辑如下：\n\n```java\n    static {\n\n        MAX_SHARED_CAPACITY_FACTOR = max(2,\n                SystemPropertyUtil.getInt(\"io.netty.recycler.maxSharedCapacityFactor\",\n                        2));\n\n        MAX_DELAYED_QUEUES_PER_THREAD = max(0,\n                SystemPropertyUtil.getInt(\"io.netty.recycler.maxDelayedQueuesPerThread\",\n                        // We use the same value as default EventLoop number\n                        NettyRuntime.availableProcessors() * 2));\n\n        LINK_CAPACITY = safeFindNextPositivePowerOfTwo(\n                max(SystemPropertyUtil.getInt(\"io.netty.recycler.linkCapacity\", 16), 16));\n\n    }\n```\n\n* ​`MAX_SHARED_CAPACITY_FACTOR`​ : 针对创建线程中的 Stack，其对应的所有回收线程总共可帮助其回收的对象总量计算因子。默认为2。可通过JVM参数 `-D io.netty.recycler.maxSharedCapacityFactor`​ 指定，总共回收对象总量就是通过对象池的最大容量和该计算因子计算出来的。计算公式： `max(maxCapacity / maxSharedCapacityFactor, LINK_CAPACITY)`​ 。由此我们可以知道创建线程对应的所有回收线程总共可帮助其回收的对象总量默认为2048个，最小回收容量为 LINK_CAPACITY  默认为16。\n* ​`MAX_DELAYED_QUEUES_PER_THREAD`​ : 该参数定义每个回收线程最多可帮助多少个创建线程回收对象。默认为：CPU核数 * 2。可通过JVM参数 `-D io.netty.recycler.maxDelayedQueuesPerThread`​ 指定。​**注意：这里是站在回收线程的角度**​。\n* ​`LINK_CAPACITY `​:  在创建线程对应的 Stack 结构中的 WeakOrderQueue 链表中，回收线程对应的WeakOrderQueue节点中的Link链表中的Link节点存储待回收对象的容量。默认为16，可通过JVM参数 `-D io.netty.recycler.linkCapacity`​ 指定。\n\n　　为了方便大家理解这些容量控制的相关参数，笔者又在对象池架构设计图的基础上补充了容量控制相关的信息。大家可以对照上边介绍到的这些参数的含义形象体会下：\n\n![image.png](/assets/d76e41420e1d44eb82e4b74dc7d4309btplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-e21hjq1.awebp)\n\n### 7.4 对象回收频率控制\n\n　　对象池不能不考虑容量的限制而无脑的进行对象的回收，而是要对回收对象的频率进行限制。在我们日常架构设计和程序设计时，我们也一定要有托底的方案，比如限流，降级，熔断等托底方案。这样程序就不至于被突发的异常流量击垮。\n\n　　在对象池的设计中，Netty用以下两个参数来控制对象回收的频率从而避免对象池迅速膨胀不可控制。\n\n```java\n    //创建线程回收对象时的回收比例，默认是8，表示只回收1/8的对象。也就是产生8个对象回收一个对象到对象池中\n    private static final int RATIO;\n    //回收线程回收对象时的回收比例，默认也是8，同样也是为了避免回收线程回收队列疯狂增长 回收比例也是1/8\n    private static final int DELAYED_QUEUE_RATIO;\n```\n\n　　对象回收频率控制参数的初始化逻辑如下：\n\n```java\n    static {\n\n        RATIO = max(0, SystemPropertyUtil.getInt(\"io.netty.recycler.ratio\", 8));\n\n        DELAYED_QUEUE_RATIO = max(0, SystemPropertyUtil.getInt(\"io.netty.recycler.delayedQueue.ratio\", RATIO));\n\n    }\n```\n\n　　通过前边对 Recycler 对象池的设计原理介绍，我们知道，在池化对象被回收的时候分别由两类线程来执行。\n\n* 一类是创建线程。池化对象在创建线程中被创建出来后，一直在创建线程中被处理，处理完毕后由创建线程直接进行回收。而为了避免对象池不可控制地迅速膨胀，所以需要对创建线程回收对象的频率进行限制。这个回收频率由参数 RATIO 控制，默认为8，可由JVM启动参数 `-D io.netty.recycler.ratio`​ 指定。表示创建线程只回收 1 / 8 的对象，也就是每创建 8 个对象最后只回收 1个对象。\n* 另一类就是回收线程。池化对象在创建线程中被创建出来，但是业务的相关处理是在回收线程中，业务处理完毕后由回收线程负责回收。前边提到对象回收有一个基本原则就是对象是谁创建的，就要回收到创建线程对应的Stack中。所以回收线程就需要将池化对象回收至其创建线程对应的Stack中的WeakOrderQueue链表中。并等待创建线程将WeakOrderQueue链表中的待回收对象**转移**至Stack中的数组栈中。同样，回收线程也需要控制回收频率，由参数 DELAYED_QUEUE_RATIO 进行控制，默认也是8，可由JVM启动参数 `-D io.netty.recycler.delayedQueue.ratio`​ 指定，表示回收线程每处理完 8 个对象才回收 1 个对象。\n\n## 8. Recycler对象池的创建\n\n```java\n    private static final class RecyclerObjectPool<T> extends ObjectPool<T> {\n        //recycler对象池实例\n        private final Recycler<T> recycler;\n\n        RecyclerObjectPool(final ObjectCreator<T> creator) {\n             recycler = new Recycler<T>() {\n                @Override\n                protected T newObject(Handle<T> handle) {\n                    return creator.newObject(handle);\n                }\n            };\n        }\n    \n        ..................省略............\n      }\n```\n\n　　Netty 中的 Recycler 对象池是一个抽象类，里面封装了对象池的核心结构以及核心方法。在创建对象池的时候，我们往往会使用Recycler的匿名类来实现抽象方法 newObject 从而来定义对象池创建对象的行为。\n\n```java\npublic abstract class Recycler<T> {\n\n   protected abstract T newObject(Handle<T> handle);\n\n   protected Recycler() {\n        this(DEFAULT_MAX_CAPACITY_PER_THREAD);\n    }\n\n    protected Recycler(int maxCapacityPerThread) {\n        this(maxCapacityPerThread, MAX_SHARED_CAPACITY_FACTOR);\n    }\n\n    protected Recycler(int maxCapacityPerThread, int maxSharedCapacityFactor) {\n        this(maxCapacityPerThread, maxSharedCapacityFactor, RATIO, MAX_DELAYED_QUEUES_PER_THREAD);\n    }\n\n    protected Recycler(int maxCapacityPerThread, int maxSharedCapacityFactor,\n                       int ratio, int maxDelayedQueuesPerThread) {\n        this(maxCapacityPerThread, maxSharedCapacityFactor, ratio, maxDelayedQueuesPerThread,\n                DELAYED_QUEUE_RATIO);\n    }\n\n    //创建线程持有对象池的最大容量\n    private final int maxCapacityPerThread;\n    //所有回收线程可回收对象的总量(计算因子)\n    private final int maxSharedCapacityFactor;\n    //创建线程的回收比例\n    private final int interval;\n    //一个回收线程可帮助多少个创建线程回收对象\n    private final int maxDelayedQueuesPerThread;\n    //回收线程回收比例\n    private final int delayedQueueInterval;\n\n    protected Recycler(int maxCapacityPerThread, int maxSharedCapacityFactor,\n                       int ratio, int maxDelayedQueuesPerThread, int delayedQueueRatio) {\n        interval = max(0, ratio);\n        delayedQueueInterval = max(0, delayedQueueRatio);\n        if (maxCapacityPerThread <= 0) {\n            this.maxCapacityPerThread = 0;\n            this.maxSharedCapacityFactor = 1;\n            this.maxDelayedQueuesPerThread = 0;\n        } else {\n            this.maxCapacityPerThread = maxCapacityPerThread;\n            this.maxSharedCapacityFactor = max(1, maxSharedCapacityFactor);\n            this.maxDelayedQueuesPerThread = max(0, maxDelayedQueuesPerThread);\n        }\n    }\n\n}\n```\n\n　　关于Recycler对象池中相关的重要属性我们在上一小节已经详细介绍过了，这里只是将这些重要参数赋值于Recycler对象池中定义的对应属性上。还是那句话，大家这里只需要对这些属性有一个感性的认识即可，并不需要强行完全理解，后面我们在介绍对象池的功能实现时还会结合具体场景来介绍这些属性。\n\n## 9. 多线程获取对象无锁化实现\n\n![image.png](/assets/908c9b12522247dfbd32bada7308cb27tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-r7sakmv.awebp)\n\n　　我们在介绍Netty对象池多线程获取对象的设计时提到，为了避免多线程并发获取对象时引入的同步开销，Netty采用了类似 TLAB 分配内存的思想，为每一个线程分配了一个独立的Stack结构，池化对象就存储在这个Stack结构中。当线程需要从对象池中获取对象时，Recycler就会从线程对应的Stakc结构中获取池化对象。各个线程独立运行，没有任何同步开销。\n\n```java\n    //threadlocal保存每个线程对应的 stack结构\n    private final FastThreadLocal<Stack<T>> threadLocal = new FastThreadLocal<Stack<T>>() {\n        @Override\n        protected Stack<T> initialValue() {\n            return new Stack<T>(Recycler.this, Thread.currentThread(), maxCapacityPerThread, maxSharedCapacityFactor,\n                    interval, maxDelayedQueuesPerThread, delayedQueueInterval);\n        }\n      \n        ..............省略..........\n    };\n```\n\n　　对象池中采用一个 FastThreadLocal 类型的字段 threadLocal 为每个线程维护一个独立的Stack结构。从而达到多线程无锁化获取对象的目的。\n\n> FastThreadLocal是Netty基于JDK的ThreadLocal做的一个优化版本，拥有更快的访问性能。详细实现笔者后面会有一篇专门讲解FastThreadLocal的文章，这里大家只需要把它当成JDK的ThreadLocal来看待即可。\n\n　　当线程第一次从对象池中获取对象时会触发其对应的Stack结构的创建。\n\n### 9.1 Stack结构的创建\n\n　　本小节我们来介绍一下对象池中Stack结构的设计实现。在前边《5.2 Stack的设计》小节中我们介绍了Stack结构中的一些核心属性，包括：数组栈以及WeakOrderQueue链表的Head指针，Prev指针，Cursor指针。\n\n　　本小节笔者会把Stack结构中的剩余属性介绍给大家，通过这一小节的介绍，相信大家就会对Stack的设计实现有了一个整体的了解。还是那句话，这里大家只需要对这些属性有一个感性的认识，先混个眼熟，后面笔者还会结合具体场景详细讲解。\n\n```java\nprivate static final class Stack<T> {\n\n        // 创建线程保存池化对象的stack结构所属对象池recycler实例\n        final Recycler<T> parent;\n\n        //用弱引用来关联当前stack对应的创建线程 因为用户可能在某个地方引用了defaultHandler -> stack -> thread，可能存在这个引用链\n        //当创建线程死掉之后 可能因为这个引用链的存在而导致thread无法被回收掉\n        final WeakReference<Thread> threadRef;\n\n        //所有回收线程能够帮助当前创建线程回收对象的总容量\n        final AtomicInteger availableSharedCapacity;\n\n        //当前Stack对应的创建线程作为其他创建线程的回收线程时可以帮助多少个线程回收其池化对象\n        private final int maxDelayedQueues;\n\n        //当前创建线程对应的stack结构中的最大容量。 默认4096个对象\n        private final int maxCapacity;\n\n        //当前创建线程回收对象时的回收比例\n        private final int interval;\n\n        //当前创建线程作为其他线程的回收线程时回收其他线程的池化对象比例\n        private final int delayedQueueInterval;\n\n        // 当前Stack中的数组栈 默认初始容量256，最大容量为4096\n        DefaultHandle<?>[] elements;\n\n        //数组栈 栈顶指针\n        int size;\n\n        //回收对象计数 与 interval配合 实现只回收一定比例的池化对象\n        private int handleRecycleCount;\n\n        //多线程回收的设计，核心还是无锁化，避免多线程回收相互竞争\n        //Stack结构中的WeakOrderQueue链表\n        private WeakOrderQueue cursor, prev;\n        private volatile WeakOrderQueue head;\n}\n```\n\n![image.png](/assets/ad0a175194af489d9c71f096ac430a03tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-4g64cdf.awebp)\n\n* ​`Recycler<T> parent`​：Stack所属Recycler对象池实例，一个对象池可被多个线程访问获取对象，所以一个对象池对应多个Stack，每个Stack的parent属性指向所属的Recycler实例。比如图中的 stack1 , stack2 , stack3 , stack4 中的parent属性均指向同一个Recycler对象池实例。\n* ​`WeakReference<Thread> threadRef `​：Stack会通过弱引用的方式引用到其对应的创建线程。这里使用弱引用来持有对应创建线程的原因是因为对象池的设计中存在这样一个引用关系：`池化对象 -> DefaultHandler -> stack -> threadRef`​。而池化对象是暴露给用户的，如果用户在某个地方持有了池化对象的强引用忘记清理，而Stack持有创建线程的强引用的话，当创建线程死掉的之后，因为这样一个强引用链的存在从而导致创建线程一直不能被GC回收。\n* ​`AtomicInteger availableSharedCapacity`​：当前创建线程对应的所有回收线程可以帮助当前创建线程回收的对象总量。比如图中thread2 , thread3 , thread4 这三个回收线程总共可以帮助 thread1 回收对象的总量。availableSharedCapacity 在多个回收线程中是​**共享的**​，回收线程每回收一个对象它的值就会减1，当小于 LINK_CAPACITY(回收线程对应WeakOrderQueue节点的最小存储单元Link)时，回收线程将不能在为该stack回收对象了。该值的计算公式为前边介绍的 `max(maxCapacity / maxSharedCapacityFactor, LINK_CAPACITY)`​。\n\n> 当创建线程从Stack结构中的WeakOrderQueue链表中转移待回收对象到数组栈中后，availableSharedCapacity 的值也会相应增加。说白了这个值就是用来指示回收线程还能继续回收多少对象。已达到控制回收线程回收对象的总体容量。\n\n* ​`int maxDelayedQueues`​： 一个线程对于对象池来说，它可以是创建线程，也可以是回收线程，当该创建线程作为回收线程时，该值定义了最多可以为多少个创建线程回收对象。默认值为 CPU * 2。比如图中 thread2 作为回收线程既可以帮 thread1 回收对象也可以帮助 thread3 , thread4 回收对象。那么maxDelayedQueues 的值就是 3 。\n* ​`int maxCapacity`​：定义当前Stack结构中的数组栈的最大容量。默认为4096。\n* ​`int interval`​：创建线程的回收比例，默认是8。\n* ​`int delayedQueueInterval`​：创建线程作为回收线程时的回收比例。默认是8。\n* ​`DefaultHandle<?>[] elements`​：这个就是我们前边反复提到的Stack结构中的数组栈。用于存放对象池中的池化对象。当线程从对象池中获取对象时就是从这里获取。\n* ​`int size`​：数组栈中的栈顶指针。\n* ​`int handleRecycleCount`​：回收对象计数。与 interval 配合达到控制回收对象比例的目的。从 0 开始每遇到一个回收对象就 +1 ，同时把对象丢弃。直到`handleRecycleCount == interval`​时回收对象，然后归零。也就是前边我们说到的每创建8个对象才回收1个。避免 Stack 不可控制的迅速增长。\n* ​`WeakOrderQueue cursor, prev，head`​：这三个指针就是前边我们在讲Stack设计的时候介绍到的用于**多线程无锁化回收**的 WeakOrderQueue 链表中的头结点指针，当前节点指针，前一个节点指针（用于删除节点）。\n\n　　介绍完Stack结构中的这些重要属性，创建的过程就很简单了。就是利用前边介绍过的已经初始化好的Recycler属性对Stack结构中的这些属性进行赋值。\n\n```java\n    private final FastThreadLocal<Stack<T>> threadLocal = new FastThreadLocal<Stack<T>>() {\n        @Override\n        protected Stack<T> initialValue() {\n            return new Stack<T>(Recycler.this, Thread.currentThread(), maxCapacityPerThread, maxSharedCapacityFactor,\n                    interval, maxDelayedQueuesPerThread, delayedQueueInterval);\n        }\n\n      ..............省略............\n    }\n```\n\n```java\n       Stack(Recycler<T> parent, Thread thread, int maxCapacity, int maxSharedCapacityFactor,\n              int interval, int maxDelayedQueues, int delayedQueueInterval) {\n            this.parent = parent;\n            threadRef = new WeakReference<Thread>(thread);\n            this.maxCapacity = maxCapacity;\n            availableSharedCapacity = new AtomicInteger(max(maxCapacity / maxSharedCapacityFactor, LINK_CAPACITY));\n            elements = new DefaultHandle[min(INITIAL_CAPACITY, maxCapacity)];\n            this.interval = interval;\n            this.delayedQueueInterval = delayedQueueInterval;\n            handleRecycleCount = interval; \n            this.maxDelayedQueues = maxDelayedQueues;\n        }\n```\n\n### 9.2 从对象池中获取对象\n\n![image.png](/assets/002bdbd0d71140c3834d44b93555237ftplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-ryqzvpj.awebp)\n\n```java\npublic abstract class Recycler<T> {\n      //一个空的Handler,表示该对象不会被池化\n     private static final Handle NOOP_HANDLE = new Handle() {\n        @Override\n        public void recycle(Object object) {\n            // NOOP\n        }\n    };\n\n    public final T get() {\n        //如果对象池容量为0，则立马新创建一个对象返回，但是该对象不会回收进对象池\n        if (maxCapacityPerThread == 0) {\n            return newObject((Handle<T>) NOOP_HANDLE);\n        }\n        //获取当前线程 保存池化对象的stack\n        Stack<T> stack = threadLocal.get();\n        //从stack中pop出对象，handler是池化对象在对象池中的模型，包装了一些池化对象的回收信息和回收状态\n        DefaultHandle<T> handle = stack.pop();\n        //如果当前线程的stack中没有池化对象 则直接创建对象\n        if (handle == null) {\n            //初始化的handler对象recycleId和lastRecyclerId均为0\n            handle = stack.newHandle();\n            //newObject为对象池recycler的抽象方法，由使用者初始化内存池的时候 匿名提供\n            handle.value = newObject(handle);\n        }\n        return (T) handle.value;\n    }\n\n}\n```\n\n　　Recycler对外表现为一个整体的对象池，但是对象池内部是按照线程的维度来池化对象的，每个线程所池化的对象保存在对应的Stack结构中。\n\n1. 当对象池的最大容量`maxCapacityPerThread == 0`​时，对象池会立马创建一个对象出来，并将一个空的Handler传递进对象中。表示该对象在使用完毕后不会被回收进对象池中。\n2. 从threadLocal中获取当前线程对应的Stack，随后从Stack结构中的数组栈中弹出栈顶对象的DefaultHandler。\n3. 如果弹出的DefaultHandler为空，说明当前Stack中并没有回收的池化对象。直接创建一个新的DefaultHandler并创建一个新的对象，然后将DefaultHandler传入到新创建的对象中，并用DefaultHandler包裹新创建的对象。这样池化对象就与DefaultHandler关联起来了。\n\n```java\nstatic final class Entry {\n\n     private static final ObjectPool<Entry> RECYCLER = ObjectPool.newPool(new ObjectCreator<Entry>() {\n            @Override\n            public Entry newObject(Handle<Entry> handle) {\n                return new Entry(handle);\n            }\n        });\n\n     private Entry(Handle<Entry> handle) {\n            this.handle = handle;\n     }\n}\n```\n\n### 9.3 DefaultHandler\n\n　　前边我们在介绍对象池的设计原理时提到，池化对象在对象池中的存储模型为 Handler。\n\n```java\npublic abstract class ObjectPool<T> {\n\n    public interface Handle<T> {\n        void recycle(T self);\n    }\n\n}\n```\n\n　　在Recycler对象池中的默认实现是 DefaultHandler ，DefaultHandler 里面包裹了池化对象以及池化对象在对象池中的一些相关信息，（比如：池化对象的相关回收信息和回收状态）。\n\n　　从结构设计角度上来说，池化对象是隶属于其创建线程对应的Stack结构的，由于这层结构关系的存在，池化对象的DefaultHandler应该由Stack来进行创建。\n\n```java\n private static final class Stack<T> {\n\n        DefaultHandle<T> newHandle() {\n            return new DefaultHandle<T>(this);\n        }\n }\n```\n\n　　我们来看下 DefaultHandler 的具体结构：\n\n```java\n   private static final class DefaultHandle<T> implements Handle<T> {\n        //用于标识最近被哪个线程回收，被回收之前均是0\n        int lastRecycledId;\n        //用于标识最终被哪个线程回收，在没被回收前是0\n        int recycleId;\n\n        //是否已经被回收\n        boolean hasBeenRecycled;\n        //强引用关联创建handler的stack\n        Stack<?> stack;\n        //池化对象\n        Object value;\n\n        DefaultHandle(Stack<?> stack) {\n            this.stack = stack;\n        }\n\n        @Override\n        public void recycle(Object object) {\n\n          ...................省略.............\n        }\n    }\n```\n\n　　DefaultHandler属性的第一部分信息，首先就是池化对象在对象池中的回收信息。\n\n* ​`int lastRecycledId`​：用于标识最近被哪个线程回收，被回收之前均是0。\n* ​`int recycleId`​：用于标识最终被哪个线程回收，在没被回收前是0。\n* ​`boolean hasBeenRecycled`​：该池化对象是否已经被回收至创建线程对应的Stack中。\n\n　　​**这里可能大家有疑问了，为什么池化对象的回收还要分最近回收和最终回收呢**​？\n\n　　因为对象池中的池化对象回收可以分为两种情况：\n\n* ​`由创建线程直接进行回收`​：这种回收情况就是一步到位，直接回收至创建线程对应的Stack中。所以这种情况下是不分阶段的。`recycleId = lastRecycledId = OWN_THREAD_ID`​。\n* ​`由回收线程帮助回收`​：这种回收情况下就要分步进行了，首先由回收线程将池化对象**暂时存储**在其创建线程对应Stack中的WeakOrderQueue链表中。此时并没有完成真正的对象回收。`recycleId = 0，lastRecycledId = 回收线程Id（WeakOrderQueue#id）`​。当创建线程将WeakOrderQueue链表中的待回收对象转移至Stack结构中的数组栈之后，这时池化对象才算真正完成了回收动作。`recycleId = lastRecycledId = 回收线程Id（WeakOrderQueue#id）`​。\n\n　　这两个字段 lastRecycledId ，recycleId 主要是用来标记池化对象所处的回收阶段，以及在这些回收阶段具体被哪个线程进行回收。\n\n　　最后两个属性就比较容易理解了，一个是 Object value 用来包裹真正的池化对象。另一个是 Stack<?> stack 用来强引用关联池化对象的Handler所属的Stack结构。\n\n　　记不记得我们在介绍Stack结构的时候提到，Stack中持有其对应创建线程的`弱引用`​。笔者在解释为什么持有创建线程的弱引用时，提到过这样一个引用链关系：`池化对象 -> DefaultHandler -> Stack -> threadRef`​。这里大家明白了吗？\n\n![image.png](/assets/d9a984a0659546258734112ce5c687f7tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-qzq41qp.awebp)\n\n```java\nstatic final class Entry {\n    //池化对象Entry强引用它的DefaultHandler\n    private  Handle<Entry> handle;\n  \n}\n\n\nprivate static final class DefaultHandle<T> implements Handle<T> {\n    // DefaultHandler强引用其所属的Stack\n    Stack<?> stack;\n\n}\n\nprivate static final class Stack<T> {\n    // Stack弱引用其对应的创建线程\n    final WeakReference<Thread> threadRef;\n\n}\n```\n\n### 9.4 从Stack中获取池化对象\n\n![image.png](/assets/6d2a0769269e405dac3519f9e45d14d7tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-hfn0g3i.awebp)\n\n```java\n        DefaultHandle<T> pop() {\n            //普通出栈操作，从栈顶弹出一个回收对象\n            int size = this.size;\n            if (size == 0) {\n                //如果当前线程所属stack已经没有对象可用，则遍历stack中的weakOrderQueue链表（其他线程帮助回收的对象存放在这里）将这些待回收对象回收进stack\n                if (!scavenge()) {\n                    return null;\n                }\n                size = this.size;\n                if (size <= 0) {\n                    // 如果WeakOrderQueue链表中也没有待回收对象可转移\n                    // 直接返回null 新创建一个对象\n                    return null;\n                }\n            }\n            size --;\n            DefaultHandle ret = elements[size];\n            elements[size] = null;\n            this.size = size;\n\n            if (ret.lastRecycledId != ret.recycleId) {\n                // 这种情况表示对象至少被一个线程回收了，要么是创建线程，要么是回收线程\n                throw new IllegalStateException(\"recycled multiple times\");\n            }\n\n            //对象初次创建以及回收对象再次使用时  它的 recycleId = lastRecycleId = 0\n            ret.recycleId = 0;\n            ret.lastRecycledId = 0;\n            return ret;\n        }\n```\n\n　　这里就是业务线程从对象池中真正获取池化对象的地方。从Stack结构中的数组栈的栈顶位置弹出池化对象。\n\n* 首先判断数组栈中是否有回收的池化对象。栈顶指针 size == 0 说明当前数组栈中是空的。随后就会调用 scavenge 方法，从Stack结构中的WeakOrderQueue链表中转移最多一个Link大小的待回收对象到数组栈中。如果WeakOrderQueue链表中也没有待回收对象，说明当前Stack结构就是空的没有任何回收的池化对象，对象池直接返回 null ，并创建一个新的池化对象返回给业务线程。\n* 如果数组栈不为空，则将栈顶元素 DefaultHandler 弹出，初始化池化对象DefaultHandler的回收信息。`recycleId  = lastRecycledId = 0`​表示该池化对象刚刚从对象池中取出。\n\n　　recycleId 与 lastRecycledId 之间的关系分为以下几种情况：\n\n* ​`recycleId  = lastRecycledId = 0`​：表示池化对象刚刚被创建或者刚刚从对象池中取出即将被再次复用。这是池化对象的初始状态。\n* ​`recycleId  = lastRecycledId != 0`​：表示当前池化对象已经被回收至对应Stack结构里的数组栈中。可以直接被取出复用。可能是被其创建线程直接回收，也可能是被回收线程回收。\n* ​`recycleId  != lastRecycledId`​：表示当前池化对象处于半回收状态。池化对象已经被业务线程处理完毕，并被回收线程回收至对应的WeakOrderQueue节点中。并等待创建线程将其最终转移至Stack结构中的数组栈中。\n\n### 9.4 转移回收线程回收的对象到Stack中\n\n![image.png](/assets/29c7d6a21d76455d9bc5443394172a2btplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-jhifgqp.awebp)\n\n　　通过前边介绍Stack结构的设计原理我们知道，对象池中池化对象的回收存储分为两个部分：\n\n* 一个是池化对象直接被创建线程回收，直接存储在创建线程对应Stack结构中的数组栈中。\n* 另一个是池化对象被回收线程回收，临时间接存储在创建线程对应Stack结构中的WeakOrderQueue链表中。每个回收线程对应一个WeakOrderQueue节点。\n\n　　当Stack结构中的数组栈为空时，创建线程会遍历WeakOrderQueue链表，从而将回收线程为其回收的对象从WeakOrderQueue节点中转移至数组栈中。**多线程回收对象无锁化设计**\n\n　　这个转移的动作就是由 scavenge 方法来完成的。\n\n```java\n       private boolean scavenge() {\n            //从其他线程回收的weakOrderQueue里 转移 待回收对像 到当前线程的stack中\n            if (scavengeSome()) {\n                return true;\n            }\n\n            // 如果weakOrderQueue中没有待回收对象可转移，那么就重置stack中的cursor.prev\n            // 因为在扫描weakOrderQueue链表的过程中，cursor已经发生变化了\n            prev = null;\n            cursor = head;\n            return false;\n        }\n```\n\n　　scavengeSome() 执行具体的转移逻辑。如果WeakOrderQueue链表中还有待回收对象并转移成功则返回 true 。如果WeakOrderQueue链表为空没有任何待回收对象可转移，则重置链表相关的指针，cursor重新指向head节点，prev指向null。因为在遍历WeakOrderQueue链表搜寻可转移对象时，cursor指针已经发生变化了，这里需要重置。\n\n### 9.5 转移回收对象\n\n　　下面创建线程就开始遍历Stack结构中的WeakOrderQueue链表，将其中存储的回收线程回收进来的对象转移到数组栈中。\n\n　　为了让大家更清晰的理解遍历WeakOrderQueue链表的过程，我们先来了解下Stack中WeakOrderQueue链表的状态结构如下图所示：\n\n![image.png](/assets/c7d327afbf054012bd98bb554bfd19a3tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-kxpsqug.awebp)\n\n　　在Stack结构刚刚创建的初始状态，WeakOrderQueue链表是空的，所以 prev = head = cursor = null 。\n\n　　后面当回收线程在回收对象时会加入自己对应的WeakOrderQueue节点到链表中。​**注意：WeakOrderQueue节点的插入都是在链表的头结点进行插入**​。\n\n> 后面我们在讲到多线程回收对象时还会再次详细讲解WeakOrderQueue链表的操作，这里大家只需要先理解链表的状态结构即可。\n\n　　head指针始终指向链表的头结点，cursor指针指向当前遍历的节点。在没有开始遍历链表前，cursor指针指向头结点。表示从头结点开始遍历。prev指针指向cursor前一个节点。当前遍历节点为头结点时，prev指针指向空。\n\n　　在理解了WeakOrderQueue链表的状态结构后，我们来看一下链表的遍历转移过程逻辑：\n\n```java\n        private boolean scavengeSome() {\n            WeakOrderQueue prev;\n            //获取当前线程stack 的weakOrderQueue链表指针（本次扫描起始节点）\n            WeakOrderQueue cursor = this.cursor;\n            //在stack初始化完成后，cursor，prev,head等指针全部是null，这里如果cursor == null 意味着当前stack第一次开始扫描weakOrderQueue链表\n            if (cursor == null) {\n                prev = null;\n                cursor = head;\n                if (cursor == null) {\n                    //说明目前weakOrderQueue链表里还没有节点，并没有其他线程帮助回收的池化对象\n                    return false;\n                }\n            } else {\n                //获取prev指针，用于操作链表（删除当前cursor节点）\n                prev = this.prev;\n            }\n\n            boolean success = false;\n            //循环遍历weakOrderQueue链表 转移待回收对象\n            do {\n                //将weakOrderQueue链表中当前节点中包含的待回收对象，转移到当前stack中，一次转移一个link\n                if (cursor.transfer(this)) {\n                    success = true;\n                    break;\n                }\n                //如果当前cursor节点没有待回收对象可转移，那么就继续遍历链表获取下一个weakOrderQueue节点\n                WeakOrderQueue next = cursor.getNext();\n                //如果当前weakOrderQueue对应的回收线程已经挂掉了，则\n                if (cursor.get() == null) {\n                    // 判断当前weakOrderQueue节点是否还有可回收对象\n                    if (cursor.hasFinalData()) {\n                        //回收weakOrderQueue中最后一点可回收对象，因为对应的回收线程已经死掉了，这个weakOrderQueue不会再有任何对象了\n                        for (;;) {\n\n                            if (cursor.transfer(this)) {\n                                success = true;\n                            } else {\n                                break;\n                            }\n                        }\n                    }\n\n                    //回收线程以死，对应的weaoOrderQueue节点中的最后一点待回收对象也已经回收完毕，就需要将当前节点从链表中删除。unlink当前cursor节点\n                    //这里需要注意的是，netty永远不会删除第一个节点，因为更新头结点是一个同步方法，避免更新头结点而导致的竞争开销\n                    // prev == null 说明当前cursor节点是头结点。不用unlink，如果不是头结点 就将其从链表中删除，因为这个节点不会再有线程来收集池化对象了\n                    if (prev != null) {\n                        //确保当前weakOrderQueue节点在被GC之前，我们已经回收掉它所有的占用空间\n                        cursor.reclaimAllSpaceAndUnlink();\n                        //利用prev指针删除cursor节点\n                        prev.setNext(next);\n                    }\n                } else {\n                    prev = cursor;\n                }\n                //向后移动prev,cursor指针继续遍历weakOrderQueue链表\n                cursor = next;\n\n            } while (cursor != null && !success);\n\n            this.prev = prev;\n            this.cursor = cursor;\n            return success;\n        }\n```\n\n1. 再开始遍历WeakOrderQueue链表之前，首先需要检查cursor指针是否为空，如果为空说明当前Stack是第一次开始遍历WeakOrderQueue链表。随后让cursor指针指向head指针，如果head指针指向为空，说明当前WeakOrderQueue链表是空的，此时没有任何回收线程在回收对象。如果head指针不为空，则从head指针指向的头结点开始遍历WeakOrderQueue链表。\n2. 首先会从cursor指针指向的当前遍历节点开始，将当前WeakOrderQueue节点中存储的待回收对象转移到Stack结构中的数组栈中。一次最多转移一个Link大小的对象。转移成功后退出。如果当前WeakOrderQueue节点此时没有任何待回收对象可被转移则转移失败，继续遍历下一个WeakOrderQueue节点。\n\n```java\n        if (cursor.transfer(this)) {\n            success = true;\n            break;\n        }\n\n        WeakOrderQueue next = cursor.getNext();\n```\n\n3. 为了多线程能够无锁化回收对象，一个回收线程对应一个WeakOrderQueue节点，在WeakOrderQueue节点中持有对应回收线程的`弱引用`​,目的也是为了当回收线程挂掉的时候，能够保证回收线程被GC及时的回收掉。如果`cursor.get() == null`​说明当前WeakOrderQueue节点对应的回收线程已经挂掉了，此时如果当前节点还有待回收对象，则需要将节点中的所有待回收对象全部转移至Stack中的数组栈中。​**注意这里是转移节点所有的待回收对象而不是只转移一个Link**​。因为对应的回收线程已经挂掉了，该线程后续将不再会帮助创建线程回收对象了，所以要清理其对应的WeakOrderQueue节点。\n\n```java\nprivate static final class WeakOrderQueue extends WeakReference<Thread> {\n\n    ............WeakOrderQueue本身就是一个弱引用，引用对应的回收线程.........\n\n}\n```\n\n4. 当清理完已经挂掉的回收线程对应的WeakOrderQueue节点后，就需要将该节点从Stack结构里的WeakOrderQueue链表中删除。保证被清理后的WeakOrderQueue节点可以被GC回收。当然删除节点之前需要通过`cursor.reclaimAllSpaceAndUnlink()`​释放回收线程回收对象的availableSharedCapacity容量。释放的容量的大小为被删除WeakOrderQueue节点中存储的待回收对象容量。\n\n```java\n        if (prev != null) {\n              cursor.reclaimAllSpaceAndUnlink();\n              //利用prev指针删除cursor节点\n              prev.setNext(next);\n        }\n```\n\n> 这里需要注意的是，Netty不会对WeakOrderQueue链表的头结点进行删除。如果`prev == null`​说明当前节点是头结点，即使对应的回收线程已经挂掉了，但在本次遍历中不会对其进行删除。因为操作链表头结点的方法是一个同步方法，Netty这里是为了避免不必要的同步开销。\n\n　　以上逻辑就是创建线程遍历WeakOrderQueue链表转移回收对象的处理逻辑，如果本次遍历的当前节点中并没有对象可转移，那么就继续从下一个节点开始遍历。循环执行转移逻辑直到遍历完链表或者中途转移成功。退出循环时要记录更新cursor指针记录当前遍历到的节点。\n\n　　这里大家可能会有两个问题：\n\n　　​**第一个问题：如果头结点对应的回收线程已经挂掉，这个头结点不在本次遍历中删除，那么会在什么时候被删除呢**​？\n\n![image.png](/assets/359cbfb6d68e450b8f611a9975099c6etplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-ol5zynd.awebp)\n\n　　首先当回收线程第一次开始帮助创建线程回收对象时，会将自己对应的WeakOrderQueue节点插入到创建线程对应Stack结构中的WeakOrderQueue链表的头结点位置。​**节点始终在链表的头结点位置插入**​。\n\n　　如图所示，当本次遍历发现头结点对应的回收线程 thread4 已经挂掉后，清理完头结点中存储的待回收对象后，让其继续呆在链表中，​**并不着急将其删除**​。随后cursor指针指向thread3对应的节点，下一次遍历就会从thread3对应的节点开始遍历。\n\n　　当有一个新的回收线程 thread5 加入后，此时thread5对应的WeakOrderQueue节点变成了链表中的头结点，当经过多次遍历之后，cursor指针最终会再次指向死亡线程`thread4`​对应的节点时，会再次进入`cursor.get() == null`​的处理逻辑，而此时`thread4`​对应的节点已经不是头结点了，所以在这次遍历中就将该节点从链表中删除。\n\n> 这就是多线程并发代码和单线程代码设计上的不同，在多线程程序设计中，我们一定要时刻警惕同步操作的开销。能避免就要尽量避免。\n\n　　**第二个问题：操作WeakOrderQueue链表的头结点为什么是同步方法呢？**\n\n　　我们都知道一个回收线程对应一个WeakOrderQueue节点，当一个回收线程第一次为该创建线程回收对象时，都会新创建一个WeakOrderQueue节点并将节点插入到创建线程对应Stack中的WeakOrderQueue链表中的头结点位置。\n\n　　在多线程回收场景下，可能会有多个回收线程同时向创建线程对应Stack中的WeakOrderQueue链表的头结点插入自己对应的节点。\n\n　　那么此时对于链表头结点的操作就必须做同步处理了。当节点同步插入到链表的头结点后，以后该回收线程回收对象就是无锁化了。​**只不过就是在一开始插入节点的时候会有一点同步的开销，但是这是无法避免的**​。\n\n```java\n        //整个recycler对象池唯一的一个同步方法，而且同步块非常小，逻辑简单，执行迅速\n        synchronized void setHead(WeakOrderQueue queue) {\n            //始终在weakOrderQueue链表头结点插入新的节点\n            queue.setNext(head);\n            head = queue;\n        }\n```\n\n　　纵观整个Recycler的设计实现，这个方法是唯一一个同步的方法，而且同步块非常的短，里面的逻辑非常简单。\n\n> 在多线程程序设计中，如果遇到无法避免的同步情况，那么也必须使同步块内的代码逻辑尽量简单。\n\n## 10. WeakOrderQueue的设计实现\n\n![image.png](/assets/53b93ae1d4dc4adeaa4d6104cc9aa7b6tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-onec9un.awebp)\n\n　　之前我们在介绍WeakOrderQueue结构设计原理的时候讲到，虽然该结构命名的后缀是一个Queue，但其实是一个链表，链表中的元素类型为Link，头结点指针Head永远指向第一个未被转移完毕的Link，当一个Link里的待回收对象被全部转移完毕后，head指针随即指向下一个节点，但是该Link节点并不会从链表中删除。尾指针Tail指向链表中最后一个`Link节点`​。节点的插入是从链表的尾部开始插入。\n\n### 10.1 Link结构\n\n```java\n    private static final class WeakOrderQueue extends WeakReference<Thread> {\n\n        // link结构是用于真正存储待回收对象的结构，继承AtomicInteger 本身可以用来当做writeindex使用\n        static final class Link extends AtomicInteger {\n            //数组用来存储待回收对象，容量为16\n            final DefaultHandle<?>[] elements = new DefaultHandle[LINK_CAPACITY];\n\n            int readIndex;\n            //weakOrderQueue中的存储结构时由link结构节点元素组成的链表结构\n            Link next;\n        }\n}\n```\n\n　　首先我们从WeakOrderQueue的继承结构上来看，它继承于 `WeakReference < Thread >`​ , 表示该结构持有一个线程的`弱引用`​，一个回收线程对应于一个WeakOrderQueue节点，很明显是持有其对应回收线程的弱引用，方便当回收线程挂掉的时候被GC回收。\n\n* ​`DefaultHandle<?>[] elements `​: Link结构中包含一个容量为LINK_CAPACITY ，默认为16大小的DefaultHandle数组，用来存储回收线程回收的对象。\n* ​`int readIndex`​：创建线程在转移Link节点中的待回收对象时，通过这个readIndex来读取未被转移的对象。由于readIndex只会被创建线程使用，所以这里并不需要保证原子性和可见性。用一个普通的int变量存储就好。\n* ​`writeIndex`​：Link结构继承于AtomicInteger类型，这就意味着Link结构本身就可以被当做一个writeIndex来使用，由于回收线程在向Link节点添加回收对象的时候需要修改writeIndex，于此同时创建线程在转移Link节点的时候需要读取writeIndex，所以writeIndex需要保证线程安全性，故采用AtomicInteger类型存储。\n* ​`Link next`​：Link节点的next指针，用于指向链表中的下一个节点。\n\n### 10.2 Head结构\n\n```java\n        // weakOrderQueue内部link链表的头结点\n        private static final class Head {\n            //所有回收线程能够帮助创建线程回收对象的总容量 reserveSpaceForLink方法中会多线程操作该字段\n            //用于指示当前回收线程是否继续为创建线程回收对象，所有回收线程都可以看到，这个值是所有回收线程共享的。以便可以保证所有回收线程回收的对象总量不能超过availableSharedCapacity\n            private final AtomicInteger availableSharedCapacity;\n            //link链表的头结点\n            Link link;\n\n            Head(AtomicInteger availableSharedCapacity) {\n                this.availableSharedCapacity = availableSharedCapacity;\n            }\n\n            void reclaimAllSpaceAndUnlink() {\n                    ....回收head节点的所有空间，并从链表中删除head节点，head指针指向下一节点....\n            }\n\n            private void reclaimSpace(int space) {\n                //所有回收线程都可以看到，这个值是所有回收线程共享的。以便可以保证所有回收线程回收的对象总量不能超过availableSharedCapacity\n                availableSharedCapacity.addAndGet(space);\n            }\n\n            //参数link为新的head节点，当前head指针指向的节点已经被回收完毕\n            void relink(Link link) {\n                  ...回收当前头结点的容量，更新head节点为指定的Link节点...\n            }\n\n            Link newLink() {\n                  ....创建新的Link节点...\n            }\n\n            //此处目的是为接下来要创建的link预留空间容量\n            static boolean reserveSpaceForLink(AtomicInteger availableSharedCapacity) {             \n                  ...在创建新的Link节点之前需要调用该方法预订容量空间...\n            }\n        }\n```\n\n　　从代码结构上我们可以看出，Head结构的设计不只是作为头结点指针那么简单，其中还封装了很多链表操作以及回收的逻辑。\n\n* ​`AtomicInteger availableSharedCapacity`​：这个字段前边已经介绍过多次了，它是多线程共享的一个字段，可以被多个回收线程进行操作，表达的语义是所有回收线程总共可以帮助创建线程一共可以回收多少对象。对所有回收线程回收对象的总量进行限制。每创建一个Link节点，它的值就减少一个LINK_CAPACITY ，每释放一个Link节点，它的值就增加一个LINK_CAPACITY 。\n* ​`Link link`​：Head结构封装的Link链表中的头结点。\n\n　　剩下Head结构中封装的相关逻辑处理方法，等到介绍到具体应用场景的时候，笔者在拿出来为大家介绍，这里先混个眼熟就行。先看懂个大概，脑海里朦朦胧胧有个粗浅的认识即可。\n\n### 10.3 WeakOrderQueue中的重要属性\n\n```java\n private static final class WeakOrderQueue extends WeakReference<Thread> {\n\n        //link链表的头结点，head指针始终指向第一个未被转移完毕的LinK节点\n        private final Head head;\n        //尾结点\n        private Link tail;\n        //站在stack的视角中，stack中包含一个weakOrderQueue的链表，每个回收线程为当前stack回收的对象存放在回收线程对应的weakOrderQueue中\n        //这样通过stack中的这个weakOrderQueue链表，就可以找到其他线程为该创建线程回收的对象\n        private WeakOrderQueue next;\n        //回收线程回收Id,每个weakOrderQueue分配一个，同一个stack下的一个回收线程对应一个weakOrderQueue节点\n        private final int id = ID_GENERATOR.getAndIncrement();\n        //回收线程回收比例 默认是8\n        private final int interval;\n        //回收线程回收计数 回收1/8的对象\n        private int handleRecycleCount;\n\n}\n```\n\n* ​`Head head`​：用于指向WeakOrderQueue中Link链表的头结点。\n* ​`Link tail`​：指向Link链表中的尾结点。\n* ​`WeakOrderQueue next`​：站在Stack结构的视角上，Stack包含一个WeakOrderQueue链表，用来存放回收线程回收过来的池化对象。该字段为WeakOrderQueue节点的next指针，用于指向下一个回收线程对应的WeakOrderQueue节点。\n* ​`int id `​：对应回收线程的回收Id，同一个Stack结构下，不同的回收线程对应不同的Id。\n* ​`int interval`​：回收线程对应的回收频率，默认只回收 1 / 8 的池化对象。\n* ​`int handleRecycleCount`​：回收对象计数，前边我们多次讲过了。用于控制回收频率。\n\n### 10.4 WeakOrderQueue结构的创建\n\n```java\nprivate static final class WeakOrderQueue extends WeakReference<Thread> {\n        //为了使stack能够被GC,这里不会持有其所属stack的引用\n        private WeakOrderQueue(Stack<?> stack, Thread thread) {\n            //weakOrderQueue持有对应回收线程的弱引用\n            super(thread);\n            //创建尾结点\n            tail = new Link();\n\n            // 创建头结点  availableSharedCapacity = maxCapacity / maxSharedCapacityFactor\n            head = new Head(stack.availableSharedCapacity);\n            head.link = tail;\n            interval = stack.delayedQueueInterval;\n            handleRecycleCount = interval; \n        }\n}\n```\n\n　　在创建WeakOrderQueue结构的时候，首先会调用父类 `WeakReference<Thread>`​ 的构造方法持有当前回收线程的弱应用。\n\n　　然后创建第一个Link节点，head指针和tail指针同时指向这第一个节点。\n\n　　用创建线程对应的Stack中的属性初始化WeakOrderQueue结构中的相关属性。\n\n　　大家这里可能会问了，既然这里用Stack中的属性去初始化WeakOrderQueue结构中的相关属性，那​**为什么WeakOrderQueue不直接持有Stack的引用呢**​？\n\n　　之前我们提到，一个回收线程对应一个WeakOrderQueue节点，当回收线程挂掉的时候，需要清理WeakOrderQueue节点并将其从Stack结构中的WeakOrderQueue链表（头结点除外）中删除。使得WeakOrderQueue节点可以被GC回收掉。\n\n　　**如果Stack结构对应的创建线程挂掉，而此时WeakOrderQueue又持有了Stack的引用，这样就使得Stack结构无法被GC掉。**\n\n　　所以这里只会用Stack结构的相关属性去初始化WeakOrderQueue结构，在WeakOrderQueue中并不会持有Stack的引用。\n\n> 在复杂程序结构的设计中，我们要时刻对对象之间的引用关系保持清晰的认识。防止内存泄露。\n\n### 10.5 从WeakOrderQueue中转移回收对象\n\n　　WeakOrderQueue的transfer方法用于将当前WeakOrderQueue节点中的待回收对象转移至创建线程对应的Stack中。\n\n　　开始转移回收对象时会从WeakOrderQueue节点中的Link链表的头结点开始遍历，如果头结点中还有未被转移的对象，则将头结点剩余的未转移对象转移至Stack中。所以创建线程每次最多转移一个LINK_CAPACITY大小的对象至Stack中。只要成功转移了哪怕一个对象，transfer方法就会返回true。\n\n　　如果头结点中存储的对象已经全部转移完毕，则更新head指针指向下一个Link节点，开始转移下一个Link节点。​**创建线程每次只会转移一个Link节点**​。如果Link链表是空的，没有转移成功一个对象，则transfer方法返回false。\n\n　　由于transfer方法体比较大，笔者将其按照上述逻辑步骤拆分开来为大家讲解：\n\n![image.png](/assets/25a723e07ab64f0fa5fcdc4eeddf1e0dtplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-afj8oqs.awebp)\n\n#### 10.5.1 判断头结点中的待回收对象是否转移完毕\n\n```java\n            //获取当前weakOrderQueue节点中的link链表头结点\n            Link head = this.head.link;\n            //头结点为null说明还没有待回收对象\n            if (head == null) {\n                return false;\n            }\n\n            //如果头结点中的待回收对象已经被转移完毕\n            if (head.readIndex == LINK_CAPACITY) {\n                //判断是否有后续Link节点\n                if (head.next == null) {\n                    //整个link链表没有待回收对象了已经\n                    return false;\n                }\n                head = head.next;\n                //当前Head节点已经被转移完毕，head指针向后移动，head指针始终指向第一个未被转移完毕的LinK节点\n                this.head.relink(head);\n            }\n```\n\n　　首先从Link链表的头结点开始转移，`head == null`​ 说明当前Link链表是空的并没有对象可被转移，直接返回false。\n\n　　​`head.readIndex == LINK_CAPACITY`​ 判断当前头结点中的对象是否已经被转移完毕，如果当前头结点中的对象已经被全部转移完毕，则将head指针更新 relink 为下一个节点，开始从下一个节点开始转移对象。如果此时Link链表已经为空了，直接返回false。\n\n```java\n private static final class Head {\n\n            //参数link为新的head节点，当前head指针指向的节点已经被回收完毕\n            void relink(Link link) {\n                //更新availableSharedCapacity，因为当前link节点中的待回收对象已经被转移完毕，所以需要增加availableSharedCapacity的值\n                reclaimSpace(LINK_CAPACITY);\n                //head指针指向新的头结点（第一个未被回收完毕的link节点）\n                this.link = link;\n            }\n            private void reclaimSpace(int space) {\n                //所有回收线程都可以看到，这个值是所有回收线程共享的。以便可以保证所有回收线程回收的对象总量不能超过availableSharedCapacity\n                availableSharedCapacity.addAndGet(space);\n            }\n}\n```\n\n#### 10.5.2 根据本次转移对象容量评估是否应该对Stack进行扩容\n\n　　此时Head节点已经校验完毕，可以执行正常的转移逻辑了。但在转移逻辑正式开始之前，还需要对本次转移对象的容量进行计算，并评估Stack的当前容量是否可以容纳的下，如果Stack的当前容量不够，则需要对Stack进行扩容。\n\n```java\n            final int srcStart = head.readIndex;\n            //writeIndex\n            int srcEnd = head.get();\n            //该link节点可被转移的对象容量\n            final int srcSize = srcEnd - srcStart;\n            if (srcSize == 0) {\n                return false;\n            }\n\n            // 获取创建线程stack中的当前回收对象数量总量\n            final int dstSize = dst.size;\n            // 待回收对象从weakOrderQueue中转移到stack后，stack的新容量 = 转移前stack容量 + 转移的待回收对象个数\n            final int expectedCapacity = dstSize + srcSize;\n\n            if (expectedCapacity > dst.elements.length) {\n                //如果转移后的stack容量超过当前stack的容量 则对stack进行扩容\n                final int actualCapacity = dst.increaseCapacity(expectedCapacity);\n                //每次转移最多一个Link的容量\n                //actualCapacity - dstSize表示扩容后的stack还有多少剩余空间\n                srcEnd = min(srcStart + actualCapacity - dstSize, srcEnd);\n            }\n```\n\n　　获取Link链表头结点的readIndex和writeIndex，通过  `writeIndex - readIndex`​ 计算出当前头结点有多少可被转移的对象。\n\n　　Stack的最终容量为： `expectedCapacity = stack当前容量 + 转移对象的容量`​。\n\n　　如果计算得出转移后Stack的最终容量 expectedCapacity 超过了Stack的当前容量则需要对Stack进行扩容。根据扩容后的容量最终决定本次转移多少对象： `min(srcStart + actualCapacity - dstSize, srcEnd)`​ ，确保不能超过Stack可容纳的空间。\n\n```java\nprivate static final class Stack<T> {\n\n        int increaseCapacity(int expectedCapacity) {\n            int newCapacity = elements.length;\n            int maxCapacity = this.maxCapacity;\n            do {\n                newCapacity <<= 1;\n            } while (newCapacity < expectedCapacity && newCapacity < maxCapacity);\n            //扩容后的新容量为最接近指定容量expectedCapacity的最大2的次幂\n            newCapacity = min(newCapacity, maxCapacity);\n            if (newCapacity != elements.length) {\n                elements = Arrays.copyOf(elements, newCapacity);\n            }\n\n            return newCapacity;\n        }\n\n}\n```\n\n　　如果当前Stack已经达到最大容量，无法再继续扩容：`actualCapacity - dstSize = 0`​，则停止本次转移操作，直接返回`false`​。\n\n```java\nif (srcStart != srcEnd) {\n   .....具体的转移逻辑.......\n}else {\n    // The destination stack is full already.\n    return false;\n}\n```\n\n　　​**如果Stack的容量可以容纳头结点中存储的待转移对象，则开始正式的转移逻辑**​：\n\n#### 10.5.3 转移回收对象\n\n```java\n                //待转移对象集合 也就是Link节点中存储的元素\n                final DefaultHandle[] srcElems = head.elements;\n                //stack中存储转移对象数组\n                final DefaultHandle[] dstElems = dst.elements;\n                int newDstSize = dstSize;\n                for (int i = srcStart; i < srcEnd; i++) {\n                    DefaultHandle<?> element = srcElems[i];\n                    //recycleId == 0 表示对象还没有被真正的回收到stack中\n                    if (element.recycleId == 0) {\n                        //设置recycleId 表明是被哪个weakOrderQueue回收的\n                        element.recycleId = element.lastRecycledId;\n                    } else if (element.recycleId != element.lastRecycledId) {\n                        //既被创建线程回收 同时也被回收线程回收  回收多次 则停止转移\n                        throw new IllegalStateException(\"recycled already\");\n                    }\n                    //对象转移后需要置空Link节点对应的位置\n                    srcElems[i] = null;\n\n                    //这里从weakOrderQueue将待回收对象真正回收到所属stack之前 需要进行回收频率控制\n                    if (dst.dropHandle(element)) {\n                        // Drop the object.\n                        continue;\n                    }\n                    //重新为defaultHandler设置其所属stack(初始创建该handler的线程对应的stack)\n                    //该defaultHandler在被回收对象回收的时候，会将其stack置为null，防止极端情况下，创建线程挂掉，对应stack无法被GC\n                    element.stack = dst;\n                    //此刻，handler才真正的被回收到所属stack中\n                    dstElems[newDstSize ++] = element;\n                }\n```\n\n　　将当前Link节点中的elements数组里存储的对象转移至Stack中的数组栈elements中。转移范围 `srcStart  ->  srcEnd `​。\n\n　　如果当前转移对象 `element.recycleId == 0`​ 说明当前对象还没有被真正的回收至创建线程对应的Stack中，符合转移条件（不能被多次回收）。还记不记得我们前边在《9.3 从Stack中获取池化对象》小节介绍的：\n\n* ​`recycleId = lastRecycledId = 0`​：表示池化对象刚刚被创建或者刚刚从对象池中取出即将被再次复用。这是池化对象的初始状态。\n\n　　随后设置回收Id `element.recycleId = element.lastRecycledId`​。此处的lastRecycledId为当前WeakOrderQueue节点对应的回收线程Id。\n\n　　​`element.recycleId != element.lastRecycledId`​ 此处表示当前对象可能被创建线程回收了，也可能被回收线程回收了。\n\n　　如果当前转移对象已经被回收至Stack中，则不能被再次回收，停止转移。\n\n#### 10.5.4 控制对象回收频率\n\n　　符合转移条件的对象，需要再次经过回收频率的控制，即前边介绍的只回收 1 / 8 的对象，也就是每 8 个对象回收 1 个。\n\n```java\n        boolean dropHandle(DefaultHandle<?> handle) {\n            if (!handle.hasBeenRecycled) {\n                //回收计数handleRecycleCount 初始值为8 这样可以保证创建的第一个对象可以被池化回收\n                //interval控制回收频率 8个对象回收一个\n                if (handleRecycleCount < interval) {\n                    handleRecycleCount++;\n                    // Drop the object.\n                    return true;\n                }\n                //回收一个对象后，回收计数清零\n                handleRecycleCount = 0;\n                //设置defaultHandler的回收标识为true\n                handle.hasBeenRecycled = true;\n            }\n            return false;\n        }\n```\n\n　　当对象通过了回收频率的验证之后，最后将回收对象的DefaultHandler中持有的Stack引用再次设置为其创建线程对应的Stack。因为在回收线程将池化对象回收至WeakOrderQueue节点时，会将其DefaultHandler中对Stack的引用置为null。所以这里需要重置回来。\n\n> 具体为什么在回收线程回收时会将回收对象的Stack引用置为null，大家这里可以自己先思考下，等到后面我们讲解多线程回收时，笔者在为大家揭开谜底。\n\n　　随后会将对象压入Stack结构中的数组栈中，到这里，回收线程帮助创建线程回收的对象才算真正的被回收了，业务线程可以直接从对象池中取出使用了。\n\n　　当对象转移完毕后，更新当前Link节点的readIndex，更新Stack中数组栈的栈顶指针。如果当前Link节点已经被转移完毕，则Head指针指向链表中的下一个节点，开始等待下一次的转移。\n\n```java\n             if (srcEnd == LINK_CAPACITY && head.next != null) {\n                    // Add capacity back as the Link is GCed.\n                    // 如果当前Link已经被回收完毕，且link链表还有后续节点，则更新head指针\n                    this.head.relink(head.next);\n                }\n\n                //更新当前回收Link的readIndex\n                head.readIndex = srcEnd;\n                //如果没有转移任何数据 return false\n                if (dst.size == newDstSize) {\n                    return false;\n                }\n                dst.size = newDstSize;\n                return true;\n```\n\n　　到现在为止，多线程从Recycler对象池中无锁化获取对象的完整流程，笔者就为大家介绍完了，下面我们来继续剖析下多线程回收对象的场景。\n\n## 11. 多线程回收对象无锁化实现\n\n　　之前我们在介绍池化对象的设计时，提到业务线程在使用对象的时候不应该感受到对象池的存在，所以将池化对象的回收，封装在其DefaultHandler中。在业务线程使用完对象时，直接调用池化对象的recycle方法进行回收即可。\n\n![image.png](/assets/58038d8ee0344260875993d8636331d5tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-lhvub6f.awebp)\n\n```java\nstatic final class Entry {\n\n       private  Handle<Entry> handle;\n\n       void recycle() {\n            next = null;\n            bufs = null;\n            buf = null;\n            msg = null;\n            promise = null;\n            progress = 0;\n            total = 0;\n            pendingSize = 0;\n            count = -1;\n            cancelled = false;\n            handle.recycle(this);\n        }\n\n}\n```\n\n```java\nprivate static final class DefaultHandle<T> implements Handle<T> {\n      \n        ..................省略............\n\n        //强引用关联创建handler的stack\n        Stack<?> stack;\n        //池化对象\n        Object value;\n\n        @Override\n        public void recycle(Object object) {\n            if (object != value) {\n                throw new IllegalArgumentException(\"object does not belong to handle\");\n            }\n\n            Stack<?> stack = this.stack;\n            //handler初次创建以及从对象池中获取到时  recycleId = lastRecycledId = 0（对象被回收之前）\n            //创建线程回收对象后recycleId = lastRecycledId = OWN_THREAD_ID\n            //回收线程回收对象后lastRecycledId = 回收线程Id,当对象被转移到stack中后 recycleId = lastRecycledId = 回收线程Id\n            if (lastRecycledId != recycleId || stack == null) {\n                throw new IllegalStateException(\"recycled already\");\n            }\n\n            stack.push(this);\n        }\n\n}\n```\n\n　　DefaultHandler中的 recycle 方法逻辑比较简单，唯一不好理解的地方在于判断对象是否已经被回收的 if 条件语句。\n\n* ​`lastRecycledId != recycleId`​ ：此时对象的状态正处于已经被回收线程回收至对应 WeakOrderQueue 节点的半回收状态，但还未被转移至其创建线程对应的Stack中。​**所以这个条件要控制的事情就是如果对象已经被回收线程回收，那么就停止本次的回收操作**​。\n\n> 忘记的同学可以在回看下《9.3 从Stack中获取池化对象》小节，那里详细介绍了 recycleId 和 lastRecycledId 之间各种关系的变化及其含义\n\n* ​`stack == null`​ ：这种情况其实前边我们也有提到过，就是当池化对象对应的创建线程挂掉的时候，对应的Stack随后也被GC回收掉。那么这时就不需要在回收该池化对象了。\n\n### 11.1 回收对象至Stack中——啊哈！Bug!\n\n```java\nprivate static final class Stack<T> {\n        //持有对应创建线程的弱引用\n        final WeakReference<Thread> threadRef;\n\n        void push(DefaultHandle<?> item) {\n            Thread currentThread = Thread.currentThread();\n            //判断当前线程是否为创建线程  对象池的回收原则是谁创建，最终由谁回收。其他线程只是将回收对象放入weakOrderQueue中\n            //最终是要回收到创建线程对应的stack中的\n            if (threadRef.get() == currentThread) {\n                // 如果当前线程正是创建对象的线程，则直接进行回收 直接放入与创建线程关联的stack中\n                pushNow(item);\n            } else {\n                // 当前线程不是创建线程，则将回收对象放入创建线程对应的stack中的weakOrderQueue链表相应节点中（currentThread对应的节点）\n                pushLater(item, currentThread);\n            }\n        }\n}\n```\n\n　　这里会进入到池化对象DefaultHandler中持有的Stack中，在Stack中进行对象的回收。\n\n> 大家这里先不要看笔者下面的解释，试着自己着重分析下这个 if...else...逻辑判断，有没有发现什么问题？？Bug就在这里！！\n\n　　这里首先会判断当前回收线程是否为池化对象的创建线程：`threadRef.get() == currentThread)`​。如果是，则由创建线程直接回收 pushNow(item) 。\n\n　　如果 `threadRef.get() != currentThread)`​ 这里有两种情况：\n\n1. currentThread是回收线程，那么就按多线程回收的逻辑 `pushLater(item, currentThread)`​ ，由回收线程将对象回收至其对应的WeakOrderQueue节点中，这里没什么毛病。\n2. Bug就出现在第二种情况，还有一种情况是 `threadRef.get()  == null`​ 也会走到 else 分支里。表示该回收对象的创建线程已经挂掉，并被GC回收。​**那么在这种情况下已经没有必要在对该对象进行回收了**​，因为创建线程已经挂掉，随后对应的Stack也迟早被GC掉，​**这个对象即使被回收进Stack也永远不会在被使用到**​。但是Netty的做法还是会让回收线程将其回收至Stack中的WeakOrderQueue链表中，笔者认为这里根本就没必要在添加至WeakOrderQueue链表中了。\n\n　　Bug产生的场景如下如所示：\n\n![image.png](/assets/53c6380455754787a12800dbf1e48a06tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-0takv3w.awebp)\n\n　　​**在第二种情况下，Netty还有一个重要的场景没有考虑到，会导致内存泄露**​！！\n\n　　什么场景呢？大家再来回顾下池化对象与对象池之间的引用关系图：\n\n![image.png](/assets/f43dc00e2347458c876f15dae66f23d4tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-lapokvs.awebp)\n\n　　这里我们看到池化对象会引用DefaultHandler，而DefaultHandler又强引用了Stack。于是就形成了这样一条引用链：\n\n![image.png](/assets/c2b0e2f9f93449e7b86ef71e2bac35e9tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-8xtfk94.awebp)\n\n　　而池化对象是对外暴露的，用户可能在某个地方一直引用着这个池化对象，如果创建线程挂掉，并被GC回收之后，那么其在对象池中对应的Stack也应该被回收，因为Stack里保存的回收对象将再也不会被用到了。但是因为这条引用链的存在，导致Stack无法被GC回收从而造成内存泄露！\n\n## 11.2 笔者反手一个PR，修复这个Bug!\n\n　　现在Bug产生的原因和造成的影响，笔者为大家已经分析清楚了，那么接下来的解决方案就变得很简单了。\n\n　　笔者先向Netty社区提了一个 Issue11864 来说明这个问题。\n\n> Issue11864 : [github.com/netty/netty…](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fnetty%2Fnetty%2Fissues%2F11864 \"https://github.com/netty/netty/issues/11864\")\n\n　　然后直接提了 PR11865 来修复这个Bug。\n\n> PR : [github.com/netty/netty…](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fnetty%2Fnetty%2Fpull%2F11865 \"https://github.com/netty/netty/pull/11865\")\n\n　　PR中主要的修改点分为以下两点：\n\n1. 笔者在修复方案中觉得在这里应该尽早处理掉 `threadRef.get()  == null`​ 的情况，因为创建线程已经死掉，此时在为创建线程回收对象已经没有任何意义了，这种情况直接 return 掉就好。\n2. 由于池化对象强引用到了其创建线程对应的Stack，当创建线程挂掉之后，我们需要解除这个引用链 `item.stack = null`​，保证Stack最终可以被GC回收。\n\n　　以下代码为笔者提交的PR中的修复方案，主要增加了对 `threadRef.get()  == null`​ 情况的处理，并添加了详细注释。\n\n```java\n        void push(DefaultHandle<?> item) {\n            Thread currentThread = Thread.currentThread();\n            if (threadRef.get() == currentThread) {\n                pushNow(item);\n            } else if (threadRef.get() == null) {\n                // when the thread that belonged to the Stack was died or GC'ed，\n                // There is no need to add this item to WeakOrderQueue-linked-list which belonged to the Stack any more\n                item.stack = null;\n            } else {\n                pushLater(item, currentThread);\n            }\n        }\n```\n\n## 11.3 PR的后续\n\n　　当笔者提交了 PR11865之后，得到了相关作者如下回复。\n\n![image.png](/assets/84c1132caafa47e1a56f670b0ac349aetplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-czmjytj.awebp)\n\n　　巧合的是Netty也意识到了对象池这块的问题，Netty最近也正在重构 Recycler 这一块，因为Recycler整体设计的还是比较复杂的，这从我们这篇源码解析的文章中也可以看的出来，Recycler的复杂性在于它的使用场景混合了**并发**以及与​**GC相关的交互**​，这些相关的问题都比较难以定位，所以Netty决定将对象池这一块用一种更加容易被理解的方式重构掉。\n\n　　相关的重构内容大家可以看作者的这个commit。\n\n> 重构commit：[github.com/netty/netty…](https://github.com/netty/netty/commit/28b9834612638ffec4948c0c650d04f766f20690)\n\n　　重构后的Recycler对象池在**4.1.71.Final**版本已经发布。笔者后续也会为大家安排一篇重构后的Recycler对象池源码解析，但是本文还是聚焦于**4.1.71.Final**之前版本的对象池介绍，虽然被重构了，但是这里也有很多的设计思想和多线程程序设计细节非常值得我们学习！\n\n　　在**4.1.71.Final**版本发布之后，笔者想的是后面抽空看下重构后的对象池实现，哈哈，只要谓语动词出现—— ”想的是.....“ 类似这样的句式，估计就没有以后了，哈哈。笔者还是大意了，这个 Issue11864 : [github.com/netty/netty…](https://github.com/netty/netty/issues/11864) 在过了几个月之后在社区里又被讨论了起来。有人发现在**4.1.71.Final**对象池重构后的版本中笔者提到的这些问题还是存在的。\n\n　　于是作者 chrisvest 又 提了一个 PR11996 最终在 **4.1.74.Final**版本中修复了笔者提的这个 Issue11864。\n\n> PR11996 ：[github.com/netty/netty…](https://github.com/netty/netty/pull/11996)\n\n> 随口提一句，这个大牛 chrisvest 是大名鼎鼎的图数据库 Neo4j 的核心commitor，同时也是Netty Buffer相关API的设计者。\n\n　　这里笔者将这个Bug在 **4.1.74.Final** 版本中的最终修复方案和大家说明一下，收个尾。\n\n1. 首先 chrisvest 大牛 认为 当创建线程挂掉的时候，我们可以在threadLocal的 onRemoval方法中将创建线程对应的LocalPool里边用于存放回收对象的pooledHandles 直接置为 null。这里的语义是标记LocalPool已经死掉了，不会再继续使用。\n\n> 在重构后的版本中引入了 LocalPool 来代替我们前边介绍的Stack。LocalPool中的pooledHandles大家可以简单认为类似Stack中数组栈的功能。\n\n```java\npublic abstract class Recycler<T> {\n\n    private final FastThreadLocal<LocalPool<T>> threadLocal = new FastThreadLocal<LocalPool<T>>() {\n        @Override\n        protected LocalPool<T> initialValue() {\n            return new LocalPool<T>(maxCapacityPerThread, interval, chunkSize);\n        }\n\n        @Override\n        protected void onRemoval(LocalPool<T> value) throws Exception {\n            //删除LocalPool\n            super.onRemoval(value);\n            MessagePassingQueue<DefaultHandle<T>> handles = value.pooledHandles;\n            //pooledHandles 置为 null，取消引用\n            value.pooledHandles = null;\n            //清除LocalPool中保存的回收对象\n            handles.clear();\n        }\n    };\n\n}\n```\n\n2. 在多线程回收对象的时候，会首先判断该回收对象对应的LocalPool里的pooledHandles是否已经被清理变为不可用状态。如果是的话就停止回收。\n\n```java\nprivate static final class LocalPool<T> {\n    //保证可见性\n    private volatile MessagePassingQueue<DefaultHandle<T>> pooledHandles;\n\n     void release(DefaultHandle<T> handle) {\n            MessagePassingQueue<DefaultHandle<T>> handles = pooledHandles;\n            handle.toAvailable();\n            if (handles != null) {\n                handles.relaxedOffer(handle);\n            }\n        }\n}\n```\n\n　　通过以上两个措施 就保证了 当创建线程被GC掉之后，它对应的 在对象池中的回收缓存LocalPool（类比Stack）不会出现内存泄露，同时保证了多线程不在将回收对象至已经被清理的LocalPool中。\n\n　　好了，这一块的Bug修改我们介绍完了，我们继续多线程回收对象主流程的介绍：\n\n### 11.4 创建线程直接回收对象\n\n```java\n       private void pushNow(DefaultHandle<?> item) {\n            //池化对象被回收前 recycleId = lastRecycleId = 0\n            //如果其中之一不为0 说明已经被回收了\n            if ((item.recycleId | item.lastRecycledId) != 0) {\n                throw new IllegalStateException(\"recycled already\");\n            }\n\n            //此处是由创建线程回收，则将池化对象的recycleId与lastRecycleId设置为创建线程Id-OWN_THREAD_ID\n            //注意这里的OWN_THREAD_ID是一个固定的值，是因为这里的视角是池化对象的视角，只需要区分创建线程和非创建线程即可。\n            //对于一个池化对象来说创建线程只有一个 所以用一个固定的OWN_THREAD_ID来表示创建线程Id\n            item.recycleId = item.lastRecycledId = OWN_THREAD_ID;\n\n            int size = this.size;\n            //如果当前池化对象的容量已经超过最大容量 则丢弃对象\n            //为了避免池化对象的急速膨胀，这里只会回收1/8的对象，剩下的对象都需要丢弃\n            if (size >= maxCapacity || dropHandle(item)) {\n                // Hit the maximum capacity or should drop - drop the possibly youngest object.\n                //丢弃对象\n                return;\n            }\n\n            //当前线程对应的stack容量已满但是还没超过最大容量限制，则对stack进行扩容\n            if (size == elements.length) {\n                //容量扩大两倍\n                elements = Arrays.copyOf(elements, min(size << 1, maxCapacity));\n            }\n            //将对象回收至当前stack中\n            elements[size] = item;\n            //更新当前stack的栈顶指针\n            this.size = size + 1;\n        }\n```\n\n* 首先需要判断该回收对象是否已经被回收了。`item.recycleId | item.lastRecycledId) != 0`​，这里任意Id只要不为0，说明该对象已经对回收了，则停止本次回收操作。\n* 当对象被创建线程回收时，设置回收Id：`item.recycleId = item.lastRecycledId = OWN_THREAD_ID`​。\n* 如果当前Stack已经达到最大容量则将对象丢弃。\n* 为了避免对象池不可控制的迅速膨胀，这里只会回收 1 / 8 的对象，剩下的对象都需要丢弃 dropHandle 。\n* 如果当前Stack容量已满但是还没超过最大容量限制，则对stack进行扩容。一次性扩容两倍但不能超过最大容量。\n* 最后将对象压入Stack结构中的数组栈中，完成对象的回收。\n\n### 11.5 回收线程间接回收对象\n\n![image.png](/assets/e87ee465af764c47866e1f69a22d065atplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-ms062uc.awebp)\n\n　　在Recycler对象池中，一个线程既可以是创建线程也可以是回收线程。\n\n　　比如上图中的 thread2 , thread3 , thread4 ...  这里的每一个线程既可以在对象池中创建对象，并将对象回收至自己对应的Stack结构里的数组栈中，此刻它们的角色为创建线程。比如图中的thread1。\n\n　　同时其他线程 比如图中的 thread2 , thread3 , thread4 ... 也可以为thread1回收由thread1创建的对象，将这些对象回收至thread1对应的Stack结构里的WeakOrderQueue链表中。此刻 thread2 , thread3 , thread4 ...  为回收线程。\n\n　　在之前介绍Recycler对象池的重要属性时，我们提到过 maxDelayedQueuesPerThread 属性。\n\n```java\npublic abstract class Recycler<T> {\n\n      //每个回收线程最多可以帮助多少个创建线程回收对象 默认：cpu核数 * 2\n      private static final int MAX_DELAYED_QUEUES_PER_THREAD;\n\n     //一个回收线程可帮助多少个创建线程回收对象\n      private final int maxDelayedQueuesPerThread;\n\n      private static final class Stack<T> {\n\n            // 当前线程可以帮助多少个线程回收其池化对象\n            private final int maxDelayedQueues;\n\n      }\n\n}\n\n```\n\n　　在Recycler对象池中，一个回收线程能够帮助多少个创建线程回收对象是有限制的，通过 maxDelayedQueuesPerThread属性 控制。\n\n　　​**那么在对象池中，一个回收线程如何存储为其他创建线程回收到的对象呢**​？\n\n![image.png](/assets/ec983e41a4b54a31a1f7f7c9ec511974tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-8ibqfew.awebp)\n\n　　如图中所示，我们站在回收线程的视角来看，在对象池中有一个 FastThreadLocal 类型的 DELAYED_RECYCLED 字段， DELAYED_RECYCLED 为每个回收线程保存了一个 WeakHashMap，正是这个回收线程持有的 WeakHashMap 结构中保存了该回收线程为每个创建线程回收的对象。\n\n　　WeakHashMap 结构中的 key 表示创建线程对应的 Stack 结构。意思是该回收线程为哪个创建线程回收对象。value 表示这个回收线程在创建线程中对应Stack结构里的WeakOrderQueue链表中对应的节点。大家在结合 《Recycler对象池.png》 这副图仔细体会下这个结构设计。\n\n```java\npublic abstract class Recycler<T> {\n\n    //实现跨线程回收的核心，这里保存的是当前线程为其他线程回收的对象（由其他线程创建的池化对象）\n    //key: 池化对象对应的创建线程stack  value: 当前线程代替该创建线程回收的池化对象 存放在weakOrderQueue中\n    //这里的value即是 创建线程对应stack中的weakOrderQueue链表中的节点（每个节点表示其他线程为当前创建线程回收的对象）\n    private static final FastThreadLocal<Map<Stack<?>, WeakOrderQueue>> DELAYED_RECYCLED =\n            new FastThreadLocal<Map<Stack<?>, WeakOrderQueue>>() {\n        @Override\n        protected Map<Stack<?>, WeakOrderQueue> initialValue() {\n            return new WeakHashMap<Stack<?>, WeakOrderQueue>();\n        }\n    };\n\n}\n```\n\n　　而这个WeakHashMap 的size即表示当前回收线程已经在为多少个创建线程回收对象了，size的值不能超过 maxDelayedQueuesPerThread 。\n\n　　​**这里为什么要用WeakHashMap呢**​?\n\n　　其实我们前边多少也提到过了，考虑到一种极端的情况就是当创建线程挂掉并且被GC回收之后，其实这个创建线程对应的Stack结构已经没有用了，存储在Stack结构中的池化对象永远不会再被使用到，此时回收线程完全就没有必要在为挂掉的创建线程回收对象了。而这个Stack结构如果没有任何引用链存在的话，随后也会被GC回收。那么这个Stack结构在WeakHashMap中对应的Entry也会被自动删除。如果这里不采用WeakHashMap，那么回收线程为该Stack回收的对象就会一直停留在回收线程中。\n\n　　介绍完这些背景知识，下面我们就来正式介绍下回收线程到底是如何帮助创建线程回收对象的：\n\n```java\n      private void pushLater(DefaultHandle<?> item, Thread thread) {\n            //maxDelayQueues == 0 表示不支持对象的跨线程回收\n            if (maxDelayedQueues == 0) {\n                //直接丢弃\n                return;\n            }\n          \n            //注意这里的视角切换，当前线程为回收线程\n            Map<Stack<?>, WeakOrderQueue> delayedRecycled = DELAYED_RECYCLED.get();\n            //获取当前回收对象属于的stack 由当前线程帮助其回收  注意这里是跨线程回收 当前线程并不是创建线程\n            WeakOrderQueue queue = delayedRecycled.get(this);\n            //queue == null 表示当前线程是第一次为该stack回收对象\n            if (queue == null) {\n                //maxDelayedQueues指示一个线程最多可以帮助多少个线程回收其创建的对象\n                //delayedRecycled.size()表示当前线程已经帮助多少个线程回收对象\n                if (delayedRecycled.size() >= maxDelayedQueues) {\n              \n                    //如果超过指定帮助线程个数，则停止为其创建WeakOrderQueue，停止为其回收对象\n                    //WeakOrderQueue.DUMMY这里是一个标识，后边遇到这个标识  就不会为其回收对象了\n                    delayedRecycled.put(this, WeakOrderQueue.DUMMY);\n                    return;\n                }\n \n                // 创建为回收线程对应的WeakOrderQueue节点以便保存当前线程为其回收的对象\n                if ((queue = newWeakOrderQueue(thread)) == null) {\n                    // 创建失败则丢弃对象\n                    return;\n                }\n                //在当前线程的threadLocal中建立 回收对象对应的stack 与 weakOrderQueue的对应关系\n                delayedRecycled.put(this, queue);\n            } else if (queue == WeakOrderQueue.DUMMY) {\n                // drop object\n                // 如果queue的值是WeakOrderQueue.DUMMY 表示当前已经超过了允许帮助的线程数 直接丢弃对象\n                return;\n            }\n\n            //当前线程为对象的创建线程回收对象  放入对应的weakOrderQueue中\n            queue.add(item);\n        }\n```\n\n1. 首先需要判断当前Recycler对象池是否支持跨线程回收。 `maxDelayedQueues == 0`​ 表示不支持对象的跨线程回收。\n2. 如果当前回收线程是第一次为该回收对象的创建线程进行回收，则需要为当前回收线程在对象的创建线程对应Stack结构中创建对应的WeakOrderQueue节点。（​**这里正是多线程无锁化回收对象的核心所在**​）。当然创建之前需要判断是否超过了可帮助创建线程的个数 maxDelayedQueues 。\n3. 如果当前回收线程帮助的创建线程个数已经超过了 maxDelayedQueues 限制，则向对应的 WeakHashMap 塞入一个空的 WeakOrderQueue节点 DUMMY，后续如果遇到 WeakOrderQueue 节点是 DUMMY 实例则丢弃对象，放弃回收。\n\n```java\n private static final class WeakOrderQueue extends WeakReference<Thread> {\n        //作为一个标识，遇到DUMMY实例，则直接丢弃回收对象\n        static final WeakOrderQueue DUMMY = new WeakOrderQueue();\n\n}\n```\n\n4. 如果当前回收线程帮助的创建线程个数还没有超过 maxDelayedQueues 限制，则通过 `stack#newWeakOrderQueue`​ 为当前回收线程在回收对象对应Stack结构中创建相应的WeakOrderQueue节点。并在回收线程持有的WeakHashMap中建立Stack与回收线程对应的WeakOrderQueue节点的关联关系。\n5. 最终由回收线程将对象回收至其创建线程对应的Stack结构中。（将回收对象添加至回收线程对应的WeakOrderQueue节点中，完成多线程无锁化回收）\n\n### 11.6  为回收线程创建对应的WeakOrderQueue节点\n\n　　上小节提到，当回收线程第一次为创建线程回收对象的时候，需要在创建线程对应Stack结构中的WeakOrderQueue链表中创建与回收线程对应的WeakOrderQueue节点。\n\n```java\n   private static final class Stack<T> {\n\n         private WeakOrderQueue newWeakOrderQueue(Thread thread) {\n              return WeakOrderQueue.newQueue(this, thread);\n        }\n   }\n```\n\n![image.png](/assets/13ba4ffef43045ba8ed42101aefd3d72tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-i9veirg.awebp)\n\n```java\nprivate static final class WeakOrderQueue extends WeakReference<Thread> {\n\n        static WeakOrderQueue newQueue(Stack<?> stack, Thread thread) {\n  \n            // link是weakOrderQueue中存储回收对象的最小结构，此处是为接下来要创建的Link预订空间容量\n            // 如果stack指定的availableSharedCapacity 小于 LINK_CAPACITY大小，则分配失败\n            if (!Head.reserveSpaceForLink(stack.availableSharedCapacity)) {\n                return null;\n            }\n\n            //如果还够容量来分配一个link那么就创建weakOrderQueue\n            final WeakOrderQueue queue = new WeakOrderQueue(stack, thread);\n\n            // 向stack中的weakOrderQueue链表中添加当前回收线程对应的weakOrderQueue节点（始终在头结点处添加节点 ）\n            // 此处向stack中添加weakOrderQueue节点的操作被移到WeakOrderQueue构造器之外的目的是防止WeakOrderQueue.this指针\n            // 逃逸避免被其他线程在其构造的过程中访问\n            stack.setHead(queue);\n\n            return queue;\n        }\n\n}\n```\n\n　　在前边介绍WeakOrderQueue的结构的时候，我们提到WeakOrderQueue结构内部其实一个由Link节点组成的链表。WeakOrderQueue在初始状态下是只包含一个Link节点的链表。\n\n　　所有在创建WeakOrderQueue结构的时候需要同时为其创建一个Link节点。而这些Link节点正是真正保存回收线程所回收到的对象的地方。\n\n　　而对于一个创建线程来说它的所有回收线程能够为其回收对象的总量是被availableSharedCapacity 限制的，每创建一个Link节点，它的值就减少一个LINK_CAPACITY ，每释放一个Link节点，它的值就增加一个LINK_CAPACITY 。这样就能保证所有回收线程的回收总量不会超过 availableSharedCapacity 的限制。\n\n　　所以在为WeakOrderQueue结构创建首个Link节点时，需要判断**当前所有回收线程回收的对象总量**是否已经超过了 availableSharedCapacity 。如果容量还够回收一个Link大小的对象，则开始创建WeakOrderQueue结构。\n\n　　如果当前回收容量已经超过availableSharedCapacity或者不足回收一个Link大小的对象，则停止创建WeakOrderQueue节点，回收流程终止。不在对该回收对象进行回收。\n\n```java\n            //此处目的是为接下来要创建的link预留空间容量\n            static boolean reserveSpaceForLink(AtomicInteger availableSharedCapacity) {\n                for (;;) {\n                    //获取stack中允许异线程回收对象的总容量（异线程还能为该stack收集多少对象）\n                    int available = availableSharedCapacity.get();\n                    //当availbale可供回收容量小于一个Link时，说明异线程回收对象已经达到上限，不能在为stack回收对象了\n                    if (available < LINK_CAPACITY) {\n                        return false;\n                    }\n                    //为Link预留到一个Link的空间容量，更新availableSharedCapacity\n                    if (availableSharedCapacity.compareAndSet(available, available - LINK_CAPACITY)) {\n                        return true;\n                    }\n                }\n            }\n```\n\n　　这里的预订容量其实就是将 availableSharedCapacity 的值减去一个 LINK_CAPACITY 大小。其他回收线程会看到这个 availableSharedCapacity 容量的变化，方便决定是否继续为创建线程回收对象。\n\n　　当为WeakOrderQueue结构的首个Link节点预订容量成功后，就开始创建WeakOrderQueue节点。\n\n```java\n        //为了使stack进行GC,这里不会持有其所属stack的引用\n        private WeakOrderQueue(Stack<?> stack, Thread thread) {\n            //weakOrderQueue持有对应跨线程的弱引用\n            super(thread);\n            //创建尾结点\n            tail = new Link();\n\n            // 创建头结点  availableSharedCapacity = maxCapacity / maxSharedCapacityFactor\n            // 此时availableSharedCapacity的值已经变化了，减去了一个link的大小\n            head = new Head(stack.availableSharedCapacity);\n            head.link = tail;\n            interval = stack.delayedQueueInterval;\n            handleRecycleCount = interval; \n        }\n```\n\n　　当回收线程对应的WeakOrderQueue节点创建成功后，就将其插入到回收对象对应的Stack结构里的WeakOrderQueue链表中的头结点处。因为这里可能会涉及多个回收线程并发向WeakOrderQueue链表头结点处添加节点，所以更新Stack结构中WeakOrderQueue链表头结点的方法被设计成同步方法。这也是整个Recycler 对象池设计中，唯一的一个同步方法。\n\n```java\n       synchronized void setHead(WeakOrderQueue queue) {\n            //始终在weakOrderQueue链表头结点插入新的queue（其他线程收集的由本线程创建的对象）\n            queue.setNext(head);\n            head = queue;\n        }\n```\n\n![image.png](/assets/523b778404c140a29621295d079be9f8tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-nuriy5k.awebp)\n\n### 11.7 向WeakOrderQueue节点中添加回收对象\n\n　　终于的终于我们到了多线程回收对象的最后一步了，本篇文章到这里也接近尾声了，大家在坚持一下。\n\n　　这里要做的事情就是，将回收对象添加到回收线程对应的WeakOrderQueue节点中，Netty会在Link链表的尾结点处添加回收对象，如果尾结点容量已满，就继续新创建一个Link。将回收对象添加到新的Link节点中。\n\n```java\n      void add(DefaultHandle<?> handle) {\n            //将handler中的lastRecycledId标记为当前weakOrderQueue中的Id,一个stack和一个回收线程对应一个weakOrderQueue节点\n            //表示该池化对象 最近的一次是被当前回收线程回收的。\n            handle.lastRecycledId = id;\n\n            // 控制异线程回收频率 只回收1/8的对象\n            // 这里需要关注的细节是其实在scavengeSome方法中将weakOrderQueue中的待回收对象转移到创建线程的stack中时，Netty也会做回收频率的限制\n            // 这里在回收线程回收的时候也会控制回收频率（总体控制两次）netty认为越早的做回收频率控制越好 这样可以避免weakOrderQueue中的容量迅速的增长从而失去控制\n            if (handleRecycleCount < interval) {\n                handleRecycleCount++;\n                // Drop the item to prevent recycling to aggressive.\n                return;\n            }\n            handleRecycleCount = 0;\n\n            //从尾部link节点开始添加新的回收对象\n            Link tail = this.tail;\n            int writeIndex;\n\n            //如果当前尾部link节点容量已满，就需要创建新的link节点\n            if ((writeIndex = tail.get()) == LINK_CAPACITY) {\n                //创建新的Link节点\n                Link link = head.newLink();\n                //如果availableSharedCapacity的容量不够了，则无法创建Link。丢弃待回收对象\n                if (link == null) {\n                    // 丢弃对象\n                    return;\n                }\n                // We allocate a Link so reserve the space\n                //更新尾结点\n                this.tail = tail = tail.next = link;\n\n                writeIndex = tail.get();\n            }\n\n            //将回收对象handler放入尾部link节点中\n            tail.elements[writeIndex] = handle;\n            //这里将stack置为null，是为了方便stack被回收。\n            //如果Stack不再使用，期望被GC回收，发现handle中还持有stack的引用，那么就无法被GC回收，从而造成内存泄漏\n            //在从对象池中再次取出该对象时，stack还会被重新赋予\n            handle.stack = null;\n            //注意这里用lazySet来延迟更新writeIndex。只有当writeIndex更新之后，在创建线程中才可以看到该待回收对象\n            //保证线程最终可见而不保证立即可见的原因就是 其实这里Netty还是为了性能考虑避免执行内存屏障指令的开销。\n            //况且这里也并不需要考虑线程的可见性，当创建线程调用scavengeSome从weakOrderQueue链表中回收对象时，看不到当前节点weakOrderQueue\n            //新添加的对象也没关系，因为是多线程一起回收，所以继续找下一个节点就好。及时全没看到，大不了就在创建一个对象。主要还是为了提高weakOrderQueue的写入性能\n            tail.lazySet(writeIndex + 1);\n        }\n```\n\n1. 首先第一步就要设置回收对象DefaultHandler中的lastRecycledId ，将其设置为该回收线程Id，表示该回收对象最近一次是由当前回收线程回收的。此时的DefaultHandler中 `recycleId != lastRecycledId `​，对象处于半回收状态。\n2. 控制回收线程的回收频率（只回收 1 / 8 的对象），大家是否还记得我们在《9.5 转移回收对象》小节中介绍 `stack#scavengeSome方法`​ 的时候，在创建线程从Stack中的WeakOrderQueue链表中转移对象到数组栈中的时候，也会被回收频率进行控制，只转移 1 / 8 的对象。所以这里我们可以看到​**回收频率的控制在多线程回收对象的时候会控制两次**​，netty认为越早做回收频率控制越好这样可以避免weakOrderQueue中的容量迅速的增长从而失去控制。\n3. 在WeakOrderQueue结构中，当我们向Link链表添加回收对象时，都会向Link链表的尾结点中添加回收对象，如果当前尾结点容量已经满了 `writeIndex = tail.get()) == LINK_CAPACITY`​ ，我们就需要新创建一个Link节点，并将tail指针指向新的Link节点更新尾结点。最后将回收对象回收至新的尾结点中。当然我们要考虑到 availableSharedCapacity 容量的限制，如果容量不够了，就不能在新建Link节点，直接将回收对象丢弃，停止回收。\n\n```java\n    private static final class Head {\n\n             Link newLink() {\n                  //此处的availableSharedCapacity可能已经被多个回收线程改变，因为availableSharedCapacity是用来控制回收线程回收的总容量限制\n                  //每个回收线程再回收对象时都需要更新availableSharedCapacity\n                  return reserveSpaceForLink(availableSharedCapacity) ? new Link() : null;\n             }\n\n            //此处目的是为接下来要创建的link预留空间容量\n            static boolean reserveSpaceForLink(AtomicInteger availableSharedCapacity) {\n                for (;;) {\n                    //获取stack中允许异线程回收对象的总容量（异线程还能为该stack收集多少对象）\n                    int available = availableSharedCapacity.get();\n                    //当availbale可供回收容量小于一个Link时，说明异线程回收对象已经达到上限，不能在为stack回收对象了\n                    if (available < LINK_CAPACITY) {\n                        return false;\n                    }\n                    //为Link预留到一个Link的空间容量，更新availableSharedCapacity\n                    if (availableSharedCapacity.compareAndSet(available, available - LINK_CAPACITY)) {\n                        return true;\n                    }\n                }\n            }\n    }\n```\n\n　　到这里Recycler对象池的整个**多线程无锁化回收对象**的流程笔者就为大家介绍完了。\n\n　　但是这里还有两个点，笔者想要和大家再强调一下：\n\n　　​**第一：为什么这里会将handle.stack设置为null**​?\n\n　　不知大家还记不记得我们在介绍 `stack#scavengeSome方法`​ 的时候专门提到，在创建线程遍历WeakOrderQueue链表将链表中的待回收对象转移至stack中的数组栈时，会将待回收对象的DefaultHandler持有的stack重新设置为其创建线程对应的stack。\n\n```java\nboolean transfer(Stack<?> dst) {\n\n      .................省略..............\n\n      //重新为defaultHandler设置其所属stack(初始创建该handler的线程对应的stack)\n      //该defaultHandler在被回收对象回收的时候，会将其stack置为null，防止极端情况下，创建线程挂掉，对应stack无法被GC\n      element.stack = dst;\n\n      .................省略..............\n}\n```\n\n　　而这里在回收线程向WeakOrderQueue节点添加回收对象时先将 handle.stack设置为 null，而在转移回收对象时又将 handle.stack 设置回来，这不是多此一举吗？\n\n　　其实并不是多此一举，这样设计是非常有必要的，我们假设一种极端的情况，当创建线程挂掉并被GC回收之后，其实stack中存储的回收对象已经不可能在被使用到了，stack应该也被回收掉。但是如果这里回收线程在回收的时候不将对象持有的stack设置为null的话，直接添加到了WeakOrderQueue节点中，当创建被GC掉的时候，由于这条引用链的存在导致对应stack永远不会被GC掉，造成内存泄露。\n\n> 所以笔者在本文中多次强调，当我们在设计比较复杂的程序结构时，对于对象之间的引用关系，一定要时刻保持清晰的认识，防止内存泄露。\n\n　　​**第二：为什么最后使用lazySet来更新尾结点的writeIndex**​？\n\n　　当我们向Link链表的尾结点添加完回收对象之后，在更新尾结点的writeIndex时，使用到了延时更新，而延时更新并不会保证多线程的可见性，如果此时创建线程正在转移对象，那么将不会看到新添加进来的回收对象了。\n\n　　而事实上，我们这里并不需要保证线程之间的实时可见性，只需要保证最终可见性即可。\n\n　　确实在当创建线程转移对象的时候可能并不会看到刚刚被回收线程新添加进来的回收对象，看不到没关系，创建线程大不了在本次转移中不回收它不就完了么。因为只要创建线程Stack结构中的数组栈为空，创建线程就会从WeakOrderQueue链表中转移对象，以后会有很多次机会来WeakOrderQueu链表中转移对象，什么时候看见了，什么时候转移它。并不需要实时性。退一万步讲，即使全部看不到，大不了创建线程直接创建一个对象返回就行了。\n\n　　而如果这里要保证线程之间的实时可见性，在更新尾结点的writeIndex的时候就不得不插入 LOCK 前缀内存屏障指令保证多线程之间的实时可见性，而执行内存屏障指令是需要开销的，所以​**为了保证WeakOrderQueue的写入性能**​，Netty这里选择了只保证最终可见性而不保证实时可见性。\n\n---\n\n## 总结\n\n　　到这里关于Recycler对象池的整个设计与源码实现，笔者就为大家详细的剖析完毕了，在剖析的过程中，我们提炼出了很多多线程并发程序的设计要点和注意事项。大家可以在日常开发工作中多多体会并实践。\n\n　　虽然本文介绍的Recycler对象池整体设计将会在**4.1.71.Final**版本被重构，但是在当前版本Recycler对象池的设计和实现中，我们还是可以学习到很多东西的。\n\n　　笔者真心十分佩服能够耐心看到这里的大家，不知不觉已经唠叨了三万多字了，谢谢大家的观看~~，大家记得晚餐时给自己加餐个鸡腿奖励一下自己，哈哈！！\n","source":"_posts/20250501/7.md","raw":"---\ntitle: Netty Recycler\ndate: 2025-05-01 16:57:07\nlastmod: 2025-05-01 16:57:07\ntags: [Recycler,Netty]\ncategory: Netty\n---\n\n\n\n# Recycler\n\n---\n> 转载          bin的技术小屋              \n> 本系列Netty源码解析文章基于 **4.1.56.Final**版本\n\n## 1. 池化思想的应用\n\n　　在我们日常开发工作中我们经常会遇到各种池化技术的设计思想，比如连接池，内存池，对象池，还有我们在业务开发过程中经常会缓存一些业务计算结果数据这也同样运用到了池化技术的设计思想，我们可以叫它为结果池。\n\n　　池化技术的应用场景就是当一个对象的创建和销毁需要付出比较大的性能开销时，我们就需要将这些重量级对象放在一个池子里管理，当需要时直接从池子里获取避免重复创建和销毁的开销从而达到了复用的效果。\n\n　　比如连接池里面保存管理的都是一些网络连接对象，这些对象创建和销毁的代价比较大。通过连接池将这些重量级的网络连接对象统一管理起来，业务线程可以直接复用，避免了重新创建，释放连接的性能开销以及等待时间。\n\n　　还有我们在日常开发中遇到的一些计算逻辑复杂的业务，我们通常会先从数据库中查询数据，然后经过复杂的计算得到结果，为了避免下次在重复计算，我们会将计算结果放入缓存中，我们可以称做结果池。也是一种池化思想。\n\n　　再比如我们在[《Netty如何高效接收网络数据》](https://link.juejin.cn/?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg2MzU3Mjc3Ng%3D%3D%26mid%3D2247484244%26idx%3D1%26sn%3D831060fc38caa201d69f87305de7f86a%26chksm%3Dce77c513f9004c05b48f849ff99997d6d7252453135ae856a029137b88aa70b8e046013d596e%23rd \"https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&mid=2247484244&idx=1&sn=831060fc38caa201d69f87305de7f86a&chksm=ce77c513f9004c05b48f849ff99997d6d7252453135ae856a029137b88aa70b8e046013d596e#rd\")一文中提到的内存池，为了避免不必要的数据拷贝以及JVM垃圾回收对性能的影响，Netty 选择使用堆外内存存储网络通信数据。在 Netty 申请堆外内存之前，首先会在 JVM 堆中创建一个用于引用 native memory 的引用对象 DirectByteBuffer ，随后会使用 native 方法 `unsafe.allocateMemory`​ 通过底层 `malloc`​ 系统调用申请一块堆外内存。\n\n　　这里就涉及到到两个重要开销：\n\n* 在 JVM 堆中创建对象 DirectByteBuffer ，并为该对象申请分配 JVM 堆内存。\n* 通过 `malloc`​ 系统调用向操作系统申请堆外内存，然后被 DirectByteBuffer 引用。但是堆外内存的申请和释放远比堆内内存申请和释放的开销要大很多。\n\n　　而在 Netty 面对的高并发网络通信场景下，申请堆外内存是一个非常频繁的操作，基于以上提到的两个重要性能开销，这种大量频繁的内存申请释放操作对程序的性能影响是巨大的，所以 Netty 就引入了内存池对内存相关的操作进行统一的管理。\n\n## 2. 对象池简介\n\n　　以上内容的介绍就是池化思想的应用以及它所解决的问题，本文我们的主题是介绍对象池，对象池的引入是为了在需要大量创建对象以及销毁对象的场景下，将对象进行池化以达到复用池中对象，避免大量地重复创建对象以及销毁对象的性能开销，\n\n　　前边我们在提到内存池的时候说到，在 Netty 所要面对的高并发网络通信场景下，需要大量的申请堆外内存用来存储通信数据。在 Netty 中，我们通过 PooledDirectByteBuf 对象来引用堆外内存。所以 Netty 在处理网络 IO 的时候是需要大量频繁的创建 PooledDirectByteBuf 对象。\n\n　　为了避免在高并发的场景下大量的创建对象所引来的性能开销，我们可以引入对象池来池化创建出来的 PooledDirectByteBuf 对象，需要用的时候直接从对象池中获取，用完之后在回收到对象池中。\n\n　　另外这里提前向大家透露一点的是我们下篇文章中即将要介绍的 Netty 发送数据流程涉及到的对象池的应用。我们都知道 Netty 是一个异步事件驱动的高性能网络框架，当在业务线程中处理完业务逻辑准备响应业务结果到客户端的时候，我们会向对应 channel 写入业务结果，此时业务线程会立即返回，这是一个异步的过程。\n\n　　原因是在底层实现中，Netty 会将用户的响应结果数据暂时写入到每个 Channel 特有的一个发送缓冲队列 ChannelOutboundBuffer 中，也就是说这个 ChannelOutboundBuffer 缓存着 Channel 中的待发送数据。最终会通过 flush 方法，将 ChannelOutboundBuffer 中的这些待发送数据写入到底层 Socket 中，从而发送给客户端。\n\n　　而这个发送缓冲队列 ChannelOutboundBuffer 中的队列元素是一个 Entry 类型的，每次的写入操作需要创建一个 Entry 对象来包裹发送数据，并将这个 Entry 对象缓存在发送缓冲队列 ChannelOutboundBuffer 中。\n\n> 这里大家只需要知道 ChannelOutboundBuffer 是个啥，它的大概作用，以及这个缓冲队列缓存的对象是 Entry 类型的就可以了，我们会在下篇文章为大家详细介绍，这里引出只是为了介绍对象池的应用场景。\n\n　　所以Netty在面对海量网络 IO 的场景下，必定会大量频繁地去创建 Entry 对象，那么每一次的网络 IO 都要重新创建这些对象，并且用完又要被垃圾回收掉这样无疑会大量增加 JVM 的负担以及 GC 的时间，这对于最求极致性能的 Netty 来说肯定是不可接受的。\n\n　　基于以上这几种情况，对象池被用来管理那些需要频繁创建使用的对象，在使用完后并不立即将它们释放，而是将它们在对象池中缓存起来，以供后续的应用程序重复使用，从而减少创建对象和释放对象的开销，进而改善应用程序的性能。\n\n　　从另一方面来看，对象池还可以将对象限制在一定的数量内从而可以有效减少应用程序在内存上的开销。\n\n---\n\n　　通过前边关于对象池的简要介绍之后，我想大家现在可能比较好奇这些对象在创建和回收的过程中到底需要哪些开销呢？\n\n　　接下来笔者就为大家介绍下这些开销方面的内容方便大家更加全面清晰地理解对象池。\n\n## 3. 对象在JVM中创建和回收开销\n\n### 3.1 对象的创建开销\n\n　　在 Java 程序中我们可以通过一个 new 关键字来创建对象，而当JVM遇到一条 new 的字节码指令后，会发生什么呢？\n\n1. 首先 JVM 要去检查 new 指令后面的参数也就是创建对象所属的 Java 类是否能够在方法区的常量池中定位到类的符号引用，进而检查这个符号引用所代表的类是否已经加载，解析，初始化过。如果没有，就需要先执行类的加载过程。\n2. 当通过类加载检查之后，就开始为对象分配内存，而对象所需内存大小其实在类加载完成后就已经确定了。JVM要做的事情就是将一块确定大小的内存区域从JVM堆中划分出来。\n\n> 关于如何确定对象所需内存大小，对这方面细节感兴趣的同学可以回看下笔者的[《对象在JVM中的内存布局》](https://link.juejin.cn/?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg2MzU3Mjc3Ng%3D%3D%26mid%3D2247484304%26idx%3D1%26sn%3D54bf0d07e69c5621c145afaece8f50d6%26chksm%3Dce77c5d7f9004cc1249a03dfd0fb12b7d75171f1b87acea1fa44bbb11ca374b6f42a66fa274d%23rd \"https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&mid=2247484304&idx=1&sn=54bf0d07e69c5621c145afaece8f50d6&chksm=ce77c5d7f9004cc1249a03dfd0fb12b7d75171f1b87acea1fa44bbb11ca374b6f42a66fa274d#rd\")这篇文章。\n\n3. 而在为对象划分堆中内存的时候又会根据JVM堆中内存是否规整，从而分为指针碰撞法和空闲列表法。而多线程同时创建对象在JVM中是非常常见的行为，所以在多线程并发创建对象的时候JVM又需要保证划分内存时的线程安全性。JVM需要对划分内存空间的动作进行同步处理（CAS  + 失败重试）。\n4. 而为了避免这种划分内存时的同步锁定，JVM提供了另外一种方式就是每个线程先预先向JVM堆申请一块内存（本地线程分配缓存-TLAB），这样当线程创建对象的时候，先是从自己的TLAB中为对象分配内存，当自己的TLAB用完时，才会去JVM堆中​**同步分配**​。 我们可以通过虚拟机参数`-XX:+UseTLAB`​开启TLAB（默认）。`-XX:-UseTLAB`​关闭TLAB。\n\n> 大家这里需要记住这种利用TLAB的分配方式，因为Netty中的对象池Recycler也是利用这种思想避免多线程获取对象的同步开销。\n\n5. 在为对象分配好内存之后，JVM会将这块内存初始化为零值。这样就可以保证对象中的实例字段不赋初始值就可以直接使用，其值为字段对应数据类型的零值。\n6. 设置对象头。包括设置MarkWord中的对象运行时信息。以及通过类型指针引用关联到类的元数据信息。这些内容我们在[《对象在JVM中的内存布局》](https://link.juejin.cn/?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg2MzU3Mjc3Ng%3D%3D%26mid%3D2247484304%26idx%3D1%26sn%3D54bf0d07e69c5621c145afaece8f50d6%26chksm%3Dce77c5d7f9004cc1249a03dfd0fb12b7d75171f1b87acea1fa44bbb11ca374b6f42a66fa274d%23rd \"https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&mid=2247484304&idx=1&sn=54bf0d07e69c5621c145afaece8f50d6&chksm=ce77c5d7f9004cc1249a03dfd0fb12b7d75171f1b87acea1fa44bbb11ca374b6f42a66fa274d#rd\")一文中都有提到过，大家还记得吗？\n7. 执行构造函数。这样一个真正可用的对象就被创建出来了。\n\n### 3.2 对象的回收开销\n\n* JVM中的垃圾回收器通过可达性分析来探索所有Java存活对象，从GC ROOTS出发边标记边探索所有对象的引用链，以判断对象是否存活。\n* 垃圾回收器在垃圾回收的过程中发生的GC PAUSE也就是STOP THE WORLD。这里详细的垃圾回收过程我们就不展开了，主要是为了指明在对象回收时最主要的两个开销点。\n\n---\n\n　　然而在高并发的网络IO处理场景下，这些单个对象的创建和回收开销会被无限放大，于是Netty引入了一个轻量级的对象池 Recycler 来负责将这些需要频繁创建的对象进行池化，统一分配，回收管理。\n\n　　在为大家详细介绍对象池 Recycler 的实现之前，笔者想先从对象池的使用上先让大家可以直观地感受一下 Recycler 对外提供的功能入口。\n\n## 4. 对象池Recycler的使用\n\n　　这里我们直接看下Netty源码中是如何使用Recycler对象池的，首先我们来看下对象池在 PooledDirectByteBuf 类中是如何使用的。\n\n> 大家这里先不用去管这个PooledDirectByteBuf类是干吗的，只需要明白这个类是会被频繁创建的，我们这里主要是演示对象池的使用。\n\n![image.png](/assets/ec623644e43b4c56bf1110c9cfc74bc8tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-1zakfmq.awebp)\n\n### 4.1 对象池在PooledDirectByteBuf类中的使用\n\n```java\nfinal class PooledDirectByteBuf extends PooledByteBuf<ByteBuffer> {\n    //创建对象池\n    private static final ObjectPool<PooledDirectByteBuf> RECYCLER = ObjectPool.newPool(\n            new ObjectCreator<PooledDirectByteBuf>() {\n        @Override\n        public PooledDirectByteBuf newObject(Handle<PooledDirectByteBuf> handle) {\n            return new PooledDirectByteBuf(handle, 0);\n        }\n    });\n\n    //对象在对象池中的回收句柄\n    private final Handle<PooledByteBuf<T>> recyclerHandle;\n\n    static PooledDirectByteBuf newInstance(int maxCapacity) {\n        //从对象池中获取对象\n        PooledDirectByteBuf buf = RECYCLER.get();\n        buf.reuse(maxCapacity);\n        return buf;\n    }\n  \n    private void recycle() {\n         //回收对象\n        recyclerHandle.recycle(this);\n    }\n\n    ................省略和对象池无关的代码..................\n}\n```\n\n　　前边我们提到在Netty中需要大量频繁的创建PooledDirectByteBuf对象，为了避免在高并发场景下频繁创建对象的开销从而引入了对象池来统一管理PooledDirectByteBuf对象。\n\n　　Netty中每个被池化的对象中都会引用对象池的实例`ObjectPool  RECYCLER `​，这个对象池的实例就是专门用来分配和管理被池化对象的。\n\n　　这里我们创建出来的对象池是专门用来管理PooledDirectByteBuf对象的（通过泛型指定对象池需要管理的具体对象）。泛型类`ObjectPool<T>`​是Netty为对象池设计的一个顶层抽象。对象池的行为功能均定义在这个泛型抽象类中。我们可以通过 ObjectPool#newPool 方法创建指定的对象池。其参数 ObjectCreator 接口用来定义创建池化对象的行为。当对象池中需要创建新对象时，就会调用该接口方法 ObjectCreatornewObject 来创建对象。\n\n　　其中每个池化对象中都会包含一个recyclerHandle，这个recyclerHandle是池化对象在对象池中的句柄。里边封装了和对象池相关的一些行为和信息，recyclerHandle是由对象池在创建对象后传递进来的。\n\n　　当我们需要PooledDirectByteBuf对象时，我们直接通过`RECYCLER.get()`​从PooledDirectByteBuf对象池中获取对象即可。\n\n　　当我们使用完毕后，直接调用PooledDirectByteBuf对象在对象池中的句柄`recyclerHandle.recycle(this) `​把对象回收到对象池中。\n\n### 4.2 对象池在Channel写入缓冲队列中的使用\n\n　　前边提到，每个Channel都会有一个独立的写入缓冲队列ChannelOutboundBuffer，用来暂时存储用户的待发送数据。这样用户可以在调用channel的write方法之后立马返回，实现异步发送流程。\n\n　　在发送数据时，Channel首先会将用户要发送的数据缓存在自己的写缓存队列ChannelOutboundBuffer中。而ChannelOutboundBuffer中的元素类型为Entry。在Netty中会大量频繁的创建Entry对象。所以Entry对象同样也需要被对象池管理起来。\n\n　　在上小节介绍PooledDirectByteBuf对象池的过程中，我想大家已经对对象池的使用套路已经有了大概的了解。这里我们借助Entry对象池将使用步骤总结如下：\n\n#### 创建对象池\n\n```java\n   static final class Entry {\n\n        private static final ObjectPool<Entry> RECYCLER = ObjectPool.newPool(new ObjectCreator<Entry>() {\n            @Override\n            public Entry newObject(Handle<Entry> handle) {\n                return new Entry(handle);\n            }\n        });\n\n        //recyclerHandle用于回收对象\n        private  Handle<Entry> handle;\n      \n        private Entry(Handle<Entry> handle) {\n            this.handle = handle;\n        }\n   }\n```\n\n　　前边我们介绍到每一个要被池化的对象都需要一个静态变量来引用其对应的对象池。\n\n```java\nstatic final ObjectPool<Entry> RECYCLER \n```\n\n　　匿名实现 ObjectCreator 接口来定义对象创建的行为方法。\n\n```java\n    public interface ObjectCreator<T> {\n        T newObject(Handle<T> handle);\n    }\n```\n\n　　通过`ObjectPool#newPool`​ 创建用于管理Entry对象的对象池。\n\n　　在对象池创建对象时，会为池化对象创建其在对象池中的句柄Handler，随后将Handler传入创建好的池化对象中。当对象使用完毕后，我们可以通过Handler来将对象回收至对象池中等待下次继续使用。\n\n#### 从对象池中获取对象\n\n　　由于Entry对象在设计上是被对象池管理的，所以不能对外提供public构造函数，无法在外面直接创建Entry对象。\n\n　　所以池化对象都会提供一个获取对象实例的 static 方法 newInstance。在该方法中通过`RECYCLER.get()`​从对象池中获取对象实例。\n\n```java\n      static Entry newInstance(Object msg, int size, long total, ChannelPromise promise) {\n            Entry entry = RECYCLER.get();\n          \n            .........省略无关代码..............\n\n            return entry;\n        }\n```\n\n#### 使用完毕回收对象\n\n　　池化对象都会提供一个 recycle 方法，当对象使用完毕后，调用该方法将对象回收进对象池中。\n\n```java\n        void recycle() {\n            next = null;\n            bufs = null;\n            buf = null;\n            msg = null;\n            promise = null;\n            progress = 0;\n            total = 0;\n            pendingSize = 0;\n            count = -1;\n            cancelled = false;\n            handle.recycle(this);\n        }\n```\n\n* 清空对象中的所有属性。\n* 通过对象中持有的对象池句柄Handler，将对象回收进对象池中。\n\n---\n\n　　从上边所列举的Netty中使用对象池的例子，我们可以直观的感受到对象池的使用非常简单。无非就是从对象池获取对象，将对象回收至对象池这两个核心步骤。\n\n　　同时我们也注意到池化对象的设计和普通对象是有所不同的，不过，我们只需要遵循本小节中所列举的几个步骤进行设计即可。\n\n## 5. Recycler总体设计\n\n　　Recycler对象池的设计还是比较复杂的但是却很精妙，所以笔者这里继续采用总 - 分 - 总的结构来为大家介绍对象池的设计与实现。\n\n　　一开始我们先不要去追求太过细节的内容，先要从总体上摸清楚对象池的设计架构，以及各个功能模块之间的关联。\n\n　　当我们从整体上理解了对象池的设计架构后，笔者后面会分模块来各个击破它的实现细节。\n\n　　在理清楚各个模块的实现细节之后，笔者将在从细节着手再次将对象池的整体设计架构为大家串联起来。\n\n　　我们按照这个思路先来看一下Recycler对象池的总体架构设计图，从整体直观上来感受下它的设计，以及包含的一些重要模块。\n\n![image.png](/assets/d8bdbd9d79814646999637ffc46281cbtplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-5lz8huo.awebp)\n\n### 5.1 多线程获取对象无锁化设计\n\n　　首先我们从外部整体来看，对象池对于我们来说它就是一个存储对象的池子，当我们需要对象时会从这个池子里直接获取，用完对象时在把对象归还回池子中方便下一次重复使用。\n\n　　但我们俯瞰整个对象池的设计架构时，我们发现整个设计还是比较复杂其中蕴含了不少精妙的细节。\n\n　　对象池中最重要的两个结构分别是 Stack 和 WeakOrderQueue。\n\n　　Stack 中包含一个用数组实现的栈结构（图中绿色部分），这个栈结构正是对象池中真正用于存储池化对象的地方，我们每次从对象池中获取对象都会从这个栈结构中弹出栈顶元素。同样我们每次将使用完的对象归还到对象池中也是将对象压入这个栈结构中。\n\n　　​**这里有一个精妙的设计**​，我们从图中可以看到每个线程都会拥有一个属于自己的Stack。在我们介绍《对象创建的开销》这一小节内容时，提到为了避免多线程并发申请内存时的同步锁定开销，JVM为每个线程预先申请了一块内存（TLAB）,这样当线程创建对象时都是从自己的TLAB中为对象分配内存。从而避免了多线程之间的同步竞争。\n\n　　同样当多线程并发从对象池中获取对象时, 如果整个对象池只有一个Stack结构的话，为了保证多线程获取对象的线程安全性，我们只能同步地来访问这个Stack，这样就为对象池的设计引入了多线程同步竞争的开销。\n\n　　​**为了避免这种不必要的同步竞争，Netty也采用了类似TLAB分配内存的方式，每个线程拥有一个独立Stack，这样当多个线程并发从对象池中获取对象时，都是从自己线程中的Stack中获取，全程无锁化运行。大大提高了多线程从对象池中获取对象的效率**​。\n\n> 这种**多线程并发无锁化**的设计思想，在Netty中比比皆是\n\n### 5.2 Stack的设计\n\n　　从Recycler对象池的整体设计架构图中我们可以看到，Stack的设计主要分为两个重要的部分：\n\n* 一个是我们前边提到的数组实现的栈结构用来存放对象池中的对象，每个线程绑定一个独立的Stack用来存储由**该线程创建出来**并回收到对象池中的对象。\n* 另一个重要的结构是WeakOrderQueue链表，head 指针指向WeakOrderQueue链表的头结点，cursor 指针指向链表的当前节点，prev 指针指向当前节点的前一个节点。WeakOrderQueue链表是用来存储其他线程帮助本线程回收的对象（我们称之为待回收对象）。其中WeakOrderQueue链表中的每一个节点对应一个其他线程，这个其他线程为本线程回收的对象存储在对应的WeakOrderQueue节点中。\n\n> 这里我们先不需要管WeakOrderQueue的具体结构\n\n　　​**那么Stack结构在设计上为什么要引入这个WeakOrderQueue链表呢**​？\n\n　　让我们考虑一种多线程回收对象的场景，我们还是以Recycler对象池的整体设计架构图为例。thread1 为当前线程，剩下的thread2 , thread3 , thread4为其他线程。让我们把视角先聚焦在当前线程上。\n\n> 我们先假设Stack结构中只有一个数组栈，并没有WeakOrderQueue链表。看看这样会产生什么后果？\n\n![image.png](/assets/d4522ab88aca42a4b9c2d633301fcac5tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-idyvok3.awebp)\n\n　　当前线程 thread1 在处理业务逻辑时，创建了一个对象（注意：这个对象是由thread1创建的）如果这是一个单线程处理业务的场景，那么对象会在thread1处理完业务逻辑后被回收至thread1对应的stack1中的数组栈中。当`hread1再次需要创建对象时，会直接从其对应的stack1中的数组栈（图中绿色部分）中直接获取上次回收的对象。\n\n> 由这一点可以看出Stack中的数组栈（绿色部分）存放的是真正被回收的对象，是可以直接被再次获取使用的。\n\n　　但如果这是一个多线程处理业务场景的话，很可能由thread1创建出来的对象，会被交给thread2或者thread3去处理剩下的业务逻辑，那么当thread2或者thread3这些其他线程处理完业务逻辑时，此时对象的释放并不是在thread1中，而是在其他线程中。\n\n　　其他线程现在面对的任务就是要将由thread1创建出来的对象，释放回收至thread1对应的stack1中的数组栈中。如果此时多个其他线程并发的向stack1释放回收对象，势必会导致多线程之前的同步竞争，​**Netty将不得不把Stack结构中的数组栈的访问设计成一个同步过程**​。\n\n　　那么如果此时更不巧的是当前线程thread1又要同时向自己的Stack1获取对象，thread1就只能同步等待，因为此时其他线程正在向Stack1释放对象。\n\n> 本来我们引入对象池的目的就是为了抵消创建对象的开销加快获取对象的速度，减少GC的压力。结果由于Stack的同步访问设计又引入了同步开销。这个同步的开销甚至会比创建对象的开销还要大，那么对象池的引入就变得得不偿失了。\n\n　　**那么Netty该如何化解这种情况呢？答案还是之前反复强调的无锁化设计思想。**\n\n　　既然多线程的回收对象场景，会引入多线程之间的同步锁定开销，那么我们就继续采用无锁化的设计思想，为每个线程（注意：这里指的是非创建对象的线程也就是图中的thead2 , thread3 ....）单独分配一个WeakOrderQueue节点，每个线程在为创建线程回收对象时，会将这些对象暂时存放到自己对应的WeakOrderQueue节点中。\n\n> 注意：存放进WeakOrderQueue中的对象我们称为待回收对象，这些待回收对象并不在Stack结构中的数组栈中，因此并不能被直接获取使用。\n\n　　为了方便后续描述，我们把创建对象的线程称作`创建线程`​（示例中的thread1），将为创建线程回收对象的其他线程称作`回收线程`​（示例中的thread2 , thread3 , thead4 .....）。\n\n　　我们在将视角拉回到创建线程thread1对应的stack1中，​**每个回收线程将待回收对象放入与自己对应的WeakOrderQueue节点中，这样就避免了在多线程回收场景中的同步竞争**​。当所有回收线程都在为stack1回收对象时，这样在stack1中就形成了一个WeakOrderQueue链表。每个回收线程只操作与自己对应的节点。在Stack结构中通过head，prev，cursor将这些WeakOrderQueue节点组成了一个链表。\n\n> 每一个WeakOrderQueue节点对应一个回收线程。\n\n　　而当创建线程thread1再次从自己对应的Stack1中获取对象时，只会从Stack结构的数组栈中获取，因为是单线程操作数组栈，自然是不会存在同步竞争的。\n\n　　当Stack结构中的数组栈没有任何对象时，那么创建线程就会根据 cursor 指针遍历Stack结构中的WeakOrderQueue链表，将当前WeakOrderQueue节点存放的待回收对象​**转移至数组栈中**​。如果WeakOrderQueue链表中也没有任何待回收对象可以转移。那么创建线程在对象池中就直接创建一个对象出来返回。\n\n> 对象池回收对象的一个原则就是对象由谁创建的，最终就要被回收到创建线程对应的Stack结构中的数组栈中。数组栈中存放的才是真正被回收的池化对象，可以直接被取出复用。回收线程只能将待回收对象暂时存放至创建线程对应的Stack结构中的WeakOrderQueue链表中。当数组栈中没有对象时，由创建线程将WeakOrderQueue链表中的待回收对象转移至数组栈中。\n\n　　**正是由于对象池的这种无锁化设计，对象池在多线程获取对象和多线程回收对象的场景下，均是不需要同步的**\n\n　　大家在体会下这张图中蕴含的这种​**无锁化设计思想**​：\n\n![image.png](/assets/0566fc7826064b12bb88082b39c10bd2tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-hkx67f6.awebp)\n\n### 5.3 WeakOrderQueue的设计\n\n　　在我们介绍完对象池在多线程回收对象场景下的设计时，我们再来看下用于回收线程存储待回收对象的WeakOrderQueue是如何设计的？\n\n> 注意：这里的回收线程，待回收对象这些概念是我们站在创建线程的视角提出的**相对**概念。\n\n![image.png](/assets/63f3b4b63fd14b7a84c33c0840bc41e2tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-7eix1tf.awebp)\n\n　　大家一开始可能从WeakOrderQueue字面意思上以为它的结构是一个队列，但实际上从图中我们可以看出WeakOrderQueue的结构其实是一个链表结构。\n\n　　其中包含了链表的头结点 Head，以及链表尾结点指针 Tail。链表中的元素类型为 Link 类型。\n\n　　Link 类型中包含了一个 elements 数组，该数组用来存放回收线程收集的待回收对象。\n\n　　除此之外Link类型中还包含了readIndex用来指示当前elements数组中的读取位置。writeIndex用来指示elements数组的写入位置。elements数组中的容量默认为`16`​，也就是说一个Link节点最多可以存放16个待回收对象。当回收线程收集的待回收对象超过16个时，就会新创建一个Link节点插入到Link链表的尾部。\n\n　　当需要将WeakoOrderQueue节点中所存放的待回收对象回收转移至其对应的Stack结构中的数组栈中时，**创建线程**会遍历当前WeakOrderQueue节点中的Link链表，然后从链表的Head节点开始，将Head节点中包裹的Link链表头结点中存放的待回收对象回收至创建线程对应的Stack中。​**一次最多转移一个Link大小的待回收对象**​（16个）。\n\n　　当Link节点中的待回收对象全部转移至创建线程对应的Stack中时，会立马将这个Link节点从当前WeakOrderQueue节点中的Link链表里删除，随后Head节点向后移动指向下一个Link节点。\n\n> head指针始终指向​**第一个未被转移完毕的Link节点**​，创建线程从head节点处读取转移待回收对象，回收线程从Tail节点处插入待回收对象。​**这样转移操作和插入操作互不影响、没有同步的开销**​。\n\n　　​**注意这里会存在线程可见性的问题**​，也就是说回收线程刚插入的待回收对象，在创建线程转移这些待回收对象时，创建线程可能会**看不到**由回收线程刚刚插入的待回收对象。\n\n　　​**Netty这里为了不引入多线程同步的开销，只会保证待回收对象的最终可见性**​。 因为如果要保证待回收对象的实时可见性，就要插入一些内存屏障指令，执行这些内存屏障指令也是需要开销的。\n\n　　事实上这里也并不需要保证实时可见性，创建线程暂时看不到WeakOrderQueue节点中的待回收对象也是没关系的，大不了就新创建一个对象。​**这里还是遵循无锁化的设计思想**​。\n\n> 维护线程之间操作的原子性，可见性都是需要开销的，我们在日常多线程程序设计中一定要根据业务场景来综合考虑，权衡取舍。尽量遵循我们这里多次强调的​**多线程无锁化设计思想**​。提高多线程的运行效率。避免引入不必要的同步开销。\n\n　　综合以上 Netty Recycler 对象池的设计原理，我们看到多线程从对象池中获取对象，以及多线程回收对象至对象池中，还有创建线程从WeakOrderQueue链表中转移待回收对象到对象池中。这些步骤均是无锁化进行的，没有同步竞争。\n\n　　在理解了对象池的基本设计原理后，下面就该介绍对象池在Netty中的源码实现环节了。\n\n## 6. Recycler对象池的实现\n\n　　在小节《4. 对象池Recycler的使用》中我们介绍了Recycler对象池的两个使用案例：\n\n* 一个是对象池在PooledDirectByteBuf类中的运用。\n* 另一个是对象池在Channel对应的写入缓冲队列ChannelOutboundBuffer中的运用。\n\n　　从这两个案例中，我们看到在设计池化对象时，都需要在池化对象内部持有一个对象池的静态引用从而可以与对象池进行交互，引用类型为 ObjectPool ，ObjectPool 是Netty对象池的顶层设计，其中定义了对象池的行为，以及各种顶层接口。\n\n　　在介绍对象池的整体实现之前，我们先来看下对象池的这个顶层接口设计。\n\n### 6.1 对象池的顶层设计ObjectPool\n\n```java\npublic abstract class ObjectPool<T> {\n\n    ObjectPool() { }\n\n    public abstract T get();\n\n    public interface Handle<T> {\n        void recycle(T self);\n    }\n\n    public interface ObjectCreator<T> {\n        T newObject(Handle<T> handle);\n    }\n\n    ......................省略............\n\n}\n```\n\n　　我们首先看到 ObjecPool 被设计成为一个泛型的抽象类，之所以使用泛型，是因为我们在创建对象池的时候需要指定对象池中被池化对象的类型。\n\n　　比如《4. 对象池Recycler的使用》小节中的这两个案例：\n\n```java\nstatic final class Entry {\n\n    private static final ObjectPool<Entry> RECYCLER\n\n}\n```\n\n```java\nfinal class PooledDirectByteBuf extends PooledByteBuf<ByteBuffer> {\n\n    private static final ObjectPool<PooledDirectByteBuf> RECYCLER\n\n}\n```\n\n　　ObjecPool 定义了从对象池中获取对象的行为：\n\n```java\npublic abstract T get();\n```\n\n　　将池化对象回收至对象池中的行为被定义在 Handler 内部接口中：\n\n```java\n     public interface Handle<T> {\n        void recycle(T self);\n    } \n```\n\n　　Handler是池化对象在对象池中的一个模型，Handler里面包裹了池化对象，并包含了池化对象的一些回收信息，以及池化对象的回收状态。它的默认实现是DefaultHandle，后面我们会详细介绍。\n\n> 我们前边介绍到的Stack结构中的数组栈里边存放的就是DefaultHandle，以及WeakOrderQueue结构里的Link节点中的elements数组里存放的也是DefaultHandle。\n\n　　​**那么为什么要将池化对象的回收行为recycle定义在Handler中，而不是ObejctPool中呢**​？\n\n　　让我们站在业务线程的角度来看，其实业务线程处理的都是对象级别这个维度，并不需要感知到对象池的存在，使用完对象，直接调用对象的回收方法recycle将池化对象回收掉即可。\n\n　　在《4. 对象池Recycler的使用》小节我们介绍过池化对象的设计方法，其中我们提到池化对象中需要引用其在对象池中的Handler，这个Handler会在对象池创建对象的时候传入。池化对象类型中需要定义recycle方法，recycle方法清空池化对象的所有属性，并调用Handler的recycle方法将池化对象回收至对象池中。\n\n```java\nstatic final class Entry {\n\n        void recycle() {\n            next = null;\n            bufs = null;\n            buf = null;\n            msg = null;\n            promise = null;\n            progress = 0;\n            total = 0;\n            pendingSize = 0;\n            count = -1;\n            cancelled = false;\n            handle.recycle(this);\n        }\n\n}\n```\n\n　　ObjectPool 还定义了对象池创建对象的行为接口：\n\n```java\n    public interface ObjectCreator<T> {\n        T newObject(Handle<T> handle);\n    }\n```\n\n　　用户在创建对象池的时候，需要通过`ObjectCreator#newObject`​方法指定对象池创建对象的行为。Handler对象正是通过这个接口传入池化对象中的。\n\n```java\n  static final class Entry {\n\n      private static final ObjectPool<Entry> RECYCLER = ObjectPool.newPool(new ObjectCreator<Entry>() {\n            @Override\n            public Entry newObject(Handle<Entry> handle) {\n                return new Entry(handle);\n            }\n        });\n\n      //Entry对象只能通过对象池获取，不可外部自行创建\n      private Entry(Handle<Entry> handle) {\n            this.handle = handle;\n        }\n\n  }\n```\n\n#### 6.1.1 创建ObjectPool\n\n![image.png](/assets/948ff8d7b81449269cbedf8928f28e59tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-2e3ivzs.awebp)\n\n```java\npublic abstract class ObjectPool<T> {\n\n    public static <T> ObjectPool<T> newPool(final ObjectCreator<T> creator) {\n        return new RecyclerObjectPool<T>(ObjectUtil.checkNotNull(creator, \"creator\"));\n    }\n\n    private static final class RecyclerObjectPool<T> extends ObjectPool<T> {\n        //recycler对象池实例\n        private final Recycler<T> recycler;\n\n        RecyclerObjectPool(final ObjectCreator<T> creator) {\n             recycler = new Recycler<T>() {\n                @Override\n                protected T newObject(Handle<T> handle) {\n                    return creator.newObject(handle);\n                }\n            };\n        }\n\n        @Override\n        public T get() {\n            return recycler.get();\n        }\n    }\n\n}\n```\n\n```java\npublic abstract class Recycler<T> {\n\n    protected abstract T newObject(Handle<T> handle);\n  \n    ........................省略.............\n}\n```\n\n　　调用 `ObjectPool#newPool`​ 创建对象池时，返回的是 RecyclerObjectPool 实例。而**真正的对象池 Recycler** 被包裹在 RecyclerObjectPool 中。\n\n　　对象池Recycler创建对象的行为定义在用户在创建对象池时指定的ObjectCreator 中。\n\n## 7. Recycler对象池属性详解\n\n　　在介绍完对象池的顶层设计之后，接下来我们介绍下Recycler对象池相关的一些重要属性。相信大家在看过前边关于对象池设计原理的介绍之后，现在应该能够比较容易的理解即将介绍的这些属性概念，这里涉及到的属性比较多，笔者把这些属性的介绍放到源码实现之前的目的也是先让大家混个眼熟，先有一个感性的认识，等到介绍源码实现时，笔者还会将涉及到的属性再次拿出来介绍。\n\n![image.png](/assets/f469c168d72b40c6b23accd8ab652a22tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-t5puo5k.awebp)\n\n### 7.1 创建线程，回收线程的Id标识\n\n```java\npublic abstract class Recycler<T> {\n\n    //用于产生池化对象中的回收Id,主要用来标识池化对象被哪个线程回收\n    private static final AtomicInteger ID_GENERATOR = new AtomicInteger(Integer.MIN_VALUE);\n    //用于标识创建池化对象的线程Id 注意这里是static final字段 也就意味着所有的创建线程OWN_THREAD_ID都是相同的\n    //这里主要用来区分创建线程与非创建线程。多个非创建线程拥有各自不同的Id\n    //这里的视角只是针对池化对象来说的：区分创建它的线程，与其他回收线程\n    private static final int OWN_THREAD_ID = ID_GENERATOR.getAndIncrement();\n\n}\n```\n\n* ​`AtomicInteger ID_GENERATOR`​ :对象池中定义了一个 AtomicInteger 类型的Id生成器，主要用于为创建线程以及回收线程创建Id标识，**目的是区分创建线程和回收线程。**\n* ​`int OWN_THREAD_ID`​：在 Recycler 类初始化的时候，会利用ID_GENERATOR 为 OWN_THREAD_ID 字段赋值，从字面意思上我们也可以看出 OWN_THREAD_ID 是用来标识创建线程Id的。这里有一点大家需要注意的是，OWN_THREAD_ID 是一个 static final 字段，这也就意味着所有的Recycler对象池实例中的 OWN_THREAD_ID 都是一样的。\n\n　　这里有的同学可能会有疑问了，在多线程从对象池中获取对象的场景中，创建线程会有很多个（比如下图中的thread1, thread2, thread3.....），既然所有的Recycler 对象池实例中的 OWN_THREAD_ID 都是一样的，那么如何区分不同的创建线程呢？\n\n![image.png](/assets/34f2d54bc3724e51b0c8ad2695f7de95tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-2cym377.awebp)\n\n　　​**事实上在对象池中我们并不需要区分创建线程与创建线程之间的Id**​，因为Netty在设计对象池的时候采用了无锁化设计，创建线程与创建线程之间并不需要交互，每个线程只需要关注自己线程内的对象管理工作即可，所以从一个线程的内部视角来看，只会有一个创建线程就是它自己本身，剩下的线程均是回收线程。​**所以我们对象池的设计中只需要区分创建线程与回收线程就可以了**​，当然每个回收线程的Id是不一样的。\n\n　　回收线程的Id是由其对应的 WeakOrderQueue 节点来分配的，一个 WeakOrderQueue 实例对应一个回收线程Id。\n\n```java\nprivate static final class WeakOrderQueue extends WeakReference<Thread> {\n\n    //回收线程回收Id,每个weakOrderQueue分配一个，同一个stack下的一个回收线程对应一个weakOrderQueue节点\n   private final int id = ID_GENERATOR.getAndIncrement();\n}\n```\n\n### 7.2 对象池中的容量控制\n\n![image.png](/assets/233f28fc503e4dcc9c1e1317a89b71d9tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-vqp6dd1.awebp)\n\n```java\n    //对象池中每个线程对应的Stack中可以存储池化对象的默认初始最大个数 默认为4096个对象 \n    private static final int DEFAULT_INITIAL_MAX_CAPACITY_PER_THREAD = 4 * 1024; // Use 4k instances as default.\n    // 对象池中线程对应的Stack可以存储池化对象默认最大个数 4096\n    private static final int DEFAULT_MAX_CAPACITY_PER_THREAD;\n    // 初始容量 min(DEFAULT_MAX_CAPACITY_PER_THREAD, 256) 初始容量不超过256个\n    private static final int INITIAL_CAPACITY;\n```\n\n　　Recycler 对象池中定义了以上三个属性用于控制对象池中可以池化的对象容量。这些属性对应的初始化逻辑如下：\n\n```java\n    static {\n\n        int maxCapacityPerThread = SystemPropertyUtil.getInt(\"io.netty.recycler.maxCapacityPerThread\",\n                SystemPropertyUtil.getInt(\"io.netty.recycler.maxCapacity\", DEFAULT_INITIAL_MAX_CAPACITY_PER_THREAD));\n        if (maxCapacityPerThread < 0) {\n            maxCapacityPerThread = DEFAULT_INITIAL_MAX_CAPACITY_PER_THREAD;\n        }\n\n        DEFAULT_MAX_CAPACITY_PER_THREAD = maxCapacityPerThread;\n\n        INITIAL_CAPACITY = min(DEFAULT_MAX_CAPACITY_PER_THREAD, 256);\n    }\n```\n\n* ​`DEFAULT_INITIAL_MAX_CAPACITY_PER_THREAD`​：定义每个创建线程对应的Stack结构中的数组栈初始默认的最大容量。默认为4096个。可由JVM启动参数 `-D io.netty.recycler.maxCapacity`​ 指定。\n* ​`DEFAULT_MAX_CAPACITY_PER_THREAD`​：定义每个创建线程对应的Stack结构中的数组栈的最大容量。可由JVM启动参数 `-D io.netty.recycler.maxCapacityPerThread`​ 指定，如无特殊指定，即采用 DEFAULT_INITIAL_MAX_CAPACITY_PER_THREAD 的值，默认为4096个。\n* ​`INITIAL_CAPACITY `​: 定义每个创建线程对应的Stack结构中的数组栈的初始容量。计算公式为`min(DEFAULT_MAX_CAPACITY_PER_THREAD, 256)`​，默认为256个。当池化对象超过256个时，则对对象池进行扩容，但不能超过最大容量 DEFAULT_MAX_CAPACITY_PER_THREAD。\n\n### 7.3 回收线程可回收对象的容量控制\n\n```java\n   //用于计算回收线程可帮助回收的最大容量因子  默认为2  \n    private static final int MAX_SHARED_CAPACITY_FACTOR;\n    //每个回收线程最多可以帮助多少个创建线程回收对象 默认：cpu核数 * 2\n    private static final int MAX_DELAYED_QUEUES_PER_THREAD;\n    //回收线程对应的WeakOrderQueue节点中的Link链表中的节点存储待回收对象的容量 默认为16\n    private static final int LINK_CAPACITY;\n```\n\n　　Recycler 对象池除了对创建线程中的 Stack 容量进行限制外，还需要对回收线程可回收对象的容量进行限制。相关回收容量限制属性初始化逻辑如下：\n\n```java\n    static {\n\n        MAX_SHARED_CAPACITY_FACTOR = max(2,\n                SystemPropertyUtil.getInt(\"io.netty.recycler.maxSharedCapacityFactor\",\n                        2));\n\n        MAX_DELAYED_QUEUES_PER_THREAD = max(0,\n                SystemPropertyUtil.getInt(\"io.netty.recycler.maxDelayedQueuesPerThread\",\n                        // We use the same value as default EventLoop number\n                        NettyRuntime.availableProcessors() * 2));\n\n        LINK_CAPACITY = safeFindNextPositivePowerOfTwo(\n                max(SystemPropertyUtil.getInt(\"io.netty.recycler.linkCapacity\", 16), 16));\n\n    }\n```\n\n* ​`MAX_SHARED_CAPACITY_FACTOR`​ : 针对创建线程中的 Stack，其对应的所有回收线程总共可帮助其回收的对象总量计算因子。默认为2。可通过JVM参数 `-D io.netty.recycler.maxSharedCapacityFactor`​ 指定，总共回收对象总量就是通过对象池的最大容量和该计算因子计算出来的。计算公式： `max(maxCapacity / maxSharedCapacityFactor, LINK_CAPACITY)`​ 。由此我们可以知道创建线程对应的所有回收线程总共可帮助其回收的对象总量默认为2048个，最小回收容量为 LINK_CAPACITY  默认为16。\n* ​`MAX_DELAYED_QUEUES_PER_THREAD`​ : 该参数定义每个回收线程最多可帮助多少个创建线程回收对象。默认为：CPU核数 * 2。可通过JVM参数 `-D io.netty.recycler.maxDelayedQueuesPerThread`​ 指定。​**注意：这里是站在回收线程的角度**​。\n* ​`LINK_CAPACITY `​:  在创建线程对应的 Stack 结构中的 WeakOrderQueue 链表中，回收线程对应的WeakOrderQueue节点中的Link链表中的Link节点存储待回收对象的容量。默认为16，可通过JVM参数 `-D io.netty.recycler.linkCapacity`​ 指定。\n\n　　为了方便大家理解这些容量控制的相关参数，笔者又在对象池架构设计图的基础上补充了容量控制相关的信息。大家可以对照上边介绍到的这些参数的含义形象体会下：\n\n![image.png](/assets/d76e41420e1d44eb82e4b74dc7d4309btplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-e21hjq1.awebp)\n\n### 7.4 对象回收频率控制\n\n　　对象池不能不考虑容量的限制而无脑的进行对象的回收，而是要对回收对象的频率进行限制。在我们日常架构设计和程序设计时，我们也一定要有托底的方案，比如限流，降级，熔断等托底方案。这样程序就不至于被突发的异常流量击垮。\n\n　　在对象池的设计中，Netty用以下两个参数来控制对象回收的频率从而避免对象池迅速膨胀不可控制。\n\n```java\n    //创建线程回收对象时的回收比例，默认是8，表示只回收1/8的对象。也就是产生8个对象回收一个对象到对象池中\n    private static final int RATIO;\n    //回收线程回收对象时的回收比例，默认也是8，同样也是为了避免回收线程回收队列疯狂增长 回收比例也是1/8\n    private static final int DELAYED_QUEUE_RATIO;\n```\n\n　　对象回收频率控制参数的初始化逻辑如下：\n\n```java\n    static {\n\n        RATIO = max(0, SystemPropertyUtil.getInt(\"io.netty.recycler.ratio\", 8));\n\n        DELAYED_QUEUE_RATIO = max(0, SystemPropertyUtil.getInt(\"io.netty.recycler.delayedQueue.ratio\", RATIO));\n\n    }\n```\n\n　　通过前边对 Recycler 对象池的设计原理介绍，我们知道，在池化对象被回收的时候分别由两类线程来执行。\n\n* 一类是创建线程。池化对象在创建线程中被创建出来后，一直在创建线程中被处理，处理完毕后由创建线程直接进行回收。而为了避免对象池不可控制地迅速膨胀，所以需要对创建线程回收对象的频率进行限制。这个回收频率由参数 RATIO 控制，默认为8，可由JVM启动参数 `-D io.netty.recycler.ratio`​ 指定。表示创建线程只回收 1 / 8 的对象，也就是每创建 8 个对象最后只回收 1个对象。\n* 另一类就是回收线程。池化对象在创建线程中被创建出来，但是业务的相关处理是在回收线程中，业务处理完毕后由回收线程负责回收。前边提到对象回收有一个基本原则就是对象是谁创建的，就要回收到创建线程对应的Stack中。所以回收线程就需要将池化对象回收至其创建线程对应的Stack中的WeakOrderQueue链表中。并等待创建线程将WeakOrderQueue链表中的待回收对象**转移**至Stack中的数组栈中。同样，回收线程也需要控制回收频率，由参数 DELAYED_QUEUE_RATIO 进行控制，默认也是8，可由JVM启动参数 `-D io.netty.recycler.delayedQueue.ratio`​ 指定，表示回收线程每处理完 8 个对象才回收 1 个对象。\n\n## 8. Recycler对象池的创建\n\n```java\n    private static final class RecyclerObjectPool<T> extends ObjectPool<T> {\n        //recycler对象池实例\n        private final Recycler<T> recycler;\n\n        RecyclerObjectPool(final ObjectCreator<T> creator) {\n             recycler = new Recycler<T>() {\n                @Override\n                protected T newObject(Handle<T> handle) {\n                    return creator.newObject(handle);\n                }\n            };\n        }\n    \n        ..................省略............\n      }\n```\n\n　　Netty 中的 Recycler 对象池是一个抽象类，里面封装了对象池的核心结构以及核心方法。在创建对象池的时候，我们往往会使用Recycler的匿名类来实现抽象方法 newObject 从而来定义对象池创建对象的行为。\n\n```java\npublic abstract class Recycler<T> {\n\n   protected abstract T newObject(Handle<T> handle);\n\n   protected Recycler() {\n        this(DEFAULT_MAX_CAPACITY_PER_THREAD);\n    }\n\n    protected Recycler(int maxCapacityPerThread) {\n        this(maxCapacityPerThread, MAX_SHARED_CAPACITY_FACTOR);\n    }\n\n    protected Recycler(int maxCapacityPerThread, int maxSharedCapacityFactor) {\n        this(maxCapacityPerThread, maxSharedCapacityFactor, RATIO, MAX_DELAYED_QUEUES_PER_THREAD);\n    }\n\n    protected Recycler(int maxCapacityPerThread, int maxSharedCapacityFactor,\n                       int ratio, int maxDelayedQueuesPerThread) {\n        this(maxCapacityPerThread, maxSharedCapacityFactor, ratio, maxDelayedQueuesPerThread,\n                DELAYED_QUEUE_RATIO);\n    }\n\n    //创建线程持有对象池的最大容量\n    private final int maxCapacityPerThread;\n    //所有回收线程可回收对象的总量(计算因子)\n    private final int maxSharedCapacityFactor;\n    //创建线程的回收比例\n    private final int interval;\n    //一个回收线程可帮助多少个创建线程回收对象\n    private final int maxDelayedQueuesPerThread;\n    //回收线程回收比例\n    private final int delayedQueueInterval;\n\n    protected Recycler(int maxCapacityPerThread, int maxSharedCapacityFactor,\n                       int ratio, int maxDelayedQueuesPerThread, int delayedQueueRatio) {\n        interval = max(0, ratio);\n        delayedQueueInterval = max(0, delayedQueueRatio);\n        if (maxCapacityPerThread <= 0) {\n            this.maxCapacityPerThread = 0;\n            this.maxSharedCapacityFactor = 1;\n            this.maxDelayedQueuesPerThread = 0;\n        } else {\n            this.maxCapacityPerThread = maxCapacityPerThread;\n            this.maxSharedCapacityFactor = max(1, maxSharedCapacityFactor);\n            this.maxDelayedQueuesPerThread = max(0, maxDelayedQueuesPerThread);\n        }\n    }\n\n}\n```\n\n　　关于Recycler对象池中相关的重要属性我们在上一小节已经详细介绍过了，这里只是将这些重要参数赋值于Recycler对象池中定义的对应属性上。还是那句话，大家这里只需要对这些属性有一个感性的认识即可，并不需要强行完全理解，后面我们在介绍对象池的功能实现时还会结合具体场景来介绍这些属性。\n\n## 9. 多线程获取对象无锁化实现\n\n![image.png](/assets/908c9b12522247dfbd32bada7308cb27tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-r7sakmv.awebp)\n\n　　我们在介绍Netty对象池多线程获取对象的设计时提到，为了避免多线程并发获取对象时引入的同步开销，Netty采用了类似 TLAB 分配内存的思想，为每一个线程分配了一个独立的Stack结构，池化对象就存储在这个Stack结构中。当线程需要从对象池中获取对象时，Recycler就会从线程对应的Stakc结构中获取池化对象。各个线程独立运行，没有任何同步开销。\n\n```java\n    //threadlocal保存每个线程对应的 stack结构\n    private final FastThreadLocal<Stack<T>> threadLocal = new FastThreadLocal<Stack<T>>() {\n        @Override\n        protected Stack<T> initialValue() {\n            return new Stack<T>(Recycler.this, Thread.currentThread(), maxCapacityPerThread, maxSharedCapacityFactor,\n                    interval, maxDelayedQueuesPerThread, delayedQueueInterval);\n        }\n      \n        ..............省略..........\n    };\n```\n\n　　对象池中采用一个 FastThreadLocal 类型的字段 threadLocal 为每个线程维护一个独立的Stack结构。从而达到多线程无锁化获取对象的目的。\n\n> FastThreadLocal是Netty基于JDK的ThreadLocal做的一个优化版本，拥有更快的访问性能。详细实现笔者后面会有一篇专门讲解FastThreadLocal的文章，这里大家只需要把它当成JDK的ThreadLocal来看待即可。\n\n　　当线程第一次从对象池中获取对象时会触发其对应的Stack结构的创建。\n\n### 9.1 Stack结构的创建\n\n　　本小节我们来介绍一下对象池中Stack结构的设计实现。在前边《5.2 Stack的设计》小节中我们介绍了Stack结构中的一些核心属性，包括：数组栈以及WeakOrderQueue链表的Head指针，Prev指针，Cursor指针。\n\n　　本小节笔者会把Stack结构中的剩余属性介绍给大家，通过这一小节的介绍，相信大家就会对Stack的设计实现有了一个整体的了解。还是那句话，这里大家只需要对这些属性有一个感性的认识，先混个眼熟，后面笔者还会结合具体场景详细讲解。\n\n```java\nprivate static final class Stack<T> {\n\n        // 创建线程保存池化对象的stack结构所属对象池recycler实例\n        final Recycler<T> parent;\n\n        //用弱引用来关联当前stack对应的创建线程 因为用户可能在某个地方引用了defaultHandler -> stack -> thread，可能存在这个引用链\n        //当创建线程死掉之后 可能因为这个引用链的存在而导致thread无法被回收掉\n        final WeakReference<Thread> threadRef;\n\n        //所有回收线程能够帮助当前创建线程回收对象的总容量\n        final AtomicInteger availableSharedCapacity;\n\n        //当前Stack对应的创建线程作为其他创建线程的回收线程时可以帮助多少个线程回收其池化对象\n        private final int maxDelayedQueues;\n\n        //当前创建线程对应的stack结构中的最大容量。 默认4096个对象\n        private final int maxCapacity;\n\n        //当前创建线程回收对象时的回收比例\n        private final int interval;\n\n        //当前创建线程作为其他线程的回收线程时回收其他线程的池化对象比例\n        private final int delayedQueueInterval;\n\n        // 当前Stack中的数组栈 默认初始容量256，最大容量为4096\n        DefaultHandle<?>[] elements;\n\n        //数组栈 栈顶指针\n        int size;\n\n        //回收对象计数 与 interval配合 实现只回收一定比例的池化对象\n        private int handleRecycleCount;\n\n        //多线程回收的设计，核心还是无锁化，避免多线程回收相互竞争\n        //Stack结构中的WeakOrderQueue链表\n        private WeakOrderQueue cursor, prev;\n        private volatile WeakOrderQueue head;\n}\n```\n\n![image.png](/assets/ad0a175194af489d9c71f096ac430a03tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-4g64cdf.awebp)\n\n* ​`Recycler<T> parent`​：Stack所属Recycler对象池实例，一个对象池可被多个线程访问获取对象，所以一个对象池对应多个Stack，每个Stack的parent属性指向所属的Recycler实例。比如图中的 stack1 , stack2 , stack3 , stack4 中的parent属性均指向同一个Recycler对象池实例。\n* ​`WeakReference<Thread> threadRef `​：Stack会通过弱引用的方式引用到其对应的创建线程。这里使用弱引用来持有对应创建线程的原因是因为对象池的设计中存在这样一个引用关系：`池化对象 -> DefaultHandler -> stack -> threadRef`​。而池化对象是暴露给用户的，如果用户在某个地方持有了池化对象的强引用忘记清理，而Stack持有创建线程的强引用的话，当创建线程死掉的之后，因为这样一个强引用链的存在从而导致创建线程一直不能被GC回收。\n* ​`AtomicInteger availableSharedCapacity`​：当前创建线程对应的所有回收线程可以帮助当前创建线程回收的对象总量。比如图中thread2 , thread3 , thread4 这三个回收线程总共可以帮助 thread1 回收对象的总量。availableSharedCapacity 在多个回收线程中是​**共享的**​，回收线程每回收一个对象它的值就会减1，当小于 LINK_CAPACITY(回收线程对应WeakOrderQueue节点的最小存储单元Link)时，回收线程将不能在为该stack回收对象了。该值的计算公式为前边介绍的 `max(maxCapacity / maxSharedCapacityFactor, LINK_CAPACITY)`​。\n\n> 当创建线程从Stack结构中的WeakOrderQueue链表中转移待回收对象到数组栈中后，availableSharedCapacity 的值也会相应增加。说白了这个值就是用来指示回收线程还能继续回收多少对象。已达到控制回收线程回收对象的总体容量。\n\n* ​`int maxDelayedQueues`​： 一个线程对于对象池来说，它可以是创建线程，也可以是回收线程，当该创建线程作为回收线程时，该值定义了最多可以为多少个创建线程回收对象。默认值为 CPU * 2。比如图中 thread2 作为回收线程既可以帮 thread1 回收对象也可以帮助 thread3 , thread4 回收对象。那么maxDelayedQueues 的值就是 3 。\n* ​`int maxCapacity`​：定义当前Stack结构中的数组栈的最大容量。默认为4096。\n* ​`int interval`​：创建线程的回收比例，默认是8。\n* ​`int delayedQueueInterval`​：创建线程作为回收线程时的回收比例。默认是8。\n* ​`DefaultHandle<?>[] elements`​：这个就是我们前边反复提到的Stack结构中的数组栈。用于存放对象池中的池化对象。当线程从对象池中获取对象时就是从这里获取。\n* ​`int size`​：数组栈中的栈顶指针。\n* ​`int handleRecycleCount`​：回收对象计数。与 interval 配合达到控制回收对象比例的目的。从 0 开始每遇到一个回收对象就 +1 ，同时把对象丢弃。直到`handleRecycleCount == interval`​时回收对象，然后归零。也就是前边我们说到的每创建8个对象才回收1个。避免 Stack 不可控制的迅速增长。\n* ​`WeakOrderQueue cursor, prev，head`​：这三个指针就是前边我们在讲Stack设计的时候介绍到的用于**多线程无锁化回收**的 WeakOrderQueue 链表中的头结点指针，当前节点指针，前一个节点指针（用于删除节点）。\n\n　　介绍完Stack结构中的这些重要属性，创建的过程就很简单了。就是利用前边介绍过的已经初始化好的Recycler属性对Stack结构中的这些属性进行赋值。\n\n```java\n    private final FastThreadLocal<Stack<T>> threadLocal = new FastThreadLocal<Stack<T>>() {\n        @Override\n        protected Stack<T> initialValue() {\n            return new Stack<T>(Recycler.this, Thread.currentThread(), maxCapacityPerThread, maxSharedCapacityFactor,\n                    interval, maxDelayedQueuesPerThread, delayedQueueInterval);\n        }\n\n      ..............省略............\n    }\n```\n\n```java\n       Stack(Recycler<T> parent, Thread thread, int maxCapacity, int maxSharedCapacityFactor,\n              int interval, int maxDelayedQueues, int delayedQueueInterval) {\n            this.parent = parent;\n            threadRef = new WeakReference<Thread>(thread);\n            this.maxCapacity = maxCapacity;\n            availableSharedCapacity = new AtomicInteger(max(maxCapacity / maxSharedCapacityFactor, LINK_CAPACITY));\n            elements = new DefaultHandle[min(INITIAL_CAPACITY, maxCapacity)];\n            this.interval = interval;\n            this.delayedQueueInterval = delayedQueueInterval;\n            handleRecycleCount = interval; \n            this.maxDelayedQueues = maxDelayedQueues;\n        }\n```\n\n### 9.2 从对象池中获取对象\n\n![image.png](/assets/002bdbd0d71140c3834d44b93555237ftplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-ryqzvpj.awebp)\n\n```java\npublic abstract class Recycler<T> {\n      //一个空的Handler,表示该对象不会被池化\n     private static final Handle NOOP_HANDLE = new Handle() {\n        @Override\n        public void recycle(Object object) {\n            // NOOP\n        }\n    };\n\n    public final T get() {\n        //如果对象池容量为0，则立马新创建一个对象返回，但是该对象不会回收进对象池\n        if (maxCapacityPerThread == 0) {\n            return newObject((Handle<T>) NOOP_HANDLE);\n        }\n        //获取当前线程 保存池化对象的stack\n        Stack<T> stack = threadLocal.get();\n        //从stack中pop出对象，handler是池化对象在对象池中的模型，包装了一些池化对象的回收信息和回收状态\n        DefaultHandle<T> handle = stack.pop();\n        //如果当前线程的stack中没有池化对象 则直接创建对象\n        if (handle == null) {\n            //初始化的handler对象recycleId和lastRecyclerId均为0\n            handle = stack.newHandle();\n            //newObject为对象池recycler的抽象方法，由使用者初始化内存池的时候 匿名提供\n            handle.value = newObject(handle);\n        }\n        return (T) handle.value;\n    }\n\n}\n```\n\n　　Recycler对外表现为一个整体的对象池，但是对象池内部是按照线程的维度来池化对象的，每个线程所池化的对象保存在对应的Stack结构中。\n\n1. 当对象池的最大容量`maxCapacityPerThread == 0`​时，对象池会立马创建一个对象出来，并将一个空的Handler传递进对象中。表示该对象在使用完毕后不会被回收进对象池中。\n2. 从threadLocal中获取当前线程对应的Stack，随后从Stack结构中的数组栈中弹出栈顶对象的DefaultHandler。\n3. 如果弹出的DefaultHandler为空，说明当前Stack中并没有回收的池化对象。直接创建一个新的DefaultHandler并创建一个新的对象，然后将DefaultHandler传入到新创建的对象中，并用DefaultHandler包裹新创建的对象。这样池化对象就与DefaultHandler关联起来了。\n\n```java\nstatic final class Entry {\n\n     private static final ObjectPool<Entry> RECYCLER = ObjectPool.newPool(new ObjectCreator<Entry>() {\n            @Override\n            public Entry newObject(Handle<Entry> handle) {\n                return new Entry(handle);\n            }\n        });\n\n     private Entry(Handle<Entry> handle) {\n            this.handle = handle;\n     }\n}\n```\n\n### 9.3 DefaultHandler\n\n　　前边我们在介绍对象池的设计原理时提到，池化对象在对象池中的存储模型为 Handler。\n\n```java\npublic abstract class ObjectPool<T> {\n\n    public interface Handle<T> {\n        void recycle(T self);\n    }\n\n}\n```\n\n　　在Recycler对象池中的默认实现是 DefaultHandler ，DefaultHandler 里面包裹了池化对象以及池化对象在对象池中的一些相关信息，（比如：池化对象的相关回收信息和回收状态）。\n\n　　从结构设计角度上来说，池化对象是隶属于其创建线程对应的Stack结构的，由于这层结构关系的存在，池化对象的DefaultHandler应该由Stack来进行创建。\n\n```java\n private static final class Stack<T> {\n\n        DefaultHandle<T> newHandle() {\n            return new DefaultHandle<T>(this);\n        }\n }\n```\n\n　　我们来看下 DefaultHandler 的具体结构：\n\n```java\n   private static final class DefaultHandle<T> implements Handle<T> {\n        //用于标识最近被哪个线程回收，被回收之前均是0\n        int lastRecycledId;\n        //用于标识最终被哪个线程回收，在没被回收前是0\n        int recycleId;\n\n        //是否已经被回收\n        boolean hasBeenRecycled;\n        //强引用关联创建handler的stack\n        Stack<?> stack;\n        //池化对象\n        Object value;\n\n        DefaultHandle(Stack<?> stack) {\n            this.stack = stack;\n        }\n\n        @Override\n        public void recycle(Object object) {\n\n          ...................省略.............\n        }\n    }\n```\n\n　　DefaultHandler属性的第一部分信息，首先就是池化对象在对象池中的回收信息。\n\n* ​`int lastRecycledId`​：用于标识最近被哪个线程回收，被回收之前均是0。\n* ​`int recycleId`​：用于标识最终被哪个线程回收，在没被回收前是0。\n* ​`boolean hasBeenRecycled`​：该池化对象是否已经被回收至创建线程对应的Stack中。\n\n　　​**这里可能大家有疑问了，为什么池化对象的回收还要分最近回收和最终回收呢**​？\n\n　　因为对象池中的池化对象回收可以分为两种情况：\n\n* ​`由创建线程直接进行回收`​：这种回收情况就是一步到位，直接回收至创建线程对应的Stack中。所以这种情况下是不分阶段的。`recycleId = lastRecycledId = OWN_THREAD_ID`​。\n* ​`由回收线程帮助回收`​：这种回收情况下就要分步进行了，首先由回收线程将池化对象**暂时存储**在其创建线程对应Stack中的WeakOrderQueue链表中。此时并没有完成真正的对象回收。`recycleId = 0，lastRecycledId = 回收线程Id（WeakOrderQueue#id）`​。当创建线程将WeakOrderQueue链表中的待回收对象转移至Stack结构中的数组栈之后，这时池化对象才算真正完成了回收动作。`recycleId = lastRecycledId = 回收线程Id（WeakOrderQueue#id）`​。\n\n　　这两个字段 lastRecycledId ，recycleId 主要是用来标记池化对象所处的回收阶段，以及在这些回收阶段具体被哪个线程进行回收。\n\n　　最后两个属性就比较容易理解了，一个是 Object value 用来包裹真正的池化对象。另一个是 Stack<?> stack 用来强引用关联池化对象的Handler所属的Stack结构。\n\n　　记不记得我们在介绍Stack结构的时候提到，Stack中持有其对应创建线程的`弱引用`​。笔者在解释为什么持有创建线程的弱引用时，提到过这样一个引用链关系：`池化对象 -> DefaultHandler -> Stack -> threadRef`​。这里大家明白了吗？\n\n![image.png](/assets/d9a984a0659546258734112ce5c687f7tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-qzq41qp.awebp)\n\n```java\nstatic final class Entry {\n    //池化对象Entry强引用它的DefaultHandler\n    private  Handle<Entry> handle;\n  \n}\n\n\nprivate static final class DefaultHandle<T> implements Handle<T> {\n    // DefaultHandler强引用其所属的Stack\n    Stack<?> stack;\n\n}\n\nprivate static final class Stack<T> {\n    // Stack弱引用其对应的创建线程\n    final WeakReference<Thread> threadRef;\n\n}\n```\n\n### 9.4 从Stack中获取池化对象\n\n![image.png](/assets/6d2a0769269e405dac3519f9e45d14d7tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-hfn0g3i.awebp)\n\n```java\n        DefaultHandle<T> pop() {\n            //普通出栈操作，从栈顶弹出一个回收对象\n            int size = this.size;\n            if (size == 0) {\n                //如果当前线程所属stack已经没有对象可用，则遍历stack中的weakOrderQueue链表（其他线程帮助回收的对象存放在这里）将这些待回收对象回收进stack\n                if (!scavenge()) {\n                    return null;\n                }\n                size = this.size;\n                if (size <= 0) {\n                    // 如果WeakOrderQueue链表中也没有待回收对象可转移\n                    // 直接返回null 新创建一个对象\n                    return null;\n                }\n            }\n            size --;\n            DefaultHandle ret = elements[size];\n            elements[size] = null;\n            this.size = size;\n\n            if (ret.lastRecycledId != ret.recycleId) {\n                // 这种情况表示对象至少被一个线程回收了，要么是创建线程，要么是回收线程\n                throw new IllegalStateException(\"recycled multiple times\");\n            }\n\n            //对象初次创建以及回收对象再次使用时  它的 recycleId = lastRecycleId = 0\n            ret.recycleId = 0;\n            ret.lastRecycledId = 0;\n            return ret;\n        }\n```\n\n　　这里就是业务线程从对象池中真正获取池化对象的地方。从Stack结构中的数组栈的栈顶位置弹出池化对象。\n\n* 首先判断数组栈中是否有回收的池化对象。栈顶指针 size == 0 说明当前数组栈中是空的。随后就会调用 scavenge 方法，从Stack结构中的WeakOrderQueue链表中转移最多一个Link大小的待回收对象到数组栈中。如果WeakOrderQueue链表中也没有待回收对象，说明当前Stack结构就是空的没有任何回收的池化对象，对象池直接返回 null ，并创建一个新的池化对象返回给业务线程。\n* 如果数组栈不为空，则将栈顶元素 DefaultHandler 弹出，初始化池化对象DefaultHandler的回收信息。`recycleId  = lastRecycledId = 0`​表示该池化对象刚刚从对象池中取出。\n\n　　recycleId 与 lastRecycledId 之间的关系分为以下几种情况：\n\n* ​`recycleId  = lastRecycledId = 0`​：表示池化对象刚刚被创建或者刚刚从对象池中取出即将被再次复用。这是池化对象的初始状态。\n* ​`recycleId  = lastRecycledId != 0`​：表示当前池化对象已经被回收至对应Stack结构里的数组栈中。可以直接被取出复用。可能是被其创建线程直接回收，也可能是被回收线程回收。\n* ​`recycleId  != lastRecycledId`​：表示当前池化对象处于半回收状态。池化对象已经被业务线程处理完毕，并被回收线程回收至对应的WeakOrderQueue节点中。并等待创建线程将其最终转移至Stack结构中的数组栈中。\n\n### 9.4 转移回收线程回收的对象到Stack中\n\n![image.png](/assets/29c7d6a21d76455d9bc5443394172a2btplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-jhifgqp.awebp)\n\n　　通过前边介绍Stack结构的设计原理我们知道，对象池中池化对象的回收存储分为两个部分：\n\n* 一个是池化对象直接被创建线程回收，直接存储在创建线程对应Stack结构中的数组栈中。\n* 另一个是池化对象被回收线程回收，临时间接存储在创建线程对应Stack结构中的WeakOrderQueue链表中。每个回收线程对应一个WeakOrderQueue节点。\n\n　　当Stack结构中的数组栈为空时，创建线程会遍历WeakOrderQueue链表，从而将回收线程为其回收的对象从WeakOrderQueue节点中转移至数组栈中。**多线程回收对象无锁化设计**\n\n　　这个转移的动作就是由 scavenge 方法来完成的。\n\n```java\n       private boolean scavenge() {\n            //从其他线程回收的weakOrderQueue里 转移 待回收对像 到当前线程的stack中\n            if (scavengeSome()) {\n                return true;\n            }\n\n            // 如果weakOrderQueue中没有待回收对象可转移，那么就重置stack中的cursor.prev\n            // 因为在扫描weakOrderQueue链表的过程中，cursor已经发生变化了\n            prev = null;\n            cursor = head;\n            return false;\n        }\n```\n\n　　scavengeSome() 执行具体的转移逻辑。如果WeakOrderQueue链表中还有待回收对象并转移成功则返回 true 。如果WeakOrderQueue链表为空没有任何待回收对象可转移，则重置链表相关的指针，cursor重新指向head节点，prev指向null。因为在遍历WeakOrderQueue链表搜寻可转移对象时，cursor指针已经发生变化了，这里需要重置。\n\n### 9.5 转移回收对象\n\n　　下面创建线程就开始遍历Stack结构中的WeakOrderQueue链表，将其中存储的回收线程回收进来的对象转移到数组栈中。\n\n　　为了让大家更清晰的理解遍历WeakOrderQueue链表的过程，我们先来了解下Stack中WeakOrderQueue链表的状态结构如下图所示：\n\n![image.png](/assets/c7d327afbf054012bd98bb554bfd19a3tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-kxpsqug.awebp)\n\n　　在Stack结构刚刚创建的初始状态，WeakOrderQueue链表是空的，所以 prev = head = cursor = null 。\n\n　　后面当回收线程在回收对象时会加入自己对应的WeakOrderQueue节点到链表中。​**注意：WeakOrderQueue节点的插入都是在链表的头结点进行插入**​。\n\n> 后面我们在讲到多线程回收对象时还会再次详细讲解WeakOrderQueue链表的操作，这里大家只需要先理解链表的状态结构即可。\n\n　　head指针始终指向链表的头结点，cursor指针指向当前遍历的节点。在没有开始遍历链表前，cursor指针指向头结点。表示从头结点开始遍历。prev指针指向cursor前一个节点。当前遍历节点为头结点时，prev指针指向空。\n\n　　在理解了WeakOrderQueue链表的状态结构后，我们来看一下链表的遍历转移过程逻辑：\n\n```java\n        private boolean scavengeSome() {\n            WeakOrderQueue prev;\n            //获取当前线程stack 的weakOrderQueue链表指针（本次扫描起始节点）\n            WeakOrderQueue cursor = this.cursor;\n            //在stack初始化完成后，cursor，prev,head等指针全部是null，这里如果cursor == null 意味着当前stack第一次开始扫描weakOrderQueue链表\n            if (cursor == null) {\n                prev = null;\n                cursor = head;\n                if (cursor == null) {\n                    //说明目前weakOrderQueue链表里还没有节点，并没有其他线程帮助回收的池化对象\n                    return false;\n                }\n            } else {\n                //获取prev指针，用于操作链表（删除当前cursor节点）\n                prev = this.prev;\n            }\n\n            boolean success = false;\n            //循环遍历weakOrderQueue链表 转移待回收对象\n            do {\n                //将weakOrderQueue链表中当前节点中包含的待回收对象，转移到当前stack中，一次转移一个link\n                if (cursor.transfer(this)) {\n                    success = true;\n                    break;\n                }\n                //如果当前cursor节点没有待回收对象可转移，那么就继续遍历链表获取下一个weakOrderQueue节点\n                WeakOrderQueue next = cursor.getNext();\n                //如果当前weakOrderQueue对应的回收线程已经挂掉了，则\n                if (cursor.get() == null) {\n                    // 判断当前weakOrderQueue节点是否还有可回收对象\n                    if (cursor.hasFinalData()) {\n                        //回收weakOrderQueue中最后一点可回收对象，因为对应的回收线程已经死掉了，这个weakOrderQueue不会再有任何对象了\n                        for (;;) {\n\n                            if (cursor.transfer(this)) {\n                                success = true;\n                            } else {\n                                break;\n                            }\n                        }\n                    }\n\n                    //回收线程以死，对应的weaoOrderQueue节点中的最后一点待回收对象也已经回收完毕，就需要将当前节点从链表中删除。unlink当前cursor节点\n                    //这里需要注意的是，netty永远不会删除第一个节点，因为更新头结点是一个同步方法，避免更新头结点而导致的竞争开销\n                    // prev == null 说明当前cursor节点是头结点。不用unlink，如果不是头结点 就将其从链表中删除，因为这个节点不会再有线程来收集池化对象了\n                    if (prev != null) {\n                        //确保当前weakOrderQueue节点在被GC之前，我们已经回收掉它所有的占用空间\n                        cursor.reclaimAllSpaceAndUnlink();\n                        //利用prev指针删除cursor节点\n                        prev.setNext(next);\n                    }\n                } else {\n                    prev = cursor;\n                }\n                //向后移动prev,cursor指针继续遍历weakOrderQueue链表\n                cursor = next;\n\n            } while (cursor != null && !success);\n\n            this.prev = prev;\n            this.cursor = cursor;\n            return success;\n        }\n```\n\n1. 再开始遍历WeakOrderQueue链表之前，首先需要检查cursor指针是否为空，如果为空说明当前Stack是第一次开始遍历WeakOrderQueue链表。随后让cursor指针指向head指针，如果head指针指向为空，说明当前WeakOrderQueue链表是空的，此时没有任何回收线程在回收对象。如果head指针不为空，则从head指针指向的头结点开始遍历WeakOrderQueue链表。\n2. 首先会从cursor指针指向的当前遍历节点开始，将当前WeakOrderQueue节点中存储的待回收对象转移到Stack结构中的数组栈中。一次最多转移一个Link大小的对象。转移成功后退出。如果当前WeakOrderQueue节点此时没有任何待回收对象可被转移则转移失败，继续遍历下一个WeakOrderQueue节点。\n\n```java\n        if (cursor.transfer(this)) {\n            success = true;\n            break;\n        }\n\n        WeakOrderQueue next = cursor.getNext();\n```\n\n3. 为了多线程能够无锁化回收对象，一个回收线程对应一个WeakOrderQueue节点，在WeakOrderQueue节点中持有对应回收线程的`弱引用`​,目的也是为了当回收线程挂掉的时候，能够保证回收线程被GC及时的回收掉。如果`cursor.get() == null`​说明当前WeakOrderQueue节点对应的回收线程已经挂掉了，此时如果当前节点还有待回收对象，则需要将节点中的所有待回收对象全部转移至Stack中的数组栈中。​**注意这里是转移节点所有的待回收对象而不是只转移一个Link**​。因为对应的回收线程已经挂掉了，该线程后续将不再会帮助创建线程回收对象了，所以要清理其对应的WeakOrderQueue节点。\n\n```java\nprivate static final class WeakOrderQueue extends WeakReference<Thread> {\n\n    ............WeakOrderQueue本身就是一个弱引用，引用对应的回收线程.........\n\n}\n```\n\n4. 当清理完已经挂掉的回收线程对应的WeakOrderQueue节点后，就需要将该节点从Stack结构里的WeakOrderQueue链表中删除。保证被清理后的WeakOrderQueue节点可以被GC回收。当然删除节点之前需要通过`cursor.reclaimAllSpaceAndUnlink()`​释放回收线程回收对象的availableSharedCapacity容量。释放的容量的大小为被删除WeakOrderQueue节点中存储的待回收对象容量。\n\n```java\n        if (prev != null) {\n              cursor.reclaimAllSpaceAndUnlink();\n              //利用prev指针删除cursor节点\n              prev.setNext(next);\n        }\n```\n\n> 这里需要注意的是，Netty不会对WeakOrderQueue链表的头结点进行删除。如果`prev == null`​说明当前节点是头结点，即使对应的回收线程已经挂掉了，但在本次遍历中不会对其进行删除。因为操作链表头结点的方法是一个同步方法，Netty这里是为了避免不必要的同步开销。\n\n　　以上逻辑就是创建线程遍历WeakOrderQueue链表转移回收对象的处理逻辑，如果本次遍历的当前节点中并没有对象可转移，那么就继续从下一个节点开始遍历。循环执行转移逻辑直到遍历完链表或者中途转移成功。退出循环时要记录更新cursor指针记录当前遍历到的节点。\n\n　　这里大家可能会有两个问题：\n\n　　​**第一个问题：如果头结点对应的回收线程已经挂掉，这个头结点不在本次遍历中删除，那么会在什么时候被删除呢**​？\n\n![image.png](/assets/359cbfb6d68e450b8f611a9975099c6etplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-ol5zynd.awebp)\n\n　　首先当回收线程第一次开始帮助创建线程回收对象时，会将自己对应的WeakOrderQueue节点插入到创建线程对应Stack结构中的WeakOrderQueue链表的头结点位置。​**节点始终在链表的头结点位置插入**​。\n\n　　如图所示，当本次遍历发现头结点对应的回收线程 thread4 已经挂掉后，清理完头结点中存储的待回收对象后，让其继续呆在链表中，​**并不着急将其删除**​。随后cursor指针指向thread3对应的节点，下一次遍历就会从thread3对应的节点开始遍历。\n\n　　当有一个新的回收线程 thread5 加入后，此时thread5对应的WeakOrderQueue节点变成了链表中的头结点，当经过多次遍历之后，cursor指针最终会再次指向死亡线程`thread4`​对应的节点时，会再次进入`cursor.get() == null`​的处理逻辑，而此时`thread4`​对应的节点已经不是头结点了，所以在这次遍历中就将该节点从链表中删除。\n\n> 这就是多线程并发代码和单线程代码设计上的不同，在多线程程序设计中，我们一定要时刻警惕同步操作的开销。能避免就要尽量避免。\n\n　　**第二个问题：操作WeakOrderQueue链表的头结点为什么是同步方法呢？**\n\n　　我们都知道一个回收线程对应一个WeakOrderQueue节点，当一个回收线程第一次为该创建线程回收对象时，都会新创建一个WeakOrderQueue节点并将节点插入到创建线程对应Stack中的WeakOrderQueue链表中的头结点位置。\n\n　　在多线程回收场景下，可能会有多个回收线程同时向创建线程对应Stack中的WeakOrderQueue链表的头结点插入自己对应的节点。\n\n　　那么此时对于链表头结点的操作就必须做同步处理了。当节点同步插入到链表的头结点后，以后该回收线程回收对象就是无锁化了。​**只不过就是在一开始插入节点的时候会有一点同步的开销，但是这是无法避免的**​。\n\n```java\n        //整个recycler对象池唯一的一个同步方法，而且同步块非常小，逻辑简单，执行迅速\n        synchronized void setHead(WeakOrderQueue queue) {\n            //始终在weakOrderQueue链表头结点插入新的节点\n            queue.setNext(head);\n            head = queue;\n        }\n```\n\n　　纵观整个Recycler的设计实现，这个方法是唯一一个同步的方法，而且同步块非常的短，里面的逻辑非常简单。\n\n> 在多线程程序设计中，如果遇到无法避免的同步情况，那么也必须使同步块内的代码逻辑尽量简单。\n\n## 10. WeakOrderQueue的设计实现\n\n![image.png](/assets/53b93ae1d4dc4adeaa4d6104cc9aa7b6tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-onec9un.awebp)\n\n　　之前我们在介绍WeakOrderQueue结构设计原理的时候讲到，虽然该结构命名的后缀是一个Queue，但其实是一个链表，链表中的元素类型为Link，头结点指针Head永远指向第一个未被转移完毕的Link，当一个Link里的待回收对象被全部转移完毕后，head指针随即指向下一个节点，但是该Link节点并不会从链表中删除。尾指针Tail指向链表中最后一个`Link节点`​。节点的插入是从链表的尾部开始插入。\n\n### 10.1 Link结构\n\n```java\n    private static final class WeakOrderQueue extends WeakReference<Thread> {\n\n        // link结构是用于真正存储待回收对象的结构，继承AtomicInteger 本身可以用来当做writeindex使用\n        static final class Link extends AtomicInteger {\n            //数组用来存储待回收对象，容量为16\n            final DefaultHandle<?>[] elements = new DefaultHandle[LINK_CAPACITY];\n\n            int readIndex;\n            //weakOrderQueue中的存储结构时由link结构节点元素组成的链表结构\n            Link next;\n        }\n}\n```\n\n　　首先我们从WeakOrderQueue的继承结构上来看，它继承于 `WeakReference < Thread >`​ , 表示该结构持有一个线程的`弱引用`​，一个回收线程对应于一个WeakOrderQueue节点，很明显是持有其对应回收线程的弱引用，方便当回收线程挂掉的时候被GC回收。\n\n* ​`DefaultHandle<?>[] elements `​: Link结构中包含一个容量为LINK_CAPACITY ，默认为16大小的DefaultHandle数组，用来存储回收线程回收的对象。\n* ​`int readIndex`​：创建线程在转移Link节点中的待回收对象时，通过这个readIndex来读取未被转移的对象。由于readIndex只会被创建线程使用，所以这里并不需要保证原子性和可见性。用一个普通的int变量存储就好。\n* ​`writeIndex`​：Link结构继承于AtomicInteger类型，这就意味着Link结构本身就可以被当做一个writeIndex来使用，由于回收线程在向Link节点添加回收对象的时候需要修改writeIndex，于此同时创建线程在转移Link节点的时候需要读取writeIndex，所以writeIndex需要保证线程安全性，故采用AtomicInteger类型存储。\n* ​`Link next`​：Link节点的next指针，用于指向链表中的下一个节点。\n\n### 10.2 Head结构\n\n```java\n        // weakOrderQueue内部link链表的头结点\n        private static final class Head {\n            //所有回收线程能够帮助创建线程回收对象的总容量 reserveSpaceForLink方法中会多线程操作该字段\n            //用于指示当前回收线程是否继续为创建线程回收对象，所有回收线程都可以看到，这个值是所有回收线程共享的。以便可以保证所有回收线程回收的对象总量不能超过availableSharedCapacity\n            private final AtomicInteger availableSharedCapacity;\n            //link链表的头结点\n            Link link;\n\n            Head(AtomicInteger availableSharedCapacity) {\n                this.availableSharedCapacity = availableSharedCapacity;\n            }\n\n            void reclaimAllSpaceAndUnlink() {\n                    ....回收head节点的所有空间，并从链表中删除head节点，head指针指向下一节点....\n            }\n\n            private void reclaimSpace(int space) {\n                //所有回收线程都可以看到，这个值是所有回收线程共享的。以便可以保证所有回收线程回收的对象总量不能超过availableSharedCapacity\n                availableSharedCapacity.addAndGet(space);\n            }\n\n            //参数link为新的head节点，当前head指针指向的节点已经被回收完毕\n            void relink(Link link) {\n                  ...回收当前头结点的容量，更新head节点为指定的Link节点...\n            }\n\n            Link newLink() {\n                  ....创建新的Link节点...\n            }\n\n            //此处目的是为接下来要创建的link预留空间容量\n            static boolean reserveSpaceForLink(AtomicInteger availableSharedCapacity) {             \n                  ...在创建新的Link节点之前需要调用该方法预订容量空间...\n            }\n        }\n```\n\n　　从代码结构上我们可以看出，Head结构的设计不只是作为头结点指针那么简单，其中还封装了很多链表操作以及回收的逻辑。\n\n* ​`AtomicInteger availableSharedCapacity`​：这个字段前边已经介绍过多次了，它是多线程共享的一个字段，可以被多个回收线程进行操作，表达的语义是所有回收线程总共可以帮助创建线程一共可以回收多少对象。对所有回收线程回收对象的总量进行限制。每创建一个Link节点，它的值就减少一个LINK_CAPACITY ，每释放一个Link节点，它的值就增加一个LINK_CAPACITY 。\n* ​`Link link`​：Head结构封装的Link链表中的头结点。\n\n　　剩下Head结构中封装的相关逻辑处理方法，等到介绍到具体应用场景的时候，笔者在拿出来为大家介绍，这里先混个眼熟就行。先看懂个大概，脑海里朦朦胧胧有个粗浅的认识即可。\n\n### 10.3 WeakOrderQueue中的重要属性\n\n```java\n private static final class WeakOrderQueue extends WeakReference<Thread> {\n\n        //link链表的头结点，head指针始终指向第一个未被转移完毕的LinK节点\n        private final Head head;\n        //尾结点\n        private Link tail;\n        //站在stack的视角中，stack中包含一个weakOrderQueue的链表，每个回收线程为当前stack回收的对象存放在回收线程对应的weakOrderQueue中\n        //这样通过stack中的这个weakOrderQueue链表，就可以找到其他线程为该创建线程回收的对象\n        private WeakOrderQueue next;\n        //回收线程回收Id,每个weakOrderQueue分配一个，同一个stack下的一个回收线程对应一个weakOrderQueue节点\n        private final int id = ID_GENERATOR.getAndIncrement();\n        //回收线程回收比例 默认是8\n        private final int interval;\n        //回收线程回收计数 回收1/8的对象\n        private int handleRecycleCount;\n\n}\n```\n\n* ​`Head head`​：用于指向WeakOrderQueue中Link链表的头结点。\n* ​`Link tail`​：指向Link链表中的尾结点。\n* ​`WeakOrderQueue next`​：站在Stack结构的视角上，Stack包含一个WeakOrderQueue链表，用来存放回收线程回收过来的池化对象。该字段为WeakOrderQueue节点的next指针，用于指向下一个回收线程对应的WeakOrderQueue节点。\n* ​`int id `​：对应回收线程的回收Id，同一个Stack结构下，不同的回收线程对应不同的Id。\n* ​`int interval`​：回收线程对应的回收频率，默认只回收 1 / 8 的池化对象。\n* ​`int handleRecycleCount`​：回收对象计数，前边我们多次讲过了。用于控制回收频率。\n\n### 10.4 WeakOrderQueue结构的创建\n\n```java\nprivate static final class WeakOrderQueue extends WeakReference<Thread> {\n        //为了使stack能够被GC,这里不会持有其所属stack的引用\n        private WeakOrderQueue(Stack<?> stack, Thread thread) {\n            //weakOrderQueue持有对应回收线程的弱引用\n            super(thread);\n            //创建尾结点\n            tail = new Link();\n\n            // 创建头结点  availableSharedCapacity = maxCapacity / maxSharedCapacityFactor\n            head = new Head(stack.availableSharedCapacity);\n            head.link = tail;\n            interval = stack.delayedQueueInterval;\n            handleRecycleCount = interval; \n        }\n}\n```\n\n　　在创建WeakOrderQueue结构的时候，首先会调用父类 `WeakReference<Thread>`​ 的构造方法持有当前回收线程的弱应用。\n\n　　然后创建第一个Link节点，head指针和tail指针同时指向这第一个节点。\n\n　　用创建线程对应的Stack中的属性初始化WeakOrderQueue结构中的相关属性。\n\n　　大家这里可能会问了，既然这里用Stack中的属性去初始化WeakOrderQueue结构中的相关属性，那​**为什么WeakOrderQueue不直接持有Stack的引用呢**​？\n\n　　之前我们提到，一个回收线程对应一个WeakOrderQueue节点，当回收线程挂掉的时候，需要清理WeakOrderQueue节点并将其从Stack结构中的WeakOrderQueue链表（头结点除外）中删除。使得WeakOrderQueue节点可以被GC回收掉。\n\n　　**如果Stack结构对应的创建线程挂掉，而此时WeakOrderQueue又持有了Stack的引用，这样就使得Stack结构无法被GC掉。**\n\n　　所以这里只会用Stack结构的相关属性去初始化WeakOrderQueue结构，在WeakOrderQueue中并不会持有Stack的引用。\n\n> 在复杂程序结构的设计中，我们要时刻对对象之间的引用关系保持清晰的认识。防止内存泄露。\n\n### 10.5 从WeakOrderQueue中转移回收对象\n\n　　WeakOrderQueue的transfer方法用于将当前WeakOrderQueue节点中的待回收对象转移至创建线程对应的Stack中。\n\n　　开始转移回收对象时会从WeakOrderQueue节点中的Link链表的头结点开始遍历，如果头结点中还有未被转移的对象，则将头结点剩余的未转移对象转移至Stack中。所以创建线程每次最多转移一个LINK_CAPACITY大小的对象至Stack中。只要成功转移了哪怕一个对象，transfer方法就会返回true。\n\n　　如果头结点中存储的对象已经全部转移完毕，则更新head指针指向下一个Link节点，开始转移下一个Link节点。​**创建线程每次只会转移一个Link节点**​。如果Link链表是空的，没有转移成功一个对象，则transfer方法返回false。\n\n　　由于transfer方法体比较大，笔者将其按照上述逻辑步骤拆分开来为大家讲解：\n\n![image.png](/assets/25a723e07ab64f0fa5fcdc4eeddf1e0dtplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-afj8oqs.awebp)\n\n#### 10.5.1 判断头结点中的待回收对象是否转移完毕\n\n```java\n            //获取当前weakOrderQueue节点中的link链表头结点\n            Link head = this.head.link;\n            //头结点为null说明还没有待回收对象\n            if (head == null) {\n                return false;\n            }\n\n            //如果头结点中的待回收对象已经被转移完毕\n            if (head.readIndex == LINK_CAPACITY) {\n                //判断是否有后续Link节点\n                if (head.next == null) {\n                    //整个link链表没有待回收对象了已经\n                    return false;\n                }\n                head = head.next;\n                //当前Head节点已经被转移完毕，head指针向后移动，head指针始终指向第一个未被转移完毕的LinK节点\n                this.head.relink(head);\n            }\n```\n\n　　首先从Link链表的头结点开始转移，`head == null`​ 说明当前Link链表是空的并没有对象可被转移，直接返回false。\n\n　　​`head.readIndex == LINK_CAPACITY`​ 判断当前头结点中的对象是否已经被转移完毕，如果当前头结点中的对象已经被全部转移完毕，则将head指针更新 relink 为下一个节点，开始从下一个节点开始转移对象。如果此时Link链表已经为空了，直接返回false。\n\n```java\n private static final class Head {\n\n            //参数link为新的head节点，当前head指针指向的节点已经被回收完毕\n            void relink(Link link) {\n                //更新availableSharedCapacity，因为当前link节点中的待回收对象已经被转移完毕，所以需要增加availableSharedCapacity的值\n                reclaimSpace(LINK_CAPACITY);\n                //head指针指向新的头结点（第一个未被回收完毕的link节点）\n                this.link = link;\n            }\n            private void reclaimSpace(int space) {\n                //所有回收线程都可以看到，这个值是所有回收线程共享的。以便可以保证所有回收线程回收的对象总量不能超过availableSharedCapacity\n                availableSharedCapacity.addAndGet(space);\n            }\n}\n```\n\n#### 10.5.2 根据本次转移对象容量评估是否应该对Stack进行扩容\n\n　　此时Head节点已经校验完毕，可以执行正常的转移逻辑了。但在转移逻辑正式开始之前，还需要对本次转移对象的容量进行计算，并评估Stack的当前容量是否可以容纳的下，如果Stack的当前容量不够，则需要对Stack进行扩容。\n\n```java\n            final int srcStart = head.readIndex;\n            //writeIndex\n            int srcEnd = head.get();\n            //该link节点可被转移的对象容量\n            final int srcSize = srcEnd - srcStart;\n            if (srcSize == 0) {\n                return false;\n            }\n\n            // 获取创建线程stack中的当前回收对象数量总量\n            final int dstSize = dst.size;\n            // 待回收对象从weakOrderQueue中转移到stack后，stack的新容量 = 转移前stack容量 + 转移的待回收对象个数\n            final int expectedCapacity = dstSize + srcSize;\n\n            if (expectedCapacity > dst.elements.length) {\n                //如果转移后的stack容量超过当前stack的容量 则对stack进行扩容\n                final int actualCapacity = dst.increaseCapacity(expectedCapacity);\n                //每次转移最多一个Link的容量\n                //actualCapacity - dstSize表示扩容后的stack还有多少剩余空间\n                srcEnd = min(srcStart + actualCapacity - dstSize, srcEnd);\n            }\n```\n\n　　获取Link链表头结点的readIndex和writeIndex，通过  `writeIndex - readIndex`​ 计算出当前头结点有多少可被转移的对象。\n\n　　Stack的最终容量为： `expectedCapacity = stack当前容量 + 转移对象的容量`​。\n\n　　如果计算得出转移后Stack的最终容量 expectedCapacity 超过了Stack的当前容量则需要对Stack进行扩容。根据扩容后的容量最终决定本次转移多少对象： `min(srcStart + actualCapacity - dstSize, srcEnd)`​ ，确保不能超过Stack可容纳的空间。\n\n```java\nprivate static final class Stack<T> {\n\n        int increaseCapacity(int expectedCapacity) {\n            int newCapacity = elements.length;\n            int maxCapacity = this.maxCapacity;\n            do {\n                newCapacity <<= 1;\n            } while (newCapacity < expectedCapacity && newCapacity < maxCapacity);\n            //扩容后的新容量为最接近指定容量expectedCapacity的最大2的次幂\n            newCapacity = min(newCapacity, maxCapacity);\n            if (newCapacity != elements.length) {\n                elements = Arrays.copyOf(elements, newCapacity);\n            }\n\n            return newCapacity;\n        }\n\n}\n```\n\n　　如果当前Stack已经达到最大容量，无法再继续扩容：`actualCapacity - dstSize = 0`​，则停止本次转移操作，直接返回`false`​。\n\n```java\nif (srcStart != srcEnd) {\n   .....具体的转移逻辑.......\n}else {\n    // The destination stack is full already.\n    return false;\n}\n```\n\n　　​**如果Stack的容量可以容纳头结点中存储的待转移对象，则开始正式的转移逻辑**​：\n\n#### 10.5.3 转移回收对象\n\n```java\n                //待转移对象集合 也就是Link节点中存储的元素\n                final DefaultHandle[] srcElems = head.elements;\n                //stack中存储转移对象数组\n                final DefaultHandle[] dstElems = dst.elements;\n                int newDstSize = dstSize;\n                for (int i = srcStart; i < srcEnd; i++) {\n                    DefaultHandle<?> element = srcElems[i];\n                    //recycleId == 0 表示对象还没有被真正的回收到stack中\n                    if (element.recycleId == 0) {\n                        //设置recycleId 表明是被哪个weakOrderQueue回收的\n                        element.recycleId = element.lastRecycledId;\n                    } else if (element.recycleId != element.lastRecycledId) {\n                        //既被创建线程回收 同时也被回收线程回收  回收多次 则停止转移\n                        throw new IllegalStateException(\"recycled already\");\n                    }\n                    //对象转移后需要置空Link节点对应的位置\n                    srcElems[i] = null;\n\n                    //这里从weakOrderQueue将待回收对象真正回收到所属stack之前 需要进行回收频率控制\n                    if (dst.dropHandle(element)) {\n                        // Drop the object.\n                        continue;\n                    }\n                    //重新为defaultHandler设置其所属stack(初始创建该handler的线程对应的stack)\n                    //该defaultHandler在被回收对象回收的时候，会将其stack置为null，防止极端情况下，创建线程挂掉，对应stack无法被GC\n                    element.stack = dst;\n                    //此刻，handler才真正的被回收到所属stack中\n                    dstElems[newDstSize ++] = element;\n                }\n```\n\n　　将当前Link节点中的elements数组里存储的对象转移至Stack中的数组栈elements中。转移范围 `srcStart  ->  srcEnd `​。\n\n　　如果当前转移对象 `element.recycleId == 0`​ 说明当前对象还没有被真正的回收至创建线程对应的Stack中，符合转移条件（不能被多次回收）。还记不记得我们前边在《9.3 从Stack中获取池化对象》小节介绍的：\n\n* ​`recycleId = lastRecycledId = 0`​：表示池化对象刚刚被创建或者刚刚从对象池中取出即将被再次复用。这是池化对象的初始状态。\n\n　　随后设置回收Id `element.recycleId = element.lastRecycledId`​。此处的lastRecycledId为当前WeakOrderQueue节点对应的回收线程Id。\n\n　　​`element.recycleId != element.lastRecycledId`​ 此处表示当前对象可能被创建线程回收了，也可能被回收线程回收了。\n\n　　如果当前转移对象已经被回收至Stack中，则不能被再次回收，停止转移。\n\n#### 10.5.4 控制对象回收频率\n\n　　符合转移条件的对象，需要再次经过回收频率的控制，即前边介绍的只回收 1 / 8 的对象，也就是每 8 个对象回收 1 个。\n\n```java\n        boolean dropHandle(DefaultHandle<?> handle) {\n            if (!handle.hasBeenRecycled) {\n                //回收计数handleRecycleCount 初始值为8 这样可以保证创建的第一个对象可以被池化回收\n                //interval控制回收频率 8个对象回收一个\n                if (handleRecycleCount < interval) {\n                    handleRecycleCount++;\n                    // Drop the object.\n                    return true;\n                }\n                //回收一个对象后，回收计数清零\n                handleRecycleCount = 0;\n                //设置defaultHandler的回收标识为true\n                handle.hasBeenRecycled = true;\n            }\n            return false;\n        }\n```\n\n　　当对象通过了回收频率的验证之后，最后将回收对象的DefaultHandler中持有的Stack引用再次设置为其创建线程对应的Stack。因为在回收线程将池化对象回收至WeakOrderQueue节点时，会将其DefaultHandler中对Stack的引用置为null。所以这里需要重置回来。\n\n> 具体为什么在回收线程回收时会将回收对象的Stack引用置为null，大家这里可以自己先思考下，等到后面我们讲解多线程回收时，笔者在为大家揭开谜底。\n\n　　随后会将对象压入Stack结构中的数组栈中，到这里，回收线程帮助创建线程回收的对象才算真正的被回收了，业务线程可以直接从对象池中取出使用了。\n\n　　当对象转移完毕后，更新当前Link节点的readIndex，更新Stack中数组栈的栈顶指针。如果当前Link节点已经被转移完毕，则Head指针指向链表中的下一个节点，开始等待下一次的转移。\n\n```java\n             if (srcEnd == LINK_CAPACITY && head.next != null) {\n                    // Add capacity back as the Link is GCed.\n                    // 如果当前Link已经被回收完毕，且link链表还有后续节点，则更新head指针\n                    this.head.relink(head.next);\n                }\n\n                //更新当前回收Link的readIndex\n                head.readIndex = srcEnd;\n                //如果没有转移任何数据 return false\n                if (dst.size == newDstSize) {\n                    return false;\n                }\n                dst.size = newDstSize;\n                return true;\n```\n\n　　到现在为止，多线程从Recycler对象池中无锁化获取对象的完整流程，笔者就为大家介绍完了，下面我们来继续剖析下多线程回收对象的场景。\n\n## 11. 多线程回收对象无锁化实现\n\n　　之前我们在介绍池化对象的设计时，提到业务线程在使用对象的时候不应该感受到对象池的存在，所以将池化对象的回收，封装在其DefaultHandler中。在业务线程使用完对象时，直接调用池化对象的recycle方法进行回收即可。\n\n![image.png](/assets/58038d8ee0344260875993d8636331d5tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-lhvub6f.awebp)\n\n```java\nstatic final class Entry {\n\n       private  Handle<Entry> handle;\n\n       void recycle() {\n            next = null;\n            bufs = null;\n            buf = null;\n            msg = null;\n            promise = null;\n            progress = 0;\n            total = 0;\n            pendingSize = 0;\n            count = -1;\n            cancelled = false;\n            handle.recycle(this);\n        }\n\n}\n```\n\n```java\nprivate static final class DefaultHandle<T> implements Handle<T> {\n      \n        ..................省略............\n\n        //强引用关联创建handler的stack\n        Stack<?> stack;\n        //池化对象\n        Object value;\n\n        @Override\n        public void recycle(Object object) {\n            if (object != value) {\n                throw new IllegalArgumentException(\"object does not belong to handle\");\n            }\n\n            Stack<?> stack = this.stack;\n            //handler初次创建以及从对象池中获取到时  recycleId = lastRecycledId = 0（对象被回收之前）\n            //创建线程回收对象后recycleId = lastRecycledId = OWN_THREAD_ID\n            //回收线程回收对象后lastRecycledId = 回收线程Id,当对象被转移到stack中后 recycleId = lastRecycledId = 回收线程Id\n            if (lastRecycledId != recycleId || stack == null) {\n                throw new IllegalStateException(\"recycled already\");\n            }\n\n            stack.push(this);\n        }\n\n}\n```\n\n　　DefaultHandler中的 recycle 方法逻辑比较简单，唯一不好理解的地方在于判断对象是否已经被回收的 if 条件语句。\n\n* ​`lastRecycledId != recycleId`​ ：此时对象的状态正处于已经被回收线程回收至对应 WeakOrderQueue 节点的半回收状态，但还未被转移至其创建线程对应的Stack中。​**所以这个条件要控制的事情就是如果对象已经被回收线程回收，那么就停止本次的回收操作**​。\n\n> 忘记的同学可以在回看下《9.3 从Stack中获取池化对象》小节，那里详细介绍了 recycleId 和 lastRecycledId 之间各种关系的变化及其含义\n\n* ​`stack == null`​ ：这种情况其实前边我们也有提到过，就是当池化对象对应的创建线程挂掉的时候，对应的Stack随后也被GC回收掉。那么这时就不需要在回收该池化对象了。\n\n### 11.1 回收对象至Stack中——啊哈！Bug!\n\n```java\nprivate static final class Stack<T> {\n        //持有对应创建线程的弱引用\n        final WeakReference<Thread> threadRef;\n\n        void push(DefaultHandle<?> item) {\n            Thread currentThread = Thread.currentThread();\n            //判断当前线程是否为创建线程  对象池的回收原则是谁创建，最终由谁回收。其他线程只是将回收对象放入weakOrderQueue中\n            //最终是要回收到创建线程对应的stack中的\n            if (threadRef.get() == currentThread) {\n                // 如果当前线程正是创建对象的线程，则直接进行回收 直接放入与创建线程关联的stack中\n                pushNow(item);\n            } else {\n                // 当前线程不是创建线程，则将回收对象放入创建线程对应的stack中的weakOrderQueue链表相应节点中（currentThread对应的节点）\n                pushLater(item, currentThread);\n            }\n        }\n}\n```\n\n　　这里会进入到池化对象DefaultHandler中持有的Stack中，在Stack中进行对象的回收。\n\n> 大家这里先不要看笔者下面的解释，试着自己着重分析下这个 if...else...逻辑判断，有没有发现什么问题？？Bug就在这里！！\n\n　　这里首先会判断当前回收线程是否为池化对象的创建线程：`threadRef.get() == currentThread)`​。如果是，则由创建线程直接回收 pushNow(item) 。\n\n　　如果 `threadRef.get() != currentThread)`​ 这里有两种情况：\n\n1. currentThread是回收线程，那么就按多线程回收的逻辑 `pushLater(item, currentThread)`​ ，由回收线程将对象回收至其对应的WeakOrderQueue节点中，这里没什么毛病。\n2. Bug就出现在第二种情况，还有一种情况是 `threadRef.get()  == null`​ 也会走到 else 分支里。表示该回收对象的创建线程已经挂掉，并被GC回收。​**那么在这种情况下已经没有必要在对该对象进行回收了**​，因为创建线程已经挂掉，随后对应的Stack也迟早被GC掉，​**这个对象即使被回收进Stack也永远不会在被使用到**​。但是Netty的做法还是会让回收线程将其回收至Stack中的WeakOrderQueue链表中，笔者认为这里根本就没必要在添加至WeakOrderQueue链表中了。\n\n　　Bug产生的场景如下如所示：\n\n![image.png](/assets/53c6380455754787a12800dbf1e48a06tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-0takv3w.awebp)\n\n　　​**在第二种情况下，Netty还有一个重要的场景没有考虑到，会导致内存泄露**​！！\n\n　　什么场景呢？大家再来回顾下池化对象与对象池之间的引用关系图：\n\n![image.png](/assets/f43dc00e2347458c876f15dae66f23d4tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-lapokvs.awebp)\n\n　　这里我们看到池化对象会引用DefaultHandler，而DefaultHandler又强引用了Stack。于是就形成了这样一条引用链：\n\n![image.png](/assets/c2b0e2f9f93449e7b86ef71e2bac35e9tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-8xtfk94.awebp)\n\n　　而池化对象是对外暴露的，用户可能在某个地方一直引用着这个池化对象，如果创建线程挂掉，并被GC回收之后，那么其在对象池中对应的Stack也应该被回收，因为Stack里保存的回收对象将再也不会被用到了。但是因为这条引用链的存在，导致Stack无法被GC回收从而造成内存泄露！\n\n## 11.2 笔者反手一个PR，修复这个Bug!\n\n　　现在Bug产生的原因和造成的影响，笔者为大家已经分析清楚了，那么接下来的解决方案就变得很简单了。\n\n　　笔者先向Netty社区提了一个 Issue11864 来说明这个问题。\n\n> Issue11864 : [github.com/netty/netty…](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fnetty%2Fnetty%2Fissues%2F11864 \"https://github.com/netty/netty/issues/11864\")\n\n　　然后直接提了 PR11865 来修复这个Bug。\n\n> PR : [github.com/netty/netty…](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fnetty%2Fnetty%2Fpull%2F11865 \"https://github.com/netty/netty/pull/11865\")\n\n　　PR中主要的修改点分为以下两点：\n\n1. 笔者在修复方案中觉得在这里应该尽早处理掉 `threadRef.get()  == null`​ 的情况，因为创建线程已经死掉，此时在为创建线程回收对象已经没有任何意义了，这种情况直接 return 掉就好。\n2. 由于池化对象强引用到了其创建线程对应的Stack，当创建线程挂掉之后，我们需要解除这个引用链 `item.stack = null`​，保证Stack最终可以被GC回收。\n\n　　以下代码为笔者提交的PR中的修复方案，主要增加了对 `threadRef.get()  == null`​ 情况的处理，并添加了详细注释。\n\n```java\n        void push(DefaultHandle<?> item) {\n            Thread currentThread = Thread.currentThread();\n            if (threadRef.get() == currentThread) {\n                pushNow(item);\n            } else if (threadRef.get() == null) {\n                // when the thread that belonged to the Stack was died or GC'ed，\n                // There is no need to add this item to WeakOrderQueue-linked-list which belonged to the Stack any more\n                item.stack = null;\n            } else {\n                pushLater(item, currentThread);\n            }\n        }\n```\n\n## 11.3 PR的后续\n\n　　当笔者提交了 PR11865之后，得到了相关作者如下回复。\n\n![image.png](/assets/84c1132caafa47e1a56f670b0ac349aetplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-czmjytj.awebp)\n\n　　巧合的是Netty也意识到了对象池这块的问题，Netty最近也正在重构 Recycler 这一块，因为Recycler整体设计的还是比较复杂的，这从我们这篇源码解析的文章中也可以看的出来，Recycler的复杂性在于它的使用场景混合了**并发**以及与​**GC相关的交互**​，这些相关的问题都比较难以定位，所以Netty决定将对象池这一块用一种更加容易被理解的方式重构掉。\n\n　　相关的重构内容大家可以看作者的这个commit。\n\n> 重构commit：[github.com/netty/netty…](https://github.com/netty/netty/commit/28b9834612638ffec4948c0c650d04f766f20690)\n\n　　重构后的Recycler对象池在**4.1.71.Final**版本已经发布。笔者后续也会为大家安排一篇重构后的Recycler对象池源码解析，但是本文还是聚焦于**4.1.71.Final**之前版本的对象池介绍，虽然被重构了，但是这里也有很多的设计思想和多线程程序设计细节非常值得我们学习！\n\n　　在**4.1.71.Final**版本发布之后，笔者想的是后面抽空看下重构后的对象池实现，哈哈，只要谓语动词出现—— ”想的是.....“ 类似这样的句式，估计就没有以后了，哈哈。笔者还是大意了，这个 Issue11864 : [github.com/netty/netty…](https://github.com/netty/netty/issues/11864) 在过了几个月之后在社区里又被讨论了起来。有人发现在**4.1.71.Final**对象池重构后的版本中笔者提到的这些问题还是存在的。\n\n　　于是作者 chrisvest 又 提了一个 PR11996 最终在 **4.1.74.Final**版本中修复了笔者提的这个 Issue11864。\n\n> PR11996 ：[github.com/netty/netty…](https://github.com/netty/netty/pull/11996)\n\n> 随口提一句，这个大牛 chrisvest 是大名鼎鼎的图数据库 Neo4j 的核心commitor，同时也是Netty Buffer相关API的设计者。\n\n　　这里笔者将这个Bug在 **4.1.74.Final** 版本中的最终修复方案和大家说明一下，收个尾。\n\n1. 首先 chrisvest 大牛 认为 当创建线程挂掉的时候，我们可以在threadLocal的 onRemoval方法中将创建线程对应的LocalPool里边用于存放回收对象的pooledHandles 直接置为 null。这里的语义是标记LocalPool已经死掉了，不会再继续使用。\n\n> 在重构后的版本中引入了 LocalPool 来代替我们前边介绍的Stack。LocalPool中的pooledHandles大家可以简单认为类似Stack中数组栈的功能。\n\n```java\npublic abstract class Recycler<T> {\n\n    private final FastThreadLocal<LocalPool<T>> threadLocal = new FastThreadLocal<LocalPool<T>>() {\n        @Override\n        protected LocalPool<T> initialValue() {\n            return new LocalPool<T>(maxCapacityPerThread, interval, chunkSize);\n        }\n\n        @Override\n        protected void onRemoval(LocalPool<T> value) throws Exception {\n            //删除LocalPool\n            super.onRemoval(value);\n            MessagePassingQueue<DefaultHandle<T>> handles = value.pooledHandles;\n            //pooledHandles 置为 null，取消引用\n            value.pooledHandles = null;\n            //清除LocalPool中保存的回收对象\n            handles.clear();\n        }\n    };\n\n}\n```\n\n2. 在多线程回收对象的时候，会首先判断该回收对象对应的LocalPool里的pooledHandles是否已经被清理变为不可用状态。如果是的话就停止回收。\n\n```java\nprivate static final class LocalPool<T> {\n    //保证可见性\n    private volatile MessagePassingQueue<DefaultHandle<T>> pooledHandles;\n\n     void release(DefaultHandle<T> handle) {\n            MessagePassingQueue<DefaultHandle<T>> handles = pooledHandles;\n            handle.toAvailable();\n            if (handles != null) {\n                handles.relaxedOffer(handle);\n            }\n        }\n}\n```\n\n　　通过以上两个措施 就保证了 当创建线程被GC掉之后，它对应的 在对象池中的回收缓存LocalPool（类比Stack）不会出现内存泄露，同时保证了多线程不在将回收对象至已经被清理的LocalPool中。\n\n　　好了，这一块的Bug修改我们介绍完了，我们继续多线程回收对象主流程的介绍：\n\n### 11.4 创建线程直接回收对象\n\n```java\n       private void pushNow(DefaultHandle<?> item) {\n            //池化对象被回收前 recycleId = lastRecycleId = 0\n            //如果其中之一不为0 说明已经被回收了\n            if ((item.recycleId | item.lastRecycledId) != 0) {\n                throw new IllegalStateException(\"recycled already\");\n            }\n\n            //此处是由创建线程回收，则将池化对象的recycleId与lastRecycleId设置为创建线程Id-OWN_THREAD_ID\n            //注意这里的OWN_THREAD_ID是一个固定的值，是因为这里的视角是池化对象的视角，只需要区分创建线程和非创建线程即可。\n            //对于一个池化对象来说创建线程只有一个 所以用一个固定的OWN_THREAD_ID来表示创建线程Id\n            item.recycleId = item.lastRecycledId = OWN_THREAD_ID;\n\n            int size = this.size;\n            //如果当前池化对象的容量已经超过最大容量 则丢弃对象\n            //为了避免池化对象的急速膨胀，这里只会回收1/8的对象，剩下的对象都需要丢弃\n            if (size >= maxCapacity || dropHandle(item)) {\n                // Hit the maximum capacity or should drop - drop the possibly youngest object.\n                //丢弃对象\n                return;\n            }\n\n            //当前线程对应的stack容量已满但是还没超过最大容量限制，则对stack进行扩容\n            if (size == elements.length) {\n                //容量扩大两倍\n                elements = Arrays.copyOf(elements, min(size << 1, maxCapacity));\n            }\n            //将对象回收至当前stack中\n            elements[size] = item;\n            //更新当前stack的栈顶指针\n            this.size = size + 1;\n        }\n```\n\n* 首先需要判断该回收对象是否已经被回收了。`item.recycleId | item.lastRecycledId) != 0`​，这里任意Id只要不为0，说明该对象已经对回收了，则停止本次回收操作。\n* 当对象被创建线程回收时，设置回收Id：`item.recycleId = item.lastRecycledId = OWN_THREAD_ID`​。\n* 如果当前Stack已经达到最大容量则将对象丢弃。\n* 为了避免对象池不可控制的迅速膨胀，这里只会回收 1 / 8 的对象，剩下的对象都需要丢弃 dropHandle 。\n* 如果当前Stack容量已满但是还没超过最大容量限制，则对stack进行扩容。一次性扩容两倍但不能超过最大容量。\n* 最后将对象压入Stack结构中的数组栈中，完成对象的回收。\n\n### 11.5 回收线程间接回收对象\n\n![image.png](/assets/e87ee465af764c47866e1f69a22d065atplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-ms062uc.awebp)\n\n　　在Recycler对象池中，一个线程既可以是创建线程也可以是回收线程。\n\n　　比如上图中的 thread2 , thread3 , thread4 ...  这里的每一个线程既可以在对象池中创建对象，并将对象回收至自己对应的Stack结构里的数组栈中，此刻它们的角色为创建线程。比如图中的thread1。\n\n　　同时其他线程 比如图中的 thread2 , thread3 , thread4 ... 也可以为thread1回收由thread1创建的对象，将这些对象回收至thread1对应的Stack结构里的WeakOrderQueue链表中。此刻 thread2 , thread3 , thread4 ...  为回收线程。\n\n　　在之前介绍Recycler对象池的重要属性时，我们提到过 maxDelayedQueuesPerThread 属性。\n\n```java\npublic abstract class Recycler<T> {\n\n      //每个回收线程最多可以帮助多少个创建线程回收对象 默认：cpu核数 * 2\n      private static final int MAX_DELAYED_QUEUES_PER_THREAD;\n\n     //一个回收线程可帮助多少个创建线程回收对象\n      private final int maxDelayedQueuesPerThread;\n\n      private static final class Stack<T> {\n\n            // 当前线程可以帮助多少个线程回收其池化对象\n            private final int maxDelayedQueues;\n\n      }\n\n}\n\n```\n\n　　在Recycler对象池中，一个回收线程能够帮助多少个创建线程回收对象是有限制的，通过 maxDelayedQueuesPerThread属性 控制。\n\n　　​**那么在对象池中，一个回收线程如何存储为其他创建线程回收到的对象呢**​？\n\n![image.png](/assets/ec983e41a4b54a31a1f7f7c9ec511974tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-8ibqfew.awebp)\n\n　　如图中所示，我们站在回收线程的视角来看，在对象池中有一个 FastThreadLocal 类型的 DELAYED_RECYCLED 字段， DELAYED_RECYCLED 为每个回收线程保存了一个 WeakHashMap，正是这个回收线程持有的 WeakHashMap 结构中保存了该回收线程为每个创建线程回收的对象。\n\n　　WeakHashMap 结构中的 key 表示创建线程对应的 Stack 结构。意思是该回收线程为哪个创建线程回收对象。value 表示这个回收线程在创建线程中对应Stack结构里的WeakOrderQueue链表中对应的节点。大家在结合 《Recycler对象池.png》 这副图仔细体会下这个结构设计。\n\n```java\npublic abstract class Recycler<T> {\n\n    //实现跨线程回收的核心，这里保存的是当前线程为其他线程回收的对象（由其他线程创建的池化对象）\n    //key: 池化对象对应的创建线程stack  value: 当前线程代替该创建线程回收的池化对象 存放在weakOrderQueue中\n    //这里的value即是 创建线程对应stack中的weakOrderQueue链表中的节点（每个节点表示其他线程为当前创建线程回收的对象）\n    private static final FastThreadLocal<Map<Stack<?>, WeakOrderQueue>> DELAYED_RECYCLED =\n            new FastThreadLocal<Map<Stack<?>, WeakOrderQueue>>() {\n        @Override\n        protected Map<Stack<?>, WeakOrderQueue> initialValue() {\n            return new WeakHashMap<Stack<?>, WeakOrderQueue>();\n        }\n    };\n\n}\n```\n\n　　而这个WeakHashMap 的size即表示当前回收线程已经在为多少个创建线程回收对象了，size的值不能超过 maxDelayedQueuesPerThread 。\n\n　　​**这里为什么要用WeakHashMap呢**​?\n\n　　其实我们前边多少也提到过了，考虑到一种极端的情况就是当创建线程挂掉并且被GC回收之后，其实这个创建线程对应的Stack结构已经没有用了，存储在Stack结构中的池化对象永远不会再被使用到，此时回收线程完全就没有必要在为挂掉的创建线程回收对象了。而这个Stack结构如果没有任何引用链存在的话，随后也会被GC回收。那么这个Stack结构在WeakHashMap中对应的Entry也会被自动删除。如果这里不采用WeakHashMap，那么回收线程为该Stack回收的对象就会一直停留在回收线程中。\n\n　　介绍完这些背景知识，下面我们就来正式介绍下回收线程到底是如何帮助创建线程回收对象的：\n\n```java\n      private void pushLater(DefaultHandle<?> item, Thread thread) {\n            //maxDelayQueues == 0 表示不支持对象的跨线程回收\n            if (maxDelayedQueues == 0) {\n                //直接丢弃\n                return;\n            }\n          \n            //注意这里的视角切换，当前线程为回收线程\n            Map<Stack<?>, WeakOrderQueue> delayedRecycled = DELAYED_RECYCLED.get();\n            //获取当前回收对象属于的stack 由当前线程帮助其回收  注意这里是跨线程回收 当前线程并不是创建线程\n            WeakOrderQueue queue = delayedRecycled.get(this);\n            //queue == null 表示当前线程是第一次为该stack回收对象\n            if (queue == null) {\n                //maxDelayedQueues指示一个线程最多可以帮助多少个线程回收其创建的对象\n                //delayedRecycled.size()表示当前线程已经帮助多少个线程回收对象\n                if (delayedRecycled.size() >= maxDelayedQueues) {\n              \n                    //如果超过指定帮助线程个数，则停止为其创建WeakOrderQueue，停止为其回收对象\n                    //WeakOrderQueue.DUMMY这里是一个标识，后边遇到这个标识  就不会为其回收对象了\n                    delayedRecycled.put(this, WeakOrderQueue.DUMMY);\n                    return;\n                }\n \n                // 创建为回收线程对应的WeakOrderQueue节点以便保存当前线程为其回收的对象\n                if ((queue = newWeakOrderQueue(thread)) == null) {\n                    // 创建失败则丢弃对象\n                    return;\n                }\n                //在当前线程的threadLocal中建立 回收对象对应的stack 与 weakOrderQueue的对应关系\n                delayedRecycled.put(this, queue);\n            } else if (queue == WeakOrderQueue.DUMMY) {\n                // drop object\n                // 如果queue的值是WeakOrderQueue.DUMMY 表示当前已经超过了允许帮助的线程数 直接丢弃对象\n                return;\n            }\n\n            //当前线程为对象的创建线程回收对象  放入对应的weakOrderQueue中\n            queue.add(item);\n        }\n```\n\n1. 首先需要判断当前Recycler对象池是否支持跨线程回收。 `maxDelayedQueues == 0`​ 表示不支持对象的跨线程回收。\n2. 如果当前回收线程是第一次为该回收对象的创建线程进行回收，则需要为当前回收线程在对象的创建线程对应Stack结构中创建对应的WeakOrderQueue节点。（​**这里正是多线程无锁化回收对象的核心所在**​）。当然创建之前需要判断是否超过了可帮助创建线程的个数 maxDelayedQueues 。\n3. 如果当前回收线程帮助的创建线程个数已经超过了 maxDelayedQueues 限制，则向对应的 WeakHashMap 塞入一个空的 WeakOrderQueue节点 DUMMY，后续如果遇到 WeakOrderQueue 节点是 DUMMY 实例则丢弃对象，放弃回收。\n\n```java\n private static final class WeakOrderQueue extends WeakReference<Thread> {\n        //作为一个标识，遇到DUMMY实例，则直接丢弃回收对象\n        static final WeakOrderQueue DUMMY = new WeakOrderQueue();\n\n}\n```\n\n4. 如果当前回收线程帮助的创建线程个数还没有超过 maxDelayedQueues 限制，则通过 `stack#newWeakOrderQueue`​ 为当前回收线程在回收对象对应Stack结构中创建相应的WeakOrderQueue节点。并在回收线程持有的WeakHashMap中建立Stack与回收线程对应的WeakOrderQueue节点的关联关系。\n5. 最终由回收线程将对象回收至其创建线程对应的Stack结构中。（将回收对象添加至回收线程对应的WeakOrderQueue节点中，完成多线程无锁化回收）\n\n### 11.6  为回收线程创建对应的WeakOrderQueue节点\n\n　　上小节提到，当回收线程第一次为创建线程回收对象的时候，需要在创建线程对应Stack结构中的WeakOrderQueue链表中创建与回收线程对应的WeakOrderQueue节点。\n\n```java\n   private static final class Stack<T> {\n\n         private WeakOrderQueue newWeakOrderQueue(Thread thread) {\n              return WeakOrderQueue.newQueue(this, thread);\n        }\n   }\n```\n\n![image.png](/assets/13ba4ffef43045ba8ed42101aefd3d72tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-i9veirg.awebp)\n\n```java\nprivate static final class WeakOrderQueue extends WeakReference<Thread> {\n\n        static WeakOrderQueue newQueue(Stack<?> stack, Thread thread) {\n  \n            // link是weakOrderQueue中存储回收对象的最小结构，此处是为接下来要创建的Link预订空间容量\n            // 如果stack指定的availableSharedCapacity 小于 LINK_CAPACITY大小，则分配失败\n            if (!Head.reserveSpaceForLink(stack.availableSharedCapacity)) {\n                return null;\n            }\n\n            //如果还够容量来分配一个link那么就创建weakOrderQueue\n            final WeakOrderQueue queue = new WeakOrderQueue(stack, thread);\n\n            // 向stack中的weakOrderQueue链表中添加当前回收线程对应的weakOrderQueue节点（始终在头结点处添加节点 ）\n            // 此处向stack中添加weakOrderQueue节点的操作被移到WeakOrderQueue构造器之外的目的是防止WeakOrderQueue.this指针\n            // 逃逸避免被其他线程在其构造的过程中访问\n            stack.setHead(queue);\n\n            return queue;\n        }\n\n}\n```\n\n　　在前边介绍WeakOrderQueue的结构的时候，我们提到WeakOrderQueue结构内部其实一个由Link节点组成的链表。WeakOrderQueue在初始状态下是只包含一个Link节点的链表。\n\n　　所有在创建WeakOrderQueue结构的时候需要同时为其创建一个Link节点。而这些Link节点正是真正保存回收线程所回收到的对象的地方。\n\n　　而对于一个创建线程来说它的所有回收线程能够为其回收对象的总量是被availableSharedCapacity 限制的，每创建一个Link节点，它的值就减少一个LINK_CAPACITY ，每释放一个Link节点，它的值就增加一个LINK_CAPACITY 。这样就能保证所有回收线程的回收总量不会超过 availableSharedCapacity 的限制。\n\n　　所以在为WeakOrderQueue结构创建首个Link节点时，需要判断**当前所有回收线程回收的对象总量**是否已经超过了 availableSharedCapacity 。如果容量还够回收一个Link大小的对象，则开始创建WeakOrderQueue结构。\n\n　　如果当前回收容量已经超过availableSharedCapacity或者不足回收一个Link大小的对象，则停止创建WeakOrderQueue节点，回收流程终止。不在对该回收对象进行回收。\n\n```java\n            //此处目的是为接下来要创建的link预留空间容量\n            static boolean reserveSpaceForLink(AtomicInteger availableSharedCapacity) {\n                for (;;) {\n                    //获取stack中允许异线程回收对象的总容量（异线程还能为该stack收集多少对象）\n                    int available = availableSharedCapacity.get();\n                    //当availbale可供回收容量小于一个Link时，说明异线程回收对象已经达到上限，不能在为stack回收对象了\n                    if (available < LINK_CAPACITY) {\n                        return false;\n                    }\n                    //为Link预留到一个Link的空间容量，更新availableSharedCapacity\n                    if (availableSharedCapacity.compareAndSet(available, available - LINK_CAPACITY)) {\n                        return true;\n                    }\n                }\n            }\n```\n\n　　这里的预订容量其实就是将 availableSharedCapacity 的值减去一个 LINK_CAPACITY 大小。其他回收线程会看到这个 availableSharedCapacity 容量的变化，方便决定是否继续为创建线程回收对象。\n\n　　当为WeakOrderQueue结构的首个Link节点预订容量成功后，就开始创建WeakOrderQueue节点。\n\n```java\n        //为了使stack进行GC,这里不会持有其所属stack的引用\n        private WeakOrderQueue(Stack<?> stack, Thread thread) {\n            //weakOrderQueue持有对应跨线程的弱引用\n            super(thread);\n            //创建尾结点\n            tail = new Link();\n\n            // 创建头结点  availableSharedCapacity = maxCapacity / maxSharedCapacityFactor\n            // 此时availableSharedCapacity的值已经变化了，减去了一个link的大小\n            head = new Head(stack.availableSharedCapacity);\n            head.link = tail;\n            interval = stack.delayedQueueInterval;\n            handleRecycleCount = interval; \n        }\n```\n\n　　当回收线程对应的WeakOrderQueue节点创建成功后，就将其插入到回收对象对应的Stack结构里的WeakOrderQueue链表中的头结点处。因为这里可能会涉及多个回收线程并发向WeakOrderQueue链表头结点处添加节点，所以更新Stack结构中WeakOrderQueue链表头结点的方法被设计成同步方法。这也是整个Recycler 对象池设计中，唯一的一个同步方法。\n\n```java\n       synchronized void setHead(WeakOrderQueue queue) {\n            //始终在weakOrderQueue链表头结点插入新的queue（其他线程收集的由本线程创建的对象）\n            queue.setNext(head);\n            head = queue;\n        }\n```\n\n![image.png](/assets/523b778404c140a29621295d079be9f8tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-nuriy5k.awebp)\n\n### 11.7 向WeakOrderQueue节点中添加回收对象\n\n　　终于的终于我们到了多线程回收对象的最后一步了，本篇文章到这里也接近尾声了，大家在坚持一下。\n\n　　这里要做的事情就是，将回收对象添加到回收线程对应的WeakOrderQueue节点中，Netty会在Link链表的尾结点处添加回收对象，如果尾结点容量已满，就继续新创建一个Link。将回收对象添加到新的Link节点中。\n\n```java\n      void add(DefaultHandle<?> handle) {\n            //将handler中的lastRecycledId标记为当前weakOrderQueue中的Id,一个stack和一个回收线程对应一个weakOrderQueue节点\n            //表示该池化对象 最近的一次是被当前回收线程回收的。\n            handle.lastRecycledId = id;\n\n            // 控制异线程回收频率 只回收1/8的对象\n            // 这里需要关注的细节是其实在scavengeSome方法中将weakOrderQueue中的待回收对象转移到创建线程的stack中时，Netty也会做回收频率的限制\n            // 这里在回收线程回收的时候也会控制回收频率（总体控制两次）netty认为越早的做回收频率控制越好 这样可以避免weakOrderQueue中的容量迅速的增长从而失去控制\n            if (handleRecycleCount < interval) {\n                handleRecycleCount++;\n                // Drop the item to prevent recycling to aggressive.\n                return;\n            }\n            handleRecycleCount = 0;\n\n            //从尾部link节点开始添加新的回收对象\n            Link tail = this.tail;\n            int writeIndex;\n\n            //如果当前尾部link节点容量已满，就需要创建新的link节点\n            if ((writeIndex = tail.get()) == LINK_CAPACITY) {\n                //创建新的Link节点\n                Link link = head.newLink();\n                //如果availableSharedCapacity的容量不够了，则无法创建Link。丢弃待回收对象\n                if (link == null) {\n                    // 丢弃对象\n                    return;\n                }\n                // We allocate a Link so reserve the space\n                //更新尾结点\n                this.tail = tail = tail.next = link;\n\n                writeIndex = tail.get();\n            }\n\n            //将回收对象handler放入尾部link节点中\n            tail.elements[writeIndex] = handle;\n            //这里将stack置为null，是为了方便stack被回收。\n            //如果Stack不再使用，期望被GC回收，发现handle中还持有stack的引用，那么就无法被GC回收，从而造成内存泄漏\n            //在从对象池中再次取出该对象时，stack还会被重新赋予\n            handle.stack = null;\n            //注意这里用lazySet来延迟更新writeIndex。只有当writeIndex更新之后，在创建线程中才可以看到该待回收对象\n            //保证线程最终可见而不保证立即可见的原因就是 其实这里Netty还是为了性能考虑避免执行内存屏障指令的开销。\n            //况且这里也并不需要考虑线程的可见性，当创建线程调用scavengeSome从weakOrderQueue链表中回收对象时，看不到当前节点weakOrderQueue\n            //新添加的对象也没关系，因为是多线程一起回收，所以继续找下一个节点就好。及时全没看到，大不了就在创建一个对象。主要还是为了提高weakOrderQueue的写入性能\n            tail.lazySet(writeIndex + 1);\n        }\n```\n\n1. 首先第一步就要设置回收对象DefaultHandler中的lastRecycledId ，将其设置为该回收线程Id，表示该回收对象最近一次是由当前回收线程回收的。此时的DefaultHandler中 `recycleId != lastRecycledId `​，对象处于半回收状态。\n2. 控制回收线程的回收频率（只回收 1 / 8 的对象），大家是否还记得我们在《9.5 转移回收对象》小节中介绍 `stack#scavengeSome方法`​ 的时候，在创建线程从Stack中的WeakOrderQueue链表中转移对象到数组栈中的时候，也会被回收频率进行控制，只转移 1 / 8 的对象。所以这里我们可以看到​**回收频率的控制在多线程回收对象的时候会控制两次**​，netty认为越早做回收频率控制越好这样可以避免weakOrderQueue中的容量迅速的增长从而失去控制。\n3. 在WeakOrderQueue结构中，当我们向Link链表添加回收对象时，都会向Link链表的尾结点中添加回收对象，如果当前尾结点容量已经满了 `writeIndex = tail.get()) == LINK_CAPACITY`​ ，我们就需要新创建一个Link节点，并将tail指针指向新的Link节点更新尾结点。最后将回收对象回收至新的尾结点中。当然我们要考虑到 availableSharedCapacity 容量的限制，如果容量不够了，就不能在新建Link节点，直接将回收对象丢弃，停止回收。\n\n```java\n    private static final class Head {\n\n             Link newLink() {\n                  //此处的availableSharedCapacity可能已经被多个回收线程改变，因为availableSharedCapacity是用来控制回收线程回收的总容量限制\n                  //每个回收线程再回收对象时都需要更新availableSharedCapacity\n                  return reserveSpaceForLink(availableSharedCapacity) ? new Link() : null;\n             }\n\n            //此处目的是为接下来要创建的link预留空间容量\n            static boolean reserveSpaceForLink(AtomicInteger availableSharedCapacity) {\n                for (;;) {\n                    //获取stack中允许异线程回收对象的总容量（异线程还能为该stack收集多少对象）\n                    int available = availableSharedCapacity.get();\n                    //当availbale可供回收容量小于一个Link时，说明异线程回收对象已经达到上限，不能在为stack回收对象了\n                    if (available < LINK_CAPACITY) {\n                        return false;\n                    }\n                    //为Link预留到一个Link的空间容量，更新availableSharedCapacity\n                    if (availableSharedCapacity.compareAndSet(available, available - LINK_CAPACITY)) {\n                        return true;\n                    }\n                }\n            }\n    }\n```\n\n　　到这里Recycler对象池的整个**多线程无锁化回收对象**的流程笔者就为大家介绍完了。\n\n　　但是这里还有两个点，笔者想要和大家再强调一下：\n\n　　​**第一：为什么这里会将handle.stack设置为null**​?\n\n　　不知大家还记不记得我们在介绍 `stack#scavengeSome方法`​ 的时候专门提到，在创建线程遍历WeakOrderQueue链表将链表中的待回收对象转移至stack中的数组栈时，会将待回收对象的DefaultHandler持有的stack重新设置为其创建线程对应的stack。\n\n```java\nboolean transfer(Stack<?> dst) {\n\n      .................省略..............\n\n      //重新为defaultHandler设置其所属stack(初始创建该handler的线程对应的stack)\n      //该defaultHandler在被回收对象回收的时候，会将其stack置为null，防止极端情况下，创建线程挂掉，对应stack无法被GC\n      element.stack = dst;\n\n      .................省略..............\n}\n```\n\n　　而这里在回收线程向WeakOrderQueue节点添加回收对象时先将 handle.stack设置为 null，而在转移回收对象时又将 handle.stack 设置回来，这不是多此一举吗？\n\n　　其实并不是多此一举，这样设计是非常有必要的，我们假设一种极端的情况，当创建线程挂掉并被GC回收之后，其实stack中存储的回收对象已经不可能在被使用到了，stack应该也被回收掉。但是如果这里回收线程在回收的时候不将对象持有的stack设置为null的话，直接添加到了WeakOrderQueue节点中，当创建被GC掉的时候，由于这条引用链的存在导致对应stack永远不会被GC掉，造成内存泄露。\n\n> 所以笔者在本文中多次强调，当我们在设计比较复杂的程序结构时，对于对象之间的引用关系，一定要时刻保持清晰的认识，防止内存泄露。\n\n　　​**第二：为什么最后使用lazySet来更新尾结点的writeIndex**​？\n\n　　当我们向Link链表的尾结点添加完回收对象之后，在更新尾结点的writeIndex时，使用到了延时更新，而延时更新并不会保证多线程的可见性，如果此时创建线程正在转移对象，那么将不会看到新添加进来的回收对象了。\n\n　　而事实上，我们这里并不需要保证线程之间的实时可见性，只需要保证最终可见性即可。\n\n　　确实在当创建线程转移对象的时候可能并不会看到刚刚被回收线程新添加进来的回收对象，看不到没关系，创建线程大不了在本次转移中不回收它不就完了么。因为只要创建线程Stack结构中的数组栈为空，创建线程就会从WeakOrderQueue链表中转移对象，以后会有很多次机会来WeakOrderQueu链表中转移对象，什么时候看见了，什么时候转移它。并不需要实时性。退一万步讲，即使全部看不到，大不了创建线程直接创建一个对象返回就行了。\n\n　　而如果这里要保证线程之间的实时可见性，在更新尾结点的writeIndex的时候就不得不插入 LOCK 前缀内存屏障指令保证多线程之间的实时可见性，而执行内存屏障指令是需要开销的，所以​**为了保证WeakOrderQueue的写入性能**​，Netty这里选择了只保证最终可见性而不保证实时可见性。\n\n---\n\n## 总结\n\n　　到这里关于Recycler对象池的整个设计与源码实现，笔者就为大家详细的剖析完毕了，在剖析的过程中，我们提炼出了很多多线程并发程序的设计要点和注意事项。大家可以在日常开发工作中多多体会并实践。\n\n　　虽然本文介绍的Recycler对象池整体设计将会在**4.1.71.Final**版本被重构，但是在当前版本Recycler对象池的设计和实现中，我们还是可以学习到很多东西的。\n\n　　笔者真心十分佩服能够耐心看到这里的大家，不知不觉已经唠叨了三万多字了，谢谢大家的观看~~，大家记得晚餐时给自己加餐个鸡腿奖励一下自己，哈哈！！\n","slug":"20250501-7","published":1,"updated":"2025-05-01T09:57:30.606Z","_id":"cma56nfvx000iisjja19xesyn","comments":1,"layout":"post","photos":[],"content":"<h1>Recycler</h1>\n<hr>\n<blockquote>\n<p>转载          bin的技术小屋<br>\n本系列Netty源码解析文章基于 <strong>4.1.56.Final</strong>版本</p>\n</blockquote>\n<h2 id=\"1-池化思想的应用\">1. 池化思想的应用</h2>\n<p>在我们日常开发工作中我们经常会遇到各种池化技术的设计思想，比如连接池，内存池，对象池，还有我们在业务开发过程中经常会缓存一些业务计算结果数据这也同样运用到了池化技术的设计思想，我们可以叫它为结果池。</p>\n<p>池化技术的应用场景就是当一个对象的创建和销毁需要付出比较大的性能开销时，我们就需要将这些重量级对象放在一个池子里管理，当需要时直接从池子里获取避免重复创建和销毁的开销从而达到了复用的效果。</p>\n<p>比如连接池里面保存管理的都是一些网络连接对象，这些对象创建和销毁的代价比较大。通过连接池将这些重量级的网络连接对象统一管理起来，业务线程可以直接复用，避免了重新创建，释放连接的性能开销以及等待时间。</p>\n<p>还有我们在日常开发中遇到的一些计算逻辑复杂的业务，我们通常会先从数据库中查询数据，然后经过复杂的计算得到结果，为了避免下次在重复计算，我们会将计算结果放入缓存中，我们可以称做结果池。也是一种池化思想。</p>\n<p>再比如我们在<a href=\"https://link.juejin.cn/?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg2MzU3Mjc3Ng%3D%3D%26mid%3D2247484244%26idx%3D1%26sn%3D831060fc38caa201d69f87305de7f86a%26chksm%3Dce77c513f9004c05b48f849ff99997d6d7252453135ae856a029137b88aa70b8e046013d596e%23rd\" title=\"https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&amp;mid=2247484244&amp;idx=1&amp;sn=831060fc38caa201d69f87305de7f86a&amp;chksm=ce77c513f9004c05b48f849ff99997d6d7252453135ae856a029137b88aa70b8e046013d596e#rd\">《Netty如何高效接收网络数据》</a>一文中提到的内存池，为了避免不必要的数据拷贝以及JVM垃圾回收对性能的影响，Netty 选择使用堆外内存存储网络通信数据。在 Netty 申请堆外内存之前，首先会在 JVM 堆中创建一个用于引用 native memory 的引用对象 DirectByteBuffer ，随后会使用 native 方法 <code>unsafe.allocateMemory</code>​ 通过底层 <code>malloc</code>​ 系统调用申请一块堆外内存。</p>\n<p>这里就涉及到到两个重要开销：</p>\n<ul>\n<li>在 JVM 堆中创建对象 DirectByteBuffer ，并为该对象申请分配 JVM 堆内存。</li>\n<li>通过 <code>malloc</code>​ 系统调用向操作系统申请堆外内存，然后被 DirectByteBuffer 引用。但是堆外内存的申请和释放远比堆内内存申请和释放的开销要大很多。</li>\n</ul>\n<p>而在 Netty 面对的高并发网络通信场景下，申请堆外内存是一个非常频繁的操作，基于以上提到的两个重要性能开销，这种大量频繁的内存申请释放操作对程序的性能影响是巨大的，所以 Netty 就引入了内存池对内存相关的操作进行统一的管理。</p>\n<h2 id=\"2-对象池简介\">2. 对象池简介</h2>\n<p>以上内容的介绍就是池化思想的应用以及它所解决的问题，本文我们的主题是介绍对象池，对象池的引入是为了在需要大量创建对象以及销毁对象的场景下，将对象进行池化以达到复用池中对象，避免大量地重复创建对象以及销毁对象的性能开销，</p>\n<p>前边我们在提到内存池的时候说到，在 Netty 所要面对的高并发网络通信场景下，需要大量的申请堆外内存用来存储通信数据。在 Netty 中，我们通过 PooledDirectByteBuf 对象来引用堆外内存。所以 Netty 在处理网络 IO 的时候是需要大量频繁的创建 PooledDirectByteBuf 对象。</p>\n<p>为了避免在高并发的场景下大量的创建对象所引来的性能开销，我们可以引入对象池来池化创建出来的 PooledDirectByteBuf 对象，需要用的时候直接从对象池中获取，用完之后在回收到对象池中。</p>\n<p>另外这里提前向大家透露一点的是我们下篇文章中即将要介绍的 Netty 发送数据流程涉及到的对象池的应用。我们都知道 Netty 是一个异步事件驱动的高性能网络框架，当在业务线程中处理完业务逻辑准备响应业务结果到客户端的时候，我们会向对应 channel 写入业务结果，此时业务线程会立即返回，这是一个异步的过程。</p>\n<p>原因是在底层实现中，Netty 会将用户的响应结果数据暂时写入到每个 Channel 特有的一个发送缓冲队列 ChannelOutboundBuffer 中，也就是说这个 ChannelOutboundBuffer 缓存着 Channel 中的待发送数据。最终会通过 flush 方法，将 ChannelOutboundBuffer 中的这些待发送数据写入到底层 Socket 中，从而发送给客户端。</p>\n<p>而这个发送缓冲队列 ChannelOutboundBuffer 中的队列元素是一个 Entry 类型的，每次的写入操作需要创建一个 Entry 对象来包裹发送数据，并将这个 Entry 对象缓存在发送缓冲队列 ChannelOutboundBuffer 中。</p>\n<blockquote>\n<p>这里大家只需要知道 ChannelOutboundBuffer 是个啥，它的大概作用，以及这个缓冲队列缓存的对象是 Entry 类型的就可以了，我们会在下篇文章为大家详细介绍，这里引出只是为了介绍对象池的应用场景。</p>\n</blockquote>\n<p>所以Netty在面对海量网络 IO 的场景下，必定会大量频繁地去创建 Entry 对象，那么每一次的网络 IO 都要重新创建这些对象，并且用完又要被垃圾回收掉这样无疑会大量增加 JVM 的负担以及 GC 的时间，这对于最求极致性能的 Netty 来说肯定是不可接受的。</p>\n<p>基于以上这几种情况，对象池被用来管理那些需要频繁创建使用的对象，在使用完后并不立即将它们释放，而是将它们在对象池中缓存起来，以供后续的应用程序重复使用，从而减少创建对象和释放对象的开销，进而改善应用程序的性能。</p>\n<p>从另一方面来看，对象池还可以将对象限制在一定的数量内从而可以有效减少应用程序在内存上的开销。</p>\n<hr>\n<p>通过前边关于对象池的简要介绍之后，我想大家现在可能比较好奇这些对象在创建和回收的过程中到底需要哪些开销呢？</p>\n<p>接下来笔者就为大家介绍下这些开销方面的内容方便大家更加全面清晰地理解对象池。</p>\n<h2 id=\"3-对象在JVM中创建和回收开销\">3. 对象在JVM中创建和回收开销</h2>\n<h3 id=\"3-1-对象的创建开销\">3.1 对象的创建开销</h3>\n<p>在 Java 程序中我们可以通过一个 new 关键字来创建对象，而当JVM遇到一条 new 的字节码指令后，会发生什么呢？</p>\n<ol>\n<li>首先 JVM 要去检查 new 指令后面的参数也就是创建对象所属的 Java 类是否能够在方法区的常量池中定位到类的符号引用，进而检查这个符号引用所代表的类是否已经加载，解析，初始化过。如果没有，就需要先执行类的加载过程。</li>\n<li>当通过类加载检查之后，就开始为对象分配内存，而对象所需内存大小其实在类加载完成后就已经确定了。JVM要做的事情就是将一块确定大小的内存区域从JVM堆中划分出来。</li>\n</ol>\n<blockquote>\n<p>关于如何确定对象所需内存大小，对这方面细节感兴趣的同学可以回看下笔者的<a href=\"https://link.juejin.cn/?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg2MzU3Mjc3Ng%3D%3D%26mid%3D2247484304%26idx%3D1%26sn%3D54bf0d07e69c5621c145afaece8f50d6%26chksm%3Dce77c5d7f9004cc1249a03dfd0fb12b7d75171f1b87acea1fa44bbb11ca374b6f42a66fa274d%23rd\" title=\"https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&amp;mid=2247484304&amp;idx=1&amp;sn=54bf0d07e69c5621c145afaece8f50d6&amp;chksm=ce77c5d7f9004cc1249a03dfd0fb12b7d75171f1b87acea1fa44bbb11ca374b6f42a66fa274d#rd\">《对象在JVM中的内存布局》</a>这篇文章。</p>\n</blockquote>\n<ol start=\"3\">\n<li>而在为对象划分堆中内存的时候又会根据JVM堆中内存是否规整，从而分为指针碰撞法和空闲列表法。而多线程同时创建对象在JVM中是非常常见的行为，所以在多线程并发创建对象的时候JVM又需要保证划分内存时的线程安全性。JVM需要对划分内存空间的动作进行同步处理（CAS  + 失败重试）。</li>\n<li>而为了避免这种划分内存时的同步锁定，JVM提供了另外一种方式就是每个线程先预先向JVM堆申请一块内存（本地线程分配缓存-TLAB），这样当线程创建对象的时候，先是从自己的TLAB中为对象分配内存，当自己的TLAB用完时，才会去JVM堆中​<strong>同步分配</strong>​。 我们可以通过虚拟机参数<code>-XX:+UseTLAB</code>​开启TLAB（默认）。<code>-XX:-UseTLAB</code>​关闭TLAB。</li>\n</ol>\n<blockquote>\n<p>大家这里需要记住这种利用TLAB的分配方式，因为Netty中的对象池Recycler也是利用这种思想避免多线程获取对象的同步开销。</p>\n</blockquote>\n<ol start=\"5\">\n<li>在为对象分配好内存之后，JVM会将这块内存初始化为零值。这样就可以保证对象中的实例字段不赋初始值就可以直接使用，其值为字段对应数据类型的零值。</li>\n<li>设置对象头。包括设置MarkWord中的对象运行时信息。以及通过类型指针引用关联到类的元数据信息。这些内容我们在<a href=\"https://link.juejin.cn/?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg2MzU3Mjc3Ng%3D%3D%26mid%3D2247484304%26idx%3D1%26sn%3D54bf0d07e69c5621c145afaece8f50d6%26chksm%3Dce77c5d7f9004cc1249a03dfd0fb12b7d75171f1b87acea1fa44bbb11ca374b6f42a66fa274d%23rd\" title=\"https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&amp;mid=2247484304&amp;idx=1&amp;sn=54bf0d07e69c5621c145afaece8f50d6&amp;chksm=ce77c5d7f9004cc1249a03dfd0fb12b7d75171f1b87acea1fa44bbb11ca374b6f42a66fa274d#rd\">《对象在JVM中的内存布局》</a>一文中都有提到过，大家还记得吗？</li>\n<li>执行构造函数。这样一个真正可用的对象就被创建出来了。</li>\n</ol>\n<h3 id=\"3-2-对象的回收开销\">3.2 对象的回收开销</h3>\n<ul>\n<li>JVM中的垃圾回收器通过可达性分析来探索所有Java存活对象，从GC ROOTS出发边标记边探索所有对象的引用链，以判断对象是否存活。</li>\n<li>垃圾回收器在垃圾回收的过程中发生的GC PAUSE也就是STOP THE WORLD。这里详细的垃圾回收过程我们就不展开了，主要是为了指明在对象回收时最主要的两个开销点。</li>\n</ul>\n<hr>\n<p>然而在高并发的网络IO处理场景下，这些单个对象的创建和回收开销会被无限放大，于是Netty引入了一个轻量级的对象池 Recycler 来负责将这些需要频繁创建的对象进行池化，统一分配，回收管理。</p>\n<p>在为大家详细介绍对象池 Recycler 的实现之前，笔者想先从对象池的使用上先让大家可以直观地感受一下 Recycler 对外提供的功能入口。</p>\n<h2 id=\"4-对象池Recycler的使用\">4. 对象池Recycler的使用</h2>\n<p>这里我们直接看下Netty源码中是如何使用Recycler对象池的，首先我们来看下对象池在 PooledDirectByteBuf 类中是如何使用的。</p>\n<blockquote>\n<p>大家这里先不用去管这个PooledDirectByteBuf类是干吗的，只需要明白这个类是会被频繁创建的，我们这里主要是演示对象池的使用。</p>\n</blockquote>\n<p><img src=\"/assets/ec623644e43b4c56bf1110c9cfc74bc8tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-1zakfmq.awebp\" alt=\"image.png\"></p>\n<h3 id=\"4-1-对象池在PooledDirectByteBuf类中的使用\">4.1 对象池在PooledDirectByteBuf类中的使用</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">PooledDirectByteBuf</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">PooledByteBuf</span>&lt;ByteBuffer&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">//创建对象池</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ObjectPool&lt;PooledDirectByteBuf&gt; RECYCLER = ObjectPool.newPool(</span><br><span class=\"line\">            <span class=\"keyword\">new</span> <span class=\"title class_\">ObjectCreator</span>&lt;PooledDirectByteBuf&gt;() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> PooledDirectByteBuf <span class=\"title function_\">newObject</span><span class=\"params\">(Handle&lt;PooledDirectByteBuf&gt; handle)</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">PooledDirectByteBuf</span>(handle, <span class=\"number\">0</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//对象在对象池中的回收句柄</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Handle&lt;PooledByteBuf&lt;T&gt;&gt; recyclerHandle;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> PooledDirectByteBuf <span class=\"title function_\">newInstance</span><span class=\"params\">(<span class=\"type\">int</span> maxCapacity)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//从对象池中获取对象</span></span><br><span class=\"line\">        <span class=\"type\">PooledDirectByteBuf</span> <span class=\"variable\">buf</span> <span class=\"operator\">=</span> RECYCLER.get();</span><br><span class=\"line\">        buf.reuse(maxCapacity);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> buf;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">recycle</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">         <span class=\"comment\">//回收对象</span></span><br><span class=\"line\">        recyclerHandle.recycle(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ................省略和对象池无关的代码..................</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>前边我们提到在Netty中需要大量频繁的创建PooledDirectByteBuf对象，为了避免在高并发场景下频繁创建对象的开销从而引入了对象池来统一管理PooledDirectByteBuf对象。</p>\n<p>Netty中每个被池化的对象中都会引用对象池的实例<code>ObjectPool  RECYCLER </code>​，这个对象池的实例就是专门用来分配和管理被池化对象的。</p>\n<p>这里我们创建出来的对象池是专门用来管理PooledDirectByteBuf对象的（通过泛型指定对象池需要管理的具体对象）。泛型类<code>ObjectPool&lt;T&gt;</code>​是Netty为对象池设计的一个顶层抽象。对象池的行为功能均定义在这个泛型抽象类中。我们可以通过 ObjectPool#newPool 方法创建指定的对象池。其参数 ObjectCreator 接口用来定义创建池化对象的行为。当对象池中需要创建新对象时，就会调用该接口方法 ObjectCreatornewObject 来创建对象。</p>\n<p>其中每个池化对象中都会包含一个recyclerHandle，这个recyclerHandle是池化对象在对象池中的句柄。里边封装了和对象池相关的一些行为和信息，recyclerHandle是由对象池在创建对象后传递进来的。</p>\n<p>当我们需要PooledDirectByteBuf对象时，我们直接通过<code>RECYCLER.get()</code>​从PooledDirectByteBuf对象池中获取对象即可。</p>\n<p>当我们使用完毕后，直接调用PooledDirectByteBuf对象在对象池中的句柄<code>recyclerHandle.recycle(this) </code>​把对象回收到对象池中。</p>\n<h3 id=\"4-2-对象池在Channel写入缓冲队列中的使用\">4.2 对象池在Channel写入缓冲队列中的使用</h3>\n<p>前边提到，每个Channel都会有一个独立的写入缓冲队列ChannelOutboundBuffer，用来暂时存储用户的待发送数据。这样用户可以在调用channel的write方法之后立马返回，实现异步发送流程。</p>\n<p>在发送数据时，Channel首先会将用户要发送的数据缓存在自己的写缓存队列ChannelOutboundBuffer中。而ChannelOutboundBuffer中的元素类型为Entry。在Netty中会大量频繁的创建Entry对象。所以Entry对象同样也需要被对象池管理起来。</p>\n<p>在上小节介绍PooledDirectByteBuf对象池的过程中，我想大家已经对对象池的使用套路已经有了大概的了解。这里我们借助Entry对象池将使用步骤总结如下：</p>\n<h4 id=\"创建对象池\">创建对象池</h4>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Entry</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ObjectPool&lt;Entry&gt; RECYCLER = ObjectPool.newPool(<span class=\"keyword\">new</span> <span class=\"title class_\">ObjectCreator</span>&lt;Entry&gt;() &#123;</span><br><span class=\"line\">         <span class=\"meta\">@Override</span></span><br><span class=\"line\">         <span class=\"keyword\">public</span> Entry <span class=\"title function_\">newObject</span><span class=\"params\">(Handle&lt;Entry&gt; handle)</span> &#123;</span><br><span class=\"line\">             <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Entry</span>(handle);</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">     &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"comment\">//recyclerHandle用于回收对象</span></span><br><span class=\"line\">     <span class=\"keyword\">private</span>  Handle&lt;Entry&gt; handle;</span><br><span class=\"line\">   </span><br><span class=\"line\">     <span class=\"keyword\">private</span> <span class=\"title function_\">Entry</span><span class=\"params\">(Handle&lt;Entry&gt; handle)</span> &#123;</span><br><span class=\"line\">         <span class=\"built_in\">this</span>.handle = handle;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>前边我们介绍到每一个要被池化的对象都需要一个静态变量来引用其对应的对象池。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ObjectPool&lt;Entry&gt; RECYCLER </span><br></pre></td></tr></table></figure>\n<p>匿名实现 ObjectCreator 接口来定义对象创建的行为方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">ObjectCreator</span>&lt;T&gt; &#123;</span><br><span class=\"line\">    T <span class=\"title function_\">newObject</span><span class=\"params\">(Handle&lt;T&gt; handle)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过<code>ObjectPool#newPool</code>​ 创建用于管理Entry对象的对象池。</p>\n<p>在对象池创建对象时，会为池化对象创建其在对象池中的句柄Handler，随后将Handler传入创建好的池化对象中。当对象使用完毕后，我们可以通过Handler来将对象回收至对象池中等待下次继续使用。</p>\n<h4 id=\"从对象池中获取对象\">从对象池中获取对象</h4>\n<p>由于Entry对象在设计上是被对象池管理的，所以不能对外提供public构造函数，无法在外面直接创建Entry对象。</p>\n<p>所以池化对象都会提供一个获取对象实例的 static 方法 newInstance。在该方法中通过<code>RECYCLER.get()</code>​从对象池中获取对象实例。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> Entry <span class=\"title function_\">newInstance</span><span class=\"params\">(Object msg, <span class=\"type\">int</span> size, <span class=\"type\">long</span> total, ChannelPromise promise)</span> &#123;</span><br><span class=\"line\">      <span class=\"type\">Entry</span> <span class=\"variable\">entry</span> <span class=\"operator\">=</span> RECYCLER.get();</span><br><span class=\"line\">    </span><br><span class=\"line\">      .........省略无关代码..............</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">return</span> entry;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"使用完毕回收对象\">使用完毕回收对象</h4>\n<p>池化对象都会提供一个 recycle 方法，当对象使用完毕后，调用该方法将对象回收进对象池中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">recycle</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    next = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    bufs = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    buf = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    msg = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    promise = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    progress = <span class=\"number\">0</span>;</span><br><span class=\"line\">    total = <span class=\"number\">0</span>;</span><br><span class=\"line\">    pendingSize = <span class=\"number\">0</span>;</span><br><span class=\"line\">    count = -<span class=\"number\">1</span>;</span><br><span class=\"line\">    cancelled = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    handle.recycle(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>清空对象中的所有属性。</li>\n<li>通过对象中持有的对象池句柄Handler，将对象回收进对象池中。</li>\n</ul>\n<hr>\n<p>从上边所列举的Netty中使用对象池的例子，我们可以直观的感受到对象池的使用非常简单。无非就是从对象池获取对象，将对象回收至对象池这两个核心步骤。</p>\n<p>同时我们也注意到池化对象的设计和普通对象是有所不同的，不过，我们只需要遵循本小节中所列举的几个步骤进行设计即可。</p>\n<h2 id=\"5-Recycler总体设计\">5. Recycler总体设计</h2>\n<p>Recycler对象池的设计还是比较复杂的但是却很精妙，所以笔者这里继续采用总 - 分 - 总的结构来为大家介绍对象池的设计与实现。</p>\n<p>一开始我们先不要去追求太过细节的内容，先要从总体上摸清楚对象池的设计架构，以及各个功能模块之间的关联。</p>\n<p>当我们从整体上理解了对象池的设计架构后，笔者后面会分模块来各个击破它的实现细节。</p>\n<p>在理清楚各个模块的实现细节之后，笔者将在从细节着手再次将对象池的整体设计架构为大家串联起来。</p>\n<p>我们按照这个思路先来看一下Recycler对象池的总体架构设计图，从整体直观上来感受下它的设计，以及包含的一些重要模块。</p>\n<p><img src=\"/assets/d8bdbd9d79814646999637ffc46281cbtplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-5lz8huo.awebp\" alt=\"image.png\"></p>\n<h3 id=\"5-1-多线程获取对象无锁化设计\">5.1 多线程获取对象无锁化设计</h3>\n<p>首先我们从外部整体来看，对象池对于我们来说它就是一个存储对象的池子，当我们需要对象时会从这个池子里直接获取，用完对象时在把对象归还回池子中方便下一次重复使用。</p>\n<p>但我们俯瞰整个对象池的设计架构时，我们发现整个设计还是比较复杂其中蕴含了不少精妙的细节。</p>\n<p>对象池中最重要的两个结构分别是 Stack 和 WeakOrderQueue。</p>\n<p>Stack 中包含一个用数组实现的栈结构（图中绿色部分），这个栈结构正是对象池中真正用于存储池化对象的地方，我们每次从对象池中获取对象都会从这个栈结构中弹出栈顶元素。同样我们每次将使用完的对象归还到对象池中也是将对象压入这个栈结构中。</p>\n<p>​<strong>这里有一个精妙的设计</strong>​，我们从图中可以看到每个线程都会拥有一个属于自己的Stack。在我们介绍《对象创建的开销》这一小节内容时，提到为了避免多线程并发申请内存时的同步锁定开销，JVM为每个线程预先申请了一块内存（TLAB）,这样当线程创建对象时都是从自己的TLAB中为对象分配内存。从而避免了多线程之间的同步竞争。</p>\n<p>同样当多线程并发从对象池中获取对象时, 如果整个对象池只有一个Stack结构的话，为了保证多线程获取对象的线程安全性，我们只能同步地来访问这个Stack，这样就为对象池的设计引入了多线程同步竞争的开销。</p>\n<p>​<strong>为了避免这种不必要的同步竞争，Netty也采用了类似TLAB分配内存的方式，每个线程拥有一个独立Stack，这样当多个线程并发从对象池中获取对象时，都是从自己线程中的Stack中获取，全程无锁化运行。大大提高了多线程从对象池中获取对象的效率</strong>​。</p>\n<blockquote>\n<p>这种<strong>多线程并发无锁化</strong>的设计思想，在Netty中比比皆是</p>\n</blockquote>\n<h3 id=\"5-2-Stack的设计\">5.2 Stack的设计</h3>\n<p>从Recycler对象池的整体设计架构图中我们可以看到，Stack的设计主要分为两个重要的部分：</p>\n<ul>\n<li>一个是我们前边提到的数组实现的栈结构用来存放对象池中的对象，每个线程绑定一个独立的Stack用来存储由<strong>该线程创建出来</strong>并回收到对象池中的对象。</li>\n<li>另一个重要的结构是WeakOrderQueue链表，head 指针指向WeakOrderQueue链表的头结点，cursor 指针指向链表的当前节点，prev 指针指向当前节点的前一个节点。WeakOrderQueue链表是用来存储其他线程帮助本线程回收的对象（我们称之为待回收对象）。其中WeakOrderQueue链表中的每一个节点对应一个其他线程，这个其他线程为本线程回收的对象存储在对应的WeakOrderQueue节点中。</li>\n</ul>\n<blockquote>\n<p>这里我们先不需要管WeakOrderQueue的具体结构</p>\n</blockquote>\n<p>​<strong>那么Stack结构在设计上为什么要引入这个WeakOrderQueue链表呢</strong>​？</p>\n<p>让我们考虑一种多线程回收对象的场景，我们还是以Recycler对象池的整体设计架构图为例。thread1 为当前线程，剩下的thread2 , thread3 , thread4为其他线程。让我们把视角先聚焦在当前线程上。</p>\n<blockquote>\n<p>我们先假设Stack结构中只有一个数组栈，并没有WeakOrderQueue链表。看看这样会产生什么后果？</p>\n</blockquote>\n<p><img src=\"/assets/d4522ab88aca42a4b9c2d633301fcac5tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-idyvok3.awebp\" alt=\"image.png\"></p>\n<p>当前线程 thread1 在处理业务逻辑时，创建了一个对象（注意：这个对象是由thread1创建的）如果这是一个单线程处理业务的场景，那么对象会在thread1处理完业务逻辑后被回收至thread1对应的stack1中的数组栈中。当`hread1再次需要创建对象时，会直接从其对应的stack1中的数组栈（图中绿色部分）中直接获取上次回收的对象。</p>\n<blockquote>\n<p>由这一点可以看出Stack中的数组栈（绿色部分）存放的是真正被回收的对象，是可以直接被再次获取使用的。</p>\n</blockquote>\n<p>但如果这是一个多线程处理业务场景的话，很可能由thread1创建出来的对象，会被交给thread2或者thread3去处理剩下的业务逻辑，那么当thread2或者thread3这些其他线程处理完业务逻辑时，此时对象的释放并不是在thread1中，而是在其他线程中。</p>\n<p>其他线程现在面对的任务就是要将由thread1创建出来的对象，释放回收至thread1对应的stack1中的数组栈中。如果此时多个其他线程并发的向stack1释放回收对象，势必会导致多线程之前的同步竞争，​<strong>Netty将不得不把Stack结构中的数组栈的访问设计成一个同步过程</strong>​。</p>\n<p>那么如果此时更不巧的是当前线程thread1又要同时向自己的Stack1获取对象，thread1就只能同步等待，因为此时其他线程正在向Stack1释放对象。</p>\n<blockquote>\n<p>本来我们引入对象池的目的就是为了抵消创建对象的开销加快获取对象的速度，减少GC的压力。结果由于Stack的同步访问设计又引入了同步开销。这个同步的开销甚至会比创建对象的开销还要大，那么对象池的引入就变得得不偿失了。</p>\n</blockquote>\n<p><strong>那么Netty该如何化解这种情况呢？答案还是之前反复强调的无锁化设计思想。</strong></p>\n<p>既然多线程的回收对象场景，会引入多线程之间的同步锁定开销，那么我们就继续采用无锁化的设计思想，为每个线程（注意：这里指的是非创建对象的线程也就是图中的thead2 , thread3 …）单独分配一个WeakOrderQueue节点，每个线程在为创建线程回收对象时，会将这些对象暂时存放到自己对应的WeakOrderQueue节点中。</p>\n<blockquote>\n<p>注意：存放进WeakOrderQueue中的对象我们称为待回收对象，这些待回收对象并不在Stack结构中的数组栈中，因此并不能被直接获取使用。</p>\n</blockquote>\n<p>为了方便后续描述，我们把创建对象的线程称作<code>创建线程</code>​（示例中的thread1），将为创建线程回收对象的其他线程称作<code>回收线程</code>​（示例中的thread2 , thread3 , thead4 …）。</p>\n<p>我们在将视角拉回到创建线程thread1对应的stack1中，​<strong>每个回收线程将待回收对象放入与自己对应的WeakOrderQueue节点中，这样就避免了在多线程回收场景中的同步竞争</strong>​。当所有回收线程都在为stack1回收对象时，这样在stack1中就形成了一个WeakOrderQueue链表。每个回收线程只操作与自己对应的节点。在Stack结构中通过head，prev，cursor将这些WeakOrderQueue节点组成了一个链表。</p>\n<blockquote>\n<p>每一个WeakOrderQueue节点对应一个回收线程。</p>\n</blockquote>\n<p>而当创建线程thread1再次从自己对应的Stack1中获取对象时，只会从Stack结构的数组栈中获取，因为是单线程操作数组栈，自然是不会存在同步竞争的。</p>\n<p>当Stack结构中的数组栈没有任何对象时，那么创建线程就会根据 cursor 指针遍历Stack结构中的WeakOrderQueue链表，将当前WeakOrderQueue节点存放的待回收对象​<strong>转移至数组栈中</strong>​。如果WeakOrderQueue链表中也没有任何待回收对象可以转移。那么创建线程在对象池中就直接创建一个对象出来返回。</p>\n<blockquote>\n<p>对象池回收对象的一个原则就是对象由谁创建的，最终就要被回收到创建线程对应的Stack结构中的数组栈中。数组栈中存放的才是真正被回收的池化对象，可以直接被取出复用。回收线程只能将待回收对象暂时存放至创建线程对应的Stack结构中的WeakOrderQueue链表中。当数组栈中没有对象时，由创建线程将WeakOrderQueue链表中的待回收对象转移至数组栈中。</p>\n</blockquote>\n<p><strong>正是由于对象池的这种无锁化设计，对象池在多线程获取对象和多线程回收对象的场景下，均是不需要同步的</strong></p>\n<p>大家在体会下这张图中蕴含的这种​<strong>无锁化设计思想</strong>​：</p>\n<p><img src=\"/assets/0566fc7826064b12bb88082b39c10bd2tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-hkx67f6.awebp\" alt=\"image.png\"></p>\n<h3 id=\"5-3-WeakOrderQueue的设计\">5.3 WeakOrderQueue的设计</h3>\n<p>在我们介绍完对象池在多线程回收对象场景下的设计时，我们再来看下用于回收线程存储待回收对象的WeakOrderQueue是如何设计的？</p>\n<blockquote>\n<p>注意：这里的回收线程，待回收对象这些概念是我们站在创建线程的视角提出的<strong>相对</strong>概念。</p>\n</blockquote>\n<p><img src=\"/assets/63f3b4b63fd14b7a84c33c0840bc41e2tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-7eix1tf.awebp\" alt=\"image.png\"></p>\n<p>大家一开始可能从WeakOrderQueue字面意思上以为它的结构是一个队列，但实际上从图中我们可以看出WeakOrderQueue的结构其实是一个链表结构。</p>\n<p>其中包含了链表的头结点 Head，以及链表尾结点指针 Tail。链表中的元素类型为 Link 类型。</p>\n<p>Link 类型中包含了一个 elements 数组，该数组用来存放回收线程收集的待回收对象。</p>\n<p>除此之外Link类型中还包含了readIndex用来指示当前elements数组中的读取位置。writeIndex用来指示elements数组的写入位置。elements数组中的容量默认为<code>16</code>​，也就是说一个Link节点最多可以存放16个待回收对象。当回收线程收集的待回收对象超过16个时，就会新创建一个Link节点插入到Link链表的尾部。</p>\n<p>当需要将WeakoOrderQueue节点中所存放的待回收对象回收转移至其对应的Stack结构中的数组栈中时，<strong>创建线程</strong>会遍历当前WeakOrderQueue节点中的Link链表，然后从链表的Head节点开始，将Head节点中包裹的Link链表头结点中存放的待回收对象回收至创建线程对应的Stack中。​<strong>一次最多转移一个Link大小的待回收对象</strong>​（16个）。</p>\n<p>当Link节点中的待回收对象全部转移至创建线程对应的Stack中时，会立马将这个Link节点从当前WeakOrderQueue节点中的Link链表里删除，随后Head节点向后移动指向下一个Link节点。</p>\n<blockquote>\n<p>head指针始终指向​<strong>第一个未被转移完毕的Link节点</strong>​，创建线程从head节点处读取转移待回收对象，回收线程从Tail节点处插入待回收对象。​<strong>这样转移操作和插入操作互不影响、没有同步的开销</strong>​。</p>\n</blockquote>\n<p>​<strong>注意这里会存在线程可见性的问题</strong>​，也就是说回收线程刚插入的待回收对象，在创建线程转移这些待回收对象时，创建线程可能会<strong>看不到</strong>由回收线程刚刚插入的待回收对象。</p>\n<p>​<strong>Netty这里为了不引入多线程同步的开销，只会保证待回收对象的最终可见性</strong>​。 因为如果要保证待回收对象的实时可见性，就要插入一些内存屏障指令，执行这些内存屏障指令也是需要开销的。</p>\n<p>事实上这里也并不需要保证实时可见性，创建线程暂时看不到WeakOrderQueue节点中的待回收对象也是没关系的，大不了就新创建一个对象。​<strong>这里还是遵循无锁化的设计思想</strong>​。</p>\n<blockquote>\n<p>维护线程之间操作的原子性，可见性都是需要开销的，我们在日常多线程程序设计中一定要根据业务场景来综合考虑，权衡取舍。尽量遵循我们这里多次强调的​<strong>多线程无锁化设计思想</strong>​。提高多线程的运行效率。避免引入不必要的同步开销。</p>\n</blockquote>\n<p>综合以上 Netty Recycler 对象池的设计原理，我们看到多线程从对象池中获取对象，以及多线程回收对象至对象池中，还有创建线程从WeakOrderQueue链表中转移待回收对象到对象池中。这些步骤均是无锁化进行的，没有同步竞争。</p>\n<p>在理解了对象池的基本设计原理后，下面就该介绍对象池在Netty中的源码实现环节了。</p>\n<h2 id=\"6-Recycler对象池的实现\">6. Recycler对象池的实现</h2>\n<p>在小节《4. 对象池Recycler的使用》中我们介绍了Recycler对象池的两个使用案例：</p>\n<ul>\n<li>一个是对象池在PooledDirectByteBuf类中的运用。</li>\n<li>另一个是对象池在Channel对应的写入缓冲队列ChannelOutboundBuffer中的运用。</li>\n</ul>\n<p>从这两个案例中，我们看到在设计池化对象时，都需要在池化对象内部持有一个对象池的静态引用从而可以与对象池进行交互，引用类型为 ObjectPool ，ObjectPool 是Netty对象池的顶层设计，其中定义了对象池的行为，以及各种顶层接口。</p>\n<p>在介绍对象池的整体实现之前，我们先来看下对象池的这个顶层接口设计。</p>\n<h3 id=\"6-1-对象池的顶层设计ObjectPool\">6.1 对象池的顶层设计ObjectPool</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ObjectPool</span>&lt;T&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    ObjectPool() &#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> T <span class=\"title function_\">get</span><span class=\"params\">()</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Handle</span>&lt;T&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">void</span> <span class=\"title function_\">recycle</span><span class=\"params\">(T self)</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">ObjectCreator</span>&lt;T&gt; &#123;</span><br><span class=\"line\">        T <span class=\"title function_\">newObject</span><span class=\"params\">(Handle&lt;T&gt; handle)</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ......................省略............</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们首先看到 ObjecPool 被设计成为一个泛型的抽象类，之所以使用泛型，是因为我们在创建对象池的时候需要指定对象池中被池化对象的类型。</p>\n<p>比如《4. 对象池Recycler的使用》小节中的这两个案例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Entry</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ObjectPool&lt;Entry&gt; RECYCLER</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">PooledDirectByteBuf</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">PooledByteBuf</span>&lt;ByteBuffer&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ObjectPool&lt;PooledDirectByteBuf&gt; RECYCLER</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>ObjecPool 定义了从对象池中获取对象的行为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> T <span class=\"title function_\">get</span><span class=\"params\">()</span>;</span><br></pre></td></tr></table></figure>\n<p>将池化对象回收至对象池中的行为被定义在 Handler 内部接口中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Handle</span>&lt;T&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">recycle</span><span class=\"params\">(T self)</span>;</span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n<p>Handler是池化对象在对象池中的一个模型，Handler里面包裹了池化对象，并包含了池化对象的一些回收信息，以及池化对象的回收状态。它的默认实现是DefaultHandle，后面我们会详细介绍。</p>\n<blockquote>\n<p>我们前边介绍到的Stack结构中的数组栈里边存放的就是DefaultHandle，以及WeakOrderQueue结构里的Link节点中的elements数组里存放的也是DefaultHandle。</p>\n</blockquote>\n<p>​<strong>那么为什么要将池化对象的回收行为recycle定义在Handler中，而不是ObejctPool中呢</strong>​？</p>\n<p>让我们站在业务线程的角度来看，其实业务线程处理的都是对象级别这个维度，并不需要感知到对象池的存在，使用完对象，直接调用对象的回收方法recycle将池化对象回收掉即可。</p>\n<p>在《4. 对象池Recycler的使用》小节我们介绍过池化对象的设计方法，其中我们提到池化对象中需要引用其在对象池中的Handler，这个Handler会在对象池创建对象的时候传入。池化对象类型中需要定义recycle方法，recycle方法清空池化对象的所有属性，并调用Handler的recycle方法将池化对象回收至对象池中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Entry</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">void</span> <span class=\"title function_\">recycle</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            next = <span class=\"literal\">null</span>;</span><br><span class=\"line\">            bufs = <span class=\"literal\">null</span>;</span><br><span class=\"line\">            buf = <span class=\"literal\">null</span>;</span><br><span class=\"line\">            msg = <span class=\"literal\">null</span>;</span><br><span class=\"line\">            promise = <span class=\"literal\">null</span>;</span><br><span class=\"line\">            progress = <span class=\"number\">0</span>;</span><br><span class=\"line\">            total = <span class=\"number\">0</span>;</span><br><span class=\"line\">            pendingSize = <span class=\"number\">0</span>;</span><br><span class=\"line\">            count = -<span class=\"number\">1</span>;</span><br><span class=\"line\">            cancelled = <span class=\"literal\">false</span>;</span><br><span class=\"line\">            handle.recycle(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>ObjectPool 还定义了对象池创建对象的行为接口：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">ObjectCreator</span>&lt;T&gt; &#123;</span><br><span class=\"line\">    T <span class=\"title function_\">newObject</span><span class=\"params\">(Handle&lt;T&gt; handle)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>用户在创建对象池的时候，需要通过<code>ObjectCreator#newObject</code>​方法指定对象池创建对象的行为。Handler对象正是通过这个接口传入池化对象中的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Entry</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ObjectPool&lt;Entry&gt; RECYCLER = ObjectPool.newPool(<span class=\"keyword\">new</span> <span class=\"title class_\">ObjectCreator</span>&lt;Entry&gt;() &#123;</span><br><span class=\"line\">          <span class=\"meta\">@Override</span></span><br><span class=\"line\">          <span class=\"keyword\">public</span> Entry <span class=\"title function_\">newObject</span><span class=\"params\">(Handle&lt;Entry&gt; handle)</span> &#123;</span><br><span class=\"line\">              <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Entry</span>(handle);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//Entry对象只能通过对象池获取，不可外部自行创建</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">Entry</span><span class=\"params\">(Handle&lt;Entry&gt; handle)</span> &#123;</span><br><span class=\"line\">          <span class=\"built_in\">this</span>.handle = handle;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"6-1-1-创建ObjectPool\">6.1.1 创建ObjectPool</h4>\n<p><img src=\"/assets/948ff8d7b81449269cbedf8928f28e59tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-2e3ivzs.awebp\" alt=\"image.png\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ObjectPool</span>&lt;T&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; ObjectPool&lt;T&gt; <span class=\"title function_\">newPool</span><span class=\"params\">(<span class=\"keyword\">final</span> ObjectCreator&lt;T&gt; creator)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RecyclerObjectPool</span>&lt;T&gt;(ObjectUtil.checkNotNull(creator, <span class=\"string\">&quot;creator&quot;</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RecyclerObjectPool</span>&lt;T&gt; <span class=\"keyword\">extends</span> <span class=\"title class_\">ObjectPool</span>&lt;T&gt; &#123;</span><br><span class=\"line\">        <span class=\"comment\">//recycler对象池实例</span></span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Recycler&lt;T&gt; recycler;</span><br><span class=\"line\"></span><br><span class=\"line\">        RecyclerObjectPool(<span class=\"keyword\">final</span> ObjectCreator&lt;T&gt; creator) &#123;</span><br><span class=\"line\">             recycler = <span class=\"keyword\">new</span> <span class=\"title class_\">Recycler</span>&lt;T&gt;() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"keyword\">protected</span> T <span class=\"title function_\">newObject</span><span class=\"params\">(Handle&lt;T&gt; handle)</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> creator.newObject(handle);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> T <span class=\"title function_\">get</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> recycler.get();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Recycler</span>&lt;T&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">abstract</span> T <span class=\"title function_\">newObject</span><span class=\"params\">(Handle&lt;T&gt; handle)</span>;</span><br><span class=\"line\">  </span><br><span class=\"line\">    ........................省略.............</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>调用 <code>ObjectPool#newPool</code>​ 创建对象池时，返回的是 RecyclerObjectPool 实例。而<strong>真正的对象池 Recycler</strong> 被包裹在 RecyclerObjectPool 中。</p>\n<p>对象池Recycler创建对象的行为定义在用户在创建对象池时指定的ObjectCreator 中。</p>\n<h2 id=\"7-Recycler对象池属性详解\">7. Recycler对象池属性详解</h2>\n<p>在介绍完对象池的顶层设计之后，接下来我们介绍下Recycler对象池相关的一些重要属性。相信大家在看过前边关于对象池设计原理的介绍之后，现在应该能够比较容易的理解即将介绍的这些属性概念，这里涉及到的属性比较多，笔者把这些属性的介绍放到源码实现之前的目的也是先让大家混个眼熟，先有一个感性的认识，等到介绍源码实现时，笔者还会将涉及到的属性再次拿出来介绍。</p>\n<p><img src=\"/assets/f469c168d72b40c6b23accd8ab652a22tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-t5puo5k.awebp\" alt=\"image.png\"></p>\n<h3 id=\"7-1-创建线程，回收线程的Id标识\">7.1 创建线程，回收线程的Id标识</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Recycler</span>&lt;T&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//用于产生池化对象中的回收Id,主要用来标识池化对象被哪个线程回收</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">AtomicInteger</span> <span class=\"variable\">ID_GENERATOR</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AtomicInteger</span>(Integer.MIN_VALUE);</span><br><span class=\"line\">    <span class=\"comment\">//用于标识创建池化对象的线程Id 注意这里是static final字段 也就意味着所有的创建线程OWN_THREAD_ID都是相同的</span></span><br><span class=\"line\">    <span class=\"comment\">//这里主要用来区分创建线程与非创建线程。多个非创建线程拥有各自不同的Id</span></span><br><span class=\"line\">    <span class=\"comment\">//这里的视角只是针对池化对象来说的：区分创建它的线程，与其他回收线程</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">OWN_THREAD_ID</span> <span class=\"operator\">=</span> ID_GENERATOR.getAndIncrement();</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>​<code>AtomicInteger ID_GENERATOR</code>​ :对象池中定义了一个 AtomicInteger 类型的Id生成器，主要用于为创建线程以及回收线程创建Id标识，<strong>目的是区分创建线程和回收线程。</strong></li>\n<li>​<code>int OWN_THREAD_ID</code>​：在 Recycler 类初始化的时候，会利用ID_GENERATOR 为 OWN_THREAD_ID 字段赋值，从字面意思上我们也可以看出 OWN_THREAD_ID 是用来标识创建线程Id的。这里有一点大家需要注意的是，OWN_THREAD_ID 是一个 static final 字段，这也就意味着所有的Recycler对象池实例中的 OWN_THREAD_ID 都是一样的。</li>\n</ul>\n<p>这里有的同学可能会有疑问了，在多线程从对象池中获取对象的场景中，创建线程会有很多个（比如下图中的thread1, thread2, thread3…），既然所有的Recycler 对象池实例中的 OWN_THREAD_ID 都是一样的，那么如何区分不同的创建线程呢？</p>\n<p><img src=\"/assets/34f2d54bc3724e51b0c8ad2695f7de95tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-2cym377.awebp\" alt=\"image.png\"></p>\n<p>​<strong>事实上在对象池中我们并不需要区分创建线程与创建线程之间的Id</strong>​，因为Netty在设计对象池的时候采用了无锁化设计，创建线程与创建线程之间并不需要交互，每个线程只需要关注自己线程内的对象管理工作即可，所以从一个线程的内部视角来看，只会有一个创建线程就是它自己本身，剩下的线程均是回收线程。​<strong>所以我们对象池的设计中只需要区分创建线程与回收线程就可以了</strong>​，当然每个回收线程的Id是不一样的。</p>\n<p>回收线程的Id是由其对应的 WeakOrderQueue 节点来分配的，一个 WeakOrderQueue 实例对应一个回收线程Id。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">WeakOrderQueue</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">WeakReference</span>&lt;Thread&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//回收线程回收Id,每个weakOrderQueue分配一个，同一个stack下的一个回收线程对应一个weakOrderQueue节点</span></span><br><span class=\"line\">   <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">id</span> <span class=\"operator\">=</span> ID_GENERATOR.getAndIncrement();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"7-2-对象池中的容量控制\">7.2 对象池中的容量控制</h3>\n<p><img src=\"/assets/233f28fc503e4dcc9c1e1317a89b71d9tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-vqp6dd1.awebp\" alt=\"image.png\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//对象池中每个线程对应的Stack中可以存储池化对象的默认初始最大个数 默认为4096个对象 </span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">DEFAULT_INITIAL_MAX_CAPACITY_PER_THREAD</span> <span class=\"operator\">=</span> <span class=\"number\">4</span> * <span class=\"number\">1024</span>; <span class=\"comment\">// Use 4k instances as default.</span></span><br><span class=\"line\"><span class=\"comment\">// 对象池中线程对应的Stack可以存储池化对象默认最大个数 4096</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> DEFAULT_MAX_CAPACITY_PER_THREAD;</span><br><span class=\"line\"><span class=\"comment\">// 初始容量 min(DEFAULT_MAX_CAPACITY_PER_THREAD, 256) 初始容量不超过256个</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> INITIAL_CAPACITY;</span><br></pre></td></tr></table></figure>\n<p>Recycler 对象池中定义了以上三个属性用于控制对象池中可以池化的对象容量。这些属性对应的初始化逻辑如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">maxCapacityPerThread</span> <span class=\"operator\">=</span> SystemPropertyUtil.getInt(<span class=\"string\">&quot;io.netty.recycler.maxCapacityPerThread&quot;</span>,</span><br><span class=\"line\">            SystemPropertyUtil.getInt(<span class=\"string\">&quot;io.netty.recycler.maxCapacity&quot;</span>, DEFAULT_INITIAL_MAX_CAPACITY_PER_THREAD));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (maxCapacityPerThread &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        maxCapacityPerThread = DEFAULT_INITIAL_MAX_CAPACITY_PER_THREAD;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    DEFAULT_MAX_CAPACITY_PER_THREAD = maxCapacityPerThread;</span><br><span class=\"line\"></span><br><span class=\"line\">    INITIAL_CAPACITY = min(DEFAULT_MAX_CAPACITY_PER_THREAD, <span class=\"number\">256</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>​<code>DEFAULT_INITIAL_MAX_CAPACITY_PER_THREAD</code>​：定义每个创建线程对应的Stack结构中的数组栈初始默认的最大容量。默认为4096个。可由JVM启动参数 <code>-D io.netty.recycler.maxCapacity</code>​ 指定。</li>\n<li>​<code>DEFAULT_MAX_CAPACITY_PER_THREAD</code>​：定义每个创建线程对应的Stack结构中的数组栈的最大容量。可由JVM启动参数 <code>-D io.netty.recycler.maxCapacityPerThread</code>​ 指定，如无特殊指定，即采用 DEFAULT_INITIAL_MAX_CAPACITY_PER_THREAD 的值，默认为4096个。</li>\n<li>​<code>INITIAL_CAPACITY </code>​: 定义每个创建线程对应的Stack结构中的数组栈的初始容量。计算公式为<code>min(DEFAULT_MAX_CAPACITY_PER_THREAD, 256)</code>​，默认为256个。当池化对象超过256个时，则对对象池进行扩容，但不能超过最大容量 DEFAULT_MAX_CAPACITY_PER_THREAD。</li>\n</ul>\n<h3 id=\"7-3-回收线程可回收对象的容量控制\">7.3 回收线程可回收对象的容量控制</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//用于计算回收线程可帮助回收的最大容量因子  默认为2  </span></span><br><span class=\"line\"> <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> MAX_SHARED_CAPACITY_FACTOR;</span><br><span class=\"line\"> <span class=\"comment\">//每个回收线程最多可以帮助多少个创建线程回收对象 默认：cpu核数 * 2</span></span><br><span class=\"line\"> <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> MAX_DELAYED_QUEUES_PER_THREAD;</span><br><span class=\"line\"> <span class=\"comment\">//回收线程对应的WeakOrderQueue节点中的Link链表中的节点存储待回收对象的容量 默认为16</span></span><br><span class=\"line\"> <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> LINK_CAPACITY;</span><br></pre></td></tr></table></figure>\n<p>Recycler 对象池除了对创建线程中的 Stack 容量进行限制外，还需要对回收线程可回收对象的容量进行限制。相关回收容量限制属性初始化逻辑如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    MAX_SHARED_CAPACITY_FACTOR = max(<span class=\"number\">2</span>,</span><br><span class=\"line\">            SystemPropertyUtil.getInt(<span class=\"string\">&quot;io.netty.recycler.maxSharedCapacityFactor&quot;</span>,</span><br><span class=\"line\">                    <span class=\"number\">2</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    MAX_DELAYED_QUEUES_PER_THREAD = max(<span class=\"number\">0</span>,</span><br><span class=\"line\">            SystemPropertyUtil.getInt(<span class=\"string\">&quot;io.netty.recycler.maxDelayedQueuesPerThread&quot;</span>,</span><br><span class=\"line\">                    <span class=\"comment\">// We use the same value as default EventLoop number</span></span><br><span class=\"line\">                    NettyRuntime.availableProcessors() * <span class=\"number\">2</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    LINK_CAPACITY = safeFindNextPositivePowerOfTwo(</span><br><span class=\"line\">            max(SystemPropertyUtil.getInt(<span class=\"string\">&quot;io.netty.recycler.linkCapacity&quot;</span>, <span class=\"number\">16</span>), <span class=\"number\">16</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>​<code>MAX_SHARED_CAPACITY_FACTOR</code>​ : 针对创建线程中的 Stack，其对应的所有回收线程总共可帮助其回收的对象总量计算因子。默认为2。可通过JVM参数 <code>-D io.netty.recycler.maxSharedCapacityFactor</code>​ 指定，总共回收对象总量就是通过对象池的最大容量和该计算因子计算出来的。计算公式： <code>max(maxCapacity / maxSharedCapacityFactor, LINK_CAPACITY)</code>​ 。由此我们可以知道创建线程对应的所有回收线程总共可帮助其回收的对象总量默认为2048个，最小回收容量为 LINK_CAPACITY  默认为16。</li>\n<li>​<code>MAX_DELAYED_QUEUES_PER_THREAD</code>​ : 该参数定义每个回收线程最多可帮助多少个创建线程回收对象。默认为：CPU核数 * 2。可通过JVM参数 <code>-D io.netty.recycler.maxDelayedQueuesPerThread</code>​ 指定。​<strong>注意：这里是站在回收线程的角度</strong>​。</li>\n<li>​<code>LINK_CAPACITY </code>​:  在创建线程对应的 Stack 结构中的 WeakOrderQueue 链表中，回收线程对应的WeakOrderQueue节点中的Link链表中的Link节点存储待回收对象的容量。默认为16，可通过JVM参数 <code>-D io.netty.recycler.linkCapacity</code>​ 指定。</li>\n</ul>\n<p>为了方便大家理解这些容量控制的相关参数，笔者又在对象池架构设计图的基础上补充了容量控制相关的信息。大家可以对照上边介绍到的这些参数的含义形象体会下：</p>\n<p><img src=\"/assets/d76e41420e1d44eb82e4b74dc7d4309btplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-e21hjq1.awebp\" alt=\"image.png\"></p>\n<h3 id=\"7-4-对象回收频率控制\">7.4 对象回收频率控制</h3>\n<p>对象池不能不考虑容量的限制而无脑的进行对象的回收，而是要对回收对象的频率进行限制。在我们日常架构设计和程序设计时，我们也一定要有托底的方案，比如限流，降级，熔断等托底方案。这样程序就不至于被突发的异常流量击垮。</p>\n<p>在对象池的设计中，Netty用以下两个参数来控制对象回收的频率从而避免对象池迅速膨胀不可控制。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//创建线程回收对象时的回收比例，默认是8，表示只回收1/8的对象。也就是产生8个对象回收一个对象到对象池中</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> RATIO;</span><br><span class=\"line\"><span class=\"comment\">//回收线程回收对象时的回收比例，默认也是8，同样也是为了避免回收线程回收队列疯狂增长 回收比例也是1/8</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> DELAYED_QUEUE_RATIO;</span><br></pre></td></tr></table></figure>\n<p>对象回收频率控制参数的初始化逻辑如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    RATIO = max(<span class=\"number\">0</span>, SystemPropertyUtil.getInt(<span class=\"string\">&quot;io.netty.recycler.ratio&quot;</span>, <span class=\"number\">8</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    DELAYED_QUEUE_RATIO = max(<span class=\"number\">0</span>, SystemPropertyUtil.getInt(<span class=\"string\">&quot;io.netty.recycler.delayedQueue.ratio&quot;</span>, RATIO));</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过前边对 Recycler 对象池的设计原理介绍，我们知道，在池化对象被回收的时候分别由两类线程来执行。</p>\n<ul>\n<li>一类是创建线程。池化对象在创建线程中被创建出来后，一直在创建线程中被处理，处理完毕后由创建线程直接进行回收。而为了避免对象池不可控制地迅速膨胀，所以需要对创建线程回收对象的频率进行限制。这个回收频率由参数 RATIO 控制，默认为8，可由JVM启动参数 <code>-D io.netty.recycler.ratio</code>​ 指定。表示创建线程只回收 1 / 8 的对象，也就是每创建 8 个对象最后只回收 1个对象。</li>\n<li>另一类就是回收线程。池化对象在创建线程中被创建出来，但是业务的相关处理是在回收线程中，业务处理完毕后由回收线程负责回收。前边提到对象回收有一个基本原则就是对象是谁创建的，就要回收到创建线程对应的Stack中。所以回收线程就需要将池化对象回收至其创建线程对应的Stack中的WeakOrderQueue链表中。并等待创建线程将WeakOrderQueue链表中的待回收对象<strong>转移</strong>至Stack中的数组栈中。同样，回收线程也需要控制回收频率，由参数 DELAYED_QUEUE_RATIO 进行控制，默认也是8，可由JVM启动参数 <code>-D io.netty.recycler.delayedQueue.ratio</code>​ 指定，表示回收线程每处理完 8 个对象才回收 1 个对象。</li>\n</ul>\n<h2 id=\"8-Recycler对象池的创建\">8. Recycler对象池的创建</h2>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RecyclerObjectPool</span>&lt;T&gt; <span class=\"keyword\">extends</span> <span class=\"title class_\">ObjectPool</span>&lt;T&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">//recycler对象池实例</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Recycler&lt;T&gt; recycler;</span><br><span class=\"line\"></span><br><span class=\"line\">    RecyclerObjectPool(<span class=\"keyword\">final</span> ObjectCreator&lt;T&gt; creator) &#123;</span><br><span class=\"line\">         recycler = <span class=\"keyword\">new</span> <span class=\"title class_\">Recycler</span>&lt;T&gt;() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">protected</span> T <span class=\"title function_\">newObject</span><span class=\"params\">(Handle&lt;T&gt; handle)</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> creator.newObject(handle);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ..................省略............</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>Netty 中的 Recycler 对象池是一个抽象类，里面封装了对象池的核心结构以及核心方法。在创建对象池的时候，我们往往会使用Recycler的匿名类来实现抽象方法 newObject 从而来定义对象池创建对象的行为。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Recycler</span>&lt;T&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">protected</span> <span class=\"keyword\">abstract</span> T <span class=\"title function_\">newObject</span><span class=\"params\">(Handle&lt;T&gt; handle)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">protected</span> <span class=\"title function_\">Recycler</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>(DEFAULT_MAX_CAPACITY_PER_THREAD);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"title function_\">Recycler</span><span class=\"params\">(<span class=\"type\">int</span> maxCapacityPerThread)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>(maxCapacityPerThread, MAX_SHARED_CAPACITY_FACTOR);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"title function_\">Recycler</span><span class=\"params\">(<span class=\"type\">int</span> maxCapacityPerThread, <span class=\"type\">int</span> maxSharedCapacityFactor)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>(maxCapacityPerThread, maxSharedCapacityFactor, RATIO, MAX_DELAYED_QUEUES_PER_THREAD);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"title function_\">Recycler</span><span class=\"params\">(<span class=\"type\">int</span> maxCapacityPerThread, <span class=\"type\">int</span> maxSharedCapacityFactor,</span></span><br><span class=\"line\"><span class=\"params\">                       <span class=\"type\">int</span> ratio, <span class=\"type\">int</span> maxDelayedQueuesPerThread)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>(maxCapacityPerThread, maxSharedCapacityFactor, ratio, maxDelayedQueuesPerThread,</span><br><span class=\"line\">                DELAYED_QUEUE_RATIO);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//创建线程持有对象池的最大容量</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> maxCapacityPerThread;</span><br><span class=\"line\">    <span class=\"comment\">//所有回收线程可回收对象的总量(计算因子)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> maxSharedCapacityFactor;</span><br><span class=\"line\">    <span class=\"comment\">//创建线程的回收比例</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> interval;</span><br><span class=\"line\">    <span class=\"comment\">//一个回收线程可帮助多少个创建线程回收对象</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> maxDelayedQueuesPerThread;</span><br><span class=\"line\">    <span class=\"comment\">//回收线程回收比例</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> delayedQueueInterval;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"title function_\">Recycler</span><span class=\"params\">(<span class=\"type\">int</span> maxCapacityPerThread, <span class=\"type\">int</span> maxSharedCapacityFactor,</span></span><br><span class=\"line\"><span class=\"params\">                       <span class=\"type\">int</span> ratio, <span class=\"type\">int</span> maxDelayedQueuesPerThread, <span class=\"type\">int</span> delayedQueueRatio)</span> &#123;</span><br><span class=\"line\">        interval = max(<span class=\"number\">0</span>, ratio);</span><br><span class=\"line\">        delayedQueueInterval = max(<span class=\"number\">0</span>, delayedQueueRatio);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (maxCapacityPerThread &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.maxCapacityPerThread = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.maxSharedCapacityFactor = <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.maxDelayedQueuesPerThread = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.maxCapacityPerThread = maxCapacityPerThread;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.maxSharedCapacityFactor = max(<span class=\"number\">1</span>, maxSharedCapacityFactor);</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.maxDelayedQueuesPerThread = max(<span class=\"number\">0</span>, maxDelayedQueuesPerThread);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>关于Recycler对象池中相关的重要属性我们在上一小节已经详细介绍过了，这里只是将这些重要参数赋值于Recycler对象池中定义的对应属性上。还是那句话，大家这里只需要对这些属性有一个感性的认识即可，并不需要强行完全理解，后面我们在介绍对象池的功能实现时还会结合具体场景来介绍这些属性。</p>\n<h2 id=\"9-多线程获取对象无锁化实现\">9. 多线程获取对象无锁化实现</h2>\n<p><img src=\"/assets/908c9b12522247dfbd32bada7308cb27tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-r7sakmv.awebp\" alt=\"image.png\"></p>\n<p>我们在介绍Netty对象池多线程获取对象的设计时提到，为了避免多线程并发获取对象时引入的同步开销，Netty采用了类似 TLAB 分配内存的思想，为每一个线程分配了一个独立的Stack结构，池化对象就存储在这个Stack结构中。当线程需要从对象池中获取对象时，Recycler就会从线程对应的Stakc结构中获取池化对象。各个线程独立运行，没有任何同步开销。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//threadlocal保存每个线程对应的 stack结构</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> FastThreadLocal&lt;Stack&lt;T&gt;&gt; threadLocal = <span class=\"keyword\">new</span> <span class=\"title class_\">FastThreadLocal</span>&lt;Stack&lt;T&gt;&gt;() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> Stack&lt;T&gt; <span class=\"title function_\">initialValue</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Stack</span>&lt;T&gt;(Recycler.<span class=\"built_in\">this</span>, Thread.currentThread(), maxCapacityPerThread, maxSharedCapacityFactor,</span><br><span class=\"line\">                interval, maxDelayedQueuesPerThread, delayedQueueInterval);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">    ..............省略..........</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>对象池中采用一个 FastThreadLocal 类型的字段 threadLocal 为每个线程维护一个独立的Stack结构。从而达到多线程无锁化获取对象的目的。</p>\n<blockquote>\n<p>FastThreadLocal是Netty基于JDK的ThreadLocal做的一个优化版本，拥有更快的访问性能。详细实现笔者后面会有一篇专门讲解FastThreadLocal的文章，这里大家只需要把它当成JDK的ThreadLocal来看待即可。</p>\n</blockquote>\n<p>当线程第一次从对象池中获取对象时会触发其对应的Stack结构的创建。</p>\n<h3 id=\"9-1-Stack结构的创建\">9.1 Stack结构的创建</h3>\n<p>本小节我们来介绍一下对象池中Stack结构的设计实现。在前边《5.2 Stack的设计》小节中我们介绍了Stack结构中的一些核心属性，包括：数组栈以及WeakOrderQueue链表的Head指针，Prev指针，Cursor指针。</p>\n<p>本小节笔者会把Stack结构中的剩余属性介绍给大家，通过这一小节的介绍，相信大家就会对Stack的设计实现有了一个整体的了解。还是那句话，这里大家只需要对这些属性有一个感性的认识，先混个眼熟，后面笔者还会结合具体场景详细讲解。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Stack</span>&lt;T&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 创建线程保存池化对象的stack结构所属对象池recycler实例</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> Recycler&lt;T&gt; parent;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//用弱引用来关联当前stack对应的创建线程 因为用户可能在某个地方引用了defaultHandler -&gt; stack -&gt; thread，可能存在这个引用链</span></span><br><span class=\"line\">        <span class=\"comment\">//当创建线程死掉之后 可能因为这个引用链的存在而导致thread无法被回收掉</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> WeakReference&lt;Thread&gt; threadRef;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//所有回收线程能够帮助当前创建线程回收对象的总容量</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> AtomicInteger availableSharedCapacity;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//当前Stack对应的创建线程作为其他创建线程的回收线程时可以帮助多少个线程回收其池化对象</span></span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> maxDelayedQueues;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//当前创建线程对应的stack结构中的最大容量。 默认4096个对象</span></span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> maxCapacity;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//当前创建线程回收对象时的回收比例</span></span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> interval;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//当前创建线程作为其他线程的回收线程时回收其他线程的池化对象比例</span></span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> delayedQueueInterval;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 当前Stack中的数组栈 默认初始容量256，最大容量为4096</span></span><br><span class=\"line\">        DefaultHandle&lt;?&gt;[] elements;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//数组栈 栈顶指针</span></span><br><span class=\"line\">        <span class=\"type\">int</span> size;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//回收对象计数 与 interval配合 实现只回收一定比例的池化对象</span></span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"type\">int</span> handleRecycleCount;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//多线程回收的设计，核心还是无锁化，避免多线程回收相互竞争</span></span><br><span class=\"line\">        <span class=\"comment\">//Stack结构中的WeakOrderQueue链表</span></span><br><span class=\"line\">        <span class=\"keyword\">private</span> WeakOrderQueue cursor, prev;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> WeakOrderQueue head;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/assets/ad0a175194af489d9c71f096ac430a03tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-4g64cdf.awebp\" alt=\"image.png\"></p>\n<ul>\n<li>​<code>Recycler&lt;T&gt; parent</code>​：Stack所属Recycler对象池实例，一个对象池可被多个线程访问获取对象，所以一个对象池对应多个Stack，每个Stack的parent属性指向所属的Recycler实例。比如图中的 stack1 , stack2 , stack3 , stack4 中的parent属性均指向同一个Recycler对象池实例。</li>\n<li>​<code>WeakReference&lt;Thread&gt; threadRef </code>​：Stack会通过弱引用的方式引用到其对应的创建线程。这里使用弱引用来持有对应创建线程的原因是因为对象池的设计中存在这样一个引用关系：<code>池化对象 -&gt; DefaultHandler -&gt; stack -&gt; threadRef</code>​。而池化对象是暴露给用户的，如果用户在某个地方持有了池化对象的强引用忘记清理，而Stack持有创建线程的强引用的话，当创建线程死掉的之后，因为这样一个强引用链的存在从而导致创建线程一直不能被GC回收。</li>\n<li>​<code>AtomicInteger availableSharedCapacity</code>​：当前创建线程对应的所有回收线程可以帮助当前创建线程回收的对象总量。比如图中thread2 , thread3 , thread4 这三个回收线程总共可以帮助 thread1 回收对象的总量。availableSharedCapacity 在多个回收线程中是​<strong>共享的</strong>​，回收线程每回收一个对象它的值就会减1，当小于 LINK_CAPACITY(回收线程对应WeakOrderQueue节点的最小存储单元Link)时，回收线程将不能在为该stack回收对象了。该值的计算公式为前边介绍的 <code>max(maxCapacity / maxSharedCapacityFactor, LINK_CAPACITY)</code>​。</li>\n</ul>\n<blockquote>\n<p>当创建线程从Stack结构中的WeakOrderQueue链表中转移待回收对象到数组栈中后，availableSharedCapacity 的值也会相应增加。说白了这个值就是用来指示回收线程还能继续回收多少对象。已达到控制回收线程回收对象的总体容量。</p>\n</blockquote>\n<ul>\n<li>​<code>int maxDelayedQueues</code>​： 一个线程对于对象池来说，它可以是创建线程，也可以是回收线程，当该创建线程作为回收线程时，该值定义了最多可以为多少个创建线程回收对象。默认值为 CPU * 2。比如图中 thread2 作为回收线程既可以帮 thread1 回收对象也可以帮助 thread3 , thread4 回收对象。那么maxDelayedQueues 的值就是 3 。</li>\n<li>​<code>int maxCapacity</code>​：定义当前Stack结构中的数组栈的最大容量。默认为4096。</li>\n<li>​<code>int interval</code>​：创建线程的回收比例，默认是8。</li>\n<li>​<code>int delayedQueueInterval</code>​：创建线程作为回收线程时的回收比例。默认是8。</li>\n<li>​<code>DefaultHandle&lt;?&gt;[] elements</code>​：这个就是我们前边反复提到的Stack结构中的数组栈。用于存放对象池中的池化对象。当线程从对象池中获取对象时就是从这里获取。</li>\n<li>​<code>int size</code>​：数组栈中的栈顶指针。</li>\n<li>​<code>int handleRecycleCount</code>​：回收对象计数。与 interval 配合达到控制回收对象比例的目的。从 0 开始每遇到一个回收对象就 +1 ，同时把对象丢弃。直到<code>handleRecycleCount == interval</code>​时回收对象，然后归零。也就是前边我们说到的每创建8个对象才回收1个。避免 Stack 不可控制的迅速增长。</li>\n<li>​<code>WeakOrderQueue cursor, prev，head</code>​：这三个指针就是前边我们在讲Stack设计的时候介绍到的用于<strong>多线程无锁化回收</strong>的 WeakOrderQueue 链表中的头结点指针，当前节点指针，前一个节点指针（用于删除节点）。</li>\n</ul>\n<p>介绍完Stack结构中的这些重要属性，创建的过程就很简单了。就是利用前边介绍过的已经初始化好的Recycler属性对Stack结构中的这些属性进行赋值。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> FastThreadLocal&lt;Stack&lt;T&gt;&gt; threadLocal = <span class=\"keyword\">new</span> <span class=\"title class_\">FastThreadLocal</span>&lt;Stack&lt;T&gt;&gt;() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> Stack&lt;T&gt; <span class=\"title function_\">initialValue</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Stack</span>&lt;T&gt;(Recycler.<span class=\"built_in\">this</span>, Thread.currentThread(), maxCapacityPerThread, maxSharedCapacityFactor,</span><br><span class=\"line\">                interval, maxDelayedQueuesPerThread, delayedQueueInterval);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  ..............省略............</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stack(Recycler&lt;T&gt; parent, Thread thread, <span class=\"type\">int</span> maxCapacity, <span class=\"type\">int</span> maxSharedCapacityFactor,</span><br><span class=\"line\">       <span class=\"type\">int</span> interval, <span class=\"type\">int</span> maxDelayedQueues, <span class=\"type\">int</span> delayedQueueInterval) &#123;</span><br><span class=\"line\">     <span class=\"built_in\">this</span>.parent = parent;</span><br><span class=\"line\">     threadRef = <span class=\"keyword\">new</span> <span class=\"title class_\">WeakReference</span>&lt;Thread&gt;(thread);</span><br><span class=\"line\">     <span class=\"built_in\">this</span>.maxCapacity = maxCapacity;</span><br><span class=\"line\">     availableSharedCapacity = <span class=\"keyword\">new</span> <span class=\"title class_\">AtomicInteger</span>(max(maxCapacity / maxSharedCapacityFactor, LINK_CAPACITY));</span><br><span class=\"line\">     elements = <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultHandle</span>[min(INITIAL_CAPACITY, maxCapacity)];</span><br><span class=\"line\">     <span class=\"built_in\">this</span>.interval = interval;</span><br><span class=\"line\">     <span class=\"built_in\">this</span>.delayedQueueInterval = delayedQueueInterval;</span><br><span class=\"line\">     handleRecycleCount = interval; </span><br><span class=\"line\">     <span class=\"built_in\">this</span>.maxDelayedQueues = maxDelayedQueues;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"9-2-从对象池中获取对象\">9.2 从对象池中获取对象</h3>\n<p><img src=\"/assets/002bdbd0d71140c3834d44b93555237ftplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-ryqzvpj.awebp\" alt=\"image.png\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Recycler</span>&lt;T&gt; &#123;</span><br><span class=\"line\">      <span class=\"comment\">//一个空的Handler,表示该对象不会被池化</span></span><br><span class=\"line\">     <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Handle</span> <span class=\"variable\">NOOP_HANDLE</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Handle</span>() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">recycle</span><span class=\"params\">(Object object)</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// NOOP</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> T <span class=\"title function_\">get</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//如果对象池容量为0，则立马新创建一个对象返回，但是该对象不会回收进对象池</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (maxCapacityPerThread == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> newObject((Handle&lt;T&gt;) NOOP_HANDLE);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//获取当前线程 保存池化对象的stack</span></span><br><span class=\"line\">        Stack&lt;T&gt; stack = threadLocal.get();</span><br><span class=\"line\">        <span class=\"comment\">//从stack中pop出对象，handler是池化对象在对象池中的模型，包装了一些池化对象的回收信息和回收状态</span></span><br><span class=\"line\">        DefaultHandle&lt;T&gt; handle = stack.pop();</span><br><span class=\"line\">        <span class=\"comment\">//如果当前线程的stack中没有池化对象 则直接创建对象</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (handle == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//初始化的handler对象recycleId和lastRecyclerId均为0</span></span><br><span class=\"line\">            handle = stack.newHandle();</span><br><span class=\"line\">            <span class=\"comment\">//newObject为对象池recycler的抽象方法，由使用者初始化内存池的时候 匿名提供</span></span><br><span class=\"line\">            handle.value = newObject(handle);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (T) handle.value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Recycler对外表现为一个整体的对象池，但是对象池内部是按照线程的维度来池化对象的，每个线程所池化的对象保存在对应的Stack结构中。</p>\n<ol>\n<li>当对象池的最大容量<code>maxCapacityPerThread == 0</code>​时，对象池会立马创建一个对象出来，并将一个空的Handler传递进对象中。表示该对象在使用完毕后不会被回收进对象池中。</li>\n<li>从threadLocal中获取当前线程对应的Stack，随后从Stack结构中的数组栈中弹出栈顶对象的DefaultHandler。</li>\n<li>如果弹出的DefaultHandler为空，说明当前Stack中并没有回收的池化对象。直接创建一个新的DefaultHandler并创建一个新的对象，然后将DefaultHandler传入到新创建的对象中，并用DefaultHandler包裹新创建的对象。这样池化对象就与DefaultHandler关联起来了。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Entry</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ObjectPool&lt;Entry&gt; RECYCLER = ObjectPool.newPool(<span class=\"keyword\">new</span> <span class=\"title class_\">ObjectCreator</span>&lt;Entry&gt;() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> Entry <span class=\"title function_\">newObject</span><span class=\"params\">(Handle&lt;Entry&gt; handle)</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Entry</span>(handle);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"keyword\">private</span> <span class=\"title function_\">Entry</span><span class=\"params\">(Handle&lt;Entry&gt; handle)</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.handle = handle;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"9-3-DefaultHandler\">9.3 DefaultHandler</h3>\n<p>前边我们在介绍对象池的设计原理时提到，池化对象在对象池中的存储模型为 Handler。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ObjectPool</span>&lt;T&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Handle</span>&lt;T&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">void</span> <span class=\"title function_\">recycle</span><span class=\"params\">(T self)</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在Recycler对象池中的默认实现是 DefaultHandler ，DefaultHandler 里面包裹了池化对象以及池化对象在对象池中的一些相关信息，（比如：池化对象的相关回收信息和回收状态）。</p>\n<p>从结构设计角度上来说，池化对象是隶属于其创建线程对应的Stack结构的，由于这层结构关系的存在，池化对象的DefaultHandler应该由Stack来进行创建。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Stack</span>&lt;T&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">       DefaultHandle&lt;T&gt; <span class=\"title function_\">newHandle</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">           <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultHandle</span>&lt;T&gt;(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们来看下 DefaultHandler 的具体结构：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DefaultHandle</span>&lt;T&gt; <span class=\"keyword\">implements</span> <span class=\"title class_\">Handle</span>&lt;T&gt; &#123;</span><br><span class=\"line\">     <span class=\"comment\">//用于标识最近被哪个线程回收，被回收之前均是0</span></span><br><span class=\"line\">     <span class=\"type\">int</span> lastRecycledId;</span><br><span class=\"line\">     <span class=\"comment\">//用于标识最终被哪个线程回收，在没被回收前是0</span></span><br><span class=\"line\">     <span class=\"type\">int</span> recycleId;</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"comment\">//是否已经被回收</span></span><br><span class=\"line\">     <span class=\"type\">boolean</span> hasBeenRecycled;</span><br><span class=\"line\">     <span class=\"comment\">//强引用关联创建handler的stack</span></span><br><span class=\"line\">     Stack&lt;?&gt; stack;</span><br><span class=\"line\">     <span class=\"comment\">//池化对象</span></span><br><span class=\"line\">     Object value;</span><br><span class=\"line\"></span><br><span class=\"line\">     DefaultHandle(Stack&lt;?&gt; stack) &#123;</span><br><span class=\"line\">         <span class=\"built_in\">this</span>.stack = stack;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"meta\">@Override</span></span><br><span class=\"line\">     <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">recycle</span><span class=\"params\">(Object object)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">       ...................省略.............</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>DefaultHandler属性的第一部分信息，首先就是池化对象在对象池中的回收信息。</p>\n<ul>\n<li>​<code>int lastRecycledId</code>​：用于标识最近被哪个线程回收，被回收之前均是0。</li>\n<li>​<code>int recycleId</code>​：用于标识最终被哪个线程回收，在没被回收前是0。</li>\n<li>​<code>boolean hasBeenRecycled</code>​：该池化对象是否已经被回收至创建线程对应的Stack中。</li>\n</ul>\n<p>​<strong>这里可能大家有疑问了，为什么池化对象的回收还要分最近回收和最终回收呢</strong>​？</p>\n<p>因为对象池中的池化对象回收可以分为两种情况：</p>\n<ul>\n<li>​<code>由创建线程直接进行回收</code>​：这种回收情况就是一步到位，直接回收至创建线程对应的Stack中。所以这种情况下是不分阶段的。<code>recycleId = lastRecycledId = OWN_THREAD_ID</code>​。</li>\n<li>​<code>由回收线程帮助回收</code>​：这种回收情况下就要分步进行了，首先由回收线程将池化对象<strong>暂时存储</strong>在其创建线程对应Stack中的WeakOrderQueue链表中。此时并没有完成真正的对象回收。<code>recycleId = 0，lastRecycledId = 回收线程Id（WeakOrderQueue#id）</code>​。当创建线程将WeakOrderQueue链表中的待回收对象转移至Stack结构中的数组栈之后，这时池化对象才算真正完成了回收动作。<code>recycleId = lastRecycledId = 回收线程Id（WeakOrderQueue#id）</code>​。</li>\n</ul>\n<p>这两个字段 lastRecycledId ，recycleId 主要是用来标记池化对象所处的回收阶段，以及在这些回收阶段具体被哪个线程进行回收。</p>\n<p>最后两个属性就比较容易理解了，一个是 Object value 用来包裹真正的池化对象。另一个是 Stack&lt;?&gt; stack 用来强引用关联池化对象的Handler所属的Stack结构。</p>\n<p>记不记得我们在介绍Stack结构的时候提到，Stack中持有其对应创建线程的<code>弱引用</code>​。笔者在解释为什么持有创建线程的弱引用时，提到过这样一个引用链关系：<code>池化对象 -&gt; DefaultHandler -&gt; Stack -&gt; threadRef</code>​。这里大家明白了吗？</p>\n<p><img src=\"/assets/d9a984a0659546258734112ce5c687f7tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-qzq41qp.awebp\" alt=\"image.png\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Entry</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//池化对象Entry强引用它的DefaultHandler</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span>  Handle&lt;Entry&gt; handle;</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DefaultHandle</span>&lt;T&gt; <span class=\"keyword\">implements</span> <span class=\"title class_\">Handle</span>&lt;T&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// DefaultHandler强引用其所属的Stack</span></span><br><span class=\"line\">    Stack&lt;?&gt; stack;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Stack</span>&lt;T&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Stack弱引用其对应的创建线程</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> WeakReference&lt;Thread&gt; threadRef;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"9-4-从Stack中获取池化对象\">9.4 从Stack中获取池化对象</h3>\n<p><img src=\"/assets/6d2a0769269e405dac3519f9e45d14d7tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-hfn0g3i.awebp\" alt=\"image.png\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DefaultHandle&lt;T&gt; <span class=\"title function_\">pop</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//普通出栈操作，从栈顶弹出一个回收对象</span></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">size</span> <span class=\"operator\">=</span> <span class=\"built_in\">this</span>.size;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (size == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//如果当前线程所属stack已经没有对象可用，则遍历stack中的weakOrderQueue链表（其他线程帮助回收的对象存放在这里）将这些待回收对象回收进stack</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!scavenge()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        size = <span class=\"built_in\">this</span>.size;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (size &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果WeakOrderQueue链表中也没有待回收对象可转移</span></span><br><span class=\"line\">            <span class=\"comment\">// 直接返回null 新创建一个对象</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    size --;</span><br><span class=\"line\">    <span class=\"type\">DefaultHandle</span> <span class=\"variable\">ret</span> <span class=\"operator\">=</span> elements[size];</span><br><span class=\"line\">    elements[size] = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.size = size;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ret.lastRecycledId != ret.recycleId) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 这种情况表示对象至少被一个线程回收了，要么是创建线程，要么是回收线程</span></span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalStateException</span>(<span class=\"string\">&quot;recycled multiple times&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//对象初次创建以及回收对象再次使用时  它的 recycleId = lastRecycleId = 0</span></span><br><span class=\"line\">    ret.recycleId = <span class=\"number\">0</span>;</span><br><span class=\"line\">    ret.lastRecycledId = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里就是业务线程从对象池中真正获取池化对象的地方。从Stack结构中的数组栈的栈顶位置弹出池化对象。</p>\n<ul>\n<li>首先判断数组栈中是否有回收的池化对象。栈顶指针 size == 0 说明当前数组栈中是空的。随后就会调用 scavenge 方法，从Stack结构中的WeakOrderQueue链表中转移最多一个Link大小的待回收对象到数组栈中。如果WeakOrderQueue链表中也没有待回收对象，说明当前Stack结构就是空的没有任何回收的池化对象，对象池直接返回 null ，并创建一个新的池化对象返回给业务线程。</li>\n<li>如果数组栈不为空，则将栈顶元素 DefaultHandler 弹出，初始化池化对象DefaultHandler的回收信息。<code>recycleId  = lastRecycledId = 0</code>​表示该池化对象刚刚从对象池中取出。</li>\n</ul>\n<p>recycleId 与 lastRecycledId 之间的关系分为以下几种情况：</p>\n<ul>\n<li>​<code>recycleId  = lastRecycledId = 0</code>​：表示池化对象刚刚被创建或者刚刚从对象池中取出即将被再次复用。这是池化对象的初始状态。</li>\n<li>​<code>recycleId  = lastRecycledId != 0</code>​：表示当前池化对象已经被回收至对应Stack结构里的数组栈中。可以直接被取出复用。可能是被其创建线程直接回收，也可能是被回收线程回收。</li>\n<li>​<code>recycleId  != lastRecycledId</code>​：表示当前池化对象处于半回收状态。池化对象已经被业务线程处理完毕，并被回收线程回收至对应的WeakOrderQueue节点中。并等待创建线程将其最终转移至Stack结构中的数组栈中。</li>\n</ul>\n<h3 id=\"9-4-转移回收线程回收的对象到Stack中\">9.4 转移回收线程回收的对象到Stack中</h3>\n<p><img src=\"/assets/29c7d6a21d76455d9bc5443394172a2btplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-jhifgqp.awebp\" alt=\"image.png\"></p>\n<p>通过前边介绍Stack结构的设计原理我们知道，对象池中池化对象的回收存储分为两个部分：</p>\n<ul>\n<li>一个是池化对象直接被创建线程回收，直接存储在创建线程对应Stack结构中的数组栈中。</li>\n<li>另一个是池化对象被回收线程回收，临时间接存储在创建线程对应Stack结构中的WeakOrderQueue链表中。每个回收线程对应一个WeakOrderQueue节点。</li>\n</ul>\n<p>当Stack结构中的数组栈为空时，创建线程会遍历WeakOrderQueue链表，从而将回收线程为其回收的对象从WeakOrderQueue节点中转移至数组栈中。<strong>多线程回收对象无锁化设计</strong></p>\n<p>这个转移的动作就是由 scavenge 方法来完成的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"type\">boolean</span> <span class=\"title function_\">scavenge</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">     <span class=\"comment\">//从其他线程回收的weakOrderQueue里 转移 待回收对像 到当前线程的stack中</span></span><br><span class=\"line\">     <span class=\"keyword\">if</span> (scavengeSome()) &#123;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"comment\">// 如果weakOrderQueue中没有待回收对象可转移，那么就重置stack中的cursor.prev</span></span><br><span class=\"line\">     <span class=\"comment\">// 因为在扫描weakOrderQueue链表的过程中，cursor已经发生变化了</span></span><br><span class=\"line\">     prev = <span class=\"literal\">null</span>;</span><br><span class=\"line\">     cursor = head;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>scavengeSome() 执行具体的转移逻辑。如果WeakOrderQueue链表中还有待回收对象并转移成功则返回 true 。如果WeakOrderQueue链表为空没有任何待回收对象可转移，则重置链表相关的指针，cursor重新指向head节点，prev指向null。因为在遍历WeakOrderQueue链表搜寻可转移对象时，cursor指针已经发生变化了，这里需要重置。</p>\n<h3 id=\"9-5-转移回收对象\">9.5 转移回收对象</h3>\n<p>下面创建线程就开始遍历Stack结构中的WeakOrderQueue链表，将其中存储的回收线程回收进来的对象转移到数组栈中。</p>\n<p>为了让大家更清晰的理解遍历WeakOrderQueue链表的过程，我们先来了解下Stack中WeakOrderQueue链表的状态结构如下图所示：</p>\n<p><img src=\"/assets/c7d327afbf054012bd98bb554bfd19a3tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-kxpsqug.awebp\" alt=\"image.png\"></p>\n<p>在Stack结构刚刚创建的初始状态，WeakOrderQueue链表是空的，所以 prev = head = cursor = null 。</p>\n<p>后面当回收线程在回收对象时会加入自己对应的WeakOrderQueue节点到链表中。​<strong>注意：WeakOrderQueue节点的插入都是在链表的头结点进行插入</strong>​。</p>\n<blockquote>\n<p>后面我们在讲到多线程回收对象时还会再次详细讲解WeakOrderQueue链表的操作，这里大家只需要先理解链表的状态结构即可。</p>\n</blockquote>\n<p>head指针始终指向链表的头结点，cursor指针指向当前遍历的节点。在没有开始遍历链表前，cursor指针指向头结点。表示从头结点开始遍历。prev指针指向cursor前一个节点。当前遍历节点为头结点时，prev指针指向空。</p>\n<p>在理解了WeakOrderQueue链表的状态结构后，我们来看一下链表的遍历转移过程逻辑：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"type\">boolean</span> <span class=\"title function_\">scavengeSome</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    WeakOrderQueue prev;</span><br><span class=\"line\">    <span class=\"comment\">//获取当前线程stack 的weakOrderQueue链表指针（本次扫描起始节点）</span></span><br><span class=\"line\">    <span class=\"type\">WeakOrderQueue</span> <span class=\"variable\">cursor</span> <span class=\"operator\">=</span> <span class=\"built_in\">this</span>.cursor;</span><br><span class=\"line\">    <span class=\"comment\">//在stack初始化完成后，cursor，prev,head等指针全部是null，这里如果cursor == null 意味着当前stack第一次开始扫描weakOrderQueue链表</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cursor == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        prev = <span class=\"literal\">null</span>;</span><br><span class=\"line\">        cursor = head;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cursor == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//说明目前weakOrderQueue链表里还没有节点，并没有其他线程帮助回收的池化对象</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//获取prev指针，用于操作链表（删除当前cursor节点）</span></span><br><span class=\"line\">        prev = <span class=\"built_in\">this</span>.prev;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"variable\">success</span> <span class=\"operator\">=</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"comment\">//循环遍历weakOrderQueue链表 转移待回收对象</span></span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//将weakOrderQueue链表中当前节点中包含的待回收对象，转移到当前stack中，一次转移一个link</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cursor.transfer(<span class=\"built_in\">this</span>)) &#123;</span><br><span class=\"line\">            success = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//如果当前cursor节点没有待回收对象可转移，那么就继续遍历链表获取下一个weakOrderQueue节点</span></span><br><span class=\"line\">        <span class=\"type\">WeakOrderQueue</span> <span class=\"variable\">next</span> <span class=\"operator\">=</span> cursor.getNext();</span><br><span class=\"line\">        <span class=\"comment\">//如果当前weakOrderQueue对应的回收线程已经挂掉了，则</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cursor.get() == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 判断当前weakOrderQueue节点是否还有可回收对象</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cursor.hasFinalData()) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//回收weakOrderQueue中最后一点可回收对象，因为对应的回收线程已经死掉了，这个weakOrderQueue不会再有任何对象了</span></span><br><span class=\"line\">                <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (cursor.transfer(<span class=\"built_in\">this</span>)) &#123;</span><br><span class=\"line\">                        success = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//回收线程以死，对应的weaoOrderQueue节点中的最后一点待回收对象也已经回收完毕，就需要将当前节点从链表中删除。unlink当前cursor节点</span></span><br><span class=\"line\">            <span class=\"comment\">//这里需要注意的是，netty永远不会删除第一个节点，因为更新头结点是一个同步方法，避免更新头结点而导致的竞争开销</span></span><br><span class=\"line\">            <span class=\"comment\">// prev == null 说明当前cursor节点是头结点。不用unlink，如果不是头结点 就将其从链表中删除，因为这个节点不会再有线程来收集池化对象了</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (prev != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//确保当前weakOrderQueue节点在被GC之前，我们已经回收掉它所有的占用空间</span></span><br><span class=\"line\">                cursor.reclaimAllSpaceAndUnlink();</span><br><span class=\"line\">                <span class=\"comment\">//利用prev指针删除cursor节点</span></span><br><span class=\"line\">                prev.setNext(next);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            prev = cursor;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//向后移动prev,cursor指针继续遍历weakOrderQueue链表</span></span><br><span class=\"line\">        cursor = next;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> (cursor != <span class=\"literal\">null</span> &amp;&amp; !success);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.prev = prev;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.cursor = cursor;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> success;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>再开始遍历WeakOrderQueue链表之前，首先需要检查cursor指针是否为空，如果为空说明当前Stack是第一次开始遍历WeakOrderQueue链表。随后让cursor指针指向head指针，如果head指针指向为空，说明当前WeakOrderQueue链表是空的，此时没有任何回收线程在回收对象。如果head指针不为空，则从head指针指向的头结点开始遍历WeakOrderQueue链表。</li>\n<li>首先会从cursor指针指向的当前遍历节点开始，将当前WeakOrderQueue节点中存储的待回收对象转移到Stack结构中的数组栈中。一次最多转移一个Link大小的对象。转移成功后退出。如果当前WeakOrderQueue节点此时没有任何待回收对象可被转移则转移失败，继续遍历下一个WeakOrderQueue节点。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (cursor.transfer(<span class=\"built_in\">this</span>)) &#123;</span><br><span class=\"line\">    success = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">WeakOrderQueue</span> <span class=\"variable\">next</span> <span class=\"operator\">=</span> cursor.getNext();</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>为了多线程能够无锁化回收对象，一个回收线程对应一个WeakOrderQueue节点，在WeakOrderQueue节点中持有对应回收线程的<code>弱引用</code>​,目的也是为了当回收线程挂掉的时候，能够保证回收线程被GC及时的回收掉。如果<code>cursor.get() == null</code>​说明当前WeakOrderQueue节点对应的回收线程已经挂掉了，此时如果当前节点还有待回收对象，则需要将节点中的所有待回收对象全部转移至Stack中的数组栈中。​<strong>注意这里是转移节点所有的待回收对象而不是只转移一个Link</strong>​。因为对应的回收线程已经挂掉了，该线程后续将不再会帮助创建线程回收对象了，所以要清理其对应的WeakOrderQueue节点。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">WeakOrderQueue</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">WeakReference</span>&lt;Thread&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    ............WeakOrderQueue本身就是一个弱引用，引用对应的回收线程.........</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>当清理完已经挂掉的回收线程对应的WeakOrderQueue节点后，就需要将该节点从Stack结构里的WeakOrderQueue链表中删除。保证被清理后的WeakOrderQueue节点可以被GC回收。当然删除节点之前需要通过<code>cursor.reclaimAllSpaceAndUnlink()</code>​释放回收线程回收对象的availableSharedCapacity容量。释放的容量的大小为被删除WeakOrderQueue节点中存储的待回收对象容量。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (prev != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      cursor.reclaimAllSpaceAndUnlink();</span><br><span class=\"line\">      <span class=\"comment\">//利用prev指针删除cursor节点</span></span><br><span class=\"line\">      prev.setNext(next);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>这里需要注意的是，Netty不会对WeakOrderQueue链表的头结点进行删除。如果<code>prev == null</code>​说明当前节点是头结点，即使对应的回收线程已经挂掉了，但在本次遍历中不会对其进行删除。因为操作链表头结点的方法是一个同步方法，Netty这里是为了避免不必要的同步开销。</p>\n</blockquote>\n<p>以上逻辑就是创建线程遍历WeakOrderQueue链表转移回收对象的处理逻辑，如果本次遍历的当前节点中并没有对象可转移，那么就继续从下一个节点开始遍历。循环执行转移逻辑直到遍历完链表或者中途转移成功。退出循环时要记录更新cursor指针记录当前遍历到的节点。</p>\n<p>这里大家可能会有两个问题：</p>\n<p>​<strong>第一个问题：如果头结点对应的回收线程已经挂掉，这个头结点不在本次遍历中删除，那么会在什么时候被删除呢</strong>​？</p>\n<p><img src=\"/assets/359cbfb6d68e450b8f611a9975099c6etplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-ol5zynd.awebp\" alt=\"image.png\"></p>\n<p>首先当回收线程第一次开始帮助创建线程回收对象时，会将自己对应的WeakOrderQueue节点插入到创建线程对应Stack结构中的WeakOrderQueue链表的头结点位置。​<strong>节点始终在链表的头结点位置插入</strong>​。</p>\n<p>如图所示，当本次遍历发现头结点对应的回收线程 thread4 已经挂掉后，清理完头结点中存储的待回收对象后，让其继续呆在链表中，​<strong>并不着急将其删除</strong>​。随后cursor指针指向thread3对应的节点，下一次遍历就会从thread3对应的节点开始遍历。</p>\n<p>当有一个新的回收线程 thread5 加入后，此时thread5对应的WeakOrderQueue节点变成了链表中的头结点，当经过多次遍历之后，cursor指针最终会再次指向死亡线程<code>thread4</code>​对应的节点时，会再次进入<code>cursor.get() == null</code>​的处理逻辑，而此时<code>thread4</code>​对应的节点已经不是头结点了，所以在这次遍历中就将该节点从链表中删除。</p>\n<blockquote>\n<p>这就是多线程并发代码和单线程代码设计上的不同，在多线程程序设计中，我们一定要时刻警惕同步操作的开销。能避免就要尽量避免。</p>\n</blockquote>\n<p><strong>第二个问题：操作WeakOrderQueue链表的头结点为什么是同步方法呢？</strong></p>\n<p>我们都知道一个回收线程对应一个WeakOrderQueue节点，当一个回收线程第一次为该创建线程回收对象时，都会新创建一个WeakOrderQueue节点并将节点插入到创建线程对应Stack中的WeakOrderQueue链表中的头结点位置。</p>\n<p>在多线程回收场景下，可能会有多个回收线程同时向创建线程对应Stack中的WeakOrderQueue链表的头结点插入自己对应的节点。</p>\n<p>那么此时对于链表头结点的操作就必须做同步处理了。当节点同步插入到链表的头结点后，以后该回收线程回收对象就是无锁化了。​<strong>只不过就是在一开始插入节点的时候会有一点同步的开销，但是这是无法避免的</strong>​。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//整个recycler对象池唯一的一个同步方法，而且同步块非常小，逻辑简单，执行迅速</span></span><br><span class=\"line\"><span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setHead</span><span class=\"params\">(WeakOrderQueue queue)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//始终在weakOrderQueue链表头结点插入新的节点</span></span><br><span class=\"line\">    queue.setNext(head);</span><br><span class=\"line\">    head = queue;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>纵观整个Recycler的设计实现，这个方法是唯一一个同步的方法，而且同步块非常的短，里面的逻辑非常简单。</p>\n<blockquote>\n<p>在多线程程序设计中，如果遇到无法避免的同步情况，那么也必须使同步块内的代码逻辑尽量简单。</p>\n</blockquote>\n<h2 id=\"10-WeakOrderQueue的设计实现\">10. WeakOrderQueue的设计实现</h2>\n<p><img src=\"/assets/53b93ae1d4dc4adeaa4d6104cc9aa7b6tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-onec9un.awebp\" alt=\"image.png\"></p>\n<p>之前我们在介绍WeakOrderQueue结构设计原理的时候讲到，虽然该结构命名的后缀是一个Queue，但其实是一个链表，链表中的元素类型为Link，头结点指针Head永远指向第一个未被转移完毕的Link，当一个Link里的待回收对象被全部转移完毕后，head指针随即指向下一个节点，但是该Link节点并不会从链表中删除。尾指针Tail指向链表中最后一个<code>Link节点</code>​。节点的插入是从链表的尾部开始插入。</p>\n<h3 id=\"10-1-Link结构\">10.1 Link结构</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">WeakOrderQueue</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">WeakReference</span>&lt;Thread&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// link结构是用于真正存储待回收对象的结构，继承AtomicInteger 本身可以用来当做writeindex使用</span></span><br><span class=\"line\">        <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Link</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">AtomicInteger</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//数组用来存储待回收对象，容量为16</span></span><br><span class=\"line\">            <span class=\"keyword\">final</span> DefaultHandle&lt;?&gt;[] elements = <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultHandle</span>[LINK_CAPACITY];</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"type\">int</span> readIndex;</span><br><span class=\"line\">            <span class=\"comment\">//weakOrderQueue中的存储结构时由link结构节点元素组成的链表结构</span></span><br><span class=\"line\">            Link next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>首先我们从WeakOrderQueue的继承结构上来看，它继承于 <code>WeakReference &lt; Thread &gt;</code>​ , 表示该结构持有一个线程的<code>弱引用</code>​，一个回收线程对应于一个WeakOrderQueue节点，很明显是持有其对应回收线程的弱引用，方便当回收线程挂掉的时候被GC回收。</p>\n<ul>\n<li>​<code>DefaultHandle&lt;?&gt;[] elements </code>​: Link结构中包含一个容量为LINK_CAPACITY ，默认为16大小的DefaultHandle数组，用来存储回收线程回收的对象。</li>\n<li>​<code>int readIndex</code>​：创建线程在转移Link节点中的待回收对象时，通过这个readIndex来读取未被转移的对象。由于readIndex只会被创建线程使用，所以这里并不需要保证原子性和可见性。用一个普通的int变量存储就好。</li>\n<li>​<code>writeIndex</code>​：Link结构继承于AtomicInteger类型，这就意味着Link结构本身就可以被当做一个writeIndex来使用，由于回收线程在向Link节点添加回收对象的时候需要修改writeIndex，于此同时创建线程在转移Link节点的时候需要读取writeIndex，所以writeIndex需要保证线程安全性，故采用AtomicInteger类型存储。</li>\n<li>​<code>Link next</code>​：Link节点的next指针，用于指向链表中的下一个节点。</li>\n</ul>\n<h3 id=\"10-2-Head结构\">10.2 Head结构</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// weakOrderQueue内部link链表的头结点</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Head</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//所有回收线程能够帮助创建线程回收对象的总容量 reserveSpaceForLink方法中会多线程操作该字段</span></span><br><span class=\"line\">    <span class=\"comment\">//用于指示当前回收线程是否继续为创建线程回收对象，所有回收线程都可以看到，这个值是所有回收线程共享的。以便可以保证所有回收线程回收的对象总量不能超过availableSharedCapacity</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> AtomicInteger availableSharedCapacity;</span><br><span class=\"line\">    <span class=\"comment\">//link链表的头结点</span></span><br><span class=\"line\">    Link link;</span><br><span class=\"line\"></span><br><span class=\"line\">    Head(AtomicInteger availableSharedCapacity) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.availableSharedCapacity = availableSharedCapacity;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">reclaimAllSpaceAndUnlink</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            ....回收head节点的所有空间，并从链表中删除head节点，head指针指向下一节点....</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">reclaimSpace</span><span class=\"params\">(<span class=\"type\">int</span> space)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//所有回收线程都可以看到，这个值是所有回收线程共享的。以便可以保证所有回收线程回收的对象总量不能超过availableSharedCapacity</span></span><br><span class=\"line\">        availableSharedCapacity.addAndGet(space);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//参数link为新的head节点，当前head指针指向的节点已经被回收完毕</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">relink</span><span class=\"params\">(Link link)</span> &#123;</span><br><span class=\"line\">          ...回收当前头结点的容量，更新head节点为指定的Link节点...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    Link <span class=\"title function_\">newLink</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">          ....创建新的Link节点...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//此处目的是为接下来要创建的link预留空间容量</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"type\">boolean</span> <span class=\"title function_\">reserveSpaceForLink</span><span class=\"params\">(AtomicInteger availableSharedCapacity)</span> &#123;             </span><br><span class=\"line\">          ...在创建新的Link节点之前需要调用该方法预订容量空间...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从代码结构上我们可以看出，Head结构的设计不只是作为头结点指针那么简单，其中还封装了很多链表操作以及回收的逻辑。</p>\n<ul>\n<li>​<code>AtomicInteger availableSharedCapacity</code>​：这个字段前边已经介绍过多次了，它是多线程共享的一个字段，可以被多个回收线程进行操作，表达的语义是所有回收线程总共可以帮助创建线程一共可以回收多少对象。对所有回收线程回收对象的总量进行限制。每创建一个Link节点，它的值就减少一个LINK_CAPACITY ，每释放一个Link节点，它的值就增加一个LINK_CAPACITY 。</li>\n<li>​<code>Link link</code>​：Head结构封装的Link链表中的头结点。</li>\n</ul>\n<p>剩下Head结构中封装的相关逻辑处理方法，等到介绍到具体应用场景的时候，笔者在拿出来为大家介绍，这里先混个眼熟就行。先看懂个大概，脑海里朦朦胧胧有个粗浅的认识即可。</p>\n<h3 id=\"10-3-WeakOrderQueue中的重要属性\">10.3 WeakOrderQueue中的重要属性</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">WeakOrderQueue</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">WeakReference</span>&lt;Thread&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//link链表的头结点，head指针始终指向第一个未被转移完毕的LinK节点</span></span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Head head;</span><br><span class=\"line\">        <span class=\"comment\">//尾结点</span></span><br><span class=\"line\">        <span class=\"keyword\">private</span> Link tail;</span><br><span class=\"line\">        <span class=\"comment\">//站在stack的视角中，stack中包含一个weakOrderQueue的链表，每个回收线程为当前stack回收的对象存放在回收线程对应的weakOrderQueue中</span></span><br><span class=\"line\">        <span class=\"comment\">//这样通过stack中的这个weakOrderQueue链表，就可以找到其他线程为该创建线程回收的对象</span></span><br><span class=\"line\">        <span class=\"keyword\">private</span> WeakOrderQueue next;</span><br><span class=\"line\">        <span class=\"comment\">//回收线程回收Id,每个weakOrderQueue分配一个，同一个stack下的一个回收线程对应一个weakOrderQueue节点</span></span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">id</span> <span class=\"operator\">=</span> ID_GENERATOR.getAndIncrement();</span><br><span class=\"line\">        <span class=\"comment\">//回收线程回收比例 默认是8</span></span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> interval;</span><br><span class=\"line\">        <span class=\"comment\">//回收线程回收计数 回收1/8的对象</span></span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"type\">int</span> handleRecycleCount;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>​<code>Head head</code>​：用于指向WeakOrderQueue中Link链表的头结点。</li>\n<li>​<code>Link tail</code>​：指向Link链表中的尾结点。</li>\n<li>​<code>WeakOrderQueue next</code>​：站在Stack结构的视角上，Stack包含一个WeakOrderQueue链表，用来存放回收线程回收过来的池化对象。该字段为WeakOrderQueue节点的next指针，用于指向下一个回收线程对应的WeakOrderQueue节点。</li>\n<li>​<code>int id </code>​：对应回收线程的回收Id，同一个Stack结构下，不同的回收线程对应不同的Id。</li>\n<li>​<code>int interval</code>​：回收线程对应的回收频率，默认只回收 1 / 8 的池化对象。</li>\n<li>​<code>int handleRecycleCount</code>​：回收对象计数，前边我们多次讲过了。用于控制回收频率。</li>\n</ul>\n<h3 id=\"10-4-WeakOrderQueue结构的创建\">10.4 WeakOrderQueue结构的创建</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">WeakOrderQueue</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">WeakReference</span>&lt;Thread&gt; &#123;</span><br><span class=\"line\">        <span class=\"comment\">//为了使stack能够被GC,这里不会持有其所属stack的引用</span></span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"title function_\">WeakOrderQueue</span><span class=\"params\">(Stack&lt;?&gt; stack, Thread thread)</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//weakOrderQueue持有对应回收线程的弱引用</span></span><br><span class=\"line\">            <span class=\"built_in\">super</span>(thread);</span><br><span class=\"line\">            <span class=\"comment\">//创建尾结点</span></span><br><span class=\"line\">            tail = <span class=\"keyword\">new</span> <span class=\"title class_\">Link</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 创建头结点  availableSharedCapacity = maxCapacity / maxSharedCapacityFactor</span></span><br><span class=\"line\">            head = <span class=\"keyword\">new</span> <span class=\"title class_\">Head</span>(stack.availableSharedCapacity);</span><br><span class=\"line\">            head.link = tail;</span><br><span class=\"line\">            interval = stack.delayedQueueInterval;</span><br><span class=\"line\">            handleRecycleCount = interval; </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在创建WeakOrderQueue结构的时候，首先会调用父类 <code>WeakReference&lt;Thread&gt;</code>​ 的构造方法持有当前回收线程的弱应用。</p>\n<p>然后创建第一个Link节点，head指针和tail指针同时指向这第一个节点。</p>\n<p>用创建线程对应的Stack中的属性初始化WeakOrderQueue结构中的相关属性。</p>\n<p>大家这里可能会问了，既然这里用Stack中的属性去初始化WeakOrderQueue结构中的相关属性，那​<strong>为什么WeakOrderQueue不直接持有Stack的引用呢</strong>​？</p>\n<p>之前我们提到，一个回收线程对应一个WeakOrderQueue节点，当回收线程挂掉的时候，需要清理WeakOrderQueue节点并将其从Stack结构中的WeakOrderQueue链表（头结点除外）中删除。使得WeakOrderQueue节点可以被GC回收掉。</p>\n<p><strong>如果Stack结构对应的创建线程挂掉，而此时WeakOrderQueue又持有了Stack的引用，这样就使得Stack结构无法被GC掉。</strong></p>\n<p>所以这里只会用Stack结构的相关属性去初始化WeakOrderQueue结构，在WeakOrderQueue中并不会持有Stack的引用。</p>\n<blockquote>\n<p>在复杂程序结构的设计中，我们要时刻对对象之间的引用关系保持清晰的认识。防止内存泄露。</p>\n</blockquote>\n<h3 id=\"10-5-从WeakOrderQueue中转移回收对象\">10.5 从WeakOrderQueue中转移回收对象</h3>\n<p>WeakOrderQueue的transfer方法用于将当前WeakOrderQueue节点中的待回收对象转移至创建线程对应的Stack中。</p>\n<p>开始转移回收对象时会从WeakOrderQueue节点中的Link链表的头结点开始遍历，如果头结点中还有未被转移的对象，则将头结点剩余的未转移对象转移至Stack中。所以创建线程每次最多转移一个LINK_CAPACITY大小的对象至Stack中。只要成功转移了哪怕一个对象，transfer方法就会返回true。</p>\n<p>如果头结点中存储的对象已经全部转移完毕，则更新head指针指向下一个Link节点，开始转移下一个Link节点。​<strong>创建线程每次只会转移一个Link节点</strong>​。如果Link链表是空的，没有转移成功一个对象，则transfer方法返回false。</p>\n<p>由于transfer方法体比较大，笔者将其按照上述逻辑步骤拆分开来为大家讲解：</p>\n<p><img src=\"/assets/25a723e07ab64f0fa5fcdc4eeddf1e0dtplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-afj8oqs.awebp\" alt=\"image.png\"></p>\n<h4 id=\"10-5-1-判断头结点中的待回收对象是否转移完毕\">10.5.1 判断头结点中的待回收对象是否转移完毕</h4>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//获取当前weakOrderQueue节点中的link链表头结点</span></span><br><span class=\"line\"><span class=\"type\">Link</span> <span class=\"variable\">head</span> <span class=\"operator\">=</span> <span class=\"built_in\">this</span>.head.link;</span><br><span class=\"line\"><span class=\"comment\">//头结点为null说明还没有待回收对象</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (head == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//如果头结点中的待回收对象已经被转移完毕</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (head.readIndex == LINK_CAPACITY) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//判断是否有后续Link节点</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (head.next == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//整个link链表没有待回收对象了已经</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    head = head.next;</span><br><span class=\"line\">    <span class=\"comment\">//当前Head节点已经被转移完毕，head指针向后移动，head指针始终指向第一个未被转移完毕的LinK节点</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.head.relink(head);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>首先从Link链表的头结点开始转移，<code>head == null</code>​ 说明当前Link链表是空的并没有对象可被转移，直接返回false。</p>\n<p>​<code>head.readIndex == LINK_CAPACITY</code>​ 判断当前头结点中的对象是否已经被转移完毕，如果当前头结点中的对象已经被全部转移完毕，则将head指针更新 relink 为下一个节点，开始从下一个节点开始转移对象。如果此时Link链表已经为空了，直接返回false。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Head</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//参数link为新的head节点，当前head指针指向的节点已经被回收完毕</span></span><br><span class=\"line\">            <span class=\"keyword\">void</span> <span class=\"title function_\">relink</span><span class=\"params\">(Link link)</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">//更新availableSharedCapacity，因为当前link节点中的待回收对象已经被转移完毕，所以需要增加availableSharedCapacity的值</span></span><br><span class=\"line\">                reclaimSpace(LINK_CAPACITY);</span><br><span class=\"line\">                <span class=\"comment\">//head指针指向新的头结点（第一个未被回收完毕的link节点）</span></span><br><span class=\"line\">                <span class=\"built_in\">this</span>.link = link;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">reclaimSpace</span><span class=\"params\">(<span class=\"type\">int</span> space)</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">//所有回收线程都可以看到，这个值是所有回收线程共享的。以便可以保证所有回收线程回收的对象总量不能超过availableSharedCapacity</span></span><br><span class=\"line\">                availableSharedCapacity.addAndGet(space);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"10-5-2-根据本次转移对象容量评估是否应该对Stack进行扩容\">10.5.2 根据本次转移对象容量评估是否应该对Stack进行扩容</h4>\n<p>此时Head节点已经校验完毕，可以执行正常的转移逻辑了。但在转移逻辑正式开始之前，还需要对本次转移对象的容量进行计算，并评估Stack的当前容量是否可以容纳的下，如果Stack的当前容量不够，则需要对Stack进行扩容。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">srcStart</span> <span class=\"operator\">=</span> head.readIndex;</span><br><span class=\"line\"><span class=\"comment\">//writeIndex</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">srcEnd</span> <span class=\"operator\">=</span> head.get();</span><br><span class=\"line\"><span class=\"comment\">//该link节点可被转移的对象容量</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">srcSize</span> <span class=\"operator\">=</span> srcEnd - srcStart;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (srcSize == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取创建线程stack中的当前回收对象数量总量</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">dstSize</span> <span class=\"operator\">=</span> dst.size;</span><br><span class=\"line\"><span class=\"comment\">// 待回收对象从weakOrderQueue中转移到stack后，stack的新容量 = 转移前stack容量 + 转移的待回收对象个数</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">expectedCapacity</span> <span class=\"operator\">=</span> dstSize + srcSize;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (expectedCapacity &gt; dst.elements.length) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//如果转移后的stack容量超过当前stack的容量 则对stack进行扩容</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">actualCapacity</span> <span class=\"operator\">=</span> dst.increaseCapacity(expectedCapacity);</span><br><span class=\"line\">    <span class=\"comment\">//每次转移最多一个Link的容量</span></span><br><span class=\"line\">    <span class=\"comment\">//actualCapacity - dstSize表示扩容后的stack还有多少剩余空间</span></span><br><span class=\"line\">    srcEnd = min(srcStart + actualCapacity - dstSize, srcEnd);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>获取Link链表头结点的readIndex和writeIndex，通过  <code>writeIndex - readIndex</code>​ 计算出当前头结点有多少可被转移的对象。</p>\n<p>Stack的最终容量为： <code>expectedCapacity = stack当前容量 + 转移对象的容量</code>​。</p>\n<p>如果计算得出转移后Stack的最终容量 expectedCapacity 超过了Stack的当前容量则需要对Stack进行扩容。根据扩容后的容量最终决定本次转移多少对象： <code>min(srcStart + actualCapacity - dstSize, srcEnd)</code>​ ，确保不能超过Stack可容纳的空间。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Stack</span>&lt;T&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"title function_\">increaseCapacity</span><span class=\"params\">(<span class=\"type\">int</span> expectedCapacity)</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">newCapacity</span> <span class=\"operator\">=</span> elements.length;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">maxCapacity</span> <span class=\"operator\">=</span> <span class=\"built_in\">this</span>.maxCapacity;</span><br><span class=\"line\">            <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">                newCapacity &lt;&lt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">while</span> (newCapacity &lt; expectedCapacity &amp;&amp; newCapacity &lt; maxCapacity);</span><br><span class=\"line\">            <span class=\"comment\">//扩容后的新容量为最接近指定容量expectedCapacity的最大2的次幂</span></span><br><span class=\"line\">            newCapacity = min(newCapacity, maxCapacity);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (newCapacity != elements.length) &#123;</span><br><span class=\"line\">                elements = Arrays.copyOf(elements, newCapacity);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">return</span> newCapacity;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果当前Stack已经达到最大容量，无法再继续扩容：<code>actualCapacity - dstSize = 0</code>​，则停止本次转移操作，直接返回<code>false</code>​。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (srcStart != srcEnd) &#123;</span><br><span class=\"line\">   .....具体的转移逻辑.......</span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// The destination stack is full already.</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>​<strong>如果Stack的容量可以容纳头结点中存储的待转移对象，则开始正式的转移逻辑</strong>​：</p>\n<h4 id=\"10-5-3-转移回收对象\">10.5.3 转移回收对象</h4>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//待转移对象集合 也就是Link节点中存储的元素</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> DefaultHandle[] srcElems = head.elements;</span><br><span class=\"line\"><span class=\"comment\">//stack中存储转移对象数组</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> DefaultHandle[] dstElems = dst.elements;</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">newDstSize</span> <span class=\"operator\">=</span> dstSize;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> srcStart; i &lt; srcEnd; i++) &#123;</span><br><span class=\"line\">    DefaultHandle&lt;?&gt; element = srcElems[i];</span><br><span class=\"line\">    <span class=\"comment\">//recycleId == 0 表示对象还没有被真正的回收到stack中</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (element.recycleId == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//设置recycleId 表明是被哪个weakOrderQueue回收的</span></span><br><span class=\"line\">        element.recycleId = element.lastRecycledId;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (element.recycleId != element.lastRecycledId) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//既被创建线程回收 同时也被回收线程回收  回收多次 则停止转移</span></span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalStateException</span>(<span class=\"string\">&quot;recycled already&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//对象转移后需要置空Link节点对应的位置</span></span><br><span class=\"line\">    srcElems[i] = <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//这里从weakOrderQueue将待回收对象真正回收到所属stack之前 需要进行回收频率控制</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (dst.dropHandle(element)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Drop the object.</span></span><br><span class=\"line\">        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//重新为defaultHandler设置其所属stack(初始创建该handler的线程对应的stack)</span></span><br><span class=\"line\">    <span class=\"comment\">//该defaultHandler在被回收对象回收的时候，会将其stack置为null，防止极端情况下，创建线程挂掉，对应stack无法被GC</span></span><br><span class=\"line\">    element.stack = dst;</span><br><span class=\"line\">    <span class=\"comment\">//此刻，handler才真正的被回收到所属stack中</span></span><br><span class=\"line\">    dstElems[newDstSize ++] = element;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>将当前Link节点中的elements数组里存储的对象转移至Stack中的数组栈elements中。转移范围 <code>srcStart  -&gt;  srcEnd </code>​。</p>\n<p>如果当前转移对象 <code>element.recycleId == 0</code>​ 说明当前对象还没有被真正的回收至创建线程对应的Stack中，符合转移条件（不能被多次回收）。还记不记得我们前边在《9.3 从Stack中获取池化对象》小节介绍的：</p>\n<ul>\n<li>​<code>recycleId = lastRecycledId = 0</code>​：表示池化对象刚刚被创建或者刚刚从对象池中取出即将被再次复用。这是池化对象的初始状态。</li>\n</ul>\n<p>随后设置回收Id <code>element.recycleId = element.lastRecycledId</code>​。此处的lastRecycledId为当前WeakOrderQueue节点对应的回收线程Id。</p>\n<p>​<code>element.recycleId != element.lastRecycledId</code>​ 此处表示当前对象可能被创建线程回收了，也可能被回收线程回收了。</p>\n<p>如果当前转移对象已经被回收至Stack中，则不能被再次回收，停止转移。</p>\n<h4 id=\"10-5-4-控制对象回收频率\">10.5.4 控制对象回收频率</h4>\n<p>符合转移条件的对象，需要再次经过回收频率的控制，即前边介绍的只回收 1 / 8 的对象，也就是每 8 个对象回收 1 个。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">boolean</span> <span class=\"title function_\">dropHandle</span><span class=\"params\">(DefaultHandle&lt;?&gt; handle)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!handle.hasBeenRecycled) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//回收计数handleRecycleCount 初始值为8 这样可以保证创建的第一个对象可以被池化回收</span></span><br><span class=\"line\">        <span class=\"comment\">//interval控制回收频率 8个对象回收一个</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (handleRecycleCount &lt; interval) &#123;</span><br><span class=\"line\">            handleRecycleCount++;</span><br><span class=\"line\">            <span class=\"comment\">// Drop the object.</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//回收一个对象后，回收计数清零</span></span><br><span class=\"line\">        handleRecycleCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">//设置defaultHandler的回收标识为true</span></span><br><span class=\"line\">        handle.hasBeenRecycled = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当对象通过了回收频率的验证之后，最后将回收对象的DefaultHandler中持有的Stack引用再次设置为其创建线程对应的Stack。因为在回收线程将池化对象回收至WeakOrderQueue节点时，会将其DefaultHandler中对Stack的引用置为null。所以这里需要重置回来。</p>\n<blockquote>\n<p>具体为什么在回收线程回收时会将回收对象的Stack引用置为null，大家这里可以自己先思考下，等到后面我们讲解多线程回收时，笔者在为大家揭开谜底。</p>\n</blockquote>\n<p>随后会将对象压入Stack结构中的数组栈中，到这里，回收线程帮助创建线程回收的对象才算真正的被回收了，业务线程可以直接从对象池中取出使用了。</p>\n<p>当对象转移完毕后，更新当前Link节点的readIndex，更新Stack中数组栈的栈顶指针。如果当前Link节点已经被转移完毕，则Head指针指向链表中的下一个节点，开始等待下一次的转移。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (srcEnd == LINK_CAPACITY &amp;&amp; head.next != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">       <span class=\"comment\">// Add capacity back as the Link is GCed.</span></span><br><span class=\"line\">       <span class=\"comment\">// 如果当前Link已经被回收完毕，且link链表还有后续节点，则更新head指针</span></span><br><span class=\"line\">       <span class=\"built_in\">this</span>.head.relink(head.next);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">//更新当前回收Link的readIndex</span></span><br><span class=\"line\">   head.readIndex = srcEnd;</span><br><span class=\"line\">   <span class=\"comment\">//如果没有转移任何数据 return false</span></span><br><span class=\"line\">   <span class=\"keyword\">if</span> (dst.size == newDstSize) &#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   dst.size = newDstSize;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br></pre></td></tr></table></figure>\n<p>到现在为止，多线程从Recycler对象池中无锁化获取对象的完整流程，笔者就为大家介绍完了，下面我们来继续剖析下多线程回收对象的场景。</p>\n<h2 id=\"11-多线程回收对象无锁化实现\">11. 多线程回收对象无锁化实现</h2>\n<p>之前我们在介绍池化对象的设计时，提到业务线程在使用对象的时候不应该感受到对象池的存在，所以将池化对象的回收，封装在其DefaultHandler中。在业务线程使用完对象时，直接调用池化对象的recycle方法进行回收即可。</p>\n<p><img src=\"/assets/58038d8ee0344260875993d8636331d5tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-lhvub6f.awebp\" alt=\"image.png\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Entry</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"keyword\">private</span>  Handle&lt;Entry&gt; handle;</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"keyword\">void</span> <span class=\"title function_\">recycle</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            next = <span class=\"literal\">null</span>;</span><br><span class=\"line\">            bufs = <span class=\"literal\">null</span>;</span><br><span class=\"line\">            buf = <span class=\"literal\">null</span>;</span><br><span class=\"line\">            msg = <span class=\"literal\">null</span>;</span><br><span class=\"line\">            promise = <span class=\"literal\">null</span>;</span><br><span class=\"line\">            progress = <span class=\"number\">0</span>;</span><br><span class=\"line\">            total = <span class=\"number\">0</span>;</span><br><span class=\"line\">            pendingSize = <span class=\"number\">0</span>;</span><br><span class=\"line\">            count = -<span class=\"number\">1</span>;</span><br><span class=\"line\">            cancelled = <span class=\"literal\">false</span>;</span><br><span class=\"line\">            handle.recycle(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DefaultHandle</span>&lt;T&gt; <span class=\"keyword\">implements</span> <span class=\"title class_\">Handle</span>&lt;T&gt; &#123;</span><br><span class=\"line\">      </span><br><span class=\"line\">        ..................省略............</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//强引用关联创建handler的stack</span></span><br><span class=\"line\">        Stack&lt;?&gt; stack;</span><br><span class=\"line\">        <span class=\"comment\">//池化对象</span></span><br><span class=\"line\">        Object value;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">recycle</span><span class=\"params\">(Object object)</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (object != value) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(<span class=\"string\">&quot;object does not belong to handle&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            Stack&lt;?&gt; stack = <span class=\"built_in\">this</span>.stack;</span><br><span class=\"line\">            <span class=\"comment\">//handler初次创建以及从对象池中获取到时  recycleId = lastRecycledId = 0（对象被回收之前）</span></span><br><span class=\"line\">            <span class=\"comment\">//创建线程回收对象后recycleId = lastRecycledId = OWN_THREAD_ID</span></span><br><span class=\"line\">            <span class=\"comment\">//回收线程回收对象后lastRecycledId = 回收线程Id,当对象被转移到stack中后 recycleId = lastRecycledId = 回收线程Id</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (lastRecycledId != recycleId || stack == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalStateException</span>(<span class=\"string\">&quot;recycled already&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            stack.push(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>DefaultHandler中的 recycle 方法逻辑比较简单，唯一不好理解的地方在于判断对象是否已经被回收的 if 条件语句。</p>\n<ul>\n<li>​<code>lastRecycledId != recycleId</code>​ ：此时对象的状态正处于已经被回收线程回收至对应 WeakOrderQueue 节点的半回收状态，但还未被转移至其创建线程对应的Stack中。​<strong>所以这个条件要控制的事情就是如果对象已经被回收线程回收，那么就停止本次的回收操作</strong>​。</li>\n</ul>\n<blockquote>\n<p>忘记的同学可以在回看下《9.3 从Stack中获取池化对象》小节，那里详细介绍了 recycleId 和 lastRecycledId 之间各种关系的变化及其含义</p>\n</blockquote>\n<ul>\n<li>​<code>stack == null</code>​ ：这种情况其实前边我们也有提到过，就是当池化对象对应的创建线程挂掉的时候，对应的Stack随后也被GC回收掉。那么这时就不需要在回收该池化对象了。</li>\n</ul>\n<h3 id=\"11-1-回收对象至Stack中——啊哈！Bug\">11.1 回收对象至Stack中——啊哈！Bug!</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Stack</span>&lt;T&gt; &#123;</span><br><span class=\"line\">        <span class=\"comment\">//持有对应创建线程的弱引用</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> WeakReference&lt;Thread&gt; threadRef;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">void</span> <span class=\"title function_\">push</span><span class=\"params\">(DefaultHandle&lt;?&gt; item)</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">Thread</span> <span class=\"variable\">currentThread</span> <span class=\"operator\">=</span> Thread.currentThread();</span><br><span class=\"line\">            <span class=\"comment\">//判断当前线程是否为创建线程  对象池的回收原则是谁创建，最终由谁回收。其他线程只是将回收对象放入weakOrderQueue中</span></span><br><span class=\"line\">            <span class=\"comment\">//最终是要回收到创建线程对应的stack中的</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (threadRef.get() == currentThread) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 如果当前线程正是创建对象的线程，则直接进行回收 直接放入与创建线程关联的stack中</span></span><br><span class=\"line\">                pushNow(item);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 当前线程不是创建线程，则将回收对象放入创建线程对应的stack中的weakOrderQueue链表相应节点中（currentThread对应的节点）</span></span><br><span class=\"line\">                pushLater(item, currentThread);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里会进入到池化对象DefaultHandler中持有的Stack中，在Stack中进行对象的回收。</p>\n<blockquote>\n<p>大家这里先不要看笔者下面的解释，试着自己着重分析下这个 if…else…逻辑判断，有没有发现什么问题？？Bug就在这里！！</p>\n</blockquote>\n<p>这里首先会判断当前回收线程是否为池化对象的创建线程：<code>threadRef.get() == currentThread)</code>​。如果是，则由创建线程直接回收 pushNow(item) 。</p>\n<p>如果 <code>threadRef.get() != currentThread)</code>​ 这里有两种情况：</p>\n<ol>\n<li>currentThread是回收线程，那么就按多线程回收的逻辑 <code>pushLater(item, currentThread)</code>​ ，由回收线程将对象回收至其对应的WeakOrderQueue节点中，这里没什么毛病。</li>\n<li>Bug就出现在第二种情况，还有一种情况是 <code>threadRef.get()  == null</code>​ 也会走到 else 分支里。表示该回收对象的创建线程已经挂掉，并被GC回收。​<strong>那么在这种情况下已经没有必要在对该对象进行回收了</strong>​，因为创建线程已经挂掉，随后对应的Stack也迟早被GC掉，​<strong>这个对象即使被回收进Stack也永远不会在被使用到</strong>​。但是Netty的做法还是会让回收线程将其回收至Stack中的WeakOrderQueue链表中，笔者认为这里根本就没必要在添加至WeakOrderQueue链表中了。</li>\n</ol>\n<p>Bug产生的场景如下如所示：</p>\n<p><img src=\"/assets/53c6380455754787a12800dbf1e48a06tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-0takv3w.awebp\" alt=\"image.png\"></p>\n<p>​<strong>在第二种情况下，Netty还有一个重要的场景没有考虑到，会导致内存泄露</strong>​！！</p>\n<p>什么场景呢？大家再来回顾下池化对象与对象池之间的引用关系图：</p>\n<p><img src=\"/assets/f43dc00e2347458c876f15dae66f23d4tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-lapokvs.awebp\" alt=\"image.png\"></p>\n<p>这里我们看到池化对象会引用DefaultHandler，而DefaultHandler又强引用了Stack。于是就形成了这样一条引用链：</p>\n<p><img src=\"/assets/c2b0e2f9f93449e7b86ef71e2bac35e9tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-8xtfk94.awebp\" alt=\"image.png\"></p>\n<p>而池化对象是对外暴露的，用户可能在某个地方一直引用着这个池化对象，如果创建线程挂掉，并被GC回收之后，那么其在对象池中对应的Stack也应该被回收，因为Stack里保存的回收对象将再也不会被用到了。但是因为这条引用链的存在，导致Stack无法被GC回收从而造成内存泄露！</p>\n<h2 id=\"11-2-笔者反手一个PR，修复这个Bug\">11.2 笔者反手一个PR，修复这个Bug!</h2>\n<p>现在Bug产生的原因和造成的影响，笔者为大家已经分析清楚了，那么接下来的解决方案就变得很简单了。</p>\n<p>笔者先向Netty社区提了一个 Issue11864 来说明这个问题。</p>\n<blockquote>\n<p>Issue11864 : <a href=\"https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fnetty%2Fnetty%2Fissues%2F11864\" title=\"https://github.com/netty/netty/issues/11864\">github.com/netty/netty…</a></p>\n</blockquote>\n<p>然后直接提了 PR11865 来修复这个Bug。</p>\n<blockquote>\n<p>PR : <a href=\"https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fnetty%2Fnetty%2Fpull%2F11865\" title=\"https://github.com/netty/netty/pull/11865\">github.com/netty/netty…</a></p>\n</blockquote>\n<p>PR中主要的修改点分为以下两点：</p>\n<ol>\n<li>笔者在修复方案中觉得在这里应该尽早处理掉 <code>threadRef.get()  == null</code>​ 的情况，因为创建线程已经死掉，此时在为创建线程回收对象已经没有任何意义了，这种情况直接 return 掉就好。</li>\n<li>由于池化对象强引用到了其创建线程对应的Stack，当创建线程挂掉之后，我们需要解除这个引用链 <code>item.stack = null</code>​，保证Stack最终可以被GC回收。</li>\n</ol>\n<p>以下代码为笔者提交的PR中的修复方案，主要增加了对 <code>threadRef.get()  == null</code>​ 情况的处理，并添加了详细注释。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">push</span><span class=\"params\">(DefaultHandle&lt;?&gt; item)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">Thread</span> <span class=\"variable\">currentThread</span> <span class=\"operator\">=</span> Thread.currentThread();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (threadRef.get() == currentThread) &#123;</span><br><span class=\"line\">        pushNow(item);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (threadRef.get() == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// when the thread that belonged to the Stack was died or GC&#x27;ed，</span></span><br><span class=\"line\">        <span class=\"comment\">// There is no need to add this item to WeakOrderQueue-linked-list which belonged to the Stack any more</span></span><br><span class=\"line\">        item.stack = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        pushLater(item, currentThread);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"11-3-PR的后续\">11.3 PR的后续</h2>\n<p>当笔者提交了 PR11865之后，得到了相关作者如下回复。</p>\n<p><img src=\"/assets/84c1132caafa47e1a56f670b0ac349aetplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-czmjytj.awebp\" alt=\"image.png\"></p>\n<p>巧合的是Netty也意识到了对象池这块的问题，Netty最近也正在重构 Recycler 这一块，因为Recycler整体设计的还是比较复杂的，这从我们这篇源码解析的文章中也可以看的出来，Recycler的复杂性在于它的使用场景混合了<strong>并发</strong>以及与​<strong>GC相关的交互</strong>​，这些相关的问题都比较难以定位，所以Netty决定将对象池这一块用一种更加容易被理解的方式重构掉。</p>\n<p>相关的重构内容大家可以看作者的这个commit。</p>\n<blockquote>\n<p>重构commit：<a href=\"https://github.com/netty/netty/commit/28b9834612638ffec4948c0c650d04f766f20690\">github.com/netty/netty…</a></p>\n</blockquote>\n<p>重构后的Recycler对象池在<strong>4.1.71.Final</strong>版本已经发布。笔者后续也会为大家安排一篇重构后的Recycler对象池源码解析，但是本文还是聚焦于<strong>4.1.71.Final</strong>之前版本的对象池介绍，虽然被重构了，但是这里也有很多的设计思想和多线程程序设计细节非常值得我们学习！</p>\n<p>在<strong>4.1.71.Final</strong>版本发布之后，笔者想的是后面抽空看下重构后的对象池实现，哈哈，只要谓语动词出现—— ”想的是…“ 类似这样的句式，估计就没有以后了，哈哈。笔者还是大意了，这个 Issue11864 : <a href=\"https://github.com/netty/netty/issues/11864\">github.com/netty/netty…</a> 在过了几个月之后在社区里又被讨论了起来。有人发现在<strong>4.1.71.Final</strong>对象池重构后的版本中笔者提到的这些问题还是存在的。</p>\n<p>于是作者 chrisvest 又 提了一个 PR11996 最终在 <strong>4.1.74.Final</strong>版本中修复了笔者提的这个 Issue11864。</p>\n<blockquote>\n<p>PR11996 ：<a href=\"https://github.com/netty/netty/pull/11996\">github.com/netty/netty…</a></p>\n</blockquote>\n<blockquote>\n<p>随口提一句，这个大牛 chrisvest 是大名鼎鼎的图数据库 Neo4j 的核心commitor，同时也是Netty Buffer相关API的设计者。</p>\n</blockquote>\n<p>这里笔者将这个Bug在 <strong>4.1.74.Final</strong> 版本中的最终修复方案和大家说明一下，收个尾。</p>\n<ol>\n<li>首先 chrisvest 大牛 认为 当创建线程挂掉的时候，我们可以在threadLocal的 onRemoval方法中将创建线程对应的LocalPool里边用于存放回收对象的pooledHandles 直接置为 null。这里的语义是标记LocalPool已经死掉了，不会再继续使用。</li>\n</ol>\n<blockquote>\n<p>在重构后的版本中引入了 LocalPool 来代替我们前边介绍的Stack。LocalPool中的pooledHandles大家可以简单认为类似Stack中数组栈的功能。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Recycler</span>&lt;T&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> FastThreadLocal&lt;LocalPool&lt;T&gt;&gt; threadLocal = <span class=\"keyword\">new</span> <span class=\"title class_\">FastThreadLocal</span>&lt;LocalPool&lt;T&gt;&gt;() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">protected</span> LocalPool&lt;T&gt; <span class=\"title function_\">initialValue</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">LocalPool</span>&lt;T&gt;(maxCapacityPerThread, interval, chunkSize);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onRemoval</span><span class=\"params\">(LocalPool&lt;T&gt; value)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">            <span class=\"comment\">//删除LocalPool</span></span><br><span class=\"line\">            <span class=\"built_in\">super</span>.onRemoval(value);</span><br><span class=\"line\">            MessagePassingQueue&lt;DefaultHandle&lt;T&gt;&gt; handles = value.pooledHandles;</span><br><span class=\"line\">            <span class=\"comment\">//pooledHandles 置为 null，取消引用</span></span><br><span class=\"line\">            value.pooledHandles = <span class=\"literal\">null</span>;</span><br><span class=\"line\">            <span class=\"comment\">//清除LocalPool中保存的回收对象</span></span><br><span class=\"line\">            handles.clear();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>在多线程回收对象的时候，会首先判断该回收对象对应的LocalPool里的pooledHandles是否已经被清理变为不可用状态。如果是的话就停止回收。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LocalPool</span>&lt;T&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">//保证可见性</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> MessagePassingQueue&lt;DefaultHandle&lt;T&gt;&gt; pooledHandles;</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"keyword\">void</span> <span class=\"title function_\">release</span><span class=\"params\">(DefaultHandle&lt;T&gt; handle)</span> &#123;</span><br><span class=\"line\">            MessagePassingQueue&lt;DefaultHandle&lt;T&gt;&gt; handles = pooledHandles;</span><br><span class=\"line\">            handle.toAvailable();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (handles != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                handles.relaxedOffer(handle);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过以上两个措施 就保证了 当创建线程被GC掉之后，它对应的 在对象池中的回收缓存LocalPool（类比Stack）不会出现内存泄露，同时保证了多线程不在将回收对象至已经被清理的LocalPool中。</p>\n<p>好了，这一块的Bug修改我们介绍完了，我们继续多线程回收对象主流程的介绍：</p>\n<h3 id=\"11-4-创建线程直接回收对象\">11.4 创建线程直接回收对象</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">pushNow</span><span class=\"params\">(DefaultHandle&lt;?&gt; item)</span> &#123;</span><br><span class=\"line\">     <span class=\"comment\">//池化对象被回收前 recycleId = lastRecycleId = 0</span></span><br><span class=\"line\">     <span class=\"comment\">//如果其中之一不为0 说明已经被回收了</span></span><br><span class=\"line\">     <span class=\"keyword\">if</span> ((item.recycleId | item.lastRecycledId) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">         <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalStateException</span>(<span class=\"string\">&quot;recycled already&quot;</span>);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"comment\">//此处是由创建线程回收，则将池化对象的recycleId与lastRecycleId设置为创建线程Id-OWN_THREAD_ID</span></span><br><span class=\"line\">     <span class=\"comment\">//注意这里的OWN_THREAD_ID是一个固定的值，是因为这里的视角是池化对象的视角，只需要区分创建线程和非创建线程即可。</span></span><br><span class=\"line\">     <span class=\"comment\">//对于一个池化对象来说创建线程只有一个 所以用一个固定的OWN_THREAD_ID来表示创建线程Id</span></span><br><span class=\"line\">     item.recycleId = item.lastRecycledId = OWN_THREAD_ID;</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"type\">int</span> <span class=\"variable\">size</span> <span class=\"operator\">=</span> <span class=\"built_in\">this</span>.size;</span><br><span class=\"line\">     <span class=\"comment\">//如果当前池化对象的容量已经超过最大容量 则丢弃对象</span></span><br><span class=\"line\">     <span class=\"comment\">//为了避免池化对象的急速膨胀，这里只会回收1/8的对象，剩下的对象都需要丢弃</span></span><br><span class=\"line\">     <span class=\"keyword\">if</span> (size &gt;= maxCapacity || dropHandle(item)) &#123;</span><br><span class=\"line\">         <span class=\"comment\">// Hit the maximum capacity or should drop - drop the possibly youngest object.</span></span><br><span class=\"line\">         <span class=\"comment\">//丢弃对象</span></span><br><span class=\"line\">         <span class=\"keyword\">return</span>;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"comment\">//当前线程对应的stack容量已满但是还没超过最大容量限制，则对stack进行扩容</span></span><br><span class=\"line\">     <span class=\"keyword\">if</span> (size == elements.length) &#123;</span><br><span class=\"line\">         <span class=\"comment\">//容量扩大两倍</span></span><br><span class=\"line\">         elements = Arrays.copyOf(elements, min(size &lt;&lt; <span class=\"number\">1</span>, maxCapacity));</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     <span class=\"comment\">//将对象回收至当前stack中</span></span><br><span class=\"line\">     elements[size] = item;</span><br><span class=\"line\">     <span class=\"comment\">//更新当前stack的栈顶指针</span></span><br><span class=\"line\">     <span class=\"built_in\">this</span>.size = size + <span class=\"number\">1</span>;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>首先需要判断该回收对象是否已经被回收了。<code>item.recycleId | item.lastRecycledId) != 0</code>​，这里任意Id只要不为0，说明该对象已经对回收了，则停止本次回收操作。</li>\n<li>当对象被创建线程回收时，设置回收Id：<code>item.recycleId = item.lastRecycledId = OWN_THREAD_ID</code>​。</li>\n<li>如果当前Stack已经达到最大容量则将对象丢弃。</li>\n<li>为了避免对象池不可控制的迅速膨胀，这里只会回收 1 / 8 的对象，剩下的对象都需要丢弃 dropHandle 。</li>\n<li>如果当前Stack容量已满但是还没超过最大容量限制，则对stack进行扩容。一次性扩容两倍但不能超过最大容量。</li>\n<li>最后将对象压入Stack结构中的数组栈中，完成对象的回收。</li>\n</ul>\n<h3 id=\"11-5-回收线程间接回收对象\">11.5 回收线程间接回收对象</h3>\n<p><img src=\"/assets/e87ee465af764c47866e1f69a22d065atplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-ms062uc.awebp\" alt=\"image.png\"></p>\n<p>在Recycler对象池中，一个线程既可以是创建线程也可以是回收线程。</p>\n<p>比如上图中的 thread2 , thread3 , thread4 …  这里的每一个线程既可以在对象池中创建对象，并将对象回收至自己对应的Stack结构里的数组栈中，此刻它们的角色为创建线程。比如图中的thread1。</p>\n<p>同时其他线程 比如图中的 thread2 , thread3 , thread4 … 也可以为thread1回收由thread1创建的对象，将这些对象回收至thread1对应的Stack结构里的WeakOrderQueue链表中。此刻 thread2 , thread3 , thread4 …  为回收线程。</p>\n<p>在之前介绍Recycler对象池的重要属性时，我们提到过 maxDelayedQueuesPerThread 属性。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Recycler</span>&lt;T&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">//每个回收线程最多可以帮助多少个创建线程回收对象 默认：cpu核数 * 2</span></span><br><span class=\"line\">      <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> MAX_DELAYED_QUEUES_PER_THREAD;</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"comment\">//一个回收线程可帮助多少个创建线程回收对象</span></span><br><span class=\"line\">      <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> maxDelayedQueuesPerThread;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Stack</span>&lt;T&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 当前线程可以帮助多少个线程回收其池化对象</span></span><br><span class=\"line\">            <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> maxDelayedQueues;</span><br><span class=\"line\"></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>在Recycler对象池中，一个回收线程能够帮助多少个创建线程回收对象是有限制的，通过 maxDelayedQueuesPerThread属性 控制。</p>\n<p>​<strong>那么在对象池中，一个回收线程如何存储为其他创建线程回收到的对象呢</strong>​？</p>\n<p><img src=\"/assets/ec983e41a4b54a31a1f7f7c9ec511974tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-8ibqfew.awebp\" alt=\"image.png\"></p>\n<p>如图中所示，我们站在回收线程的视角来看，在对象池中有一个 FastThreadLocal 类型的 DELAYED_RECYCLED 字段， DELAYED_RECYCLED 为每个回收线程保存了一个 WeakHashMap，正是这个回收线程持有的 WeakHashMap 结构中保存了该回收线程为每个创建线程回收的对象。</p>\n<p>WeakHashMap 结构中的 key 表示创建线程对应的 Stack 结构。意思是该回收线程为哪个创建线程回收对象。value 表示这个回收线程在创建线程中对应Stack结构里的WeakOrderQueue链表中对应的节点。大家在结合 《Recycler对象池.png》 这副图仔细体会下这个结构设计。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Recycler</span>&lt;T&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//实现跨线程回收的核心，这里保存的是当前线程为其他线程回收的对象（由其他线程创建的池化对象）</span></span><br><span class=\"line\">    <span class=\"comment\">//key: 池化对象对应的创建线程stack  value: 当前线程代替该创建线程回收的池化对象 存放在weakOrderQueue中</span></span><br><span class=\"line\">    <span class=\"comment\">//这里的value即是 创建线程对应stack中的weakOrderQueue链表中的节点（每个节点表示其他线程为当前创建线程回收的对象）</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> FastThreadLocal&lt;Map&lt;Stack&lt;?&gt;, WeakOrderQueue&gt;&gt; DELAYED_RECYCLED =</span><br><span class=\"line\">            <span class=\"keyword\">new</span> <span class=\"title class_\">FastThreadLocal</span>&lt;Map&lt;Stack&lt;?&gt;, WeakOrderQueue&gt;&gt;() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">protected</span> Map&lt;Stack&lt;?&gt;, WeakOrderQueue&gt; initialValue() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">WeakHashMap</span>&lt;Stack&lt;?&gt;, WeakOrderQueue&gt;();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>而这个WeakHashMap 的size即表示当前回收线程已经在为多少个创建线程回收对象了，size的值不能超过 maxDelayedQueuesPerThread 。</p>\n<p>​<strong>这里为什么要用WeakHashMap呢</strong>​?</p>\n<p>其实我们前边多少也提到过了，考虑到一种极端的情况就是当创建线程挂掉并且被GC回收之后，其实这个创建线程对应的Stack结构已经没有用了，存储在Stack结构中的池化对象永远不会再被使用到，此时回收线程完全就没有必要在为挂掉的创建线程回收对象了。而这个Stack结构如果没有任何引用链存在的话，随后也会被GC回收。那么这个Stack结构在WeakHashMap中对应的Entry也会被自动删除。如果这里不采用WeakHashMap，那么回收线程为该Stack回收的对象就会一直停留在回收线程中。</p>\n<p>介绍完这些背景知识，下面我们就来正式介绍下回收线程到底是如何帮助创建线程回收对象的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">pushLater</span><span class=\"params\">(DefaultHandle&lt;?&gt; item, Thread thread)</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">//maxDelayQueues == 0 表示不支持对象的跨线程回收</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (maxDelayedQueues == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">          <span class=\"comment\">//直接丢弃</span></span><br><span class=\"line\">          <span class=\"keyword\">return</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">      <span class=\"comment\">//注意这里的视角切换，当前线程为回收线程</span></span><br><span class=\"line\">      Map&lt;Stack&lt;?&gt;, WeakOrderQueue&gt; delayedRecycled = DELAYED_RECYCLED.get();</span><br><span class=\"line\">      <span class=\"comment\">//获取当前回收对象属于的stack 由当前线程帮助其回收  注意这里是跨线程回收 当前线程并不是创建线程</span></span><br><span class=\"line\">      <span class=\"type\">WeakOrderQueue</span> <span class=\"variable\">queue</span> <span class=\"operator\">=</span> delayedRecycled.get(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">      <span class=\"comment\">//queue == null 表示当前线程是第一次为该stack回收对象</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (queue == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">          <span class=\"comment\">//maxDelayedQueues指示一个线程最多可以帮助多少个线程回收其创建的对象</span></span><br><span class=\"line\">          <span class=\"comment\">//delayedRecycled.size()表示当前线程已经帮助多少个线程回收对象</span></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (delayedRecycled.size() &gt;= maxDelayedQueues) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">              <span class=\"comment\">//如果超过指定帮助线程个数，则停止为其创建WeakOrderQueue，停止为其回收对象</span></span><br><span class=\"line\">              <span class=\"comment\">//WeakOrderQueue.DUMMY这里是一个标识，后边遇到这个标识  就不会为其回收对象了</span></span><br><span class=\"line\">              delayedRecycled.put(<span class=\"built_in\">this</span>, WeakOrderQueue.DUMMY);</span><br><span class=\"line\">              <span class=\"keyword\">return</span>;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">          <span class=\"comment\">// 创建为回收线程对应的WeakOrderQueue节点以便保存当前线程为其回收的对象</span></span><br><span class=\"line\">          <span class=\"keyword\">if</span> ((queue = newWeakOrderQueue(thread)) == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">              <span class=\"comment\">// 创建失败则丢弃对象</span></span><br><span class=\"line\">              <span class=\"keyword\">return</span>;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"comment\">//在当前线程的threadLocal中建立 回收对象对应的stack 与 weakOrderQueue的对应关系</span></span><br><span class=\"line\">          delayedRecycled.put(<span class=\"built_in\">this</span>, queue);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (queue == WeakOrderQueue.DUMMY) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// drop object</span></span><br><span class=\"line\">          <span class=\"comment\">// 如果queue的值是WeakOrderQueue.DUMMY 表示当前已经超过了允许帮助的线程数 直接丢弃对象</span></span><br><span class=\"line\">          <span class=\"keyword\">return</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">//当前线程为对象的创建线程回收对象  放入对应的weakOrderQueue中</span></span><br><span class=\"line\">      queue.add(item);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>首先需要判断当前Recycler对象池是否支持跨线程回收。 <code>maxDelayedQueues == 0</code>​ 表示不支持对象的跨线程回收。</li>\n<li>如果当前回收线程是第一次为该回收对象的创建线程进行回收，则需要为当前回收线程在对象的创建线程对应Stack结构中创建对应的WeakOrderQueue节点。（​<strong>这里正是多线程无锁化回收对象的核心所在</strong>​）。当然创建之前需要判断是否超过了可帮助创建线程的个数 maxDelayedQueues 。</li>\n<li>如果当前回收线程帮助的创建线程个数已经超过了 maxDelayedQueues 限制，则向对应的 WeakHashMap 塞入一个空的 WeakOrderQueue节点 DUMMY，后续如果遇到 WeakOrderQueue 节点是 DUMMY 实例则丢弃对象，放弃回收。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">WeakOrderQueue</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">WeakReference</span>&lt;Thread&gt; &#123;</span><br><span class=\"line\">        <span class=\"comment\">//作为一个标识，遇到DUMMY实例，则直接丢弃回收对象</span></span><br><span class=\"line\">        <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">WeakOrderQueue</span> <span class=\"variable\">DUMMY</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">WeakOrderQueue</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>如果当前回收线程帮助的创建线程个数还没有超过 maxDelayedQueues 限制，则通过 <code>stack#newWeakOrderQueue</code>​ 为当前回收线程在回收对象对应Stack结构中创建相应的WeakOrderQueue节点。并在回收线程持有的WeakHashMap中建立Stack与回收线程对应的WeakOrderQueue节点的关联关系。</li>\n<li>最终由回收线程将对象回收至其创建线程对应的Stack结构中。（将回收对象添加至回收线程对应的WeakOrderQueue节点中，完成多线程无锁化回收）</li>\n</ol>\n<h3 id=\"11-6-为回收线程创建对应的WeakOrderQueue节点\">11.6  为回收线程创建对应的WeakOrderQueue节点</h3>\n<p>上小节提到，当回收线程第一次为创建线程回收对象的时候，需要在创建线程对应Stack结构中的WeakOrderQueue链表中创建与回收线程对应的WeakOrderQueue节点。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Stack</span>&lt;T&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">private</span> WeakOrderQueue <span class=\"title function_\">newWeakOrderQueue</span><span class=\"params\">(Thread thread)</span> &#123;</span><br><span class=\"line\">           <span class=\"keyword\">return</span> WeakOrderQueue.newQueue(<span class=\"built_in\">this</span>, thread);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/assets/13ba4ffef43045ba8ed42101aefd3d72tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-i9veirg.awebp\" alt=\"image.png\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">WeakOrderQueue</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">WeakReference</span>&lt;Thread&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">static</span> WeakOrderQueue <span class=\"title function_\">newQueue</span><span class=\"params\">(Stack&lt;?&gt; stack, Thread thread)</span> &#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">            <span class=\"comment\">// link是weakOrderQueue中存储回收对象的最小结构，此处是为接下来要创建的Link预订空间容量</span></span><br><span class=\"line\">            <span class=\"comment\">// 如果stack指定的availableSharedCapacity 小于 LINK_CAPACITY大小，则分配失败</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!Head.reserveSpaceForLink(stack.availableSharedCapacity)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//如果还够容量来分配一个link那么就创建weakOrderQueue</span></span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"type\">WeakOrderQueue</span> <span class=\"variable\">queue</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">WeakOrderQueue</span>(stack, thread);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 向stack中的weakOrderQueue链表中添加当前回收线程对应的weakOrderQueue节点（始终在头结点处添加节点 ）</span></span><br><span class=\"line\">            <span class=\"comment\">// 此处向stack中添加weakOrderQueue节点的操作被移到WeakOrderQueue构造器之外的目的是防止WeakOrderQueue.this指针</span></span><br><span class=\"line\">            <span class=\"comment\">// 逃逸避免被其他线程在其构造的过程中访问</span></span><br><span class=\"line\">            stack.setHead(queue);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">return</span> queue;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在前边介绍WeakOrderQueue的结构的时候，我们提到WeakOrderQueue结构内部其实一个由Link节点组成的链表。WeakOrderQueue在初始状态下是只包含一个Link节点的链表。</p>\n<p>所有在创建WeakOrderQueue结构的时候需要同时为其创建一个Link节点。而这些Link节点正是真正保存回收线程所回收到的对象的地方。</p>\n<p>而对于一个创建线程来说它的所有回收线程能够为其回收对象的总量是被availableSharedCapacity 限制的，每创建一个Link节点，它的值就减少一个LINK_CAPACITY ，每释放一个Link节点，它的值就增加一个LINK_CAPACITY 。这样就能保证所有回收线程的回收总量不会超过 availableSharedCapacity 的限制。</p>\n<p>所以在为WeakOrderQueue结构创建首个Link节点时，需要判断<strong>当前所有回收线程回收的对象总量</strong>是否已经超过了 availableSharedCapacity 。如果容量还够回收一个Link大小的对象，则开始创建WeakOrderQueue结构。</p>\n<p>如果当前回收容量已经超过availableSharedCapacity或者不足回收一个Link大小的对象，则停止创建WeakOrderQueue节点，回收流程终止。不在对该回收对象进行回收。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//此处目的是为接下来要创建的link预留空间容量</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"type\">boolean</span> <span class=\"title function_\">reserveSpaceForLink</span><span class=\"params\">(AtomicInteger availableSharedCapacity)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//获取stack中允许异线程回收对象的总容量（异线程还能为该stack收集多少对象）</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">available</span> <span class=\"operator\">=</span> availableSharedCapacity.get();</span><br><span class=\"line\">        <span class=\"comment\">//当availbale可供回收容量小于一个Link时，说明异线程回收对象已经达到上限，不能在为stack回收对象了</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (available &lt; LINK_CAPACITY) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//为Link预留到一个Link的空间容量，更新availableSharedCapacity</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (availableSharedCapacity.compareAndSet(available, available - LINK_CAPACITY)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里的预订容量其实就是将 availableSharedCapacity 的值减去一个 LINK_CAPACITY 大小。其他回收线程会看到这个 availableSharedCapacity 容量的变化，方便决定是否继续为创建线程回收对象。</p>\n<p>当为WeakOrderQueue结构的首个Link节点预订容量成功后，就开始创建WeakOrderQueue节点。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//为了使stack进行GC,这里不会持有其所属stack的引用</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"title function_\">WeakOrderQueue</span><span class=\"params\">(Stack&lt;?&gt; stack, Thread thread)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//weakOrderQueue持有对应跨线程的弱引用</span></span><br><span class=\"line\">    <span class=\"built_in\">super</span>(thread);</span><br><span class=\"line\">    <span class=\"comment\">//创建尾结点</span></span><br><span class=\"line\">    tail = <span class=\"keyword\">new</span> <span class=\"title class_\">Link</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 创建头结点  availableSharedCapacity = maxCapacity / maxSharedCapacityFactor</span></span><br><span class=\"line\">    <span class=\"comment\">// 此时availableSharedCapacity的值已经变化了，减去了一个link的大小</span></span><br><span class=\"line\">    head = <span class=\"keyword\">new</span> <span class=\"title class_\">Head</span>(stack.availableSharedCapacity);</span><br><span class=\"line\">    head.link = tail;</span><br><span class=\"line\">    interval = stack.delayedQueueInterval;</span><br><span class=\"line\">    handleRecycleCount = interval; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当回收线程对应的WeakOrderQueue节点创建成功后，就将其插入到回收对象对应的Stack结构里的WeakOrderQueue链表中的头结点处。因为这里可能会涉及多个回收线程并发向WeakOrderQueue链表头结点处添加节点，所以更新Stack结构中WeakOrderQueue链表头结点的方法被设计成同步方法。这也是整个Recycler 对象池设计中，唯一的一个同步方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setHead</span><span class=\"params\">(WeakOrderQueue queue)</span> &#123;</span><br><span class=\"line\">     <span class=\"comment\">//始终在weakOrderQueue链表头结点插入新的queue（其他线程收集的由本线程创建的对象）</span></span><br><span class=\"line\">     queue.setNext(head);</span><br><span class=\"line\">     head = queue;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/assets/523b778404c140a29621295d079be9f8tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-nuriy5k.awebp\" alt=\"image.png\"></p>\n<h3 id=\"11-7-向WeakOrderQueue节点中添加回收对象\">11.7 向WeakOrderQueue节点中添加回收对象</h3>\n<p>终于的终于我们到了多线程回收对象的最后一步了，本篇文章到这里也接近尾声了，大家在坚持一下。</p>\n<p>这里要做的事情就是，将回收对象添加到回收线程对应的WeakOrderQueue节点中，Netty会在Link链表的尾结点处添加回收对象，如果尾结点容量已满，就继续新创建一个Link。将回收对象添加到新的Link节点中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">add</span><span class=\"params\">(DefaultHandle&lt;?&gt; handle)</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">//将handler中的lastRecycledId标记为当前weakOrderQueue中的Id,一个stack和一个回收线程对应一个weakOrderQueue节点</span></span><br><span class=\"line\">      <span class=\"comment\">//表示该池化对象 最近的一次是被当前回收线程回收的。</span></span><br><span class=\"line\">      handle.lastRecycledId = id;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 控制异线程回收频率 只回收1/8的对象</span></span><br><span class=\"line\">      <span class=\"comment\">// 这里需要关注的细节是其实在scavengeSome方法中将weakOrderQueue中的待回收对象转移到创建线程的stack中时，Netty也会做回收频率的限制</span></span><br><span class=\"line\">      <span class=\"comment\">// 这里在回收线程回收的时候也会控制回收频率（总体控制两次）netty认为越早的做回收频率控制越好 这样可以避免weakOrderQueue中的容量迅速的增长从而失去控制</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (handleRecycleCount &lt; interval) &#123;</span><br><span class=\"line\">          handleRecycleCount++;</span><br><span class=\"line\">          <span class=\"comment\">// Drop the item to prevent recycling to aggressive.</span></span><br><span class=\"line\">          <span class=\"keyword\">return</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      handleRecycleCount = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">//从尾部link节点开始添加新的回收对象</span></span><br><span class=\"line\">      <span class=\"type\">Link</span> <span class=\"variable\">tail</span> <span class=\"operator\">=</span> <span class=\"built_in\">this</span>.tail;</span><br><span class=\"line\">      <span class=\"type\">int</span> writeIndex;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">//如果当前尾部link节点容量已满，就需要创建新的link节点</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> ((writeIndex = tail.get()) == LINK_CAPACITY) &#123;</span><br><span class=\"line\">          <span class=\"comment\">//创建新的Link节点</span></span><br><span class=\"line\">          <span class=\"type\">Link</span> <span class=\"variable\">link</span> <span class=\"operator\">=</span> head.newLink();</span><br><span class=\"line\">          <span class=\"comment\">//如果availableSharedCapacity的容量不够了，则无法创建Link。丢弃待回收对象</span></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (link == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">              <span class=\"comment\">// 丢弃对象</span></span><br><span class=\"line\">              <span class=\"keyword\">return</span>;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"comment\">// We allocate a Link so reserve the space</span></span><br><span class=\"line\">          <span class=\"comment\">//更新尾结点</span></span><br><span class=\"line\">          <span class=\"built_in\">this</span>.tail = tail = tail.next = link;</span><br><span class=\"line\"></span><br><span class=\"line\">          writeIndex = tail.get();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">//将回收对象handler放入尾部link节点中</span></span><br><span class=\"line\">      tail.elements[writeIndex] = handle;</span><br><span class=\"line\">      <span class=\"comment\">//这里将stack置为null，是为了方便stack被回收。</span></span><br><span class=\"line\">      <span class=\"comment\">//如果Stack不再使用，期望被GC回收，发现handle中还持有stack的引用，那么就无法被GC回收，从而造成内存泄漏</span></span><br><span class=\"line\">      <span class=\"comment\">//在从对象池中再次取出该对象时，stack还会被重新赋予</span></span><br><span class=\"line\">      handle.stack = <span class=\"literal\">null</span>;</span><br><span class=\"line\">      <span class=\"comment\">//注意这里用lazySet来延迟更新writeIndex。只有当writeIndex更新之后，在创建线程中才可以看到该待回收对象</span></span><br><span class=\"line\">      <span class=\"comment\">//保证线程最终可见而不保证立即可见的原因就是 其实这里Netty还是为了性能考虑避免执行内存屏障指令的开销。</span></span><br><span class=\"line\">      <span class=\"comment\">//况且这里也并不需要考虑线程的可见性，当创建线程调用scavengeSome从weakOrderQueue链表中回收对象时，看不到当前节点weakOrderQueue</span></span><br><span class=\"line\">      <span class=\"comment\">//新添加的对象也没关系，因为是多线程一起回收，所以继续找下一个节点就好。及时全没看到，大不了就在创建一个对象。主要还是为了提高weakOrderQueue的写入性能</span></span><br><span class=\"line\">      tail.lazySet(writeIndex + <span class=\"number\">1</span>);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>首先第一步就要设置回收对象DefaultHandler中的lastRecycledId ，将其设置为该回收线程Id，表示该回收对象最近一次是由当前回收线程回收的。此时的DefaultHandler中 <code>recycleId != lastRecycledId </code>​，对象处于半回收状态。</li>\n<li>控制回收线程的回收频率（只回收 1 / 8 的对象），大家是否还记得我们在《9.5 转移回收对象》小节中介绍 <code>stack#scavengeSome方法</code>​ 的时候，在创建线程从Stack中的WeakOrderQueue链表中转移对象到数组栈中的时候，也会被回收频率进行控制，只转移 1 / 8 的对象。所以这里我们可以看到​<strong>回收频率的控制在多线程回收对象的时候会控制两次</strong>​，netty认为越早做回收频率控制越好这样可以避免weakOrderQueue中的容量迅速的增长从而失去控制。</li>\n<li>在WeakOrderQueue结构中，当我们向Link链表添加回收对象时，都会向Link链表的尾结点中添加回收对象，如果当前尾结点容量已经满了 <code>writeIndex = tail.get()) == LINK_CAPACITY</code>​ ，我们就需要新创建一个Link节点，并将tail指针指向新的Link节点更新尾结点。最后将回收对象回收至新的尾结点中。当然我们要考虑到 availableSharedCapacity 容量的限制，如果容量不够了，就不能在新建Link节点，直接将回收对象丢弃，停止回收。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Head</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">         Link <span class=\"title function_\">newLink</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">              <span class=\"comment\">//此处的availableSharedCapacity可能已经被多个回收线程改变，因为availableSharedCapacity是用来控制回收线程回收的总容量限制</span></span><br><span class=\"line\">              <span class=\"comment\">//每个回收线程再回收对象时都需要更新availableSharedCapacity</span></span><br><span class=\"line\">              <span class=\"keyword\">return</span> reserveSpaceForLink(availableSharedCapacity) ? <span class=\"keyword\">new</span> <span class=\"title class_\">Link</span>() : <span class=\"literal\">null</span>;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//此处目的是为接下来要创建的link预留空间容量</span></span><br><span class=\"line\">        <span class=\"keyword\">static</span> <span class=\"type\">boolean</span> <span class=\"title function_\">reserveSpaceForLink</span><span class=\"params\">(AtomicInteger availableSharedCapacity)</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//获取stack中允许异线程回收对象的总容量（异线程还能为该stack收集多少对象）</span></span><br><span class=\"line\">                <span class=\"type\">int</span> <span class=\"variable\">available</span> <span class=\"operator\">=</span> availableSharedCapacity.get();</span><br><span class=\"line\">                <span class=\"comment\">//当availbale可供回收容量小于一个Link时，说明异线程回收对象已经达到上限，不能在为stack回收对象了</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (available &lt; LINK_CAPACITY) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">//为Link预留到一个Link的空间容量，更新availableSharedCapacity</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (availableSharedCapacity.compareAndSet(available, available - LINK_CAPACITY)) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>到这里Recycler对象池的整个<strong>多线程无锁化回收对象</strong>的流程笔者就为大家介绍完了。</p>\n<p>但是这里还有两个点，笔者想要和大家再强调一下：</p>\n<p>​<strong>第一：为什么这里会将handle.stack设置为null</strong>​?</p>\n<p>不知大家还记不记得我们在介绍 <code>stack#scavengeSome方法</code>​ 的时候专门提到，在创建线程遍历WeakOrderQueue链表将链表中的待回收对象转移至stack中的数组栈时，会将待回收对象的DefaultHandler持有的stack重新设置为其创建线程对应的stack。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">boolean</span> <span class=\"title function_\">transfer</span><span class=\"params\">(Stack&lt;?&gt; dst)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">      .................省略..............</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">//重新为defaultHandler设置其所属stack(初始创建该handler的线程对应的stack)</span></span><br><span class=\"line\">      <span class=\"comment\">//该defaultHandler在被回收对象回收的时候，会将其stack置为null，防止极端情况下，创建线程挂掉，对应stack无法被GC</span></span><br><span class=\"line\">      element.stack = dst;</span><br><span class=\"line\"></span><br><span class=\"line\">      .................省略..............</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>而这里在回收线程向WeakOrderQueue节点添加回收对象时先将 handle.stack设置为 null，而在转移回收对象时又将 handle.stack 设置回来，这不是多此一举吗？</p>\n<p>其实并不是多此一举，这样设计是非常有必要的，我们假设一种极端的情况，当创建线程挂掉并被GC回收之后，其实stack中存储的回收对象已经不可能在被使用到了，stack应该也被回收掉。但是如果这里回收线程在回收的时候不将对象持有的stack设置为null的话，直接添加到了WeakOrderQueue节点中，当创建被GC掉的时候，由于这条引用链的存在导致对应stack永远不会被GC掉，造成内存泄露。</p>\n<blockquote>\n<p>所以笔者在本文中多次强调，当我们在设计比较复杂的程序结构时，对于对象之间的引用关系，一定要时刻保持清晰的认识，防止内存泄露。</p>\n</blockquote>\n<p>​<strong>第二：为什么最后使用lazySet来更新尾结点的writeIndex</strong>​？</p>\n<p>当我们向Link链表的尾结点添加完回收对象之后，在更新尾结点的writeIndex时，使用到了延时更新，而延时更新并不会保证多线程的可见性，如果此时创建线程正在转移对象，那么将不会看到新添加进来的回收对象了。</p>\n<p>而事实上，我们这里并不需要保证线程之间的实时可见性，只需要保证最终可见性即可。</p>\n<p>确实在当创建线程转移对象的时候可能并不会看到刚刚被回收线程新添加进来的回收对象，看不到没关系，创建线程大不了在本次转移中不回收它不就完了么。因为只要创建线程Stack结构中的数组栈为空，创建线程就会从WeakOrderQueue链表中转移对象，以后会有很多次机会来WeakOrderQueu链表中转移对象，什么时候看见了，什么时候转移它。并不需要实时性。退一万步讲，即使全部看不到，大不了创建线程直接创建一个对象返回就行了。</p>\n<p>而如果这里要保证线程之间的实时可见性，在更新尾结点的writeIndex的时候就不得不插入 LOCK 前缀内存屏障指令保证多线程之间的实时可见性，而执行内存屏障指令是需要开销的，所以​<strong>为了保证WeakOrderQueue的写入性能</strong>​，Netty这里选择了只保证最终可见性而不保证实时可见性。</p>\n<hr>\n<h2 id=\"总结\">总结</h2>\n<p>到这里关于Recycler对象池的整个设计与源码实现，笔者就为大家详细的剖析完毕了，在剖析的过程中，我们提炼出了很多多线程并发程序的设计要点和注意事项。大家可以在日常开发工作中多多体会并实践。</p>\n<p>虽然本文介绍的Recycler对象池整体设计将会在<strong>4.1.71.Final</strong>版本被重构，但是在当前版本Recycler对象池的设计和实现中，我们还是可以学习到很多东西的。</p>\n<p>笔者真心十分佩服能够耐心看到这里的大家，不知不觉已经唠叨了三万多字了，谢谢大家的观看~~，大家记得晚餐时给自己加餐个鸡腿奖励一下自己，哈哈！！</p>\n","excerpt":"","more":"<h1>Recycler</h1>\n<hr>\n<blockquote>\n<p>转载          bin的技术小屋<br>\n本系列Netty源码解析文章基于 <strong>4.1.56.Final</strong>版本</p>\n</blockquote>\n<h2 id=\"1-池化思想的应用\">1. 池化思想的应用</h2>\n<p>在我们日常开发工作中我们经常会遇到各种池化技术的设计思想，比如连接池，内存池，对象池，还有我们在业务开发过程中经常会缓存一些业务计算结果数据这也同样运用到了池化技术的设计思想，我们可以叫它为结果池。</p>\n<p>池化技术的应用场景就是当一个对象的创建和销毁需要付出比较大的性能开销时，我们就需要将这些重量级对象放在一个池子里管理，当需要时直接从池子里获取避免重复创建和销毁的开销从而达到了复用的效果。</p>\n<p>比如连接池里面保存管理的都是一些网络连接对象，这些对象创建和销毁的代价比较大。通过连接池将这些重量级的网络连接对象统一管理起来，业务线程可以直接复用，避免了重新创建，释放连接的性能开销以及等待时间。</p>\n<p>还有我们在日常开发中遇到的一些计算逻辑复杂的业务，我们通常会先从数据库中查询数据，然后经过复杂的计算得到结果，为了避免下次在重复计算，我们会将计算结果放入缓存中，我们可以称做结果池。也是一种池化思想。</p>\n<p>再比如我们在<a href=\"https://link.juejin.cn/?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg2MzU3Mjc3Ng%3D%3D%26mid%3D2247484244%26idx%3D1%26sn%3D831060fc38caa201d69f87305de7f86a%26chksm%3Dce77c513f9004c05b48f849ff99997d6d7252453135ae856a029137b88aa70b8e046013d596e%23rd\" title=\"https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&amp;mid=2247484244&amp;idx=1&amp;sn=831060fc38caa201d69f87305de7f86a&amp;chksm=ce77c513f9004c05b48f849ff99997d6d7252453135ae856a029137b88aa70b8e046013d596e#rd\">《Netty如何高效接收网络数据》</a>一文中提到的内存池，为了避免不必要的数据拷贝以及JVM垃圾回收对性能的影响，Netty 选择使用堆外内存存储网络通信数据。在 Netty 申请堆外内存之前，首先会在 JVM 堆中创建一个用于引用 native memory 的引用对象 DirectByteBuffer ，随后会使用 native 方法 <code>unsafe.allocateMemory</code>​ 通过底层 <code>malloc</code>​ 系统调用申请一块堆外内存。</p>\n<p>这里就涉及到到两个重要开销：</p>\n<ul>\n<li>在 JVM 堆中创建对象 DirectByteBuffer ，并为该对象申请分配 JVM 堆内存。</li>\n<li>通过 <code>malloc</code>​ 系统调用向操作系统申请堆外内存，然后被 DirectByteBuffer 引用。但是堆外内存的申请和释放远比堆内内存申请和释放的开销要大很多。</li>\n</ul>\n<p>而在 Netty 面对的高并发网络通信场景下，申请堆外内存是一个非常频繁的操作，基于以上提到的两个重要性能开销，这种大量频繁的内存申请释放操作对程序的性能影响是巨大的，所以 Netty 就引入了内存池对内存相关的操作进行统一的管理。</p>\n<h2 id=\"2-对象池简介\">2. 对象池简介</h2>\n<p>以上内容的介绍就是池化思想的应用以及它所解决的问题，本文我们的主题是介绍对象池，对象池的引入是为了在需要大量创建对象以及销毁对象的场景下，将对象进行池化以达到复用池中对象，避免大量地重复创建对象以及销毁对象的性能开销，</p>\n<p>前边我们在提到内存池的时候说到，在 Netty 所要面对的高并发网络通信场景下，需要大量的申请堆外内存用来存储通信数据。在 Netty 中，我们通过 PooledDirectByteBuf 对象来引用堆外内存。所以 Netty 在处理网络 IO 的时候是需要大量频繁的创建 PooledDirectByteBuf 对象。</p>\n<p>为了避免在高并发的场景下大量的创建对象所引来的性能开销，我们可以引入对象池来池化创建出来的 PooledDirectByteBuf 对象，需要用的时候直接从对象池中获取，用完之后在回收到对象池中。</p>\n<p>另外这里提前向大家透露一点的是我们下篇文章中即将要介绍的 Netty 发送数据流程涉及到的对象池的应用。我们都知道 Netty 是一个异步事件驱动的高性能网络框架，当在业务线程中处理完业务逻辑准备响应业务结果到客户端的时候，我们会向对应 channel 写入业务结果，此时业务线程会立即返回，这是一个异步的过程。</p>\n<p>原因是在底层实现中，Netty 会将用户的响应结果数据暂时写入到每个 Channel 特有的一个发送缓冲队列 ChannelOutboundBuffer 中，也就是说这个 ChannelOutboundBuffer 缓存着 Channel 中的待发送数据。最终会通过 flush 方法，将 ChannelOutboundBuffer 中的这些待发送数据写入到底层 Socket 中，从而发送给客户端。</p>\n<p>而这个发送缓冲队列 ChannelOutboundBuffer 中的队列元素是一个 Entry 类型的，每次的写入操作需要创建一个 Entry 对象来包裹发送数据，并将这个 Entry 对象缓存在发送缓冲队列 ChannelOutboundBuffer 中。</p>\n<blockquote>\n<p>这里大家只需要知道 ChannelOutboundBuffer 是个啥，它的大概作用，以及这个缓冲队列缓存的对象是 Entry 类型的就可以了，我们会在下篇文章为大家详细介绍，这里引出只是为了介绍对象池的应用场景。</p>\n</blockquote>\n<p>所以Netty在面对海量网络 IO 的场景下，必定会大量频繁地去创建 Entry 对象，那么每一次的网络 IO 都要重新创建这些对象，并且用完又要被垃圾回收掉这样无疑会大量增加 JVM 的负担以及 GC 的时间，这对于最求极致性能的 Netty 来说肯定是不可接受的。</p>\n<p>基于以上这几种情况，对象池被用来管理那些需要频繁创建使用的对象，在使用完后并不立即将它们释放，而是将它们在对象池中缓存起来，以供后续的应用程序重复使用，从而减少创建对象和释放对象的开销，进而改善应用程序的性能。</p>\n<p>从另一方面来看，对象池还可以将对象限制在一定的数量内从而可以有效减少应用程序在内存上的开销。</p>\n<hr>\n<p>通过前边关于对象池的简要介绍之后，我想大家现在可能比较好奇这些对象在创建和回收的过程中到底需要哪些开销呢？</p>\n<p>接下来笔者就为大家介绍下这些开销方面的内容方便大家更加全面清晰地理解对象池。</p>\n<h2 id=\"3-对象在JVM中创建和回收开销\">3. 对象在JVM中创建和回收开销</h2>\n<h3 id=\"3-1-对象的创建开销\">3.1 对象的创建开销</h3>\n<p>在 Java 程序中我们可以通过一个 new 关键字来创建对象，而当JVM遇到一条 new 的字节码指令后，会发生什么呢？</p>\n<ol>\n<li>首先 JVM 要去检查 new 指令后面的参数也就是创建对象所属的 Java 类是否能够在方法区的常量池中定位到类的符号引用，进而检查这个符号引用所代表的类是否已经加载，解析，初始化过。如果没有，就需要先执行类的加载过程。</li>\n<li>当通过类加载检查之后，就开始为对象分配内存，而对象所需内存大小其实在类加载完成后就已经确定了。JVM要做的事情就是将一块确定大小的内存区域从JVM堆中划分出来。</li>\n</ol>\n<blockquote>\n<p>关于如何确定对象所需内存大小，对这方面细节感兴趣的同学可以回看下笔者的<a href=\"https://link.juejin.cn/?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg2MzU3Mjc3Ng%3D%3D%26mid%3D2247484304%26idx%3D1%26sn%3D54bf0d07e69c5621c145afaece8f50d6%26chksm%3Dce77c5d7f9004cc1249a03dfd0fb12b7d75171f1b87acea1fa44bbb11ca374b6f42a66fa274d%23rd\" title=\"https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&amp;mid=2247484304&amp;idx=1&amp;sn=54bf0d07e69c5621c145afaece8f50d6&amp;chksm=ce77c5d7f9004cc1249a03dfd0fb12b7d75171f1b87acea1fa44bbb11ca374b6f42a66fa274d#rd\">《对象在JVM中的内存布局》</a>这篇文章。</p>\n</blockquote>\n<ol start=\"3\">\n<li>而在为对象划分堆中内存的时候又会根据JVM堆中内存是否规整，从而分为指针碰撞法和空闲列表法。而多线程同时创建对象在JVM中是非常常见的行为，所以在多线程并发创建对象的时候JVM又需要保证划分内存时的线程安全性。JVM需要对划分内存空间的动作进行同步处理（CAS  + 失败重试）。</li>\n<li>而为了避免这种划分内存时的同步锁定，JVM提供了另外一种方式就是每个线程先预先向JVM堆申请一块内存（本地线程分配缓存-TLAB），这样当线程创建对象的时候，先是从自己的TLAB中为对象分配内存，当自己的TLAB用完时，才会去JVM堆中​<strong>同步分配</strong>​。 我们可以通过虚拟机参数<code>-XX:+UseTLAB</code>​开启TLAB（默认）。<code>-XX:-UseTLAB</code>​关闭TLAB。</li>\n</ol>\n<blockquote>\n<p>大家这里需要记住这种利用TLAB的分配方式，因为Netty中的对象池Recycler也是利用这种思想避免多线程获取对象的同步开销。</p>\n</blockquote>\n<ol start=\"5\">\n<li>在为对象分配好内存之后，JVM会将这块内存初始化为零值。这样就可以保证对象中的实例字段不赋初始值就可以直接使用，其值为字段对应数据类型的零值。</li>\n<li>设置对象头。包括设置MarkWord中的对象运行时信息。以及通过类型指针引用关联到类的元数据信息。这些内容我们在<a href=\"https://link.juejin.cn/?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg2MzU3Mjc3Ng%3D%3D%26mid%3D2247484304%26idx%3D1%26sn%3D54bf0d07e69c5621c145afaece8f50d6%26chksm%3Dce77c5d7f9004cc1249a03dfd0fb12b7d75171f1b87acea1fa44bbb11ca374b6f42a66fa274d%23rd\" title=\"https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&amp;mid=2247484304&amp;idx=1&amp;sn=54bf0d07e69c5621c145afaece8f50d6&amp;chksm=ce77c5d7f9004cc1249a03dfd0fb12b7d75171f1b87acea1fa44bbb11ca374b6f42a66fa274d#rd\">《对象在JVM中的内存布局》</a>一文中都有提到过，大家还记得吗？</li>\n<li>执行构造函数。这样一个真正可用的对象就被创建出来了。</li>\n</ol>\n<h3 id=\"3-2-对象的回收开销\">3.2 对象的回收开销</h3>\n<ul>\n<li>JVM中的垃圾回收器通过可达性分析来探索所有Java存活对象，从GC ROOTS出发边标记边探索所有对象的引用链，以判断对象是否存活。</li>\n<li>垃圾回收器在垃圾回收的过程中发生的GC PAUSE也就是STOP THE WORLD。这里详细的垃圾回收过程我们就不展开了，主要是为了指明在对象回收时最主要的两个开销点。</li>\n</ul>\n<hr>\n<p>然而在高并发的网络IO处理场景下，这些单个对象的创建和回收开销会被无限放大，于是Netty引入了一个轻量级的对象池 Recycler 来负责将这些需要频繁创建的对象进行池化，统一分配，回收管理。</p>\n<p>在为大家详细介绍对象池 Recycler 的实现之前，笔者想先从对象池的使用上先让大家可以直观地感受一下 Recycler 对外提供的功能入口。</p>\n<h2 id=\"4-对象池Recycler的使用\">4. 对象池Recycler的使用</h2>\n<p>这里我们直接看下Netty源码中是如何使用Recycler对象池的，首先我们来看下对象池在 PooledDirectByteBuf 类中是如何使用的。</p>\n<blockquote>\n<p>大家这里先不用去管这个PooledDirectByteBuf类是干吗的，只需要明白这个类是会被频繁创建的，我们这里主要是演示对象池的使用。</p>\n</blockquote>\n<p><img src=\"/assets/ec623644e43b4c56bf1110c9cfc74bc8tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-1zakfmq.awebp\" alt=\"image.png\"></p>\n<h3 id=\"4-1-对象池在PooledDirectByteBuf类中的使用\">4.1 对象池在PooledDirectByteBuf类中的使用</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">PooledDirectByteBuf</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">PooledByteBuf</span>&lt;ByteBuffer&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">//创建对象池</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ObjectPool&lt;PooledDirectByteBuf&gt; RECYCLER = ObjectPool.newPool(</span><br><span class=\"line\">            <span class=\"keyword\">new</span> <span class=\"title class_\">ObjectCreator</span>&lt;PooledDirectByteBuf&gt;() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> PooledDirectByteBuf <span class=\"title function_\">newObject</span><span class=\"params\">(Handle&lt;PooledDirectByteBuf&gt; handle)</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">PooledDirectByteBuf</span>(handle, <span class=\"number\">0</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//对象在对象池中的回收句柄</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Handle&lt;PooledByteBuf&lt;T&gt;&gt; recyclerHandle;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> PooledDirectByteBuf <span class=\"title function_\">newInstance</span><span class=\"params\">(<span class=\"type\">int</span> maxCapacity)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//从对象池中获取对象</span></span><br><span class=\"line\">        <span class=\"type\">PooledDirectByteBuf</span> <span class=\"variable\">buf</span> <span class=\"operator\">=</span> RECYCLER.get();</span><br><span class=\"line\">        buf.reuse(maxCapacity);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> buf;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">recycle</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">         <span class=\"comment\">//回收对象</span></span><br><span class=\"line\">        recyclerHandle.recycle(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ................省略和对象池无关的代码..................</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>前边我们提到在Netty中需要大量频繁的创建PooledDirectByteBuf对象，为了避免在高并发场景下频繁创建对象的开销从而引入了对象池来统一管理PooledDirectByteBuf对象。</p>\n<p>Netty中每个被池化的对象中都会引用对象池的实例<code>ObjectPool  RECYCLER </code>​，这个对象池的实例就是专门用来分配和管理被池化对象的。</p>\n<p>这里我们创建出来的对象池是专门用来管理PooledDirectByteBuf对象的（通过泛型指定对象池需要管理的具体对象）。泛型类<code>ObjectPool&lt;T&gt;</code>​是Netty为对象池设计的一个顶层抽象。对象池的行为功能均定义在这个泛型抽象类中。我们可以通过 ObjectPool#newPool 方法创建指定的对象池。其参数 ObjectCreator 接口用来定义创建池化对象的行为。当对象池中需要创建新对象时，就会调用该接口方法 ObjectCreatornewObject 来创建对象。</p>\n<p>其中每个池化对象中都会包含一个recyclerHandle，这个recyclerHandle是池化对象在对象池中的句柄。里边封装了和对象池相关的一些行为和信息，recyclerHandle是由对象池在创建对象后传递进来的。</p>\n<p>当我们需要PooledDirectByteBuf对象时，我们直接通过<code>RECYCLER.get()</code>​从PooledDirectByteBuf对象池中获取对象即可。</p>\n<p>当我们使用完毕后，直接调用PooledDirectByteBuf对象在对象池中的句柄<code>recyclerHandle.recycle(this) </code>​把对象回收到对象池中。</p>\n<h3 id=\"4-2-对象池在Channel写入缓冲队列中的使用\">4.2 对象池在Channel写入缓冲队列中的使用</h3>\n<p>前边提到，每个Channel都会有一个独立的写入缓冲队列ChannelOutboundBuffer，用来暂时存储用户的待发送数据。这样用户可以在调用channel的write方法之后立马返回，实现异步发送流程。</p>\n<p>在发送数据时，Channel首先会将用户要发送的数据缓存在自己的写缓存队列ChannelOutboundBuffer中。而ChannelOutboundBuffer中的元素类型为Entry。在Netty中会大量频繁的创建Entry对象。所以Entry对象同样也需要被对象池管理起来。</p>\n<p>在上小节介绍PooledDirectByteBuf对象池的过程中，我想大家已经对对象池的使用套路已经有了大概的了解。这里我们借助Entry对象池将使用步骤总结如下：</p>\n<h4 id=\"创建对象池\">创建对象池</h4>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Entry</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ObjectPool&lt;Entry&gt; RECYCLER = ObjectPool.newPool(<span class=\"keyword\">new</span> <span class=\"title class_\">ObjectCreator</span>&lt;Entry&gt;() &#123;</span><br><span class=\"line\">         <span class=\"meta\">@Override</span></span><br><span class=\"line\">         <span class=\"keyword\">public</span> Entry <span class=\"title function_\">newObject</span><span class=\"params\">(Handle&lt;Entry&gt; handle)</span> &#123;</span><br><span class=\"line\">             <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Entry</span>(handle);</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">     &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"comment\">//recyclerHandle用于回收对象</span></span><br><span class=\"line\">     <span class=\"keyword\">private</span>  Handle&lt;Entry&gt; handle;</span><br><span class=\"line\">   </span><br><span class=\"line\">     <span class=\"keyword\">private</span> <span class=\"title function_\">Entry</span><span class=\"params\">(Handle&lt;Entry&gt; handle)</span> &#123;</span><br><span class=\"line\">         <span class=\"built_in\">this</span>.handle = handle;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>前边我们介绍到每一个要被池化的对象都需要一个静态变量来引用其对应的对象池。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ObjectPool&lt;Entry&gt; RECYCLER </span><br></pre></td></tr></table></figure>\n<p>匿名实现 ObjectCreator 接口来定义对象创建的行为方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">ObjectCreator</span>&lt;T&gt; &#123;</span><br><span class=\"line\">    T <span class=\"title function_\">newObject</span><span class=\"params\">(Handle&lt;T&gt; handle)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过<code>ObjectPool#newPool</code>​ 创建用于管理Entry对象的对象池。</p>\n<p>在对象池创建对象时，会为池化对象创建其在对象池中的句柄Handler，随后将Handler传入创建好的池化对象中。当对象使用完毕后，我们可以通过Handler来将对象回收至对象池中等待下次继续使用。</p>\n<h4 id=\"从对象池中获取对象\">从对象池中获取对象</h4>\n<p>由于Entry对象在设计上是被对象池管理的，所以不能对外提供public构造函数，无法在外面直接创建Entry对象。</p>\n<p>所以池化对象都会提供一个获取对象实例的 static 方法 newInstance。在该方法中通过<code>RECYCLER.get()</code>​从对象池中获取对象实例。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> Entry <span class=\"title function_\">newInstance</span><span class=\"params\">(Object msg, <span class=\"type\">int</span> size, <span class=\"type\">long</span> total, ChannelPromise promise)</span> &#123;</span><br><span class=\"line\">      <span class=\"type\">Entry</span> <span class=\"variable\">entry</span> <span class=\"operator\">=</span> RECYCLER.get();</span><br><span class=\"line\">    </span><br><span class=\"line\">      .........省略无关代码..............</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">return</span> entry;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"使用完毕回收对象\">使用完毕回收对象</h4>\n<p>池化对象都会提供一个 recycle 方法，当对象使用完毕后，调用该方法将对象回收进对象池中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">recycle</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    next = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    bufs = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    buf = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    msg = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    promise = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    progress = <span class=\"number\">0</span>;</span><br><span class=\"line\">    total = <span class=\"number\">0</span>;</span><br><span class=\"line\">    pendingSize = <span class=\"number\">0</span>;</span><br><span class=\"line\">    count = -<span class=\"number\">1</span>;</span><br><span class=\"line\">    cancelled = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    handle.recycle(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>清空对象中的所有属性。</li>\n<li>通过对象中持有的对象池句柄Handler，将对象回收进对象池中。</li>\n</ul>\n<hr>\n<p>从上边所列举的Netty中使用对象池的例子，我们可以直观的感受到对象池的使用非常简单。无非就是从对象池获取对象，将对象回收至对象池这两个核心步骤。</p>\n<p>同时我们也注意到池化对象的设计和普通对象是有所不同的，不过，我们只需要遵循本小节中所列举的几个步骤进行设计即可。</p>\n<h2 id=\"5-Recycler总体设计\">5. Recycler总体设计</h2>\n<p>Recycler对象池的设计还是比较复杂的但是却很精妙，所以笔者这里继续采用总 - 分 - 总的结构来为大家介绍对象池的设计与实现。</p>\n<p>一开始我们先不要去追求太过细节的内容，先要从总体上摸清楚对象池的设计架构，以及各个功能模块之间的关联。</p>\n<p>当我们从整体上理解了对象池的设计架构后，笔者后面会分模块来各个击破它的实现细节。</p>\n<p>在理清楚各个模块的实现细节之后，笔者将在从细节着手再次将对象池的整体设计架构为大家串联起来。</p>\n<p>我们按照这个思路先来看一下Recycler对象池的总体架构设计图，从整体直观上来感受下它的设计，以及包含的一些重要模块。</p>\n<p><img src=\"/assets/d8bdbd9d79814646999637ffc46281cbtplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-5lz8huo.awebp\" alt=\"image.png\"></p>\n<h3 id=\"5-1-多线程获取对象无锁化设计\">5.1 多线程获取对象无锁化设计</h3>\n<p>首先我们从外部整体来看，对象池对于我们来说它就是一个存储对象的池子，当我们需要对象时会从这个池子里直接获取，用完对象时在把对象归还回池子中方便下一次重复使用。</p>\n<p>但我们俯瞰整个对象池的设计架构时，我们发现整个设计还是比较复杂其中蕴含了不少精妙的细节。</p>\n<p>对象池中最重要的两个结构分别是 Stack 和 WeakOrderQueue。</p>\n<p>Stack 中包含一个用数组实现的栈结构（图中绿色部分），这个栈结构正是对象池中真正用于存储池化对象的地方，我们每次从对象池中获取对象都会从这个栈结构中弹出栈顶元素。同样我们每次将使用完的对象归还到对象池中也是将对象压入这个栈结构中。</p>\n<p>​<strong>这里有一个精妙的设计</strong>​，我们从图中可以看到每个线程都会拥有一个属于自己的Stack。在我们介绍《对象创建的开销》这一小节内容时，提到为了避免多线程并发申请内存时的同步锁定开销，JVM为每个线程预先申请了一块内存（TLAB）,这样当线程创建对象时都是从自己的TLAB中为对象分配内存。从而避免了多线程之间的同步竞争。</p>\n<p>同样当多线程并发从对象池中获取对象时, 如果整个对象池只有一个Stack结构的话，为了保证多线程获取对象的线程安全性，我们只能同步地来访问这个Stack，这样就为对象池的设计引入了多线程同步竞争的开销。</p>\n<p>​<strong>为了避免这种不必要的同步竞争，Netty也采用了类似TLAB分配内存的方式，每个线程拥有一个独立Stack，这样当多个线程并发从对象池中获取对象时，都是从自己线程中的Stack中获取，全程无锁化运行。大大提高了多线程从对象池中获取对象的效率</strong>​。</p>\n<blockquote>\n<p>这种<strong>多线程并发无锁化</strong>的设计思想，在Netty中比比皆是</p>\n</blockquote>\n<h3 id=\"5-2-Stack的设计\">5.2 Stack的设计</h3>\n<p>从Recycler对象池的整体设计架构图中我们可以看到，Stack的设计主要分为两个重要的部分：</p>\n<ul>\n<li>一个是我们前边提到的数组实现的栈结构用来存放对象池中的对象，每个线程绑定一个独立的Stack用来存储由<strong>该线程创建出来</strong>并回收到对象池中的对象。</li>\n<li>另一个重要的结构是WeakOrderQueue链表，head 指针指向WeakOrderQueue链表的头结点，cursor 指针指向链表的当前节点，prev 指针指向当前节点的前一个节点。WeakOrderQueue链表是用来存储其他线程帮助本线程回收的对象（我们称之为待回收对象）。其中WeakOrderQueue链表中的每一个节点对应一个其他线程，这个其他线程为本线程回收的对象存储在对应的WeakOrderQueue节点中。</li>\n</ul>\n<blockquote>\n<p>这里我们先不需要管WeakOrderQueue的具体结构</p>\n</blockquote>\n<p>​<strong>那么Stack结构在设计上为什么要引入这个WeakOrderQueue链表呢</strong>​？</p>\n<p>让我们考虑一种多线程回收对象的场景，我们还是以Recycler对象池的整体设计架构图为例。thread1 为当前线程，剩下的thread2 , thread3 , thread4为其他线程。让我们把视角先聚焦在当前线程上。</p>\n<blockquote>\n<p>我们先假设Stack结构中只有一个数组栈，并没有WeakOrderQueue链表。看看这样会产生什么后果？</p>\n</blockquote>\n<p><img src=\"/assets/d4522ab88aca42a4b9c2d633301fcac5tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-idyvok3.awebp\" alt=\"image.png\"></p>\n<p>当前线程 thread1 在处理业务逻辑时，创建了一个对象（注意：这个对象是由thread1创建的）如果这是一个单线程处理业务的场景，那么对象会在thread1处理完业务逻辑后被回收至thread1对应的stack1中的数组栈中。当`hread1再次需要创建对象时，会直接从其对应的stack1中的数组栈（图中绿色部分）中直接获取上次回收的对象。</p>\n<blockquote>\n<p>由这一点可以看出Stack中的数组栈（绿色部分）存放的是真正被回收的对象，是可以直接被再次获取使用的。</p>\n</blockquote>\n<p>但如果这是一个多线程处理业务场景的话，很可能由thread1创建出来的对象，会被交给thread2或者thread3去处理剩下的业务逻辑，那么当thread2或者thread3这些其他线程处理完业务逻辑时，此时对象的释放并不是在thread1中，而是在其他线程中。</p>\n<p>其他线程现在面对的任务就是要将由thread1创建出来的对象，释放回收至thread1对应的stack1中的数组栈中。如果此时多个其他线程并发的向stack1释放回收对象，势必会导致多线程之前的同步竞争，​<strong>Netty将不得不把Stack结构中的数组栈的访问设计成一个同步过程</strong>​。</p>\n<p>那么如果此时更不巧的是当前线程thread1又要同时向自己的Stack1获取对象，thread1就只能同步等待，因为此时其他线程正在向Stack1释放对象。</p>\n<blockquote>\n<p>本来我们引入对象池的目的就是为了抵消创建对象的开销加快获取对象的速度，减少GC的压力。结果由于Stack的同步访问设计又引入了同步开销。这个同步的开销甚至会比创建对象的开销还要大，那么对象池的引入就变得得不偿失了。</p>\n</blockquote>\n<p><strong>那么Netty该如何化解这种情况呢？答案还是之前反复强调的无锁化设计思想。</strong></p>\n<p>既然多线程的回收对象场景，会引入多线程之间的同步锁定开销，那么我们就继续采用无锁化的设计思想，为每个线程（注意：这里指的是非创建对象的线程也就是图中的thead2 , thread3 …）单独分配一个WeakOrderQueue节点，每个线程在为创建线程回收对象时，会将这些对象暂时存放到自己对应的WeakOrderQueue节点中。</p>\n<blockquote>\n<p>注意：存放进WeakOrderQueue中的对象我们称为待回收对象，这些待回收对象并不在Stack结构中的数组栈中，因此并不能被直接获取使用。</p>\n</blockquote>\n<p>为了方便后续描述，我们把创建对象的线程称作<code>创建线程</code>​（示例中的thread1），将为创建线程回收对象的其他线程称作<code>回收线程</code>​（示例中的thread2 , thread3 , thead4 …）。</p>\n<p>我们在将视角拉回到创建线程thread1对应的stack1中，​<strong>每个回收线程将待回收对象放入与自己对应的WeakOrderQueue节点中，这样就避免了在多线程回收场景中的同步竞争</strong>​。当所有回收线程都在为stack1回收对象时，这样在stack1中就形成了一个WeakOrderQueue链表。每个回收线程只操作与自己对应的节点。在Stack结构中通过head，prev，cursor将这些WeakOrderQueue节点组成了一个链表。</p>\n<blockquote>\n<p>每一个WeakOrderQueue节点对应一个回收线程。</p>\n</blockquote>\n<p>而当创建线程thread1再次从自己对应的Stack1中获取对象时，只会从Stack结构的数组栈中获取，因为是单线程操作数组栈，自然是不会存在同步竞争的。</p>\n<p>当Stack结构中的数组栈没有任何对象时，那么创建线程就会根据 cursor 指针遍历Stack结构中的WeakOrderQueue链表，将当前WeakOrderQueue节点存放的待回收对象​<strong>转移至数组栈中</strong>​。如果WeakOrderQueue链表中也没有任何待回收对象可以转移。那么创建线程在对象池中就直接创建一个对象出来返回。</p>\n<blockquote>\n<p>对象池回收对象的一个原则就是对象由谁创建的，最终就要被回收到创建线程对应的Stack结构中的数组栈中。数组栈中存放的才是真正被回收的池化对象，可以直接被取出复用。回收线程只能将待回收对象暂时存放至创建线程对应的Stack结构中的WeakOrderQueue链表中。当数组栈中没有对象时，由创建线程将WeakOrderQueue链表中的待回收对象转移至数组栈中。</p>\n</blockquote>\n<p><strong>正是由于对象池的这种无锁化设计，对象池在多线程获取对象和多线程回收对象的场景下，均是不需要同步的</strong></p>\n<p>大家在体会下这张图中蕴含的这种​<strong>无锁化设计思想</strong>​：</p>\n<p><img src=\"/assets/0566fc7826064b12bb88082b39c10bd2tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-hkx67f6.awebp\" alt=\"image.png\"></p>\n<h3 id=\"5-3-WeakOrderQueue的设计\">5.3 WeakOrderQueue的设计</h3>\n<p>在我们介绍完对象池在多线程回收对象场景下的设计时，我们再来看下用于回收线程存储待回收对象的WeakOrderQueue是如何设计的？</p>\n<blockquote>\n<p>注意：这里的回收线程，待回收对象这些概念是我们站在创建线程的视角提出的<strong>相对</strong>概念。</p>\n</blockquote>\n<p><img src=\"/assets/63f3b4b63fd14b7a84c33c0840bc41e2tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-7eix1tf.awebp\" alt=\"image.png\"></p>\n<p>大家一开始可能从WeakOrderQueue字面意思上以为它的结构是一个队列，但实际上从图中我们可以看出WeakOrderQueue的结构其实是一个链表结构。</p>\n<p>其中包含了链表的头结点 Head，以及链表尾结点指针 Tail。链表中的元素类型为 Link 类型。</p>\n<p>Link 类型中包含了一个 elements 数组，该数组用来存放回收线程收集的待回收对象。</p>\n<p>除此之外Link类型中还包含了readIndex用来指示当前elements数组中的读取位置。writeIndex用来指示elements数组的写入位置。elements数组中的容量默认为<code>16</code>​，也就是说一个Link节点最多可以存放16个待回收对象。当回收线程收集的待回收对象超过16个时，就会新创建一个Link节点插入到Link链表的尾部。</p>\n<p>当需要将WeakoOrderQueue节点中所存放的待回收对象回收转移至其对应的Stack结构中的数组栈中时，<strong>创建线程</strong>会遍历当前WeakOrderQueue节点中的Link链表，然后从链表的Head节点开始，将Head节点中包裹的Link链表头结点中存放的待回收对象回收至创建线程对应的Stack中。​<strong>一次最多转移一个Link大小的待回收对象</strong>​（16个）。</p>\n<p>当Link节点中的待回收对象全部转移至创建线程对应的Stack中时，会立马将这个Link节点从当前WeakOrderQueue节点中的Link链表里删除，随后Head节点向后移动指向下一个Link节点。</p>\n<blockquote>\n<p>head指针始终指向​<strong>第一个未被转移完毕的Link节点</strong>​，创建线程从head节点处读取转移待回收对象，回收线程从Tail节点处插入待回收对象。​<strong>这样转移操作和插入操作互不影响、没有同步的开销</strong>​。</p>\n</blockquote>\n<p>​<strong>注意这里会存在线程可见性的问题</strong>​，也就是说回收线程刚插入的待回收对象，在创建线程转移这些待回收对象时，创建线程可能会<strong>看不到</strong>由回收线程刚刚插入的待回收对象。</p>\n<p>​<strong>Netty这里为了不引入多线程同步的开销，只会保证待回收对象的最终可见性</strong>​。 因为如果要保证待回收对象的实时可见性，就要插入一些内存屏障指令，执行这些内存屏障指令也是需要开销的。</p>\n<p>事实上这里也并不需要保证实时可见性，创建线程暂时看不到WeakOrderQueue节点中的待回收对象也是没关系的，大不了就新创建一个对象。​<strong>这里还是遵循无锁化的设计思想</strong>​。</p>\n<blockquote>\n<p>维护线程之间操作的原子性，可见性都是需要开销的，我们在日常多线程程序设计中一定要根据业务场景来综合考虑，权衡取舍。尽量遵循我们这里多次强调的​<strong>多线程无锁化设计思想</strong>​。提高多线程的运行效率。避免引入不必要的同步开销。</p>\n</blockquote>\n<p>综合以上 Netty Recycler 对象池的设计原理，我们看到多线程从对象池中获取对象，以及多线程回收对象至对象池中，还有创建线程从WeakOrderQueue链表中转移待回收对象到对象池中。这些步骤均是无锁化进行的，没有同步竞争。</p>\n<p>在理解了对象池的基本设计原理后，下面就该介绍对象池在Netty中的源码实现环节了。</p>\n<h2 id=\"6-Recycler对象池的实现\">6. Recycler对象池的实现</h2>\n<p>在小节《4. 对象池Recycler的使用》中我们介绍了Recycler对象池的两个使用案例：</p>\n<ul>\n<li>一个是对象池在PooledDirectByteBuf类中的运用。</li>\n<li>另一个是对象池在Channel对应的写入缓冲队列ChannelOutboundBuffer中的运用。</li>\n</ul>\n<p>从这两个案例中，我们看到在设计池化对象时，都需要在池化对象内部持有一个对象池的静态引用从而可以与对象池进行交互，引用类型为 ObjectPool ，ObjectPool 是Netty对象池的顶层设计，其中定义了对象池的行为，以及各种顶层接口。</p>\n<p>在介绍对象池的整体实现之前，我们先来看下对象池的这个顶层接口设计。</p>\n<h3 id=\"6-1-对象池的顶层设计ObjectPool\">6.1 对象池的顶层设计ObjectPool</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ObjectPool</span>&lt;T&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    ObjectPool() &#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> T <span class=\"title function_\">get</span><span class=\"params\">()</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Handle</span>&lt;T&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">void</span> <span class=\"title function_\">recycle</span><span class=\"params\">(T self)</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">ObjectCreator</span>&lt;T&gt; &#123;</span><br><span class=\"line\">        T <span class=\"title function_\">newObject</span><span class=\"params\">(Handle&lt;T&gt; handle)</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ......................省略............</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们首先看到 ObjecPool 被设计成为一个泛型的抽象类，之所以使用泛型，是因为我们在创建对象池的时候需要指定对象池中被池化对象的类型。</p>\n<p>比如《4. 对象池Recycler的使用》小节中的这两个案例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Entry</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ObjectPool&lt;Entry&gt; RECYCLER</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">PooledDirectByteBuf</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">PooledByteBuf</span>&lt;ByteBuffer&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ObjectPool&lt;PooledDirectByteBuf&gt; RECYCLER</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>ObjecPool 定义了从对象池中获取对象的行为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> T <span class=\"title function_\">get</span><span class=\"params\">()</span>;</span><br></pre></td></tr></table></figure>\n<p>将池化对象回收至对象池中的行为被定义在 Handler 内部接口中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Handle</span>&lt;T&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">recycle</span><span class=\"params\">(T self)</span>;</span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n<p>Handler是池化对象在对象池中的一个模型，Handler里面包裹了池化对象，并包含了池化对象的一些回收信息，以及池化对象的回收状态。它的默认实现是DefaultHandle，后面我们会详细介绍。</p>\n<blockquote>\n<p>我们前边介绍到的Stack结构中的数组栈里边存放的就是DefaultHandle，以及WeakOrderQueue结构里的Link节点中的elements数组里存放的也是DefaultHandle。</p>\n</blockquote>\n<p>​<strong>那么为什么要将池化对象的回收行为recycle定义在Handler中，而不是ObejctPool中呢</strong>​？</p>\n<p>让我们站在业务线程的角度来看，其实业务线程处理的都是对象级别这个维度，并不需要感知到对象池的存在，使用完对象，直接调用对象的回收方法recycle将池化对象回收掉即可。</p>\n<p>在《4. 对象池Recycler的使用》小节我们介绍过池化对象的设计方法，其中我们提到池化对象中需要引用其在对象池中的Handler，这个Handler会在对象池创建对象的时候传入。池化对象类型中需要定义recycle方法，recycle方法清空池化对象的所有属性，并调用Handler的recycle方法将池化对象回收至对象池中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Entry</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">void</span> <span class=\"title function_\">recycle</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            next = <span class=\"literal\">null</span>;</span><br><span class=\"line\">            bufs = <span class=\"literal\">null</span>;</span><br><span class=\"line\">            buf = <span class=\"literal\">null</span>;</span><br><span class=\"line\">            msg = <span class=\"literal\">null</span>;</span><br><span class=\"line\">            promise = <span class=\"literal\">null</span>;</span><br><span class=\"line\">            progress = <span class=\"number\">0</span>;</span><br><span class=\"line\">            total = <span class=\"number\">0</span>;</span><br><span class=\"line\">            pendingSize = <span class=\"number\">0</span>;</span><br><span class=\"line\">            count = -<span class=\"number\">1</span>;</span><br><span class=\"line\">            cancelled = <span class=\"literal\">false</span>;</span><br><span class=\"line\">            handle.recycle(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>ObjectPool 还定义了对象池创建对象的行为接口：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">ObjectCreator</span>&lt;T&gt; &#123;</span><br><span class=\"line\">    T <span class=\"title function_\">newObject</span><span class=\"params\">(Handle&lt;T&gt; handle)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>用户在创建对象池的时候，需要通过<code>ObjectCreator#newObject</code>​方法指定对象池创建对象的行为。Handler对象正是通过这个接口传入池化对象中的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Entry</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ObjectPool&lt;Entry&gt; RECYCLER = ObjectPool.newPool(<span class=\"keyword\">new</span> <span class=\"title class_\">ObjectCreator</span>&lt;Entry&gt;() &#123;</span><br><span class=\"line\">          <span class=\"meta\">@Override</span></span><br><span class=\"line\">          <span class=\"keyword\">public</span> Entry <span class=\"title function_\">newObject</span><span class=\"params\">(Handle&lt;Entry&gt; handle)</span> &#123;</span><br><span class=\"line\">              <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Entry</span>(handle);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//Entry对象只能通过对象池获取，不可外部自行创建</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">Entry</span><span class=\"params\">(Handle&lt;Entry&gt; handle)</span> &#123;</span><br><span class=\"line\">          <span class=\"built_in\">this</span>.handle = handle;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"6-1-1-创建ObjectPool\">6.1.1 创建ObjectPool</h4>\n<p><img src=\"/assets/948ff8d7b81449269cbedf8928f28e59tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-2e3ivzs.awebp\" alt=\"image.png\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ObjectPool</span>&lt;T&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; ObjectPool&lt;T&gt; <span class=\"title function_\">newPool</span><span class=\"params\">(<span class=\"keyword\">final</span> ObjectCreator&lt;T&gt; creator)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RecyclerObjectPool</span>&lt;T&gt;(ObjectUtil.checkNotNull(creator, <span class=\"string\">&quot;creator&quot;</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RecyclerObjectPool</span>&lt;T&gt; <span class=\"keyword\">extends</span> <span class=\"title class_\">ObjectPool</span>&lt;T&gt; &#123;</span><br><span class=\"line\">        <span class=\"comment\">//recycler对象池实例</span></span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Recycler&lt;T&gt; recycler;</span><br><span class=\"line\"></span><br><span class=\"line\">        RecyclerObjectPool(<span class=\"keyword\">final</span> ObjectCreator&lt;T&gt; creator) &#123;</span><br><span class=\"line\">             recycler = <span class=\"keyword\">new</span> <span class=\"title class_\">Recycler</span>&lt;T&gt;() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"keyword\">protected</span> T <span class=\"title function_\">newObject</span><span class=\"params\">(Handle&lt;T&gt; handle)</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> creator.newObject(handle);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> T <span class=\"title function_\">get</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> recycler.get();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Recycler</span>&lt;T&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">abstract</span> T <span class=\"title function_\">newObject</span><span class=\"params\">(Handle&lt;T&gt; handle)</span>;</span><br><span class=\"line\">  </span><br><span class=\"line\">    ........................省略.............</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>调用 <code>ObjectPool#newPool</code>​ 创建对象池时，返回的是 RecyclerObjectPool 实例。而<strong>真正的对象池 Recycler</strong> 被包裹在 RecyclerObjectPool 中。</p>\n<p>对象池Recycler创建对象的行为定义在用户在创建对象池时指定的ObjectCreator 中。</p>\n<h2 id=\"7-Recycler对象池属性详解\">7. Recycler对象池属性详解</h2>\n<p>在介绍完对象池的顶层设计之后，接下来我们介绍下Recycler对象池相关的一些重要属性。相信大家在看过前边关于对象池设计原理的介绍之后，现在应该能够比较容易的理解即将介绍的这些属性概念，这里涉及到的属性比较多，笔者把这些属性的介绍放到源码实现之前的目的也是先让大家混个眼熟，先有一个感性的认识，等到介绍源码实现时，笔者还会将涉及到的属性再次拿出来介绍。</p>\n<p><img src=\"/assets/f469c168d72b40c6b23accd8ab652a22tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-t5puo5k.awebp\" alt=\"image.png\"></p>\n<h3 id=\"7-1-创建线程，回收线程的Id标识\">7.1 创建线程，回收线程的Id标识</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Recycler</span>&lt;T&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//用于产生池化对象中的回收Id,主要用来标识池化对象被哪个线程回收</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">AtomicInteger</span> <span class=\"variable\">ID_GENERATOR</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AtomicInteger</span>(Integer.MIN_VALUE);</span><br><span class=\"line\">    <span class=\"comment\">//用于标识创建池化对象的线程Id 注意这里是static final字段 也就意味着所有的创建线程OWN_THREAD_ID都是相同的</span></span><br><span class=\"line\">    <span class=\"comment\">//这里主要用来区分创建线程与非创建线程。多个非创建线程拥有各自不同的Id</span></span><br><span class=\"line\">    <span class=\"comment\">//这里的视角只是针对池化对象来说的：区分创建它的线程，与其他回收线程</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">OWN_THREAD_ID</span> <span class=\"operator\">=</span> ID_GENERATOR.getAndIncrement();</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>​<code>AtomicInteger ID_GENERATOR</code>​ :对象池中定义了一个 AtomicInteger 类型的Id生成器，主要用于为创建线程以及回收线程创建Id标识，<strong>目的是区分创建线程和回收线程。</strong></li>\n<li>​<code>int OWN_THREAD_ID</code>​：在 Recycler 类初始化的时候，会利用ID_GENERATOR 为 OWN_THREAD_ID 字段赋值，从字面意思上我们也可以看出 OWN_THREAD_ID 是用来标识创建线程Id的。这里有一点大家需要注意的是，OWN_THREAD_ID 是一个 static final 字段，这也就意味着所有的Recycler对象池实例中的 OWN_THREAD_ID 都是一样的。</li>\n</ul>\n<p>这里有的同学可能会有疑问了，在多线程从对象池中获取对象的场景中，创建线程会有很多个（比如下图中的thread1, thread2, thread3…），既然所有的Recycler 对象池实例中的 OWN_THREAD_ID 都是一样的，那么如何区分不同的创建线程呢？</p>\n<p><img src=\"/assets/34f2d54bc3724e51b0c8ad2695f7de95tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-2cym377.awebp\" alt=\"image.png\"></p>\n<p>​<strong>事实上在对象池中我们并不需要区分创建线程与创建线程之间的Id</strong>​，因为Netty在设计对象池的时候采用了无锁化设计，创建线程与创建线程之间并不需要交互，每个线程只需要关注自己线程内的对象管理工作即可，所以从一个线程的内部视角来看，只会有一个创建线程就是它自己本身，剩下的线程均是回收线程。​<strong>所以我们对象池的设计中只需要区分创建线程与回收线程就可以了</strong>​，当然每个回收线程的Id是不一样的。</p>\n<p>回收线程的Id是由其对应的 WeakOrderQueue 节点来分配的，一个 WeakOrderQueue 实例对应一个回收线程Id。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">WeakOrderQueue</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">WeakReference</span>&lt;Thread&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//回收线程回收Id,每个weakOrderQueue分配一个，同一个stack下的一个回收线程对应一个weakOrderQueue节点</span></span><br><span class=\"line\">   <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">id</span> <span class=\"operator\">=</span> ID_GENERATOR.getAndIncrement();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"7-2-对象池中的容量控制\">7.2 对象池中的容量控制</h3>\n<p><img src=\"/assets/233f28fc503e4dcc9c1e1317a89b71d9tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-vqp6dd1.awebp\" alt=\"image.png\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//对象池中每个线程对应的Stack中可以存储池化对象的默认初始最大个数 默认为4096个对象 </span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">DEFAULT_INITIAL_MAX_CAPACITY_PER_THREAD</span> <span class=\"operator\">=</span> <span class=\"number\">4</span> * <span class=\"number\">1024</span>; <span class=\"comment\">// Use 4k instances as default.</span></span><br><span class=\"line\"><span class=\"comment\">// 对象池中线程对应的Stack可以存储池化对象默认最大个数 4096</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> DEFAULT_MAX_CAPACITY_PER_THREAD;</span><br><span class=\"line\"><span class=\"comment\">// 初始容量 min(DEFAULT_MAX_CAPACITY_PER_THREAD, 256) 初始容量不超过256个</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> INITIAL_CAPACITY;</span><br></pre></td></tr></table></figure>\n<p>Recycler 对象池中定义了以上三个属性用于控制对象池中可以池化的对象容量。这些属性对应的初始化逻辑如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">maxCapacityPerThread</span> <span class=\"operator\">=</span> SystemPropertyUtil.getInt(<span class=\"string\">&quot;io.netty.recycler.maxCapacityPerThread&quot;</span>,</span><br><span class=\"line\">            SystemPropertyUtil.getInt(<span class=\"string\">&quot;io.netty.recycler.maxCapacity&quot;</span>, DEFAULT_INITIAL_MAX_CAPACITY_PER_THREAD));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (maxCapacityPerThread &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        maxCapacityPerThread = DEFAULT_INITIAL_MAX_CAPACITY_PER_THREAD;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    DEFAULT_MAX_CAPACITY_PER_THREAD = maxCapacityPerThread;</span><br><span class=\"line\"></span><br><span class=\"line\">    INITIAL_CAPACITY = min(DEFAULT_MAX_CAPACITY_PER_THREAD, <span class=\"number\">256</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>​<code>DEFAULT_INITIAL_MAX_CAPACITY_PER_THREAD</code>​：定义每个创建线程对应的Stack结构中的数组栈初始默认的最大容量。默认为4096个。可由JVM启动参数 <code>-D io.netty.recycler.maxCapacity</code>​ 指定。</li>\n<li>​<code>DEFAULT_MAX_CAPACITY_PER_THREAD</code>​：定义每个创建线程对应的Stack结构中的数组栈的最大容量。可由JVM启动参数 <code>-D io.netty.recycler.maxCapacityPerThread</code>​ 指定，如无特殊指定，即采用 DEFAULT_INITIAL_MAX_CAPACITY_PER_THREAD 的值，默认为4096个。</li>\n<li>​<code>INITIAL_CAPACITY </code>​: 定义每个创建线程对应的Stack结构中的数组栈的初始容量。计算公式为<code>min(DEFAULT_MAX_CAPACITY_PER_THREAD, 256)</code>​，默认为256个。当池化对象超过256个时，则对对象池进行扩容，但不能超过最大容量 DEFAULT_MAX_CAPACITY_PER_THREAD。</li>\n</ul>\n<h3 id=\"7-3-回收线程可回收对象的容量控制\">7.3 回收线程可回收对象的容量控制</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//用于计算回收线程可帮助回收的最大容量因子  默认为2  </span></span><br><span class=\"line\"> <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> MAX_SHARED_CAPACITY_FACTOR;</span><br><span class=\"line\"> <span class=\"comment\">//每个回收线程最多可以帮助多少个创建线程回收对象 默认：cpu核数 * 2</span></span><br><span class=\"line\"> <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> MAX_DELAYED_QUEUES_PER_THREAD;</span><br><span class=\"line\"> <span class=\"comment\">//回收线程对应的WeakOrderQueue节点中的Link链表中的节点存储待回收对象的容量 默认为16</span></span><br><span class=\"line\"> <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> LINK_CAPACITY;</span><br></pre></td></tr></table></figure>\n<p>Recycler 对象池除了对创建线程中的 Stack 容量进行限制外，还需要对回收线程可回收对象的容量进行限制。相关回收容量限制属性初始化逻辑如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    MAX_SHARED_CAPACITY_FACTOR = max(<span class=\"number\">2</span>,</span><br><span class=\"line\">            SystemPropertyUtil.getInt(<span class=\"string\">&quot;io.netty.recycler.maxSharedCapacityFactor&quot;</span>,</span><br><span class=\"line\">                    <span class=\"number\">2</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    MAX_DELAYED_QUEUES_PER_THREAD = max(<span class=\"number\">0</span>,</span><br><span class=\"line\">            SystemPropertyUtil.getInt(<span class=\"string\">&quot;io.netty.recycler.maxDelayedQueuesPerThread&quot;</span>,</span><br><span class=\"line\">                    <span class=\"comment\">// We use the same value as default EventLoop number</span></span><br><span class=\"line\">                    NettyRuntime.availableProcessors() * <span class=\"number\">2</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    LINK_CAPACITY = safeFindNextPositivePowerOfTwo(</span><br><span class=\"line\">            max(SystemPropertyUtil.getInt(<span class=\"string\">&quot;io.netty.recycler.linkCapacity&quot;</span>, <span class=\"number\">16</span>), <span class=\"number\">16</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>​<code>MAX_SHARED_CAPACITY_FACTOR</code>​ : 针对创建线程中的 Stack，其对应的所有回收线程总共可帮助其回收的对象总量计算因子。默认为2。可通过JVM参数 <code>-D io.netty.recycler.maxSharedCapacityFactor</code>​ 指定，总共回收对象总量就是通过对象池的最大容量和该计算因子计算出来的。计算公式： <code>max(maxCapacity / maxSharedCapacityFactor, LINK_CAPACITY)</code>​ 。由此我们可以知道创建线程对应的所有回收线程总共可帮助其回收的对象总量默认为2048个，最小回收容量为 LINK_CAPACITY  默认为16。</li>\n<li>​<code>MAX_DELAYED_QUEUES_PER_THREAD</code>​ : 该参数定义每个回收线程最多可帮助多少个创建线程回收对象。默认为：CPU核数 * 2。可通过JVM参数 <code>-D io.netty.recycler.maxDelayedQueuesPerThread</code>​ 指定。​<strong>注意：这里是站在回收线程的角度</strong>​。</li>\n<li>​<code>LINK_CAPACITY </code>​:  在创建线程对应的 Stack 结构中的 WeakOrderQueue 链表中，回收线程对应的WeakOrderQueue节点中的Link链表中的Link节点存储待回收对象的容量。默认为16，可通过JVM参数 <code>-D io.netty.recycler.linkCapacity</code>​ 指定。</li>\n</ul>\n<p>为了方便大家理解这些容量控制的相关参数，笔者又在对象池架构设计图的基础上补充了容量控制相关的信息。大家可以对照上边介绍到的这些参数的含义形象体会下：</p>\n<p><img src=\"/assets/d76e41420e1d44eb82e4b74dc7d4309btplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-e21hjq1.awebp\" alt=\"image.png\"></p>\n<h3 id=\"7-4-对象回收频率控制\">7.4 对象回收频率控制</h3>\n<p>对象池不能不考虑容量的限制而无脑的进行对象的回收，而是要对回收对象的频率进行限制。在我们日常架构设计和程序设计时，我们也一定要有托底的方案，比如限流，降级，熔断等托底方案。这样程序就不至于被突发的异常流量击垮。</p>\n<p>在对象池的设计中，Netty用以下两个参数来控制对象回收的频率从而避免对象池迅速膨胀不可控制。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//创建线程回收对象时的回收比例，默认是8，表示只回收1/8的对象。也就是产生8个对象回收一个对象到对象池中</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> RATIO;</span><br><span class=\"line\"><span class=\"comment\">//回收线程回收对象时的回收比例，默认也是8，同样也是为了避免回收线程回收队列疯狂增长 回收比例也是1/8</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> DELAYED_QUEUE_RATIO;</span><br></pre></td></tr></table></figure>\n<p>对象回收频率控制参数的初始化逻辑如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    RATIO = max(<span class=\"number\">0</span>, SystemPropertyUtil.getInt(<span class=\"string\">&quot;io.netty.recycler.ratio&quot;</span>, <span class=\"number\">8</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    DELAYED_QUEUE_RATIO = max(<span class=\"number\">0</span>, SystemPropertyUtil.getInt(<span class=\"string\">&quot;io.netty.recycler.delayedQueue.ratio&quot;</span>, RATIO));</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过前边对 Recycler 对象池的设计原理介绍，我们知道，在池化对象被回收的时候分别由两类线程来执行。</p>\n<ul>\n<li>一类是创建线程。池化对象在创建线程中被创建出来后，一直在创建线程中被处理，处理完毕后由创建线程直接进行回收。而为了避免对象池不可控制地迅速膨胀，所以需要对创建线程回收对象的频率进行限制。这个回收频率由参数 RATIO 控制，默认为8，可由JVM启动参数 <code>-D io.netty.recycler.ratio</code>​ 指定。表示创建线程只回收 1 / 8 的对象，也就是每创建 8 个对象最后只回收 1个对象。</li>\n<li>另一类就是回收线程。池化对象在创建线程中被创建出来，但是业务的相关处理是在回收线程中，业务处理完毕后由回收线程负责回收。前边提到对象回收有一个基本原则就是对象是谁创建的，就要回收到创建线程对应的Stack中。所以回收线程就需要将池化对象回收至其创建线程对应的Stack中的WeakOrderQueue链表中。并等待创建线程将WeakOrderQueue链表中的待回收对象<strong>转移</strong>至Stack中的数组栈中。同样，回收线程也需要控制回收频率，由参数 DELAYED_QUEUE_RATIO 进行控制，默认也是8，可由JVM启动参数 <code>-D io.netty.recycler.delayedQueue.ratio</code>​ 指定，表示回收线程每处理完 8 个对象才回收 1 个对象。</li>\n</ul>\n<h2 id=\"8-Recycler对象池的创建\">8. Recycler对象池的创建</h2>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RecyclerObjectPool</span>&lt;T&gt; <span class=\"keyword\">extends</span> <span class=\"title class_\">ObjectPool</span>&lt;T&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">//recycler对象池实例</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Recycler&lt;T&gt; recycler;</span><br><span class=\"line\"></span><br><span class=\"line\">    RecyclerObjectPool(<span class=\"keyword\">final</span> ObjectCreator&lt;T&gt; creator) &#123;</span><br><span class=\"line\">         recycler = <span class=\"keyword\">new</span> <span class=\"title class_\">Recycler</span>&lt;T&gt;() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">protected</span> T <span class=\"title function_\">newObject</span><span class=\"params\">(Handle&lt;T&gt; handle)</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> creator.newObject(handle);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ..................省略............</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>Netty 中的 Recycler 对象池是一个抽象类，里面封装了对象池的核心结构以及核心方法。在创建对象池的时候，我们往往会使用Recycler的匿名类来实现抽象方法 newObject 从而来定义对象池创建对象的行为。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Recycler</span>&lt;T&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">protected</span> <span class=\"keyword\">abstract</span> T <span class=\"title function_\">newObject</span><span class=\"params\">(Handle&lt;T&gt; handle)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">protected</span> <span class=\"title function_\">Recycler</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>(DEFAULT_MAX_CAPACITY_PER_THREAD);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"title function_\">Recycler</span><span class=\"params\">(<span class=\"type\">int</span> maxCapacityPerThread)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>(maxCapacityPerThread, MAX_SHARED_CAPACITY_FACTOR);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"title function_\">Recycler</span><span class=\"params\">(<span class=\"type\">int</span> maxCapacityPerThread, <span class=\"type\">int</span> maxSharedCapacityFactor)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>(maxCapacityPerThread, maxSharedCapacityFactor, RATIO, MAX_DELAYED_QUEUES_PER_THREAD);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"title function_\">Recycler</span><span class=\"params\">(<span class=\"type\">int</span> maxCapacityPerThread, <span class=\"type\">int</span> maxSharedCapacityFactor,</span></span><br><span class=\"line\"><span class=\"params\">                       <span class=\"type\">int</span> ratio, <span class=\"type\">int</span> maxDelayedQueuesPerThread)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>(maxCapacityPerThread, maxSharedCapacityFactor, ratio, maxDelayedQueuesPerThread,</span><br><span class=\"line\">                DELAYED_QUEUE_RATIO);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//创建线程持有对象池的最大容量</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> maxCapacityPerThread;</span><br><span class=\"line\">    <span class=\"comment\">//所有回收线程可回收对象的总量(计算因子)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> maxSharedCapacityFactor;</span><br><span class=\"line\">    <span class=\"comment\">//创建线程的回收比例</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> interval;</span><br><span class=\"line\">    <span class=\"comment\">//一个回收线程可帮助多少个创建线程回收对象</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> maxDelayedQueuesPerThread;</span><br><span class=\"line\">    <span class=\"comment\">//回收线程回收比例</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> delayedQueueInterval;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"title function_\">Recycler</span><span class=\"params\">(<span class=\"type\">int</span> maxCapacityPerThread, <span class=\"type\">int</span> maxSharedCapacityFactor,</span></span><br><span class=\"line\"><span class=\"params\">                       <span class=\"type\">int</span> ratio, <span class=\"type\">int</span> maxDelayedQueuesPerThread, <span class=\"type\">int</span> delayedQueueRatio)</span> &#123;</span><br><span class=\"line\">        interval = max(<span class=\"number\">0</span>, ratio);</span><br><span class=\"line\">        delayedQueueInterval = max(<span class=\"number\">0</span>, delayedQueueRatio);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (maxCapacityPerThread &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.maxCapacityPerThread = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.maxSharedCapacityFactor = <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.maxDelayedQueuesPerThread = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.maxCapacityPerThread = maxCapacityPerThread;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.maxSharedCapacityFactor = max(<span class=\"number\">1</span>, maxSharedCapacityFactor);</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.maxDelayedQueuesPerThread = max(<span class=\"number\">0</span>, maxDelayedQueuesPerThread);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>关于Recycler对象池中相关的重要属性我们在上一小节已经详细介绍过了，这里只是将这些重要参数赋值于Recycler对象池中定义的对应属性上。还是那句话，大家这里只需要对这些属性有一个感性的认识即可，并不需要强行完全理解，后面我们在介绍对象池的功能实现时还会结合具体场景来介绍这些属性。</p>\n<h2 id=\"9-多线程获取对象无锁化实现\">9. 多线程获取对象无锁化实现</h2>\n<p><img src=\"/assets/908c9b12522247dfbd32bada7308cb27tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-r7sakmv.awebp\" alt=\"image.png\"></p>\n<p>我们在介绍Netty对象池多线程获取对象的设计时提到，为了避免多线程并发获取对象时引入的同步开销，Netty采用了类似 TLAB 分配内存的思想，为每一个线程分配了一个独立的Stack结构，池化对象就存储在这个Stack结构中。当线程需要从对象池中获取对象时，Recycler就会从线程对应的Stakc结构中获取池化对象。各个线程独立运行，没有任何同步开销。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//threadlocal保存每个线程对应的 stack结构</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> FastThreadLocal&lt;Stack&lt;T&gt;&gt; threadLocal = <span class=\"keyword\">new</span> <span class=\"title class_\">FastThreadLocal</span>&lt;Stack&lt;T&gt;&gt;() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> Stack&lt;T&gt; <span class=\"title function_\">initialValue</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Stack</span>&lt;T&gt;(Recycler.<span class=\"built_in\">this</span>, Thread.currentThread(), maxCapacityPerThread, maxSharedCapacityFactor,</span><br><span class=\"line\">                interval, maxDelayedQueuesPerThread, delayedQueueInterval);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">    ..............省略..........</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>对象池中采用一个 FastThreadLocal 类型的字段 threadLocal 为每个线程维护一个独立的Stack结构。从而达到多线程无锁化获取对象的目的。</p>\n<blockquote>\n<p>FastThreadLocal是Netty基于JDK的ThreadLocal做的一个优化版本，拥有更快的访问性能。详细实现笔者后面会有一篇专门讲解FastThreadLocal的文章，这里大家只需要把它当成JDK的ThreadLocal来看待即可。</p>\n</blockquote>\n<p>当线程第一次从对象池中获取对象时会触发其对应的Stack结构的创建。</p>\n<h3 id=\"9-1-Stack结构的创建\">9.1 Stack结构的创建</h3>\n<p>本小节我们来介绍一下对象池中Stack结构的设计实现。在前边《5.2 Stack的设计》小节中我们介绍了Stack结构中的一些核心属性，包括：数组栈以及WeakOrderQueue链表的Head指针，Prev指针，Cursor指针。</p>\n<p>本小节笔者会把Stack结构中的剩余属性介绍给大家，通过这一小节的介绍，相信大家就会对Stack的设计实现有了一个整体的了解。还是那句话，这里大家只需要对这些属性有一个感性的认识，先混个眼熟，后面笔者还会结合具体场景详细讲解。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Stack</span>&lt;T&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 创建线程保存池化对象的stack结构所属对象池recycler实例</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> Recycler&lt;T&gt; parent;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//用弱引用来关联当前stack对应的创建线程 因为用户可能在某个地方引用了defaultHandler -&gt; stack -&gt; thread，可能存在这个引用链</span></span><br><span class=\"line\">        <span class=\"comment\">//当创建线程死掉之后 可能因为这个引用链的存在而导致thread无法被回收掉</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> WeakReference&lt;Thread&gt; threadRef;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//所有回收线程能够帮助当前创建线程回收对象的总容量</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> AtomicInteger availableSharedCapacity;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//当前Stack对应的创建线程作为其他创建线程的回收线程时可以帮助多少个线程回收其池化对象</span></span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> maxDelayedQueues;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//当前创建线程对应的stack结构中的最大容量。 默认4096个对象</span></span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> maxCapacity;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//当前创建线程回收对象时的回收比例</span></span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> interval;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//当前创建线程作为其他线程的回收线程时回收其他线程的池化对象比例</span></span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> delayedQueueInterval;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 当前Stack中的数组栈 默认初始容量256，最大容量为4096</span></span><br><span class=\"line\">        DefaultHandle&lt;?&gt;[] elements;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//数组栈 栈顶指针</span></span><br><span class=\"line\">        <span class=\"type\">int</span> size;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//回收对象计数 与 interval配合 实现只回收一定比例的池化对象</span></span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"type\">int</span> handleRecycleCount;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//多线程回收的设计，核心还是无锁化，避免多线程回收相互竞争</span></span><br><span class=\"line\">        <span class=\"comment\">//Stack结构中的WeakOrderQueue链表</span></span><br><span class=\"line\">        <span class=\"keyword\">private</span> WeakOrderQueue cursor, prev;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> WeakOrderQueue head;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/assets/ad0a175194af489d9c71f096ac430a03tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-4g64cdf.awebp\" alt=\"image.png\"></p>\n<ul>\n<li>​<code>Recycler&lt;T&gt; parent</code>​：Stack所属Recycler对象池实例，一个对象池可被多个线程访问获取对象，所以一个对象池对应多个Stack，每个Stack的parent属性指向所属的Recycler实例。比如图中的 stack1 , stack2 , stack3 , stack4 中的parent属性均指向同一个Recycler对象池实例。</li>\n<li>​<code>WeakReference&lt;Thread&gt; threadRef </code>​：Stack会通过弱引用的方式引用到其对应的创建线程。这里使用弱引用来持有对应创建线程的原因是因为对象池的设计中存在这样一个引用关系：<code>池化对象 -&gt; DefaultHandler -&gt; stack -&gt; threadRef</code>​。而池化对象是暴露给用户的，如果用户在某个地方持有了池化对象的强引用忘记清理，而Stack持有创建线程的强引用的话，当创建线程死掉的之后，因为这样一个强引用链的存在从而导致创建线程一直不能被GC回收。</li>\n<li>​<code>AtomicInteger availableSharedCapacity</code>​：当前创建线程对应的所有回收线程可以帮助当前创建线程回收的对象总量。比如图中thread2 , thread3 , thread4 这三个回收线程总共可以帮助 thread1 回收对象的总量。availableSharedCapacity 在多个回收线程中是​<strong>共享的</strong>​，回收线程每回收一个对象它的值就会减1，当小于 LINK_CAPACITY(回收线程对应WeakOrderQueue节点的最小存储单元Link)时，回收线程将不能在为该stack回收对象了。该值的计算公式为前边介绍的 <code>max(maxCapacity / maxSharedCapacityFactor, LINK_CAPACITY)</code>​。</li>\n</ul>\n<blockquote>\n<p>当创建线程从Stack结构中的WeakOrderQueue链表中转移待回收对象到数组栈中后，availableSharedCapacity 的值也会相应增加。说白了这个值就是用来指示回收线程还能继续回收多少对象。已达到控制回收线程回收对象的总体容量。</p>\n</blockquote>\n<ul>\n<li>​<code>int maxDelayedQueues</code>​： 一个线程对于对象池来说，它可以是创建线程，也可以是回收线程，当该创建线程作为回收线程时，该值定义了最多可以为多少个创建线程回收对象。默认值为 CPU * 2。比如图中 thread2 作为回收线程既可以帮 thread1 回收对象也可以帮助 thread3 , thread4 回收对象。那么maxDelayedQueues 的值就是 3 。</li>\n<li>​<code>int maxCapacity</code>​：定义当前Stack结构中的数组栈的最大容量。默认为4096。</li>\n<li>​<code>int interval</code>​：创建线程的回收比例，默认是8。</li>\n<li>​<code>int delayedQueueInterval</code>​：创建线程作为回收线程时的回收比例。默认是8。</li>\n<li>​<code>DefaultHandle&lt;?&gt;[] elements</code>​：这个就是我们前边反复提到的Stack结构中的数组栈。用于存放对象池中的池化对象。当线程从对象池中获取对象时就是从这里获取。</li>\n<li>​<code>int size</code>​：数组栈中的栈顶指针。</li>\n<li>​<code>int handleRecycleCount</code>​：回收对象计数。与 interval 配合达到控制回收对象比例的目的。从 0 开始每遇到一个回收对象就 +1 ，同时把对象丢弃。直到<code>handleRecycleCount == interval</code>​时回收对象，然后归零。也就是前边我们说到的每创建8个对象才回收1个。避免 Stack 不可控制的迅速增长。</li>\n<li>​<code>WeakOrderQueue cursor, prev，head</code>​：这三个指针就是前边我们在讲Stack设计的时候介绍到的用于<strong>多线程无锁化回收</strong>的 WeakOrderQueue 链表中的头结点指针，当前节点指针，前一个节点指针（用于删除节点）。</li>\n</ul>\n<p>介绍完Stack结构中的这些重要属性，创建的过程就很简单了。就是利用前边介绍过的已经初始化好的Recycler属性对Stack结构中的这些属性进行赋值。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> FastThreadLocal&lt;Stack&lt;T&gt;&gt; threadLocal = <span class=\"keyword\">new</span> <span class=\"title class_\">FastThreadLocal</span>&lt;Stack&lt;T&gt;&gt;() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> Stack&lt;T&gt; <span class=\"title function_\">initialValue</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Stack</span>&lt;T&gt;(Recycler.<span class=\"built_in\">this</span>, Thread.currentThread(), maxCapacityPerThread, maxSharedCapacityFactor,</span><br><span class=\"line\">                interval, maxDelayedQueuesPerThread, delayedQueueInterval);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  ..............省略............</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Stack(Recycler&lt;T&gt; parent, Thread thread, <span class=\"type\">int</span> maxCapacity, <span class=\"type\">int</span> maxSharedCapacityFactor,</span><br><span class=\"line\">       <span class=\"type\">int</span> interval, <span class=\"type\">int</span> maxDelayedQueues, <span class=\"type\">int</span> delayedQueueInterval) &#123;</span><br><span class=\"line\">     <span class=\"built_in\">this</span>.parent = parent;</span><br><span class=\"line\">     threadRef = <span class=\"keyword\">new</span> <span class=\"title class_\">WeakReference</span>&lt;Thread&gt;(thread);</span><br><span class=\"line\">     <span class=\"built_in\">this</span>.maxCapacity = maxCapacity;</span><br><span class=\"line\">     availableSharedCapacity = <span class=\"keyword\">new</span> <span class=\"title class_\">AtomicInteger</span>(max(maxCapacity / maxSharedCapacityFactor, LINK_CAPACITY));</span><br><span class=\"line\">     elements = <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultHandle</span>[min(INITIAL_CAPACITY, maxCapacity)];</span><br><span class=\"line\">     <span class=\"built_in\">this</span>.interval = interval;</span><br><span class=\"line\">     <span class=\"built_in\">this</span>.delayedQueueInterval = delayedQueueInterval;</span><br><span class=\"line\">     handleRecycleCount = interval; </span><br><span class=\"line\">     <span class=\"built_in\">this</span>.maxDelayedQueues = maxDelayedQueues;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"9-2-从对象池中获取对象\">9.2 从对象池中获取对象</h3>\n<p><img src=\"/assets/002bdbd0d71140c3834d44b93555237ftplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-ryqzvpj.awebp\" alt=\"image.png\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Recycler</span>&lt;T&gt; &#123;</span><br><span class=\"line\">      <span class=\"comment\">//一个空的Handler,表示该对象不会被池化</span></span><br><span class=\"line\">     <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Handle</span> <span class=\"variable\">NOOP_HANDLE</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Handle</span>() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">recycle</span><span class=\"params\">(Object object)</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// NOOP</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> T <span class=\"title function_\">get</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//如果对象池容量为0，则立马新创建一个对象返回，但是该对象不会回收进对象池</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (maxCapacityPerThread == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> newObject((Handle&lt;T&gt;) NOOP_HANDLE);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//获取当前线程 保存池化对象的stack</span></span><br><span class=\"line\">        Stack&lt;T&gt; stack = threadLocal.get();</span><br><span class=\"line\">        <span class=\"comment\">//从stack中pop出对象，handler是池化对象在对象池中的模型，包装了一些池化对象的回收信息和回收状态</span></span><br><span class=\"line\">        DefaultHandle&lt;T&gt; handle = stack.pop();</span><br><span class=\"line\">        <span class=\"comment\">//如果当前线程的stack中没有池化对象 则直接创建对象</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (handle == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//初始化的handler对象recycleId和lastRecyclerId均为0</span></span><br><span class=\"line\">            handle = stack.newHandle();</span><br><span class=\"line\">            <span class=\"comment\">//newObject为对象池recycler的抽象方法，由使用者初始化内存池的时候 匿名提供</span></span><br><span class=\"line\">            handle.value = newObject(handle);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (T) handle.value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Recycler对外表现为一个整体的对象池，但是对象池内部是按照线程的维度来池化对象的，每个线程所池化的对象保存在对应的Stack结构中。</p>\n<ol>\n<li>当对象池的最大容量<code>maxCapacityPerThread == 0</code>​时，对象池会立马创建一个对象出来，并将一个空的Handler传递进对象中。表示该对象在使用完毕后不会被回收进对象池中。</li>\n<li>从threadLocal中获取当前线程对应的Stack，随后从Stack结构中的数组栈中弹出栈顶对象的DefaultHandler。</li>\n<li>如果弹出的DefaultHandler为空，说明当前Stack中并没有回收的池化对象。直接创建一个新的DefaultHandler并创建一个新的对象，然后将DefaultHandler传入到新创建的对象中，并用DefaultHandler包裹新创建的对象。这样池化对象就与DefaultHandler关联起来了。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Entry</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ObjectPool&lt;Entry&gt; RECYCLER = ObjectPool.newPool(<span class=\"keyword\">new</span> <span class=\"title class_\">ObjectCreator</span>&lt;Entry&gt;() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> Entry <span class=\"title function_\">newObject</span><span class=\"params\">(Handle&lt;Entry&gt; handle)</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Entry</span>(handle);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"keyword\">private</span> <span class=\"title function_\">Entry</span><span class=\"params\">(Handle&lt;Entry&gt; handle)</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.handle = handle;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"9-3-DefaultHandler\">9.3 DefaultHandler</h3>\n<p>前边我们在介绍对象池的设计原理时提到，池化对象在对象池中的存储模型为 Handler。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ObjectPool</span>&lt;T&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Handle</span>&lt;T&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">void</span> <span class=\"title function_\">recycle</span><span class=\"params\">(T self)</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在Recycler对象池中的默认实现是 DefaultHandler ，DefaultHandler 里面包裹了池化对象以及池化对象在对象池中的一些相关信息，（比如：池化对象的相关回收信息和回收状态）。</p>\n<p>从结构设计角度上来说，池化对象是隶属于其创建线程对应的Stack结构的，由于这层结构关系的存在，池化对象的DefaultHandler应该由Stack来进行创建。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Stack</span>&lt;T&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">       DefaultHandle&lt;T&gt; <span class=\"title function_\">newHandle</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">           <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultHandle</span>&lt;T&gt;(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们来看下 DefaultHandler 的具体结构：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DefaultHandle</span>&lt;T&gt; <span class=\"keyword\">implements</span> <span class=\"title class_\">Handle</span>&lt;T&gt; &#123;</span><br><span class=\"line\">     <span class=\"comment\">//用于标识最近被哪个线程回收，被回收之前均是0</span></span><br><span class=\"line\">     <span class=\"type\">int</span> lastRecycledId;</span><br><span class=\"line\">     <span class=\"comment\">//用于标识最终被哪个线程回收，在没被回收前是0</span></span><br><span class=\"line\">     <span class=\"type\">int</span> recycleId;</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"comment\">//是否已经被回收</span></span><br><span class=\"line\">     <span class=\"type\">boolean</span> hasBeenRecycled;</span><br><span class=\"line\">     <span class=\"comment\">//强引用关联创建handler的stack</span></span><br><span class=\"line\">     Stack&lt;?&gt; stack;</span><br><span class=\"line\">     <span class=\"comment\">//池化对象</span></span><br><span class=\"line\">     Object value;</span><br><span class=\"line\"></span><br><span class=\"line\">     DefaultHandle(Stack&lt;?&gt; stack) &#123;</span><br><span class=\"line\">         <span class=\"built_in\">this</span>.stack = stack;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"meta\">@Override</span></span><br><span class=\"line\">     <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">recycle</span><span class=\"params\">(Object object)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">       ...................省略.............</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>DefaultHandler属性的第一部分信息，首先就是池化对象在对象池中的回收信息。</p>\n<ul>\n<li>​<code>int lastRecycledId</code>​：用于标识最近被哪个线程回收，被回收之前均是0。</li>\n<li>​<code>int recycleId</code>​：用于标识最终被哪个线程回收，在没被回收前是0。</li>\n<li>​<code>boolean hasBeenRecycled</code>​：该池化对象是否已经被回收至创建线程对应的Stack中。</li>\n</ul>\n<p>​<strong>这里可能大家有疑问了，为什么池化对象的回收还要分最近回收和最终回收呢</strong>​？</p>\n<p>因为对象池中的池化对象回收可以分为两种情况：</p>\n<ul>\n<li>​<code>由创建线程直接进行回收</code>​：这种回收情况就是一步到位，直接回收至创建线程对应的Stack中。所以这种情况下是不分阶段的。<code>recycleId = lastRecycledId = OWN_THREAD_ID</code>​。</li>\n<li>​<code>由回收线程帮助回收</code>​：这种回收情况下就要分步进行了，首先由回收线程将池化对象<strong>暂时存储</strong>在其创建线程对应Stack中的WeakOrderQueue链表中。此时并没有完成真正的对象回收。<code>recycleId = 0，lastRecycledId = 回收线程Id（WeakOrderQueue#id）</code>​。当创建线程将WeakOrderQueue链表中的待回收对象转移至Stack结构中的数组栈之后，这时池化对象才算真正完成了回收动作。<code>recycleId = lastRecycledId = 回收线程Id（WeakOrderQueue#id）</code>​。</li>\n</ul>\n<p>这两个字段 lastRecycledId ，recycleId 主要是用来标记池化对象所处的回收阶段，以及在这些回收阶段具体被哪个线程进行回收。</p>\n<p>最后两个属性就比较容易理解了，一个是 Object value 用来包裹真正的池化对象。另一个是 Stack&lt;?&gt; stack 用来强引用关联池化对象的Handler所属的Stack结构。</p>\n<p>记不记得我们在介绍Stack结构的时候提到，Stack中持有其对应创建线程的<code>弱引用</code>​。笔者在解释为什么持有创建线程的弱引用时，提到过这样一个引用链关系：<code>池化对象 -&gt; DefaultHandler -&gt; Stack -&gt; threadRef</code>​。这里大家明白了吗？</p>\n<p><img src=\"/assets/d9a984a0659546258734112ce5c687f7tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-qzq41qp.awebp\" alt=\"image.png\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Entry</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//池化对象Entry强引用它的DefaultHandler</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span>  Handle&lt;Entry&gt; handle;</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DefaultHandle</span>&lt;T&gt; <span class=\"keyword\">implements</span> <span class=\"title class_\">Handle</span>&lt;T&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// DefaultHandler强引用其所属的Stack</span></span><br><span class=\"line\">    Stack&lt;?&gt; stack;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Stack</span>&lt;T&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Stack弱引用其对应的创建线程</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> WeakReference&lt;Thread&gt; threadRef;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"9-4-从Stack中获取池化对象\">9.4 从Stack中获取池化对象</h3>\n<p><img src=\"/assets/6d2a0769269e405dac3519f9e45d14d7tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-hfn0g3i.awebp\" alt=\"image.png\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DefaultHandle&lt;T&gt; <span class=\"title function_\">pop</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//普通出栈操作，从栈顶弹出一个回收对象</span></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">size</span> <span class=\"operator\">=</span> <span class=\"built_in\">this</span>.size;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (size == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//如果当前线程所属stack已经没有对象可用，则遍历stack中的weakOrderQueue链表（其他线程帮助回收的对象存放在这里）将这些待回收对象回收进stack</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!scavenge()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        size = <span class=\"built_in\">this</span>.size;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (size &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果WeakOrderQueue链表中也没有待回收对象可转移</span></span><br><span class=\"line\">            <span class=\"comment\">// 直接返回null 新创建一个对象</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    size --;</span><br><span class=\"line\">    <span class=\"type\">DefaultHandle</span> <span class=\"variable\">ret</span> <span class=\"operator\">=</span> elements[size];</span><br><span class=\"line\">    elements[size] = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.size = size;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ret.lastRecycledId != ret.recycleId) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 这种情况表示对象至少被一个线程回收了，要么是创建线程，要么是回收线程</span></span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalStateException</span>(<span class=\"string\">&quot;recycled multiple times&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//对象初次创建以及回收对象再次使用时  它的 recycleId = lastRecycleId = 0</span></span><br><span class=\"line\">    ret.recycleId = <span class=\"number\">0</span>;</span><br><span class=\"line\">    ret.lastRecycledId = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里就是业务线程从对象池中真正获取池化对象的地方。从Stack结构中的数组栈的栈顶位置弹出池化对象。</p>\n<ul>\n<li>首先判断数组栈中是否有回收的池化对象。栈顶指针 size == 0 说明当前数组栈中是空的。随后就会调用 scavenge 方法，从Stack结构中的WeakOrderQueue链表中转移最多一个Link大小的待回收对象到数组栈中。如果WeakOrderQueue链表中也没有待回收对象，说明当前Stack结构就是空的没有任何回收的池化对象，对象池直接返回 null ，并创建一个新的池化对象返回给业务线程。</li>\n<li>如果数组栈不为空，则将栈顶元素 DefaultHandler 弹出，初始化池化对象DefaultHandler的回收信息。<code>recycleId  = lastRecycledId = 0</code>​表示该池化对象刚刚从对象池中取出。</li>\n</ul>\n<p>recycleId 与 lastRecycledId 之间的关系分为以下几种情况：</p>\n<ul>\n<li>​<code>recycleId  = lastRecycledId = 0</code>​：表示池化对象刚刚被创建或者刚刚从对象池中取出即将被再次复用。这是池化对象的初始状态。</li>\n<li>​<code>recycleId  = lastRecycledId != 0</code>​：表示当前池化对象已经被回收至对应Stack结构里的数组栈中。可以直接被取出复用。可能是被其创建线程直接回收，也可能是被回收线程回收。</li>\n<li>​<code>recycleId  != lastRecycledId</code>​：表示当前池化对象处于半回收状态。池化对象已经被业务线程处理完毕，并被回收线程回收至对应的WeakOrderQueue节点中。并等待创建线程将其最终转移至Stack结构中的数组栈中。</li>\n</ul>\n<h3 id=\"9-4-转移回收线程回收的对象到Stack中\">9.4 转移回收线程回收的对象到Stack中</h3>\n<p><img src=\"/assets/29c7d6a21d76455d9bc5443394172a2btplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-jhifgqp.awebp\" alt=\"image.png\"></p>\n<p>通过前边介绍Stack结构的设计原理我们知道，对象池中池化对象的回收存储分为两个部分：</p>\n<ul>\n<li>一个是池化对象直接被创建线程回收，直接存储在创建线程对应Stack结构中的数组栈中。</li>\n<li>另一个是池化对象被回收线程回收，临时间接存储在创建线程对应Stack结构中的WeakOrderQueue链表中。每个回收线程对应一个WeakOrderQueue节点。</li>\n</ul>\n<p>当Stack结构中的数组栈为空时，创建线程会遍历WeakOrderQueue链表，从而将回收线程为其回收的对象从WeakOrderQueue节点中转移至数组栈中。<strong>多线程回收对象无锁化设计</strong></p>\n<p>这个转移的动作就是由 scavenge 方法来完成的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"type\">boolean</span> <span class=\"title function_\">scavenge</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">     <span class=\"comment\">//从其他线程回收的weakOrderQueue里 转移 待回收对像 到当前线程的stack中</span></span><br><span class=\"line\">     <span class=\"keyword\">if</span> (scavengeSome()) &#123;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"comment\">// 如果weakOrderQueue中没有待回收对象可转移，那么就重置stack中的cursor.prev</span></span><br><span class=\"line\">     <span class=\"comment\">// 因为在扫描weakOrderQueue链表的过程中，cursor已经发生变化了</span></span><br><span class=\"line\">     prev = <span class=\"literal\">null</span>;</span><br><span class=\"line\">     cursor = head;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>scavengeSome() 执行具体的转移逻辑。如果WeakOrderQueue链表中还有待回收对象并转移成功则返回 true 。如果WeakOrderQueue链表为空没有任何待回收对象可转移，则重置链表相关的指针，cursor重新指向head节点，prev指向null。因为在遍历WeakOrderQueue链表搜寻可转移对象时，cursor指针已经发生变化了，这里需要重置。</p>\n<h3 id=\"9-5-转移回收对象\">9.5 转移回收对象</h3>\n<p>下面创建线程就开始遍历Stack结构中的WeakOrderQueue链表，将其中存储的回收线程回收进来的对象转移到数组栈中。</p>\n<p>为了让大家更清晰的理解遍历WeakOrderQueue链表的过程，我们先来了解下Stack中WeakOrderQueue链表的状态结构如下图所示：</p>\n<p><img src=\"/assets/c7d327afbf054012bd98bb554bfd19a3tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-kxpsqug.awebp\" alt=\"image.png\"></p>\n<p>在Stack结构刚刚创建的初始状态，WeakOrderQueue链表是空的，所以 prev = head = cursor = null 。</p>\n<p>后面当回收线程在回收对象时会加入自己对应的WeakOrderQueue节点到链表中。​<strong>注意：WeakOrderQueue节点的插入都是在链表的头结点进行插入</strong>​。</p>\n<blockquote>\n<p>后面我们在讲到多线程回收对象时还会再次详细讲解WeakOrderQueue链表的操作，这里大家只需要先理解链表的状态结构即可。</p>\n</blockquote>\n<p>head指针始终指向链表的头结点，cursor指针指向当前遍历的节点。在没有开始遍历链表前，cursor指针指向头结点。表示从头结点开始遍历。prev指针指向cursor前一个节点。当前遍历节点为头结点时，prev指针指向空。</p>\n<p>在理解了WeakOrderQueue链表的状态结构后，我们来看一下链表的遍历转移过程逻辑：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"type\">boolean</span> <span class=\"title function_\">scavengeSome</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    WeakOrderQueue prev;</span><br><span class=\"line\">    <span class=\"comment\">//获取当前线程stack 的weakOrderQueue链表指针（本次扫描起始节点）</span></span><br><span class=\"line\">    <span class=\"type\">WeakOrderQueue</span> <span class=\"variable\">cursor</span> <span class=\"operator\">=</span> <span class=\"built_in\">this</span>.cursor;</span><br><span class=\"line\">    <span class=\"comment\">//在stack初始化完成后，cursor，prev,head等指针全部是null，这里如果cursor == null 意味着当前stack第一次开始扫描weakOrderQueue链表</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cursor == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        prev = <span class=\"literal\">null</span>;</span><br><span class=\"line\">        cursor = head;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cursor == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//说明目前weakOrderQueue链表里还没有节点，并没有其他线程帮助回收的池化对象</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//获取prev指针，用于操作链表（删除当前cursor节点）</span></span><br><span class=\"line\">        prev = <span class=\"built_in\">this</span>.prev;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"variable\">success</span> <span class=\"operator\">=</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"comment\">//循环遍历weakOrderQueue链表 转移待回收对象</span></span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//将weakOrderQueue链表中当前节点中包含的待回收对象，转移到当前stack中，一次转移一个link</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cursor.transfer(<span class=\"built_in\">this</span>)) &#123;</span><br><span class=\"line\">            success = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//如果当前cursor节点没有待回收对象可转移，那么就继续遍历链表获取下一个weakOrderQueue节点</span></span><br><span class=\"line\">        <span class=\"type\">WeakOrderQueue</span> <span class=\"variable\">next</span> <span class=\"operator\">=</span> cursor.getNext();</span><br><span class=\"line\">        <span class=\"comment\">//如果当前weakOrderQueue对应的回收线程已经挂掉了，则</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cursor.get() == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 判断当前weakOrderQueue节点是否还有可回收对象</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cursor.hasFinalData()) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//回收weakOrderQueue中最后一点可回收对象，因为对应的回收线程已经死掉了，这个weakOrderQueue不会再有任何对象了</span></span><br><span class=\"line\">                <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (cursor.transfer(<span class=\"built_in\">this</span>)) &#123;</span><br><span class=\"line\">                        success = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//回收线程以死，对应的weaoOrderQueue节点中的最后一点待回收对象也已经回收完毕，就需要将当前节点从链表中删除。unlink当前cursor节点</span></span><br><span class=\"line\">            <span class=\"comment\">//这里需要注意的是，netty永远不会删除第一个节点，因为更新头结点是一个同步方法，避免更新头结点而导致的竞争开销</span></span><br><span class=\"line\">            <span class=\"comment\">// prev == null 说明当前cursor节点是头结点。不用unlink，如果不是头结点 就将其从链表中删除，因为这个节点不会再有线程来收集池化对象了</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (prev != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//确保当前weakOrderQueue节点在被GC之前，我们已经回收掉它所有的占用空间</span></span><br><span class=\"line\">                cursor.reclaimAllSpaceAndUnlink();</span><br><span class=\"line\">                <span class=\"comment\">//利用prev指针删除cursor节点</span></span><br><span class=\"line\">                prev.setNext(next);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            prev = cursor;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//向后移动prev,cursor指针继续遍历weakOrderQueue链表</span></span><br><span class=\"line\">        cursor = next;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> (cursor != <span class=\"literal\">null</span> &amp;&amp; !success);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.prev = prev;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.cursor = cursor;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> success;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>再开始遍历WeakOrderQueue链表之前，首先需要检查cursor指针是否为空，如果为空说明当前Stack是第一次开始遍历WeakOrderQueue链表。随后让cursor指针指向head指针，如果head指针指向为空，说明当前WeakOrderQueue链表是空的，此时没有任何回收线程在回收对象。如果head指针不为空，则从head指针指向的头结点开始遍历WeakOrderQueue链表。</li>\n<li>首先会从cursor指针指向的当前遍历节点开始，将当前WeakOrderQueue节点中存储的待回收对象转移到Stack结构中的数组栈中。一次最多转移一个Link大小的对象。转移成功后退出。如果当前WeakOrderQueue节点此时没有任何待回收对象可被转移则转移失败，继续遍历下一个WeakOrderQueue节点。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (cursor.transfer(<span class=\"built_in\">this</span>)) &#123;</span><br><span class=\"line\">    success = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">WeakOrderQueue</span> <span class=\"variable\">next</span> <span class=\"operator\">=</span> cursor.getNext();</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>为了多线程能够无锁化回收对象，一个回收线程对应一个WeakOrderQueue节点，在WeakOrderQueue节点中持有对应回收线程的<code>弱引用</code>​,目的也是为了当回收线程挂掉的时候，能够保证回收线程被GC及时的回收掉。如果<code>cursor.get() == null</code>​说明当前WeakOrderQueue节点对应的回收线程已经挂掉了，此时如果当前节点还有待回收对象，则需要将节点中的所有待回收对象全部转移至Stack中的数组栈中。​<strong>注意这里是转移节点所有的待回收对象而不是只转移一个Link</strong>​。因为对应的回收线程已经挂掉了，该线程后续将不再会帮助创建线程回收对象了，所以要清理其对应的WeakOrderQueue节点。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">WeakOrderQueue</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">WeakReference</span>&lt;Thread&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    ............WeakOrderQueue本身就是一个弱引用，引用对应的回收线程.........</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>当清理完已经挂掉的回收线程对应的WeakOrderQueue节点后，就需要将该节点从Stack结构里的WeakOrderQueue链表中删除。保证被清理后的WeakOrderQueue节点可以被GC回收。当然删除节点之前需要通过<code>cursor.reclaimAllSpaceAndUnlink()</code>​释放回收线程回收对象的availableSharedCapacity容量。释放的容量的大小为被删除WeakOrderQueue节点中存储的待回收对象容量。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (prev != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      cursor.reclaimAllSpaceAndUnlink();</span><br><span class=\"line\">      <span class=\"comment\">//利用prev指针删除cursor节点</span></span><br><span class=\"line\">      prev.setNext(next);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>这里需要注意的是，Netty不会对WeakOrderQueue链表的头结点进行删除。如果<code>prev == null</code>​说明当前节点是头结点，即使对应的回收线程已经挂掉了，但在本次遍历中不会对其进行删除。因为操作链表头结点的方法是一个同步方法，Netty这里是为了避免不必要的同步开销。</p>\n</blockquote>\n<p>以上逻辑就是创建线程遍历WeakOrderQueue链表转移回收对象的处理逻辑，如果本次遍历的当前节点中并没有对象可转移，那么就继续从下一个节点开始遍历。循环执行转移逻辑直到遍历完链表或者中途转移成功。退出循环时要记录更新cursor指针记录当前遍历到的节点。</p>\n<p>这里大家可能会有两个问题：</p>\n<p>​<strong>第一个问题：如果头结点对应的回收线程已经挂掉，这个头结点不在本次遍历中删除，那么会在什么时候被删除呢</strong>​？</p>\n<p><img src=\"/assets/359cbfb6d68e450b8f611a9975099c6etplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-ol5zynd.awebp\" alt=\"image.png\"></p>\n<p>首先当回收线程第一次开始帮助创建线程回收对象时，会将自己对应的WeakOrderQueue节点插入到创建线程对应Stack结构中的WeakOrderQueue链表的头结点位置。​<strong>节点始终在链表的头结点位置插入</strong>​。</p>\n<p>如图所示，当本次遍历发现头结点对应的回收线程 thread4 已经挂掉后，清理完头结点中存储的待回收对象后，让其继续呆在链表中，​<strong>并不着急将其删除</strong>​。随后cursor指针指向thread3对应的节点，下一次遍历就会从thread3对应的节点开始遍历。</p>\n<p>当有一个新的回收线程 thread5 加入后，此时thread5对应的WeakOrderQueue节点变成了链表中的头结点，当经过多次遍历之后，cursor指针最终会再次指向死亡线程<code>thread4</code>​对应的节点时，会再次进入<code>cursor.get() == null</code>​的处理逻辑，而此时<code>thread4</code>​对应的节点已经不是头结点了，所以在这次遍历中就将该节点从链表中删除。</p>\n<blockquote>\n<p>这就是多线程并发代码和单线程代码设计上的不同，在多线程程序设计中，我们一定要时刻警惕同步操作的开销。能避免就要尽量避免。</p>\n</blockquote>\n<p><strong>第二个问题：操作WeakOrderQueue链表的头结点为什么是同步方法呢？</strong></p>\n<p>我们都知道一个回收线程对应一个WeakOrderQueue节点，当一个回收线程第一次为该创建线程回收对象时，都会新创建一个WeakOrderQueue节点并将节点插入到创建线程对应Stack中的WeakOrderQueue链表中的头结点位置。</p>\n<p>在多线程回收场景下，可能会有多个回收线程同时向创建线程对应Stack中的WeakOrderQueue链表的头结点插入自己对应的节点。</p>\n<p>那么此时对于链表头结点的操作就必须做同步处理了。当节点同步插入到链表的头结点后，以后该回收线程回收对象就是无锁化了。​<strong>只不过就是在一开始插入节点的时候会有一点同步的开销，但是这是无法避免的</strong>​。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//整个recycler对象池唯一的一个同步方法，而且同步块非常小，逻辑简单，执行迅速</span></span><br><span class=\"line\"><span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setHead</span><span class=\"params\">(WeakOrderQueue queue)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//始终在weakOrderQueue链表头结点插入新的节点</span></span><br><span class=\"line\">    queue.setNext(head);</span><br><span class=\"line\">    head = queue;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>纵观整个Recycler的设计实现，这个方法是唯一一个同步的方法，而且同步块非常的短，里面的逻辑非常简单。</p>\n<blockquote>\n<p>在多线程程序设计中，如果遇到无法避免的同步情况，那么也必须使同步块内的代码逻辑尽量简单。</p>\n</blockquote>\n<h2 id=\"10-WeakOrderQueue的设计实现\">10. WeakOrderQueue的设计实现</h2>\n<p><img src=\"/assets/53b93ae1d4dc4adeaa4d6104cc9aa7b6tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-onec9un.awebp\" alt=\"image.png\"></p>\n<p>之前我们在介绍WeakOrderQueue结构设计原理的时候讲到，虽然该结构命名的后缀是一个Queue，但其实是一个链表，链表中的元素类型为Link，头结点指针Head永远指向第一个未被转移完毕的Link，当一个Link里的待回收对象被全部转移完毕后，head指针随即指向下一个节点，但是该Link节点并不会从链表中删除。尾指针Tail指向链表中最后一个<code>Link节点</code>​。节点的插入是从链表的尾部开始插入。</p>\n<h3 id=\"10-1-Link结构\">10.1 Link结构</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">WeakOrderQueue</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">WeakReference</span>&lt;Thread&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// link结构是用于真正存储待回收对象的结构，继承AtomicInteger 本身可以用来当做writeindex使用</span></span><br><span class=\"line\">        <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Link</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">AtomicInteger</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//数组用来存储待回收对象，容量为16</span></span><br><span class=\"line\">            <span class=\"keyword\">final</span> DefaultHandle&lt;?&gt;[] elements = <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultHandle</span>[LINK_CAPACITY];</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"type\">int</span> readIndex;</span><br><span class=\"line\">            <span class=\"comment\">//weakOrderQueue中的存储结构时由link结构节点元素组成的链表结构</span></span><br><span class=\"line\">            Link next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>首先我们从WeakOrderQueue的继承结构上来看，它继承于 <code>WeakReference &lt; Thread &gt;</code>​ , 表示该结构持有一个线程的<code>弱引用</code>​，一个回收线程对应于一个WeakOrderQueue节点，很明显是持有其对应回收线程的弱引用，方便当回收线程挂掉的时候被GC回收。</p>\n<ul>\n<li>​<code>DefaultHandle&lt;?&gt;[] elements </code>​: Link结构中包含一个容量为LINK_CAPACITY ，默认为16大小的DefaultHandle数组，用来存储回收线程回收的对象。</li>\n<li>​<code>int readIndex</code>​：创建线程在转移Link节点中的待回收对象时，通过这个readIndex来读取未被转移的对象。由于readIndex只会被创建线程使用，所以这里并不需要保证原子性和可见性。用一个普通的int变量存储就好。</li>\n<li>​<code>writeIndex</code>​：Link结构继承于AtomicInteger类型，这就意味着Link结构本身就可以被当做一个writeIndex来使用，由于回收线程在向Link节点添加回收对象的时候需要修改writeIndex，于此同时创建线程在转移Link节点的时候需要读取writeIndex，所以writeIndex需要保证线程安全性，故采用AtomicInteger类型存储。</li>\n<li>​<code>Link next</code>​：Link节点的next指针，用于指向链表中的下一个节点。</li>\n</ul>\n<h3 id=\"10-2-Head结构\">10.2 Head结构</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// weakOrderQueue内部link链表的头结点</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Head</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//所有回收线程能够帮助创建线程回收对象的总容量 reserveSpaceForLink方法中会多线程操作该字段</span></span><br><span class=\"line\">    <span class=\"comment\">//用于指示当前回收线程是否继续为创建线程回收对象，所有回收线程都可以看到，这个值是所有回收线程共享的。以便可以保证所有回收线程回收的对象总量不能超过availableSharedCapacity</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> AtomicInteger availableSharedCapacity;</span><br><span class=\"line\">    <span class=\"comment\">//link链表的头结点</span></span><br><span class=\"line\">    Link link;</span><br><span class=\"line\"></span><br><span class=\"line\">    Head(AtomicInteger availableSharedCapacity) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.availableSharedCapacity = availableSharedCapacity;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">reclaimAllSpaceAndUnlink</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            ....回收head节点的所有空间，并从链表中删除head节点，head指针指向下一节点....</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">reclaimSpace</span><span class=\"params\">(<span class=\"type\">int</span> space)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//所有回收线程都可以看到，这个值是所有回收线程共享的。以便可以保证所有回收线程回收的对象总量不能超过availableSharedCapacity</span></span><br><span class=\"line\">        availableSharedCapacity.addAndGet(space);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//参数link为新的head节点，当前head指针指向的节点已经被回收完毕</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">relink</span><span class=\"params\">(Link link)</span> &#123;</span><br><span class=\"line\">          ...回收当前头结点的容量，更新head节点为指定的Link节点...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    Link <span class=\"title function_\">newLink</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">          ....创建新的Link节点...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//此处目的是为接下来要创建的link预留空间容量</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"type\">boolean</span> <span class=\"title function_\">reserveSpaceForLink</span><span class=\"params\">(AtomicInteger availableSharedCapacity)</span> &#123;             </span><br><span class=\"line\">          ...在创建新的Link节点之前需要调用该方法预订容量空间...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从代码结构上我们可以看出，Head结构的设计不只是作为头结点指针那么简单，其中还封装了很多链表操作以及回收的逻辑。</p>\n<ul>\n<li>​<code>AtomicInteger availableSharedCapacity</code>​：这个字段前边已经介绍过多次了，它是多线程共享的一个字段，可以被多个回收线程进行操作，表达的语义是所有回收线程总共可以帮助创建线程一共可以回收多少对象。对所有回收线程回收对象的总量进行限制。每创建一个Link节点，它的值就减少一个LINK_CAPACITY ，每释放一个Link节点，它的值就增加一个LINK_CAPACITY 。</li>\n<li>​<code>Link link</code>​：Head结构封装的Link链表中的头结点。</li>\n</ul>\n<p>剩下Head结构中封装的相关逻辑处理方法，等到介绍到具体应用场景的时候，笔者在拿出来为大家介绍，这里先混个眼熟就行。先看懂个大概，脑海里朦朦胧胧有个粗浅的认识即可。</p>\n<h3 id=\"10-3-WeakOrderQueue中的重要属性\">10.3 WeakOrderQueue中的重要属性</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">WeakOrderQueue</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">WeakReference</span>&lt;Thread&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//link链表的头结点，head指针始终指向第一个未被转移完毕的LinK节点</span></span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Head head;</span><br><span class=\"line\">        <span class=\"comment\">//尾结点</span></span><br><span class=\"line\">        <span class=\"keyword\">private</span> Link tail;</span><br><span class=\"line\">        <span class=\"comment\">//站在stack的视角中，stack中包含一个weakOrderQueue的链表，每个回收线程为当前stack回收的对象存放在回收线程对应的weakOrderQueue中</span></span><br><span class=\"line\">        <span class=\"comment\">//这样通过stack中的这个weakOrderQueue链表，就可以找到其他线程为该创建线程回收的对象</span></span><br><span class=\"line\">        <span class=\"keyword\">private</span> WeakOrderQueue next;</span><br><span class=\"line\">        <span class=\"comment\">//回收线程回收Id,每个weakOrderQueue分配一个，同一个stack下的一个回收线程对应一个weakOrderQueue节点</span></span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">id</span> <span class=\"operator\">=</span> ID_GENERATOR.getAndIncrement();</span><br><span class=\"line\">        <span class=\"comment\">//回收线程回收比例 默认是8</span></span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> interval;</span><br><span class=\"line\">        <span class=\"comment\">//回收线程回收计数 回收1/8的对象</span></span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"type\">int</span> handleRecycleCount;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>​<code>Head head</code>​：用于指向WeakOrderQueue中Link链表的头结点。</li>\n<li>​<code>Link tail</code>​：指向Link链表中的尾结点。</li>\n<li>​<code>WeakOrderQueue next</code>​：站在Stack结构的视角上，Stack包含一个WeakOrderQueue链表，用来存放回收线程回收过来的池化对象。该字段为WeakOrderQueue节点的next指针，用于指向下一个回收线程对应的WeakOrderQueue节点。</li>\n<li>​<code>int id </code>​：对应回收线程的回收Id，同一个Stack结构下，不同的回收线程对应不同的Id。</li>\n<li>​<code>int interval</code>​：回收线程对应的回收频率，默认只回收 1 / 8 的池化对象。</li>\n<li>​<code>int handleRecycleCount</code>​：回收对象计数，前边我们多次讲过了。用于控制回收频率。</li>\n</ul>\n<h3 id=\"10-4-WeakOrderQueue结构的创建\">10.4 WeakOrderQueue结构的创建</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">WeakOrderQueue</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">WeakReference</span>&lt;Thread&gt; &#123;</span><br><span class=\"line\">        <span class=\"comment\">//为了使stack能够被GC,这里不会持有其所属stack的引用</span></span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"title function_\">WeakOrderQueue</span><span class=\"params\">(Stack&lt;?&gt; stack, Thread thread)</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//weakOrderQueue持有对应回收线程的弱引用</span></span><br><span class=\"line\">            <span class=\"built_in\">super</span>(thread);</span><br><span class=\"line\">            <span class=\"comment\">//创建尾结点</span></span><br><span class=\"line\">            tail = <span class=\"keyword\">new</span> <span class=\"title class_\">Link</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 创建头结点  availableSharedCapacity = maxCapacity / maxSharedCapacityFactor</span></span><br><span class=\"line\">            head = <span class=\"keyword\">new</span> <span class=\"title class_\">Head</span>(stack.availableSharedCapacity);</span><br><span class=\"line\">            head.link = tail;</span><br><span class=\"line\">            interval = stack.delayedQueueInterval;</span><br><span class=\"line\">            handleRecycleCount = interval; </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在创建WeakOrderQueue结构的时候，首先会调用父类 <code>WeakReference&lt;Thread&gt;</code>​ 的构造方法持有当前回收线程的弱应用。</p>\n<p>然后创建第一个Link节点，head指针和tail指针同时指向这第一个节点。</p>\n<p>用创建线程对应的Stack中的属性初始化WeakOrderQueue结构中的相关属性。</p>\n<p>大家这里可能会问了，既然这里用Stack中的属性去初始化WeakOrderQueue结构中的相关属性，那​<strong>为什么WeakOrderQueue不直接持有Stack的引用呢</strong>​？</p>\n<p>之前我们提到，一个回收线程对应一个WeakOrderQueue节点，当回收线程挂掉的时候，需要清理WeakOrderQueue节点并将其从Stack结构中的WeakOrderQueue链表（头结点除外）中删除。使得WeakOrderQueue节点可以被GC回收掉。</p>\n<p><strong>如果Stack结构对应的创建线程挂掉，而此时WeakOrderQueue又持有了Stack的引用，这样就使得Stack结构无法被GC掉。</strong></p>\n<p>所以这里只会用Stack结构的相关属性去初始化WeakOrderQueue结构，在WeakOrderQueue中并不会持有Stack的引用。</p>\n<blockquote>\n<p>在复杂程序结构的设计中，我们要时刻对对象之间的引用关系保持清晰的认识。防止内存泄露。</p>\n</blockquote>\n<h3 id=\"10-5-从WeakOrderQueue中转移回收对象\">10.5 从WeakOrderQueue中转移回收对象</h3>\n<p>WeakOrderQueue的transfer方法用于将当前WeakOrderQueue节点中的待回收对象转移至创建线程对应的Stack中。</p>\n<p>开始转移回收对象时会从WeakOrderQueue节点中的Link链表的头结点开始遍历，如果头结点中还有未被转移的对象，则将头结点剩余的未转移对象转移至Stack中。所以创建线程每次最多转移一个LINK_CAPACITY大小的对象至Stack中。只要成功转移了哪怕一个对象，transfer方法就会返回true。</p>\n<p>如果头结点中存储的对象已经全部转移完毕，则更新head指针指向下一个Link节点，开始转移下一个Link节点。​<strong>创建线程每次只会转移一个Link节点</strong>​。如果Link链表是空的，没有转移成功一个对象，则transfer方法返回false。</p>\n<p>由于transfer方法体比较大，笔者将其按照上述逻辑步骤拆分开来为大家讲解：</p>\n<p><img src=\"/assets/25a723e07ab64f0fa5fcdc4eeddf1e0dtplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-afj8oqs.awebp\" alt=\"image.png\"></p>\n<h4 id=\"10-5-1-判断头结点中的待回收对象是否转移完毕\">10.5.1 判断头结点中的待回收对象是否转移完毕</h4>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//获取当前weakOrderQueue节点中的link链表头结点</span></span><br><span class=\"line\"><span class=\"type\">Link</span> <span class=\"variable\">head</span> <span class=\"operator\">=</span> <span class=\"built_in\">this</span>.head.link;</span><br><span class=\"line\"><span class=\"comment\">//头结点为null说明还没有待回收对象</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (head == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//如果头结点中的待回收对象已经被转移完毕</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (head.readIndex == LINK_CAPACITY) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//判断是否有后续Link节点</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (head.next == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//整个link链表没有待回收对象了已经</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    head = head.next;</span><br><span class=\"line\">    <span class=\"comment\">//当前Head节点已经被转移完毕，head指针向后移动，head指针始终指向第一个未被转移完毕的LinK节点</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.head.relink(head);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>首先从Link链表的头结点开始转移，<code>head == null</code>​ 说明当前Link链表是空的并没有对象可被转移，直接返回false。</p>\n<p>​<code>head.readIndex == LINK_CAPACITY</code>​ 判断当前头结点中的对象是否已经被转移完毕，如果当前头结点中的对象已经被全部转移完毕，则将head指针更新 relink 为下一个节点，开始从下一个节点开始转移对象。如果此时Link链表已经为空了，直接返回false。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Head</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//参数link为新的head节点，当前head指针指向的节点已经被回收完毕</span></span><br><span class=\"line\">            <span class=\"keyword\">void</span> <span class=\"title function_\">relink</span><span class=\"params\">(Link link)</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">//更新availableSharedCapacity，因为当前link节点中的待回收对象已经被转移完毕，所以需要增加availableSharedCapacity的值</span></span><br><span class=\"line\">                reclaimSpace(LINK_CAPACITY);</span><br><span class=\"line\">                <span class=\"comment\">//head指针指向新的头结点（第一个未被回收完毕的link节点）</span></span><br><span class=\"line\">                <span class=\"built_in\">this</span>.link = link;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">reclaimSpace</span><span class=\"params\">(<span class=\"type\">int</span> space)</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">//所有回收线程都可以看到，这个值是所有回收线程共享的。以便可以保证所有回收线程回收的对象总量不能超过availableSharedCapacity</span></span><br><span class=\"line\">                availableSharedCapacity.addAndGet(space);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"10-5-2-根据本次转移对象容量评估是否应该对Stack进行扩容\">10.5.2 根据本次转移对象容量评估是否应该对Stack进行扩容</h4>\n<p>此时Head节点已经校验完毕，可以执行正常的转移逻辑了。但在转移逻辑正式开始之前，还需要对本次转移对象的容量进行计算，并评估Stack的当前容量是否可以容纳的下，如果Stack的当前容量不够，则需要对Stack进行扩容。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">srcStart</span> <span class=\"operator\">=</span> head.readIndex;</span><br><span class=\"line\"><span class=\"comment\">//writeIndex</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">srcEnd</span> <span class=\"operator\">=</span> head.get();</span><br><span class=\"line\"><span class=\"comment\">//该link节点可被转移的对象容量</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">srcSize</span> <span class=\"operator\">=</span> srcEnd - srcStart;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (srcSize == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取创建线程stack中的当前回收对象数量总量</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">dstSize</span> <span class=\"operator\">=</span> dst.size;</span><br><span class=\"line\"><span class=\"comment\">// 待回收对象从weakOrderQueue中转移到stack后，stack的新容量 = 转移前stack容量 + 转移的待回收对象个数</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">expectedCapacity</span> <span class=\"operator\">=</span> dstSize + srcSize;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (expectedCapacity &gt; dst.elements.length) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//如果转移后的stack容量超过当前stack的容量 则对stack进行扩容</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">actualCapacity</span> <span class=\"operator\">=</span> dst.increaseCapacity(expectedCapacity);</span><br><span class=\"line\">    <span class=\"comment\">//每次转移最多一个Link的容量</span></span><br><span class=\"line\">    <span class=\"comment\">//actualCapacity - dstSize表示扩容后的stack还有多少剩余空间</span></span><br><span class=\"line\">    srcEnd = min(srcStart + actualCapacity - dstSize, srcEnd);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>获取Link链表头结点的readIndex和writeIndex，通过  <code>writeIndex - readIndex</code>​ 计算出当前头结点有多少可被转移的对象。</p>\n<p>Stack的最终容量为： <code>expectedCapacity = stack当前容量 + 转移对象的容量</code>​。</p>\n<p>如果计算得出转移后Stack的最终容量 expectedCapacity 超过了Stack的当前容量则需要对Stack进行扩容。根据扩容后的容量最终决定本次转移多少对象： <code>min(srcStart + actualCapacity - dstSize, srcEnd)</code>​ ，确保不能超过Stack可容纳的空间。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Stack</span>&lt;T&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"title function_\">increaseCapacity</span><span class=\"params\">(<span class=\"type\">int</span> expectedCapacity)</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">newCapacity</span> <span class=\"operator\">=</span> elements.length;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">maxCapacity</span> <span class=\"operator\">=</span> <span class=\"built_in\">this</span>.maxCapacity;</span><br><span class=\"line\">            <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">                newCapacity &lt;&lt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">while</span> (newCapacity &lt; expectedCapacity &amp;&amp; newCapacity &lt; maxCapacity);</span><br><span class=\"line\">            <span class=\"comment\">//扩容后的新容量为最接近指定容量expectedCapacity的最大2的次幂</span></span><br><span class=\"line\">            newCapacity = min(newCapacity, maxCapacity);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (newCapacity != elements.length) &#123;</span><br><span class=\"line\">                elements = Arrays.copyOf(elements, newCapacity);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">return</span> newCapacity;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果当前Stack已经达到最大容量，无法再继续扩容：<code>actualCapacity - dstSize = 0</code>​，则停止本次转移操作，直接返回<code>false</code>​。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (srcStart != srcEnd) &#123;</span><br><span class=\"line\">   .....具体的转移逻辑.......</span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// The destination stack is full already.</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>​<strong>如果Stack的容量可以容纳头结点中存储的待转移对象，则开始正式的转移逻辑</strong>​：</p>\n<h4 id=\"10-5-3-转移回收对象\">10.5.3 转移回收对象</h4>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//待转移对象集合 也就是Link节点中存储的元素</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> DefaultHandle[] srcElems = head.elements;</span><br><span class=\"line\"><span class=\"comment\">//stack中存储转移对象数组</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> DefaultHandle[] dstElems = dst.elements;</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">newDstSize</span> <span class=\"operator\">=</span> dstSize;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> srcStart; i &lt; srcEnd; i++) &#123;</span><br><span class=\"line\">    DefaultHandle&lt;?&gt; element = srcElems[i];</span><br><span class=\"line\">    <span class=\"comment\">//recycleId == 0 表示对象还没有被真正的回收到stack中</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (element.recycleId == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//设置recycleId 表明是被哪个weakOrderQueue回收的</span></span><br><span class=\"line\">        element.recycleId = element.lastRecycledId;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (element.recycleId != element.lastRecycledId) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//既被创建线程回收 同时也被回收线程回收  回收多次 则停止转移</span></span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalStateException</span>(<span class=\"string\">&quot;recycled already&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//对象转移后需要置空Link节点对应的位置</span></span><br><span class=\"line\">    srcElems[i] = <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//这里从weakOrderQueue将待回收对象真正回收到所属stack之前 需要进行回收频率控制</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (dst.dropHandle(element)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Drop the object.</span></span><br><span class=\"line\">        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//重新为defaultHandler设置其所属stack(初始创建该handler的线程对应的stack)</span></span><br><span class=\"line\">    <span class=\"comment\">//该defaultHandler在被回收对象回收的时候，会将其stack置为null，防止极端情况下，创建线程挂掉，对应stack无法被GC</span></span><br><span class=\"line\">    element.stack = dst;</span><br><span class=\"line\">    <span class=\"comment\">//此刻，handler才真正的被回收到所属stack中</span></span><br><span class=\"line\">    dstElems[newDstSize ++] = element;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>将当前Link节点中的elements数组里存储的对象转移至Stack中的数组栈elements中。转移范围 <code>srcStart  -&gt;  srcEnd </code>​。</p>\n<p>如果当前转移对象 <code>element.recycleId == 0</code>​ 说明当前对象还没有被真正的回收至创建线程对应的Stack中，符合转移条件（不能被多次回收）。还记不记得我们前边在《9.3 从Stack中获取池化对象》小节介绍的：</p>\n<ul>\n<li>​<code>recycleId = lastRecycledId = 0</code>​：表示池化对象刚刚被创建或者刚刚从对象池中取出即将被再次复用。这是池化对象的初始状态。</li>\n</ul>\n<p>随后设置回收Id <code>element.recycleId = element.lastRecycledId</code>​。此处的lastRecycledId为当前WeakOrderQueue节点对应的回收线程Id。</p>\n<p>​<code>element.recycleId != element.lastRecycledId</code>​ 此处表示当前对象可能被创建线程回收了，也可能被回收线程回收了。</p>\n<p>如果当前转移对象已经被回收至Stack中，则不能被再次回收，停止转移。</p>\n<h4 id=\"10-5-4-控制对象回收频率\">10.5.4 控制对象回收频率</h4>\n<p>符合转移条件的对象，需要再次经过回收频率的控制，即前边介绍的只回收 1 / 8 的对象，也就是每 8 个对象回收 1 个。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">boolean</span> <span class=\"title function_\">dropHandle</span><span class=\"params\">(DefaultHandle&lt;?&gt; handle)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!handle.hasBeenRecycled) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//回收计数handleRecycleCount 初始值为8 这样可以保证创建的第一个对象可以被池化回收</span></span><br><span class=\"line\">        <span class=\"comment\">//interval控制回收频率 8个对象回收一个</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (handleRecycleCount &lt; interval) &#123;</span><br><span class=\"line\">            handleRecycleCount++;</span><br><span class=\"line\">            <span class=\"comment\">// Drop the object.</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//回收一个对象后，回收计数清零</span></span><br><span class=\"line\">        handleRecycleCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">//设置defaultHandler的回收标识为true</span></span><br><span class=\"line\">        handle.hasBeenRecycled = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当对象通过了回收频率的验证之后，最后将回收对象的DefaultHandler中持有的Stack引用再次设置为其创建线程对应的Stack。因为在回收线程将池化对象回收至WeakOrderQueue节点时，会将其DefaultHandler中对Stack的引用置为null。所以这里需要重置回来。</p>\n<blockquote>\n<p>具体为什么在回收线程回收时会将回收对象的Stack引用置为null，大家这里可以自己先思考下，等到后面我们讲解多线程回收时，笔者在为大家揭开谜底。</p>\n</blockquote>\n<p>随后会将对象压入Stack结构中的数组栈中，到这里，回收线程帮助创建线程回收的对象才算真正的被回收了，业务线程可以直接从对象池中取出使用了。</p>\n<p>当对象转移完毕后，更新当前Link节点的readIndex，更新Stack中数组栈的栈顶指针。如果当前Link节点已经被转移完毕，则Head指针指向链表中的下一个节点，开始等待下一次的转移。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (srcEnd == LINK_CAPACITY &amp;&amp; head.next != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">       <span class=\"comment\">// Add capacity back as the Link is GCed.</span></span><br><span class=\"line\">       <span class=\"comment\">// 如果当前Link已经被回收完毕，且link链表还有后续节点，则更新head指针</span></span><br><span class=\"line\">       <span class=\"built_in\">this</span>.head.relink(head.next);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">//更新当前回收Link的readIndex</span></span><br><span class=\"line\">   head.readIndex = srcEnd;</span><br><span class=\"line\">   <span class=\"comment\">//如果没有转移任何数据 return false</span></span><br><span class=\"line\">   <span class=\"keyword\">if</span> (dst.size == newDstSize) &#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   dst.size = newDstSize;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br></pre></td></tr></table></figure>\n<p>到现在为止，多线程从Recycler对象池中无锁化获取对象的完整流程，笔者就为大家介绍完了，下面我们来继续剖析下多线程回收对象的场景。</p>\n<h2 id=\"11-多线程回收对象无锁化实现\">11. 多线程回收对象无锁化实现</h2>\n<p>之前我们在介绍池化对象的设计时，提到业务线程在使用对象的时候不应该感受到对象池的存在，所以将池化对象的回收，封装在其DefaultHandler中。在业务线程使用完对象时，直接调用池化对象的recycle方法进行回收即可。</p>\n<p><img src=\"/assets/58038d8ee0344260875993d8636331d5tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-lhvub6f.awebp\" alt=\"image.png\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Entry</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"keyword\">private</span>  Handle&lt;Entry&gt; handle;</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"keyword\">void</span> <span class=\"title function_\">recycle</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            next = <span class=\"literal\">null</span>;</span><br><span class=\"line\">            bufs = <span class=\"literal\">null</span>;</span><br><span class=\"line\">            buf = <span class=\"literal\">null</span>;</span><br><span class=\"line\">            msg = <span class=\"literal\">null</span>;</span><br><span class=\"line\">            promise = <span class=\"literal\">null</span>;</span><br><span class=\"line\">            progress = <span class=\"number\">0</span>;</span><br><span class=\"line\">            total = <span class=\"number\">0</span>;</span><br><span class=\"line\">            pendingSize = <span class=\"number\">0</span>;</span><br><span class=\"line\">            count = -<span class=\"number\">1</span>;</span><br><span class=\"line\">            cancelled = <span class=\"literal\">false</span>;</span><br><span class=\"line\">            handle.recycle(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DefaultHandle</span>&lt;T&gt; <span class=\"keyword\">implements</span> <span class=\"title class_\">Handle</span>&lt;T&gt; &#123;</span><br><span class=\"line\">      </span><br><span class=\"line\">        ..................省略............</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//强引用关联创建handler的stack</span></span><br><span class=\"line\">        Stack&lt;?&gt; stack;</span><br><span class=\"line\">        <span class=\"comment\">//池化对象</span></span><br><span class=\"line\">        Object value;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">recycle</span><span class=\"params\">(Object object)</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (object != value) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalArgumentException</span>(<span class=\"string\">&quot;object does not belong to handle&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            Stack&lt;?&gt; stack = <span class=\"built_in\">this</span>.stack;</span><br><span class=\"line\">            <span class=\"comment\">//handler初次创建以及从对象池中获取到时  recycleId = lastRecycledId = 0（对象被回收之前）</span></span><br><span class=\"line\">            <span class=\"comment\">//创建线程回收对象后recycleId = lastRecycledId = OWN_THREAD_ID</span></span><br><span class=\"line\">            <span class=\"comment\">//回收线程回收对象后lastRecycledId = 回收线程Id,当对象被转移到stack中后 recycleId = lastRecycledId = 回收线程Id</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (lastRecycledId != recycleId || stack == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalStateException</span>(<span class=\"string\">&quot;recycled already&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            stack.push(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>DefaultHandler中的 recycle 方法逻辑比较简单，唯一不好理解的地方在于判断对象是否已经被回收的 if 条件语句。</p>\n<ul>\n<li>​<code>lastRecycledId != recycleId</code>​ ：此时对象的状态正处于已经被回收线程回收至对应 WeakOrderQueue 节点的半回收状态，但还未被转移至其创建线程对应的Stack中。​<strong>所以这个条件要控制的事情就是如果对象已经被回收线程回收，那么就停止本次的回收操作</strong>​。</li>\n</ul>\n<blockquote>\n<p>忘记的同学可以在回看下《9.3 从Stack中获取池化对象》小节，那里详细介绍了 recycleId 和 lastRecycledId 之间各种关系的变化及其含义</p>\n</blockquote>\n<ul>\n<li>​<code>stack == null</code>​ ：这种情况其实前边我们也有提到过，就是当池化对象对应的创建线程挂掉的时候，对应的Stack随后也被GC回收掉。那么这时就不需要在回收该池化对象了。</li>\n</ul>\n<h3 id=\"11-1-回收对象至Stack中——啊哈！Bug\">11.1 回收对象至Stack中——啊哈！Bug!</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Stack</span>&lt;T&gt; &#123;</span><br><span class=\"line\">        <span class=\"comment\">//持有对应创建线程的弱引用</span></span><br><span class=\"line\">        <span class=\"keyword\">final</span> WeakReference&lt;Thread&gt; threadRef;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">void</span> <span class=\"title function_\">push</span><span class=\"params\">(DefaultHandle&lt;?&gt; item)</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">Thread</span> <span class=\"variable\">currentThread</span> <span class=\"operator\">=</span> Thread.currentThread();</span><br><span class=\"line\">            <span class=\"comment\">//判断当前线程是否为创建线程  对象池的回收原则是谁创建，最终由谁回收。其他线程只是将回收对象放入weakOrderQueue中</span></span><br><span class=\"line\">            <span class=\"comment\">//最终是要回收到创建线程对应的stack中的</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (threadRef.get() == currentThread) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 如果当前线程正是创建对象的线程，则直接进行回收 直接放入与创建线程关联的stack中</span></span><br><span class=\"line\">                pushNow(item);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 当前线程不是创建线程，则将回收对象放入创建线程对应的stack中的weakOrderQueue链表相应节点中（currentThread对应的节点）</span></span><br><span class=\"line\">                pushLater(item, currentThread);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里会进入到池化对象DefaultHandler中持有的Stack中，在Stack中进行对象的回收。</p>\n<blockquote>\n<p>大家这里先不要看笔者下面的解释，试着自己着重分析下这个 if…else…逻辑判断，有没有发现什么问题？？Bug就在这里！！</p>\n</blockquote>\n<p>这里首先会判断当前回收线程是否为池化对象的创建线程：<code>threadRef.get() == currentThread)</code>​。如果是，则由创建线程直接回收 pushNow(item) 。</p>\n<p>如果 <code>threadRef.get() != currentThread)</code>​ 这里有两种情况：</p>\n<ol>\n<li>currentThread是回收线程，那么就按多线程回收的逻辑 <code>pushLater(item, currentThread)</code>​ ，由回收线程将对象回收至其对应的WeakOrderQueue节点中，这里没什么毛病。</li>\n<li>Bug就出现在第二种情况，还有一种情况是 <code>threadRef.get()  == null</code>​ 也会走到 else 分支里。表示该回收对象的创建线程已经挂掉，并被GC回收。​<strong>那么在这种情况下已经没有必要在对该对象进行回收了</strong>​，因为创建线程已经挂掉，随后对应的Stack也迟早被GC掉，​<strong>这个对象即使被回收进Stack也永远不会在被使用到</strong>​。但是Netty的做法还是会让回收线程将其回收至Stack中的WeakOrderQueue链表中，笔者认为这里根本就没必要在添加至WeakOrderQueue链表中了。</li>\n</ol>\n<p>Bug产生的场景如下如所示：</p>\n<p><img src=\"/assets/53c6380455754787a12800dbf1e48a06tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-0takv3w.awebp\" alt=\"image.png\"></p>\n<p>​<strong>在第二种情况下，Netty还有一个重要的场景没有考虑到，会导致内存泄露</strong>​！！</p>\n<p>什么场景呢？大家再来回顾下池化对象与对象池之间的引用关系图：</p>\n<p><img src=\"/assets/f43dc00e2347458c876f15dae66f23d4tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-lapokvs.awebp\" alt=\"image.png\"></p>\n<p>这里我们看到池化对象会引用DefaultHandler，而DefaultHandler又强引用了Stack。于是就形成了这样一条引用链：</p>\n<p><img src=\"/assets/c2b0e2f9f93449e7b86ef71e2bac35e9tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-8xtfk94.awebp\" alt=\"image.png\"></p>\n<p>而池化对象是对外暴露的，用户可能在某个地方一直引用着这个池化对象，如果创建线程挂掉，并被GC回收之后，那么其在对象池中对应的Stack也应该被回收，因为Stack里保存的回收对象将再也不会被用到了。但是因为这条引用链的存在，导致Stack无法被GC回收从而造成内存泄露！</p>\n<h2 id=\"11-2-笔者反手一个PR，修复这个Bug\">11.2 笔者反手一个PR，修复这个Bug!</h2>\n<p>现在Bug产生的原因和造成的影响，笔者为大家已经分析清楚了，那么接下来的解决方案就变得很简单了。</p>\n<p>笔者先向Netty社区提了一个 Issue11864 来说明这个问题。</p>\n<blockquote>\n<p>Issue11864 : <a href=\"https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fnetty%2Fnetty%2Fissues%2F11864\" title=\"https://github.com/netty/netty/issues/11864\">github.com/netty/netty…</a></p>\n</blockquote>\n<p>然后直接提了 PR11865 来修复这个Bug。</p>\n<blockquote>\n<p>PR : <a href=\"https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fnetty%2Fnetty%2Fpull%2F11865\" title=\"https://github.com/netty/netty/pull/11865\">github.com/netty/netty…</a></p>\n</blockquote>\n<p>PR中主要的修改点分为以下两点：</p>\n<ol>\n<li>笔者在修复方案中觉得在这里应该尽早处理掉 <code>threadRef.get()  == null</code>​ 的情况，因为创建线程已经死掉，此时在为创建线程回收对象已经没有任何意义了，这种情况直接 return 掉就好。</li>\n<li>由于池化对象强引用到了其创建线程对应的Stack，当创建线程挂掉之后，我们需要解除这个引用链 <code>item.stack = null</code>​，保证Stack最终可以被GC回收。</li>\n</ol>\n<p>以下代码为笔者提交的PR中的修复方案，主要增加了对 <code>threadRef.get()  == null</code>​ 情况的处理，并添加了详细注释。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">push</span><span class=\"params\">(DefaultHandle&lt;?&gt; item)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">Thread</span> <span class=\"variable\">currentThread</span> <span class=\"operator\">=</span> Thread.currentThread();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (threadRef.get() == currentThread) &#123;</span><br><span class=\"line\">        pushNow(item);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (threadRef.get() == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// when the thread that belonged to the Stack was died or GC&#x27;ed，</span></span><br><span class=\"line\">        <span class=\"comment\">// There is no need to add this item to WeakOrderQueue-linked-list which belonged to the Stack any more</span></span><br><span class=\"line\">        item.stack = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        pushLater(item, currentThread);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"11-3-PR的后续\">11.3 PR的后续</h2>\n<p>当笔者提交了 PR11865之后，得到了相关作者如下回复。</p>\n<p><img src=\"/assets/84c1132caafa47e1a56f670b0ac349aetplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-czmjytj.awebp\" alt=\"image.png\"></p>\n<p>巧合的是Netty也意识到了对象池这块的问题，Netty最近也正在重构 Recycler 这一块，因为Recycler整体设计的还是比较复杂的，这从我们这篇源码解析的文章中也可以看的出来，Recycler的复杂性在于它的使用场景混合了<strong>并发</strong>以及与​<strong>GC相关的交互</strong>​，这些相关的问题都比较难以定位，所以Netty决定将对象池这一块用一种更加容易被理解的方式重构掉。</p>\n<p>相关的重构内容大家可以看作者的这个commit。</p>\n<blockquote>\n<p>重构commit：<a href=\"https://github.com/netty/netty/commit/28b9834612638ffec4948c0c650d04f766f20690\">github.com/netty/netty…</a></p>\n</blockquote>\n<p>重构后的Recycler对象池在<strong>4.1.71.Final</strong>版本已经发布。笔者后续也会为大家安排一篇重构后的Recycler对象池源码解析，但是本文还是聚焦于<strong>4.1.71.Final</strong>之前版本的对象池介绍，虽然被重构了，但是这里也有很多的设计思想和多线程程序设计细节非常值得我们学习！</p>\n<p>在<strong>4.1.71.Final</strong>版本发布之后，笔者想的是后面抽空看下重构后的对象池实现，哈哈，只要谓语动词出现—— ”想的是…“ 类似这样的句式，估计就没有以后了，哈哈。笔者还是大意了，这个 Issue11864 : <a href=\"https://github.com/netty/netty/issues/11864\">github.com/netty/netty…</a> 在过了几个月之后在社区里又被讨论了起来。有人发现在<strong>4.1.71.Final</strong>对象池重构后的版本中笔者提到的这些问题还是存在的。</p>\n<p>于是作者 chrisvest 又 提了一个 PR11996 最终在 <strong>4.1.74.Final</strong>版本中修复了笔者提的这个 Issue11864。</p>\n<blockquote>\n<p>PR11996 ：<a href=\"https://github.com/netty/netty/pull/11996\">github.com/netty/netty…</a></p>\n</blockquote>\n<blockquote>\n<p>随口提一句，这个大牛 chrisvest 是大名鼎鼎的图数据库 Neo4j 的核心commitor，同时也是Netty Buffer相关API的设计者。</p>\n</blockquote>\n<p>这里笔者将这个Bug在 <strong>4.1.74.Final</strong> 版本中的最终修复方案和大家说明一下，收个尾。</p>\n<ol>\n<li>首先 chrisvest 大牛 认为 当创建线程挂掉的时候，我们可以在threadLocal的 onRemoval方法中将创建线程对应的LocalPool里边用于存放回收对象的pooledHandles 直接置为 null。这里的语义是标记LocalPool已经死掉了，不会再继续使用。</li>\n</ol>\n<blockquote>\n<p>在重构后的版本中引入了 LocalPool 来代替我们前边介绍的Stack。LocalPool中的pooledHandles大家可以简单认为类似Stack中数组栈的功能。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Recycler</span>&lt;T&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> FastThreadLocal&lt;LocalPool&lt;T&gt;&gt; threadLocal = <span class=\"keyword\">new</span> <span class=\"title class_\">FastThreadLocal</span>&lt;LocalPool&lt;T&gt;&gt;() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">protected</span> LocalPool&lt;T&gt; <span class=\"title function_\">initialValue</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">LocalPool</span>&lt;T&gt;(maxCapacityPerThread, interval, chunkSize);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onRemoval</span><span class=\"params\">(LocalPool&lt;T&gt; value)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">            <span class=\"comment\">//删除LocalPool</span></span><br><span class=\"line\">            <span class=\"built_in\">super</span>.onRemoval(value);</span><br><span class=\"line\">            MessagePassingQueue&lt;DefaultHandle&lt;T&gt;&gt; handles = value.pooledHandles;</span><br><span class=\"line\">            <span class=\"comment\">//pooledHandles 置为 null，取消引用</span></span><br><span class=\"line\">            value.pooledHandles = <span class=\"literal\">null</span>;</span><br><span class=\"line\">            <span class=\"comment\">//清除LocalPool中保存的回收对象</span></span><br><span class=\"line\">            handles.clear();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>在多线程回收对象的时候，会首先判断该回收对象对应的LocalPool里的pooledHandles是否已经被清理变为不可用状态。如果是的话就停止回收。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LocalPool</span>&lt;T&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">//保证可见性</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> MessagePassingQueue&lt;DefaultHandle&lt;T&gt;&gt; pooledHandles;</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"keyword\">void</span> <span class=\"title function_\">release</span><span class=\"params\">(DefaultHandle&lt;T&gt; handle)</span> &#123;</span><br><span class=\"line\">            MessagePassingQueue&lt;DefaultHandle&lt;T&gt;&gt; handles = pooledHandles;</span><br><span class=\"line\">            handle.toAvailable();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (handles != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                handles.relaxedOffer(handle);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过以上两个措施 就保证了 当创建线程被GC掉之后，它对应的 在对象池中的回收缓存LocalPool（类比Stack）不会出现内存泄露，同时保证了多线程不在将回收对象至已经被清理的LocalPool中。</p>\n<p>好了，这一块的Bug修改我们介绍完了，我们继续多线程回收对象主流程的介绍：</p>\n<h3 id=\"11-4-创建线程直接回收对象\">11.4 创建线程直接回收对象</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">pushNow</span><span class=\"params\">(DefaultHandle&lt;?&gt; item)</span> &#123;</span><br><span class=\"line\">     <span class=\"comment\">//池化对象被回收前 recycleId = lastRecycleId = 0</span></span><br><span class=\"line\">     <span class=\"comment\">//如果其中之一不为0 说明已经被回收了</span></span><br><span class=\"line\">     <span class=\"keyword\">if</span> ((item.recycleId | item.lastRecycledId) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">         <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalStateException</span>(<span class=\"string\">&quot;recycled already&quot;</span>);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"comment\">//此处是由创建线程回收，则将池化对象的recycleId与lastRecycleId设置为创建线程Id-OWN_THREAD_ID</span></span><br><span class=\"line\">     <span class=\"comment\">//注意这里的OWN_THREAD_ID是一个固定的值，是因为这里的视角是池化对象的视角，只需要区分创建线程和非创建线程即可。</span></span><br><span class=\"line\">     <span class=\"comment\">//对于一个池化对象来说创建线程只有一个 所以用一个固定的OWN_THREAD_ID来表示创建线程Id</span></span><br><span class=\"line\">     item.recycleId = item.lastRecycledId = OWN_THREAD_ID;</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"type\">int</span> <span class=\"variable\">size</span> <span class=\"operator\">=</span> <span class=\"built_in\">this</span>.size;</span><br><span class=\"line\">     <span class=\"comment\">//如果当前池化对象的容量已经超过最大容量 则丢弃对象</span></span><br><span class=\"line\">     <span class=\"comment\">//为了避免池化对象的急速膨胀，这里只会回收1/8的对象，剩下的对象都需要丢弃</span></span><br><span class=\"line\">     <span class=\"keyword\">if</span> (size &gt;= maxCapacity || dropHandle(item)) &#123;</span><br><span class=\"line\">         <span class=\"comment\">// Hit the maximum capacity or should drop - drop the possibly youngest object.</span></span><br><span class=\"line\">         <span class=\"comment\">//丢弃对象</span></span><br><span class=\"line\">         <span class=\"keyword\">return</span>;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"comment\">//当前线程对应的stack容量已满但是还没超过最大容量限制，则对stack进行扩容</span></span><br><span class=\"line\">     <span class=\"keyword\">if</span> (size == elements.length) &#123;</span><br><span class=\"line\">         <span class=\"comment\">//容量扩大两倍</span></span><br><span class=\"line\">         elements = Arrays.copyOf(elements, min(size &lt;&lt; <span class=\"number\">1</span>, maxCapacity));</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     <span class=\"comment\">//将对象回收至当前stack中</span></span><br><span class=\"line\">     elements[size] = item;</span><br><span class=\"line\">     <span class=\"comment\">//更新当前stack的栈顶指针</span></span><br><span class=\"line\">     <span class=\"built_in\">this</span>.size = size + <span class=\"number\">1</span>;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>首先需要判断该回收对象是否已经被回收了。<code>item.recycleId | item.lastRecycledId) != 0</code>​，这里任意Id只要不为0，说明该对象已经对回收了，则停止本次回收操作。</li>\n<li>当对象被创建线程回收时，设置回收Id：<code>item.recycleId = item.lastRecycledId = OWN_THREAD_ID</code>​。</li>\n<li>如果当前Stack已经达到最大容量则将对象丢弃。</li>\n<li>为了避免对象池不可控制的迅速膨胀，这里只会回收 1 / 8 的对象，剩下的对象都需要丢弃 dropHandle 。</li>\n<li>如果当前Stack容量已满但是还没超过最大容量限制，则对stack进行扩容。一次性扩容两倍但不能超过最大容量。</li>\n<li>最后将对象压入Stack结构中的数组栈中，完成对象的回收。</li>\n</ul>\n<h3 id=\"11-5-回收线程间接回收对象\">11.5 回收线程间接回收对象</h3>\n<p><img src=\"/assets/e87ee465af764c47866e1f69a22d065atplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-ms062uc.awebp\" alt=\"image.png\"></p>\n<p>在Recycler对象池中，一个线程既可以是创建线程也可以是回收线程。</p>\n<p>比如上图中的 thread2 , thread3 , thread4 …  这里的每一个线程既可以在对象池中创建对象，并将对象回收至自己对应的Stack结构里的数组栈中，此刻它们的角色为创建线程。比如图中的thread1。</p>\n<p>同时其他线程 比如图中的 thread2 , thread3 , thread4 … 也可以为thread1回收由thread1创建的对象，将这些对象回收至thread1对应的Stack结构里的WeakOrderQueue链表中。此刻 thread2 , thread3 , thread4 …  为回收线程。</p>\n<p>在之前介绍Recycler对象池的重要属性时，我们提到过 maxDelayedQueuesPerThread 属性。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Recycler</span>&lt;T&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">//每个回收线程最多可以帮助多少个创建线程回收对象 默认：cpu核数 * 2</span></span><br><span class=\"line\">      <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> MAX_DELAYED_QUEUES_PER_THREAD;</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"comment\">//一个回收线程可帮助多少个创建线程回收对象</span></span><br><span class=\"line\">      <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> maxDelayedQueuesPerThread;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Stack</span>&lt;T&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 当前线程可以帮助多少个线程回收其池化对象</span></span><br><span class=\"line\">            <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> maxDelayedQueues;</span><br><span class=\"line\"></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>在Recycler对象池中，一个回收线程能够帮助多少个创建线程回收对象是有限制的，通过 maxDelayedQueuesPerThread属性 控制。</p>\n<p>​<strong>那么在对象池中，一个回收线程如何存储为其他创建线程回收到的对象呢</strong>​？</p>\n<p><img src=\"/assets/ec983e41a4b54a31a1f7f7c9ec511974tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-8ibqfew.awebp\" alt=\"image.png\"></p>\n<p>如图中所示，我们站在回收线程的视角来看，在对象池中有一个 FastThreadLocal 类型的 DELAYED_RECYCLED 字段， DELAYED_RECYCLED 为每个回收线程保存了一个 WeakHashMap，正是这个回收线程持有的 WeakHashMap 结构中保存了该回收线程为每个创建线程回收的对象。</p>\n<p>WeakHashMap 结构中的 key 表示创建线程对应的 Stack 结构。意思是该回收线程为哪个创建线程回收对象。value 表示这个回收线程在创建线程中对应Stack结构里的WeakOrderQueue链表中对应的节点。大家在结合 《Recycler对象池.png》 这副图仔细体会下这个结构设计。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Recycler</span>&lt;T&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//实现跨线程回收的核心，这里保存的是当前线程为其他线程回收的对象（由其他线程创建的池化对象）</span></span><br><span class=\"line\">    <span class=\"comment\">//key: 池化对象对应的创建线程stack  value: 当前线程代替该创建线程回收的池化对象 存放在weakOrderQueue中</span></span><br><span class=\"line\">    <span class=\"comment\">//这里的value即是 创建线程对应stack中的weakOrderQueue链表中的节点（每个节点表示其他线程为当前创建线程回收的对象）</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> FastThreadLocal&lt;Map&lt;Stack&lt;?&gt;, WeakOrderQueue&gt;&gt; DELAYED_RECYCLED =</span><br><span class=\"line\">            <span class=\"keyword\">new</span> <span class=\"title class_\">FastThreadLocal</span>&lt;Map&lt;Stack&lt;?&gt;, WeakOrderQueue&gt;&gt;() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">protected</span> Map&lt;Stack&lt;?&gt;, WeakOrderQueue&gt; initialValue() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">WeakHashMap</span>&lt;Stack&lt;?&gt;, WeakOrderQueue&gt;();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>而这个WeakHashMap 的size即表示当前回收线程已经在为多少个创建线程回收对象了，size的值不能超过 maxDelayedQueuesPerThread 。</p>\n<p>​<strong>这里为什么要用WeakHashMap呢</strong>​?</p>\n<p>其实我们前边多少也提到过了，考虑到一种极端的情况就是当创建线程挂掉并且被GC回收之后，其实这个创建线程对应的Stack结构已经没有用了，存储在Stack结构中的池化对象永远不会再被使用到，此时回收线程完全就没有必要在为挂掉的创建线程回收对象了。而这个Stack结构如果没有任何引用链存在的话，随后也会被GC回收。那么这个Stack结构在WeakHashMap中对应的Entry也会被自动删除。如果这里不采用WeakHashMap，那么回收线程为该Stack回收的对象就会一直停留在回收线程中。</p>\n<p>介绍完这些背景知识，下面我们就来正式介绍下回收线程到底是如何帮助创建线程回收对象的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">pushLater</span><span class=\"params\">(DefaultHandle&lt;?&gt; item, Thread thread)</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">//maxDelayQueues == 0 表示不支持对象的跨线程回收</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (maxDelayedQueues == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">          <span class=\"comment\">//直接丢弃</span></span><br><span class=\"line\">          <span class=\"keyword\">return</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">      <span class=\"comment\">//注意这里的视角切换，当前线程为回收线程</span></span><br><span class=\"line\">      Map&lt;Stack&lt;?&gt;, WeakOrderQueue&gt; delayedRecycled = DELAYED_RECYCLED.get();</span><br><span class=\"line\">      <span class=\"comment\">//获取当前回收对象属于的stack 由当前线程帮助其回收  注意这里是跨线程回收 当前线程并不是创建线程</span></span><br><span class=\"line\">      <span class=\"type\">WeakOrderQueue</span> <span class=\"variable\">queue</span> <span class=\"operator\">=</span> delayedRecycled.get(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">      <span class=\"comment\">//queue == null 表示当前线程是第一次为该stack回收对象</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (queue == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">          <span class=\"comment\">//maxDelayedQueues指示一个线程最多可以帮助多少个线程回收其创建的对象</span></span><br><span class=\"line\">          <span class=\"comment\">//delayedRecycled.size()表示当前线程已经帮助多少个线程回收对象</span></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (delayedRecycled.size() &gt;= maxDelayedQueues) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">              <span class=\"comment\">//如果超过指定帮助线程个数，则停止为其创建WeakOrderQueue，停止为其回收对象</span></span><br><span class=\"line\">              <span class=\"comment\">//WeakOrderQueue.DUMMY这里是一个标识，后边遇到这个标识  就不会为其回收对象了</span></span><br><span class=\"line\">              delayedRecycled.put(<span class=\"built_in\">this</span>, WeakOrderQueue.DUMMY);</span><br><span class=\"line\">              <span class=\"keyword\">return</span>;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">          <span class=\"comment\">// 创建为回收线程对应的WeakOrderQueue节点以便保存当前线程为其回收的对象</span></span><br><span class=\"line\">          <span class=\"keyword\">if</span> ((queue = newWeakOrderQueue(thread)) == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">              <span class=\"comment\">// 创建失败则丢弃对象</span></span><br><span class=\"line\">              <span class=\"keyword\">return</span>;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"comment\">//在当前线程的threadLocal中建立 回收对象对应的stack 与 weakOrderQueue的对应关系</span></span><br><span class=\"line\">          delayedRecycled.put(<span class=\"built_in\">this</span>, queue);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (queue == WeakOrderQueue.DUMMY) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// drop object</span></span><br><span class=\"line\">          <span class=\"comment\">// 如果queue的值是WeakOrderQueue.DUMMY 表示当前已经超过了允许帮助的线程数 直接丢弃对象</span></span><br><span class=\"line\">          <span class=\"keyword\">return</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">//当前线程为对象的创建线程回收对象  放入对应的weakOrderQueue中</span></span><br><span class=\"line\">      queue.add(item);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>首先需要判断当前Recycler对象池是否支持跨线程回收。 <code>maxDelayedQueues == 0</code>​ 表示不支持对象的跨线程回收。</li>\n<li>如果当前回收线程是第一次为该回收对象的创建线程进行回收，则需要为当前回收线程在对象的创建线程对应Stack结构中创建对应的WeakOrderQueue节点。（​<strong>这里正是多线程无锁化回收对象的核心所在</strong>​）。当然创建之前需要判断是否超过了可帮助创建线程的个数 maxDelayedQueues 。</li>\n<li>如果当前回收线程帮助的创建线程个数已经超过了 maxDelayedQueues 限制，则向对应的 WeakHashMap 塞入一个空的 WeakOrderQueue节点 DUMMY，后续如果遇到 WeakOrderQueue 节点是 DUMMY 实例则丢弃对象，放弃回收。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">WeakOrderQueue</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">WeakReference</span>&lt;Thread&gt; &#123;</span><br><span class=\"line\">        <span class=\"comment\">//作为一个标识，遇到DUMMY实例，则直接丢弃回收对象</span></span><br><span class=\"line\">        <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">WeakOrderQueue</span> <span class=\"variable\">DUMMY</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">WeakOrderQueue</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>如果当前回收线程帮助的创建线程个数还没有超过 maxDelayedQueues 限制，则通过 <code>stack#newWeakOrderQueue</code>​ 为当前回收线程在回收对象对应Stack结构中创建相应的WeakOrderQueue节点。并在回收线程持有的WeakHashMap中建立Stack与回收线程对应的WeakOrderQueue节点的关联关系。</li>\n<li>最终由回收线程将对象回收至其创建线程对应的Stack结构中。（将回收对象添加至回收线程对应的WeakOrderQueue节点中，完成多线程无锁化回收）</li>\n</ol>\n<h3 id=\"11-6-为回收线程创建对应的WeakOrderQueue节点\">11.6  为回收线程创建对应的WeakOrderQueue节点</h3>\n<p>上小节提到，当回收线程第一次为创建线程回收对象的时候，需要在创建线程对应Stack结构中的WeakOrderQueue链表中创建与回收线程对应的WeakOrderQueue节点。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Stack</span>&lt;T&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">private</span> WeakOrderQueue <span class=\"title function_\">newWeakOrderQueue</span><span class=\"params\">(Thread thread)</span> &#123;</span><br><span class=\"line\">           <span class=\"keyword\">return</span> WeakOrderQueue.newQueue(<span class=\"built_in\">this</span>, thread);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/assets/13ba4ffef43045ba8ed42101aefd3d72tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-i9veirg.awebp\" alt=\"image.png\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">WeakOrderQueue</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">WeakReference</span>&lt;Thread&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">static</span> WeakOrderQueue <span class=\"title function_\">newQueue</span><span class=\"params\">(Stack&lt;?&gt; stack, Thread thread)</span> &#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">            <span class=\"comment\">// link是weakOrderQueue中存储回收对象的最小结构，此处是为接下来要创建的Link预订空间容量</span></span><br><span class=\"line\">            <span class=\"comment\">// 如果stack指定的availableSharedCapacity 小于 LINK_CAPACITY大小，则分配失败</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!Head.reserveSpaceForLink(stack.availableSharedCapacity)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//如果还够容量来分配一个link那么就创建weakOrderQueue</span></span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"type\">WeakOrderQueue</span> <span class=\"variable\">queue</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">WeakOrderQueue</span>(stack, thread);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 向stack中的weakOrderQueue链表中添加当前回收线程对应的weakOrderQueue节点（始终在头结点处添加节点 ）</span></span><br><span class=\"line\">            <span class=\"comment\">// 此处向stack中添加weakOrderQueue节点的操作被移到WeakOrderQueue构造器之外的目的是防止WeakOrderQueue.this指针</span></span><br><span class=\"line\">            <span class=\"comment\">// 逃逸避免被其他线程在其构造的过程中访问</span></span><br><span class=\"line\">            stack.setHead(queue);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">return</span> queue;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在前边介绍WeakOrderQueue的结构的时候，我们提到WeakOrderQueue结构内部其实一个由Link节点组成的链表。WeakOrderQueue在初始状态下是只包含一个Link节点的链表。</p>\n<p>所有在创建WeakOrderQueue结构的时候需要同时为其创建一个Link节点。而这些Link节点正是真正保存回收线程所回收到的对象的地方。</p>\n<p>而对于一个创建线程来说它的所有回收线程能够为其回收对象的总量是被availableSharedCapacity 限制的，每创建一个Link节点，它的值就减少一个LINK_CAPACITY ，每释放一个Link节点，它的值就增加一个LINK_CAPACITY 。这样就能保证所有回收线程的回收总量不会超过 availableSharedCapacity 的限制。</p>\n<p>所以在为WeakOrderQueue结构创建首个Link节点时，需要判断<strong>当前所有回收线程回收的对象总量</strong>是否已经超过了 availableSharedCapacity 。如果容量还够回收一个Link大小的对象，则开始创建WeakOrderQueue结构。</p>\n<p>如果当前回收容量已经超过availableSharedCapacity或者不足回收一个Link大小的对象，则停止创建WeakOrderQueue节点，回收流程终止。不在对该回收对象进行回收。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//此处目的是为接下来要创建的link预留空间容量</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"type\">boolean</span> <span class=\"title function_\">reserveSpaceForLink</span><span class=\"params\">(AtomicInteger availableSharedCapacity)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//获取stack中允许异线程回收对象的总容量（异线程还能为该stack收集多少对象）</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">available</span> <span class=\"operator\">=</span> availableSharedCapacity.get();</span><br><span class=\"line\">        <span class=\"comment\">//当availbale可供回收容量小于一个Link时，说明异线程回收对象已经达到上限，不能在为stack回收对象了</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (available &lt; LINK_CAPACITY) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//为Link预留到一个Link的空间容量，更新availableSharedCapacity</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (availableSharedCapacity.compareAndSet(available, available - LINK_CAPACITY)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里的预订容量其实就是将 availableSharedCapacity 的值减去一个 LINK_CAPACITY 大小。其他回收线程会看到这个 availableSharedCapacity 容量的变化，方便决定是否继续为创建线程回收对象。</p>\n<p>当为WeakOrderQueue结构的首个Link节点预订容量成功后，就开始创建WeakOrderQueue节点。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//为了使stack进行GC,这里不会持有其所属stack的引用</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"title function_\">WeakOrderQueue</span><span class=\"params\">(Stack&lt;?&gt; stack, Thread thread)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//weakOrderQueue持有对应跨线程的弱引用</span></span><br><span class=\"line\">    <span class=\"built_in\">super</span>(thread);</span><br><span class=\"line\">    <span class=\"comment\">//创建尾结点</span></span><br><span class=\"line\">    tail = <span class=\"keyword\">new</span> <span class=\"title class_\">Link</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 创建头结点  availableSharedCapacity = maxCapacity / maxSharedCapacityFactor</span></span><br><span class=\"line\">    <span class=\"comment\">// 此时availableSharedCapacity的值已经变化了，减去了一个link的大小</span></span><br><span class=\"line\">    head = <span class=\"keyword\">new</span> <span class=\"title class_\">Head</span>(stack.availableSharedCapacity);</span><br><span class=\"line\">    head.link = tail;</span><br><span class=\"line\">    interval = stack.delayedQueueInterval;</span><br><span class=\"line\">    handleRecycleCount = interval; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当回收线程对应的WeakOrderQueue节点创建成功后，就将其插入到回收对象对应的Stack结构里的WeakOrderQueue链表中的头结点处。因为这里可能会涉及多个回收线程并发向WeakOrderQueue链表头结点处添加节点，所以更新Stack结构中WeakOrderQueue链表头结点的方法被设计成同步方法。这也是整个Recycler 对象池设计中，唯一的一个同步方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setHead</span><span class=\"params\">(WeakOrderQueue queue)</span> &#123;</span><br><span class=\"line\">     <span class=\"comment\">//始终在weakOrderQueue链表头结点插入新的queue（其他线程收集的由本线程创建的对象）</span></span><br><span class=\"line\">     queue.setNext(head);</span><br><span class=\"line\">     head = queue;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/assets/523b778404c140a29621295d079be9f8tplv-k3u1fbpfcp-zoom-in-crop-mark1512000-20231005102344-nuriy5k.awebp\" alt=\"image.png\"></p>\n<h3 id=\"11-7-向WeakOrderQueue节点中添加回收对象\">11.7 向WeakOrderQueue节点中添加回收对象</h3>\n<p>终于的终于我们到了多线程回收对象的最后一步了，本篇文章到这里也接近尾声了，大家在坚持一下。</p>\n<p>这里要做的事情就是，将回收对象添加到回收线程对应的WeakOrderQueue节点中，Netty会在Link链表的尾结点处添加回收对象，如果尾结点容量已满，就继续新创建一个Link。将回收对象添加到新的Link节点中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">add</span><span class=\"params\">(DefaultHandle&lt;?&gt; handle)</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">//将handler中的lastRecycledId标记为当前weakOrderQueue中的Id,一个stack和一个回收线程对应一个weakOrderQueue节点</span></span><br><span class=\"line\">      <span class=\"comment\">//表示该池化对象 最近的一次是被当前回收线程回收的。</span></span><br><span class=\"line\">      handle.lastRecycledId = id;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 控制异线程回收频率 只回收1/8的对象</span></span><br><span class=\"line\">      <span class=\"comment\">// 这里需要关注的细节是其实在scavengeSome方法中将weakOrderQueue中的待回收对象转移到创建线程的stack中时，Netty也会做回收频率的限制</span></span><br><span class=\"line\">      <span class=\"comment\">// 这里在回收线程回收的时候也会控制回收频率（总体控制两次）netty认为越早的做回收频率控制越好 这样可以避免weakOrderQueue中的容量迅速的增长从而失去控制</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (handleRecycleCount &lt; interval) &#123;</span><br><span class=\"line\">          handleRecycleCount++;</span><br><span class=\"line\">          <span class=\"comment\">// Drop the item to prevent recycling to aggressive.</span></span><br><span class=\"line\">          <span class=\"keyword\">return</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      handleRecycleCount = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">//从尾部link节点开始添加新的回收对象</span></span><br><span class=\"line\">      <span class=\"type\">Link</span> <span class=\"variable\">tail</span> <span class=\"operator\">=</span> <span class=\"built_in\">this</span>.tail;</span><br><span class=\"line\">      <span class=\"type\">int</span> writeIndex;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">//如果当前尾部link节点容量已满，就需要创建新的link节点</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> ((writeIndex = tail.get()) == LINK_CAPACITY) &#123;</span><br><span class=\"line\">          <span class=\"comment\">//创建新的Link节点</span></span><br><span class=\"line\">          <span class=\"type\">Link</span> <span class=\"variable\">link</span> <span class=\"operator\">=</span> head.newLink();</span><br><span class=\"line\">          <span class=\"comment\">//如果availableSharedCapacity的容量不够了，则无法创建Link。丢弃待回收对象</span></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (link == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">              <span class=\"comment\">// 丢弃对象</span></span><br><span class=\"line\">              <span class=\"keyword\">return</span>;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"comment\">// We allocate a Link so reserve the space</span></span><br><span class=\"line\">          <span class=\"comment\">//更新尾结点</span></span><br><span class=\"line\">          <span class=\"built_in\">this</span>.tail = tail = tail.next = link;</span><br><span class=\"line\"></span><br><span class=\"line\">          writeIndex = tail.get();</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">//将回收对象handler放入尾部link节点中</span></span><br><span class=\"line\">      tail.elements[writeIndex] = handle;</span><br><span class=\"line\">      <span class=\"comment\">//这里将stack置为null，是为了方便stack被回收。</span></span><br><span class=\"line\">      <span class=\"comment\">//如果Stack不再使用，期望被GC回收，发现handle中还持有stack的引用，那么就无法被GC回收，从而造成内存泄漏</span></span><br><span class=\"line\">      <span class=\"comment\">//在从对象池中再次取出该对象时，stack还会被重新赋予</span></span><br><span class=\"line\">      handle.stack = <span class=\"literal\">null</span>;</span><br><span class=\"line\">      <span class=\"comment\">//注意这里用lazySet来延迟更新writeIndex。只有当writeIndex更新之后，在创建线程中才可以看到该待回收对象</span></span><br><span class=\"line\">      <span class=\"comment\">//保证线程最终可见而不保证立即可见的原因就是 其实这里Netty还是为了性能考虑避免执行内存屏障指令的开销。</span></span><br><span class=\"line\">      <span class=\"comment\">//况且这里也并不需要考虑线程的可见性，当创建线程调用scavengeSome从weakOrderQueue链表中回收对象时，看不到当前节点weakOrderQueue</span></span><br><span class=\"line\">      <span class=\"comment\">//新添加的对象也没关系，因为是多线程一起回收，所以继续找下一个节点就好。及时全没看到，大不了就在创建一个对象。主要还是为了提高weakOrderQueue的写入性能</span></span><br><span class=\"line\">      tail.lazySet(writeIndex + <span class=\"number\">1</span>);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>首先第一步就要设置回收对象DefaultHandler中的lastRecycledId ，将其设置为该回收线程Id，表示该回收对象最近一次是由当前回收线程回收的。此时的DefaultHandler中 <code>recycleId != lastRecycledId </code>​，对象处于半回收状态。</li>\n<li>控制回收线程的回收频率（只回收 1 / 8 的对象），大家是否还记得我们在《9.5 转移回收对象》小节中介绍 <code>stack#scavengeSome方法</code>​ 的时候，在创建线程从Stack中的WeakOrderQueue链表中转移对象到数组栈中的时候，也会被回收频率进行控制，只转移 1 / 8 的对象。所以这里我们可以看到​<strong>回收频率的控制在多线程回收对象的时候会控制两次</strong>​，netty认为越早做回收频率控制越好这样可以避免weakOrderQueue中的容量迅速的增长从而失去控制。</li>\n<li>在WeakOrderQueue结构中，当我们向Link链表添加回收对象时，都会向Link链表的尾结点中添加回收对象，如果当前尾结点容量已经满了 <code>writeIndex = tail.get()) == LINK_CAPACITY</code>​ ，我们就需要新创建一个Link节点，并将tail指针指向新的Link节点更新尾结点。最后将回收对象回收至新的尾结点中。当然我们要考虑到 availableSharedCapacity 容量的限制，如果容量不够了，就不能在新建Link节点，直接将回收对象丢弃，停止回收。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Head</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">         Link <span class=\"title function_\">newLink</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">              <span class=\"comment\">//此处的availableSharedCapacity可能已经被多个回收线程改变，因为availableSharedCapacity是用来控制回收线程回收的总容量限制</span></span><br><span class=\"line\">              <span class=\"comment\">//每个回收线程再回收对象时都需要更新availableSharedCapacity</span></span><br><span class=\"line\">              <span class=\"keyword\">return</span> reserveSpaceForLink(availableSharedCapacity) ? <span class=\"keyword\">new</span> <span class=\"title class_\">Link</span>() : <span class=\"literal\">null</span>;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//此处目的是为接下来要创建的link预留空间容量</span></span><br><span class=\"line\">        <span class=\"keyword\">static</span> <span class=\"type\">boolean</span> <span class=\"title function_\">reserveSpaceForLink</span><span class=\"params\">(AtomicInteger availableSharedCapacity)</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//获取stack中允许异线程回收对象的总容量（异线程还能为该stack收集多少对象）</span></span><br><span class=\"line\">                <span class=\"type\">int</span> <span class=\"variable\">available</span> <span class=\"operator\">=</span> availableSharedCapacity.get();</span><br><span class=\"line\">                <span class=\"comment\">//当availbale可供回收容量小于一个Link时，说明异线程回收对象已经达到上限，不能在为stack回收对象了</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (available &lt; LINK_CAPACITY) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">//为Link预留到一个Link的空间容量，更新availableSharedCapacity</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (availableSharedCapacity.compareAndSet(available, available - LINK_CAPACITY)) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>到这里Recycler对象池的整个<strong>多线程无锁化回收对象</strong>的流程笔者就为大家介绍完了。</p>\n<p>但是这里还有两个点，笔者想要和大家再强调一下：</p>\n<p>​<strong>第一：为什么这里会将handle.stack设置为null</strong>​?</p>\n<p>不知大家还记不记得我们在介绍 <code>stack#scavengeSome方法</code>​ 的时候专门提到，在创建线程遍历WeakOrderQueue链表将链表中的待回收对象转移至stack中的数组栈时，会将待回收对象的DefaultHandler持有的stack重新设置为其创建线程对应的stack。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">boolean</span> <span class=\"title function_\">transfer</span><span class=\"params\">(Stack&lt;?&gt; dst)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">      .................省略..............</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">//重新为defaultHandler设置其所属stack(初始创建该handler的线程对应的stack)</span></span><br><span class=\"line\">      <span class=\"comment\">//该defaultHandler在被回收对象回收的时候，会将其stack置为null，防止极端情况下，创建线程挂掉，对应stack无法被GC</span></span><br><span class=\"line\">      element.stack = dst;</span><br><span class=\"line\"></span><br><span class=\"line\">      .................省略..............</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>而这里在回收线程向WeakOrderQueue节点添加回收对象时先将 handle.stack设置为 null，而在转移回收对象时又将 handle.stack 设置回来，这不是多此一举吗？</p>\n<p>其实并不是多此一举，这样设计是非常有必要的，我们假设一种极端的情况，当创建线程挂掉并被GC回收之后，其实stack中存储的回收对象已经不可能在被使用到了，stack应该也被回收掉。但是如果这里回收线程在回收的时候不将对象持有的stack设置为null的话，直接添加到了WeakOrderQueue节点中，当创建被GC掉的时候，由于这条引用链的存在导致对应stack永远不会被GC掉，造成内存泄露。</p>\n<blockquote>\n<p>所以笔者在本文中多次强调，当我们在设计比较复杂的程序结构时，对于对象之间的引用关系，一定要时刻保持清晰的认识，防止内存泄露。</p>\n</blockquote>\n<p>​<strong>第二：为什么最后使用lazySet来更新尾结点的writeIndex</strong>​？</p>\n<p>当我们向Link链表的尾结点添加完回收对象之后，在更新尾结点的writeIndex时，使用到了延时更新，而延时更新并不会保证多线程的可见性，如果此时创建线程正在转移对象，那么将不会看到新添加进来的回收对象了。</p>\n<p>而事实上，我们这里并不需要保证线程之间的实时可见性，只需要保证最终可见性即可。</p>\n<p>确实在当创建线程转移对象的时候可能并不会看到刚刚被回收线程新添加进来的回收对象，看不到没关系，创建线程大不了在本次转移中不回收它不就完了么。因为只要创建线程Stack结构中的数组栈为空，创建线程就会从WeakOrderQueue链表中转移对象，以后会有很多次机会来WeakOrderQueu链表中转移对象，什么时候看见了，什么时候转移它。并不需要实时性。退一万步讲，即使全部看不到，大不了创建线程直接创建一个对象返回就行了。</p>\n<p>而如果这里要保证线程之间的实时可见性，在更新尾结点的writeIndex的时候就不得不插入 LOCK 前缀内存屏障指令保证多线程之间的实时可见性，而执行内存屏障指令是需要开销的，所以​<strong>为了保证WeakOrderQueue的写入性能</strong>​，Netty这里选择了只保证最终可见性而不保证实时可见性。</p>\n<hr>\n<h2 id=\"总结\">总结</h2>\n<p>到这里关于Recycler对象池的整个设计与源码实现，笔者就为大家详细的剖析完毕了，在剖析的过程中，我们提炼出了很多多线程并发程序的设计要点和注意事项。大家可以在日常开发工作中多多体会并实践。</p>\n<p>虽然本文介绍的Recycler对象池整体设计将会在<strong>4.1.71.Final</strong>版本被重构，但是在当前版本Recycler对象池的设计和实现中，我们还是可以学习到很多东西的。</p>\n<p>笔者真心十分佩服能够耐心看到这里的大家，不知不觉已经唠叨了三万多字了，谢谢大家的观看~~，大家记得晚餐时给自己加餐个鸡腿奖励一下自己，哈哈！！</p>\n"}],"PostAsset":[{"_id":"source/_posts/java/Base/JavaStream.md","post":"cm9s3f3yo0001bfg4gji44ji6","slug":"JavaStream.md","modified":1,"renderable":1},{"_id":"source/_posts/java/Base/ThreadLocal.md","post":"cm9s3f3yo0001bfg4gji44ji6","slug":"ThreadLocal.md","modified":1,"renderable":1},{"_id":"source/_posts/java/Base/Volatile.md","post":"cm9s3f3yo0001bfg4gji44ji6","slug":"Volatile.md","modified":1,"renderable":1},{"_id":"source/_posts/java/Collection/List.md","post":"cm9s3f3yv0005bfg49hwx0b2y","slug":"List.md","modified":1,"renderable":1},{"_id":"source/_posts/java/Collection/Map.md","post":"cm9s3f3yv0005bfg49hwx0b2y","slug":"Map.md","modified":1,"renderable":1},{"_id":"source/_posts/java/Collection/Queue.md","post":"cm9s3f3yv0005bfg49hwx0b2y","slug":"Queue.md","modified":1,"renderable":1},{"_id":"source/_posts/java/Collection/Set.md","post":"cm9s3f3yv0005bfg49hwx0b2y","slug":"Set.md","modified":1,"renderable":1},{"_id":"source/_posts/java/JVM/Java虚拟机栈栈帧.md","post":"cm9s3f3yv0006bfg45rn42dzz","slug":"Java虚拟机栈栈帧.md","modified":1,"renderable":1},{"_id":"source/_posts/java/JVM/垃圾回收和内存分配.md","post":"cm9s3f3yv0006bfg45rn42dzz","slug":"垃圾回收和内存分配.md","modified":1,"renderable":1},{"_id":"source/_posts/java/JVM/虚拟机中的对象.md","post":"cm9s3f3yv0006bfg45rn42dzz","slug":"虚拟机中的对象.md","modified":1,"renderable":1},{"_id":"source/_posts/java/JVM/虚拟机运行时数据区域.md","post":"cm9s3f3yv0006bfg45rn42dzz","slug":"虚拟机运行时数据区域.md","modified":1,"renderable":1},{"_id":"source/_posts/java/JavaWeb/Filter拦截器.md","post":"cm9s3f3yx0007bfg47uroaeyi","slug":"Filter拦截器.md","modified":1,"renderable":1},{"_id":"source/_posts/java/thread/并发处理.md","post":"cm9s3f3yx0008bfg4d2n5e8hf","slug":"并发处理.md","modified":1,"renderable":1},{"_id":"source/_posts/java/thread/并发锁.md","post":"cm9s3f3yx0008bfg4d2n5e8hf","slug":"并发锁.md","modified":1,"renderable":1},{"_id":"source/_posts/java/thread/线程池.md","post":"cm9s3f3yx0008bfg4d2n5e8hf","slug":"线程池.md","modified":1,"renderable":1},{"_id":"source/_posts/java/thread/线程间通讯.md","post":"cm9s3f3yx0008bfg4d2n5e8hf","slug":"线程间通讯.md","modified":1,"renderable":1}],"PostCategory":[{"post_id":"cma56nfvk0000isjj1wo3gapa","category_id":"cma56nfvo0002isjj047r393u","_id":"cma56nfvv000aisjja2jb480r"},{"post_id":"cma56nfvn0001isjj99f3c6ak","category_id":"cma56nfvu0007isjjehho4osz","_id":"cma56nfvx000fisjj67wlclyy"},{"post_id":"cma56nfvs0004isjj2ege7b7j","category_id":"cma56nfvv000bisjj7bkx50ac","_id":"cma56nfvy000jisjj8ovu6gub"},{"post_id":"cma56nfvs0005isjj2cea5i9y","category_id":"cma56nfvx000gisjj2yvi3urh","_id":"cma56nfvz000oisjjhpmk52xo"},{"post_id":"cma56nfvt0006isjjfwyu6rwf","category_id":"cma56nfvy000kisjj25czg1g4","_id":"cma56nfw0000risjjfp3s5v53"},{"post_id":"cma56nfvu0009isjjedzadazh","category_id":"cma56nfvz000pisjj1sdd2g4z","_id":"cma56nfw0000wisjjdawu039e"},{"post_id":"cma56nfvx000iisjja19xesyn","category_id":"cma56nfw0000sisjj95c85bq1","_id":"cma56nfw1000zisjjbyx4a5hu"}],"PostTag":[{"post_id":"cma56nfvk0000isjj1wo3gapa","tag_id":"cma56nfvr0003isjj5rd06rxm","_id":"cma56nfvw000disjj7qsy2gry"},{"post_id":"cma56nfvk0000isjj1wo3gapa","tag_id":"cma56nfvu0008isjje443g871","_id":"cma56nfvx000eisjj8rjtbtkx"},{"post_id":"cma56nfvn0001isjj99f3c6ak","tag_id":"cma56nfvv000cisjjgehcdcfz","_id":"cma56nfvz000misjj8mng6e54"},{"post_id":"cma56nfvn0001isjj99f3c6ak","tag_id":"cma56nfvx000hisjj9olk93bm","_id":"cma56nfvz000nisjjcdgoaw6e"},{"post_id":"cma56nfvs0004isjj2ege7b7j","tag_id":"cma56nfvy000lisjj5a7e9qy4","_id":"cma56nfw0000uisjjbg1j4dr1"},{"post_id":"cma56nfvs0004isjj2ege7b7j","tag_id":"cma56nfvz000qisjj0awnesx3","_id":"cma56nfw0000visjj123jg1sk"},{"post_id":"cma56nfvs0005isjj2cea5i9y","tag_id":"cma56nfw0000tisjj178sduy9","_id":"cma56nfw1000yisjj5w0kh9fn"},{"post_id":"cma56nfvt0006isjjfwyu6rwf","tag_id":"cma56nfw0000xisjjflesd0lq","_id":"cma56nfw10012isjjfmc5f3ax"},{"post_id":"cma56nfvt0006isjjfwyu6rwf","tag_id":"cma56nfw10010isjj0pbcbclr","_id":"cma56nfw10013isjje8an94gu"},{"post_id":"cma56nfvu0009isjjedzadazh","tag_id":"cma56nfw10011isjjgm0tdnuf","_id":"cma56nfw10015isjjdmno9np4"},{"post_id":"cma56nfvx000iisjja19xesyn","tag_id":"cma56nfw10014isjjgiceaoet","_id":"cma56nfw20017isjjat8rhad4"},{"post_id":"cma56nfvx000iisjja19xesyn","tag_id":"cma56nfw10016isjj6p3u1muh","_id":"cma56nfw20018isjjg9gy51sc"}],"Tag":[{"name":"WSL","_id":"cma56nfvr0003isjj5rd06rxm"},{"name":"Kali","_id":"cma56nfvu0008isjje443g871"},{"name":"logback","_id":"cma56nfvv000cisjjgehcdcfz"},{"name":"log","_id":"cma56nfvx000hisjj9olk93bm"},{"name":"Redis","_id":"cma56nfvy000lisjj5a7e9qy4"},{"name":"Linux","_id":"cma56nfvz000qisjj0awnesx3"},{"name":"Javascript","_id":"cma56nfw0000tisjj178sduy9"},{"name":"K3S","_id":"cma56nfw0000xisjjflesd0lq"},{"name":"EMQX","_id":"cma56nfw10010isjj0pbcbclr"},{"name":"Consul","_id":"cma56nfw10011isjjgm0tdnuf"},{"name":"Recycler","_id":"cma56nfw10014isjjgiceaoet"},{"name":"Netty","_id":"cma56nfw10016isjj6p3u1muh"}]}}