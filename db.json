{"meta":{"version":1,"warehouse":"5.0.1"},"models":{"Asset":[{"_id":"node_modules/hexo-theme-kratos-rebirth/source/css/kr-core.min.css","path":"css/kr-core.min.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/404.webp","path":"images/404.webp","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/default.webp","path":"images/default.webp","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/user.svg","path":"images/user.svg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/js/kr-core.min.js","path":"js/kr-core.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/js/kr-pjax.min.js","path":"js/kr-pjax.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/js/kr-search.min.js","path":"js/kr-search.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/js/kr-theme.min.js","path":"js/kr-theme.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/css/kr-theme/dark.min.css","path":"css/kr-theme/dark.min.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/css/kr-theme/light.min.css","path":"css/kr-theme/light.min.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/js/kr-modal/donate.min.js","path":"js/kr-modal/donate.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/js/kr-modal/share.min.js","path":"js/kr-modal/share.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/nprogress@0.2.0/History.md","path":"vendors/nprogress@0.2.0/History.md","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/nprogress@0.2.0/License.md","path":"vendors/nprogress@0.2.0/License.md","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/nprogress@0.2.0/Notes.md","path":"vendors/nprogress@0.2.0/Notes.md","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/nprogress@0.2.0/Readme.md","path":"vendors/nprogress@0.2.0/Readme.md","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/nprogress@0.2.0/bower.json","path":"vendors/nprogress@0.2.0/bower.json","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/nprogress@0.2.0/component.json","path":"vendors/nprogress@0.2.0/component.json","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/nprogress@0.2.0/nprogress.css","path":"vendors/nprogress@0.2.0/nprogress.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/nprogress@0.2.0/nprogress.js","path":"vendors/nprogress@0.2.0/nprogress.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/nprogress@0.2.0/package.json","path":"vendors/nprogress@0.2.0/package.json","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/css/highlight/highlight.js/light.min.css","path":"css/highlight/highlight.js/light.min.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/css/highlight/highlight.js/night-blue.min.css","path":"css/highlight/highlight.js/night-blue.min.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/css/highlight/highlight.js/night-bright.min.css","path":"css/highlight/highlight.js/night-bright.min.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/css/highlight/highlight.js/night-eighties.min.css","path":"css/highlight/highlight.js/night-eighties.min.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/css/highlight/highlight.js/night.min.css","path":"css/highlight/highlight.js/night.min.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/css/highlight/prismjs/atom-dark.min.css","path":"css/highlight/prismjs/atom-dark.min.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/css/font-awesome.css","path":"vendors/font-awesome@4.7.0/css/font-awesome.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/css/font-awesome.css.map","path":"vendors/font-awesome@4.7.0/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/css/font-awesome.min.css","path":"vendors/font-awesome@4.7.0/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/fonts/FontAwesome.otf","path":"vendors/font-awesome@4.7.0/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/fonts/fontawesome-webfont.eot","path":"vendors/font-awesome@4.7.0/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/fonts/fontawesome-webfont.svg","path":"vendors/font-awesome@4.7.0/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/fonts/fontawesome-webfont.ttf","path":"vendors/font-awesome@4.7.0/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/fonts/fontawesome-webfont.woff","path":"vendors/font-awesome@4.7.0/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/fonts/fontawesome-webfont.woff2","path":"vendors/font-awesome@4.7.0/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/nprogress@0.2.0/test/component.html","path":"vendors/nprogress@0.2.0/test/component.html","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/nprogress@0.2.0/test/test.js","path":"vendors/nprogress@0.2.0/test/test.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/qr-code-styling@1.6.0-rc.1/lib/qr-code-styling.js","path":"vendors/qr-code-styling@1.6.0-rc.1/lib/qr-code-styling.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/viewerjs@1.11.6/dist/viewer.common.js","path":"vendors/viewerjs@1.11.6/dist/viewer.common.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/viewerjs@1.11.6/dist/viewer.css","path":"vendors/viewerjs@1.11.6/dist/viewer.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/viewerjs@1.11.6/dist/viewer.esm.js","path":"vendors/viewerjs@1.11.6/dist/viewer.esm.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/viewerjs@1.11.6/dist/viewer.js","path":"vendors/viewerjs@1.11.6/dist/viewer.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/viewerjs@1.11.6/dist/viewer.min.css","path":"vendors/viewerjs@1.11.6/dist/viewer.min.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/viewerjs@1.11.6/dist/viewer.min.js","path":"vendors/viewerjs@1.11.6/dist/viewer.min.js","modified":0,"renderable":1},{"_id":"source/img/avatar.jpg","path":"img/avatar.jpg","modified":0,"renderable":0},{"_id":"source/assets/0b6fcecfe53184140bb4005dd0eab836-20230127151311-0gha64i.png","path":"assets/0b6fcecfe53184140bb4005dd0eab836-20230127151311-0gha64i.png","modified":0,"renderable":0},{"_id":"source/assets/20200809110444386-20230127151311-z1qxdzv.png","path":"assets/20200809110444386-20230127151311-z1qxdzv.png","modified":0,"renderable":0},{"_id":"source/assets/20210417191156743-20230127151311-j5awou3.png","path":"assets/20210417191156743-20230127151311-j5awou3.png","modified":0,"renderable":0},{"_id":"source/assets/20210417191226786-20230127151312-304h995.png","path":"assets/20210417191226786-20230127151312-304h995.png","modified":0,"renderable":0},{"_id":"source/assets/20210417191245920-20230127151311-nf45pi0.png","path":"assets/20210417191245920-20230127151311-nf45pi0.png","modified":0,"renderable":0},{"_id":"source/assets/20210417191255980-20230127151311-y6imh9a.png","path":"assets/20210417191255980-20230127151311-y6imh9a.png","modified":0,"renderable":0},{"_id":"source/assets/20210417191320754-20230127151312-g8jrdjp.png","path":"assets/20210417191320754-20230127151312-g8jrdjp.png","modified":0,"renderable":0},{"_id":"source/assets/2d694736eb7778a548cdcb8189d6e226-20230127151312-riapszh.png","path":"assets/2d694736eb7778a548cdcb8189d6e226-20230127151312-riapszh.png","modified":0,"renderable":0},{"_id":"source/assets/327dcba48317d39b2cd0ee081d4e3fdc-20230127151312-4qigjlr.png","path":"assets/327dcba48317d39b2cd0ee081d4e3fdc-20230127151312-4qigjlr.png","modified":0,"renderable":0},{"_id":"source/assets/2edff9c3d5cb698abb0e62d720ad704b-20230127151311-dy2b8hg.png","path":"assets/2edff9c3d5cb698abb0e62d720ad704b-20230127151311-dy2b8hg.png","modified":0,"renderable":0},{"_id":"source/assets/39c6a500cefa6e29150c1295d3e152d1-20230127151312-5z7fqgr.png","path":"assets/39c6a500cefa6e29150c1295d3e152d1-20230127151312-5z7fqgr.png","modified":0,"renderable":0},{"_id":"source/assets/3fdc14e6be9f37b481abe633ac866a26-20230127151312-ko7ta8u.png","path":"assets/3fdc14e6be9f37b481abe633ac866a26-20230127151312-ko7ta8u.png","modified":0,"renderable":0},{"_id":"source/assets/640-20230404215050-p95bson.png","path":"assets/640-20230404215050-p95bson.png","modified":0,"renderable":0},{"_id":"source/assets/410360b70936d286a4df4ab2c11f28ad-20230127151311-j96gr8d.png","path":"assets/410360b70936d286a4df4ab2c11f28ad-20230127151311-j96gr8d.png","modified":0,"renderable":0},{"_id":"source/assets/640-20230404215050-qd8x4fd.png","path":"assets/640-20230404215050-qd8x4fd.png","modified":0,"renderable":0},{"_id":"source/assets/640-20230404215051-hnbb7ug.png","path":"assets/640-20230404215051-hnbb7ug.png","modified":0,"renderable":0},{"_id":"source/assets/640-20230404215051-lu967n5.png","path":"assets/640-20230404215051-lu967n5.png","modified":0,"renderable":0},{"_id":"source/assets/640-20230404215051-nrxnl0j.png","path":"assets/640-20230404215051-nrxnl0j.png","modified":0,"renderable":0},{"_id":"source/assets/640-20230404215051-pdghyi7.png","path":"assets/640-20230404215051-pdghyi7.png","modified":0,"renderable":0},{"_id":"source/assets/640-20230404215051-rx0ju25.png","path":"assets/640-20230404215051-rx0ju25.png","modified":0,"renderable":0},{"_id":"source/assets/6c916769e7f2450157bce49ea9438c10-20230127151312-x7ufhrj.png","path":"assets/6c916769e7f2450157bce49ea9438c10-20230127151312-x7ufhrj.png","modified":0,"renderable":0},{"_id":"source/assets/704e3015827edff48d6c84777aa28006-20230127151312-jonjh5w.png","path":"assets/704e3015827edff48d6c84777aa28006-20230127151312-jonjh5w.png","modified":0,"renderable":0},{"_id":"source/assets/83f121c9c340db46f955badf876220b2-20230127151311-j2wtijc.png","path":"assets/83f121c9c340db46f955badf876220b2-20230127151311-j2wtijc.png","modified":0,"renderable":0},{"_id":"source/assets/a0d8c504b2c17abbfb8eb40bc4d86d79-20230127151311-0azix9f.png","path":"assets/a0d8c504b2c17abbfb8eb40bc4d86d79-20230127151311-0azix9f.png","modified":0,"renderable":0},{"_id":"source/assets/b5e5ca9c35421192e7f02864c4fb30bb-20230127151311-iwgg2ln.png","path":"assets/b5e5ca9c35421192e7f02864c4fb30bb-20230127151311-iwgg2ln.png","modified":0,"renderable":0},{"_id":"source/assets/c2d8c43d5c018eb584586ad5857fbbf4-20230127151311-ml2ddae.png","path":"assets/c2d8c43d5c018eb584586ad5857fbbf4-20230127151311-ml2ddae.png","modified":0,"renderable":0},{"_id":"source/assets/da55da191ca558b60531e3a6b6ce5267-20230127151311-wiqzfgo.png","path":"assets/da55da191ca558b60531e3a6b6ce5267-20230127151311-wiqzfgo.png","modified":0,"renderable":0},{"_id":"source/assets/dubbo-export-20221214214601-bb3rzp9.jpg","path":"assets/dubbo-export-20221214214601-bb3rzp9.jpg","modified":0,"renderable":0},{"_id":"source/assets/dubbo-extension-20221214214601-56szafs.jpg","path":"assets/dubbo-extension-20221214214601-56szafs.jpg","modified":0,"renderable":0},{"_id":"source/assets/dubbo-framework-20221214214602-6xcgoty.jpg","path":"assets/dubbo-framework-20221214214602-6xcgoty.jpg","modified":0,"renderable":0},{"_id":"source/assets/dubbo-modules-20221214214601-dcxfz3a.jpg","path":"assets/dubbo-modules-20221214214601-dcxfz3a.jpg","modified":0,"renderable":0},{"_id":"source/assets/dubbo-refer-20221214214601-20gbi94.jpg","path":"assets/dubbo-refer-20221214214601-20gbi94.jpg","modified":0,"renderable":0},{"_id":"source/assets/dubbo-relation-20221214214601-7hb77fv.jpg","path":"assets/dubbo-relation-20221214214601-7hb77fv.jpg","modified":0,"renderable":0},{"_id":"source/assets/f0b471f40aa64279914a3acbd6e2913b-20230127151312-khh42zb.png","path":"assets/f0b471f40aa64279914a3acbd6e2913b-20230127151312-khh42zb.png","modified":0,"renderable":0},{"_id":"source/assets/ff614ca7c83414c712848a25b23e6a91-20230127151312-slrk125.png","path":"assets/ff614ca7c83414c712848a25b23e6a91-20230127151312-slrk125.png","modified":0,"renderable":0},{"_id":"source/assets/image-20221212232058-z1xl373.png","path":"assets/image-20221212232058-z1xl373.png","modified":0,"renderable":0},{"_id":"source/assets/image-20230218230318-0kn4aj5.png","path":"assets/image-20230218230318-0kn4aj5.png","modified":0,"renderable":0},{"_id":"source/assets/image-20230218230318-31t0a0v.png","path":"assets/image-20230218230318-31t0a0v.png","modified":0,"renderable":0},{"_id":"source/assets/image-20230218230318-cknlz85.png","path":"assets/image-20230218230318-cknlz85.png","modified":0,"renderable":0},{"_id":"source/assets/image-20230218230318-i0g5orx.png","path":"assets/image-20230218230318-i0g5orx.png","modified":0,"renderable":0},{"_id":"source/assets/image-20230218230318-nedvesv.png","path":"assets/image-20230218230318-nedvesv.png","modified":0,"renderable":0},{"_id":"source/assets/image-20230218230318-t4i4y3l.png","path":"assets/image-20230218230318-t4i4y3l.png","modified":0,"renderable":0},{"_id":"source/assets/image-20230218230318-t9tvsgp.png","path":"assets/image-20230218230318-t9tvsgp.png","modified":0,"renderable":0},{"_id":"source/assets/image-20230218230318-w95qpr6.png","path":"assets/image-20230218230318-w95qpr6.png","modified":0,"renderable":0},{"_id":"source/assets/image-20230218230318-ybffha3.png","path":"assets/image-20230218230318-ybffha3.png","modified":0,"renderable":0},{"_id":"source/assets/image-20230218230318-ye9g47h.png","path":"assets/image-20230218230318-ye9g47h.png","modified":0,"renderable":0},{"_id":"source/assets/image-20230218230318-ypt4n3t.png","path":"assets/image-20230218230318-ypt4n3t.png","modified":0,"renderable":0},{"_id":"source/assets/image-20230423172026-j99710c.png","path":"assets/image-20230423172026-j99710c.png","modified":0,"renderable":0},{"_id":"source/assets/image-20230424141422-t5zbclo.png","path":"assets/image-20230424141422-t5zbclo.png","modified":0,"renderable":0},{"_id":"source/assets/image-20230503214900-rmo1ydd.png","path":"assets/image-20230503214900-rmo1ydd.png","modified":0,"renderable":0},{"_id":"source/assets/image-20230505215709-q6pir67.png","path":"assets/image-20230505215709-q6pir67.png","modified":0,"renderable":0},{"_id":"source/assets/image-20230519215732-zz9jpqo.png","path":"assets/image-20230519215732-zz9jpqo.png","modified":0,"renderable":0},{"_id":"source/assets/image-20230527140729-waan312.png","path":"assets/image-20230527140729-waan312.png","modified":0,"renderable":0},{"_id":"source/assets/image-20230527154724-v674duu.png","path":"assets/image-20230527154724-v674duu.png","modified":0,"renderable":0},{"_id":"source/assets/image-20230619222624-l98xjgi.png","path":"assets/image-20230619222624-l98xjgi.png","modified":0,"renderable":0},{"_id":"source/assets/image-20230619222818-5btwdt3.png","path":"assets/image-20230619222818-5btwdt3.png","modified":0,"renderable":0},{"_id":"source/assets/image-20231117162020-0zic8ee.png","path":"assets/image-20231117162020-0zic8ee.png","modified":0,"renderable":0},{"_id":"source/assets/image-20231117162030-ue9pyz9.png","path":"assets/image-20231117162030-ue9pyz9.png","modified":0,"renderable":0},{"_id":"source/assets/image-20231117164621-qjdsktw.png","path":"assets/image-20231117164621-qjdsktw.png","modified":0,"renderable":0},{"_id":"source/assets/image-20231119124040-5kytmcz.png","path":"assets/image-20231119124040-5kytmcz.png","modified":0,"renderable":0},{"_id":"source/assets/image-20231119124137-6apottn.png","path":"assets/image-20231119124137-6apottn.png","modified":0,"renderable":0},{"_id":"source/assets/image-20231119124615-vxa33dm.png","path":"assets/image-20231119124615-vxa33dm.png","modified":0,"renderable":0},{"_id":"source/assets/image-20231119154230-3g5nidd.png","path":"assets/image-20231119154230-3g5nidd.png","modified":0,"renderable":0},{"_id":"source/assets/image-20231119154304-hwfdw8h.jpeg","path":"assets/image-20231119154304-hwfdw8h.jpeg","modified":0,"renderable":0},{"_id":"source/assets/image-20231126145713-0pou43f.png","path":"assets/image-20231126145713-0pou43f.png","modified":0,"renderable":0},{"_id":"source/assets/image-20231126155909-4zbslm1.png","path":"assets/image-20231126155909-4zbslm1.png","modified":0,"renderable":0},{"_id":"source/assets/image-20231126161709-b35di3t.png","path":"assets/image-20231126161709-b35di3t.png","modified":0,"renderable":0},{"_id":"source/assets/image-20231202123415-e2licnx.jpeg","path":"assets/image-20231202123415-e2licnx.jpeg","modified":0,"renderable":0},{"_id":"source/assets/net-img-0002-20230327194009-43b76u4.png","path":"assets/net-img-0002-20230327194009-43b76u4.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-0004-20230327194009-xusl7vj.png","path":"assets/net-img-0004-20230327194009-xusl7vj.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-0005-20230327194009-2m11zb7.png","path":"assets/net-img-0005-20230327194009-2m11zb7.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-0006-20230327194009-rdpidiy.png","path":"assets/net-img-0006-20230327194009-rdpidiy.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-0008-20230327194010-vj80p08.jpg","path":"assets/net-img-0008-20230327194010-vj80p08.jpg","modified":0,"renderable":0},{"_id":"source/assets/net-img-0009-20230327193706-lo1au43.jpg","path":"assets/net-img-0009-20230327193706-lo1au43.jpg","modified":0,"renderable":0},{"_id":"source/assets/net-img-0007-20230327194009-obwi5jv.png","path":"assets/net-img-0007-20230327194009-obwi5jv.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-0010-20230327194235-781jk47.png","path":"assets/net-img-0010-20230327194235-781jk47.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-0011-20230327194235-6us5fo3.png","path":"assets/net-img-0011-20230327194235-6us5fo3.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-0012-20230327194235-dpf6how.png","path":"assets/net-img-0012-20230327194235-dpf6how.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1582873055902-03de6700-dcb1-42a8-927e-af658b90b6b0-20230330213228-vjyh5tl.png","path":"assets/net-img-1582873055902-03de6700-dcb1-42a8-927e-af658b90b6b0-20230330213228-vjyh5tl.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1582873072467-a61dd6d9-f02a-4653-bcff-eeb592deaf68-20230330213234-ppelol3.png","path":"assets/net-img-1582873072467-a61dd6d9-f02a-4653-bcff-eeb592deaf68-20230330213234-ppelol3.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1582873090325-a7683e68-a46d-418f-bba5-0bd6c8c7575b-20230330213237-ldsjgn2.webp","path":"assets/net-img-1582873090325-a7683e68-a46d-418f-bba5-0bd6c8c7575b-20230330213237-ldsjgn2.webp","modified":0,"renderable":0},{"_id":"source/assets/net-img-1582873104499-77f0b1b3-a218-4cc7-9cd1-c5ab317f53ce-20230330213239-aq0b92g.png","path":"assets/net-img-1582873104499-77f0b1b3-a218-4cc7-9cd1-c5ab317f53ce-20230330213239-aq0b92g.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1582873144333-18753191-d8b2-47e1-a610-33c7c552fdaa-20230330213217-uigw9ix.png","path":"assets/net-img-1582873144333-18753191-d8b2-47e1-a610-33c7c552fdaa-20230330213217-uigw9ix.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1582873156123-9f655847-4b5d-4c84-8116-ede849af16e3-20230330213218-q1lh95h.png","path":"assets/net-img-1582873156123-9f655847-4b5d-4c84-8116-ede849af16e3-20230330213218-q1lh95h.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1582873335047-0818927f-77de-4ad8-aa95-fb7d537f6700-20230330213215-9u0gs7n.webp","path":"assets/net-img-1582873335047-0818927f-77de-4ad8-aa95-fb7d537f6700-20230330213215-9u0gs7n.webp","modified":0,"renderable":0},{"_id":"source/assets/net-img-1582873408415-b3e28487-6473-4fff-b4c9-b99b6b91a53a-20230330213216-4pmp0ac.webp","path":"assets/net-img-1582873408415-b3e28487-6473-4fff-b4c9-b99b6b91a53a-20230330213216-4pmp0ac.webp","modified":0,"renderable":0},{"_id":"source/assets/net-img-1582873416741-a71a0d28-b66d-49ca-8487-c0e0ceaa704c-20230330213216-jddkbfu.webp","path":"assets/net-img-1582873416741-a71a0d28-b66d-49ca-8487-c0e0ceaa704c-20230330213216-jddkbfu.webp","modified":0,"renderable":0},{"_id":"source/assets/net-img-1582873565810-556fde0f-9973-46d5-9e8e-4853e80b6ba3-20230330213302-b5p12uc.png","path":"assets/net-img-1582873565810-556fde0f-9973-46d5-9e8e-4853e80b6ba3-20230330213302-b5p12uc.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1582873583782-b5959bc6-9ff9-4ef1-95b3-9bc3fc1f83b9-20230330213307-m55wdql.png","path":"assets/net-img-1582873583782-b5959bc6-9ff9-4ef1-95b3-9bc3fc1f83b9-20230330213307-m55wdql.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1582873589321-1b21962d-3411-4d4f-af00-b2a82490e43c-20230330213311-i7hquya.png","path":"assets/net-img-1582873589321-1b21962d-3411-4d4f-af00-b2a82490e43c-20230330213311-i7hquya.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1582873594959-8501a655-dbe2-4983-9dcd-a33bde8f07f6-20230330213317-uu5k36v.png","path":"assets/net-img-1582873594959-8501a655-dbe2-4983-9dcd-a33bde8f07f6-20230330213317-uu5k36v.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1582873601269-c3ee8a62-7c38-4751-8cff-f60ddc262d41-20230330213313-8vw56oe.png","path":"assets/net-img-1582873601269-c3ee8a62-7c38-4751-8cff-f60ddc262d41-20230330213313-8vw56oe.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1582873690823-e85d7b31-4173-4adc-b4b4-92f314fd952b-20230330213322-ngp5u86.webp","path":"assets/net-img-1582873690823-e85d7b31-4173-4adc-b4b4-92f314fd952b-20230330213322-ngp5u86.webp","modified":0,"renderable":0},{"_id":"source/assets/net-img-1582873927778-b80fd046-98af-4768-bfc1-6d59761271e2-20230330213325-w0s4a7u.png","path":"assets/net-img-1582873927778-b80fd046-98af-4768-bfc1-6d59761271e2-20230330213325-w0s4a7u.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1582873928532-40dd13b8-87fb-4ecd-8e07-399dbc61eeb8-20230330213331-q75g2s7.png","path":"assets/net-img-1582873928532-40dd13b8-87fb-4ecd-8e07-399dbc61eeb8-20230330213331-q75g2s7.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1582873954652-cd9e9eab-021c-4792-9558-291d9ec5d743-20230330213333-aijfe0m.png","path":"assets/net-img-1582873954652-cd9e9eab-021c-4792-9558-291d9ec5d743-20230330213333-aijfe0m.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1582874001071-2fe5ab73-14e5-45aa-b07c-81ba0fecc256-20230330213404-cm5njiz.png","path":"assets/net-img-1582874001071-2fe5ab73-14e5-45aa-b07c-81ba0fecc256-20230330213404-cm5njiz.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1582874136797-a333d011-4325-4f7c-82f6-9792216b1a21-20230330213157-i9zy78v.webp","path":"assets/net-img-1582874136797-a333d011-4325-4f7c-82f6-9792216b1a21-20230330213157-i9zy78v.webp","modified":0,"renderable":0},{"_id":"source/assets/net-img-1582874168420-5865fe9a-fe6d-49b5-961a-2addc05fce6a-20230330213157-z8hfg9r.webp","path":"assets/net-img-1582874168420-5865fe9a-fe6d-49b5-961a-2addc05fce6a-20230330213157-z8hfg9r.webp","modified":0,"renderable":0},{"_id":"source/assets/net-img-1582874168964-bb84b249-5332-4a93-b161-842b2e6955ed-20230330213157-wrr6xqk.webp","path":"assets/net-img-1582874168964-bb84b249-5332-4a93-b161-842b2e6955ed-20230330213157-wrr6xqk.webp","modified":0,"renderable":0},{"_id":"source/assets/net-img-1582874243939-2eae4163-881d-47f6-b75d-18c057db48ef-20230330213158-setmh7t.webp","path":"assets/net-img-1582874243939-2eae4163-881d-47f6-b75d-18c057db48ef-20230330213158-setmh7t.webp","modified":0,"renderable":0},{"_id":"source/assets/net-img-1582874263210-a9e7bda6-4ed7-4d2d-8991-cdad8a2c292b-20230330213158-fukp6eb.png","path":"assets/net-img-1582874263210-a9e7bda6-4ed7-4d2d-8991-cdad8a2c292b-20230330213158-fukp6eb.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1582874272168-5169d4d6-17f9-493d-b99b-c9a678dd13da-20230330213159-jscv9ip.webp","path":"assets/net-img-1582874272168-5169d4d6-17f9-493d-b99b-c9a678dd13da-20230330213159-jscv9ip.webp","modified":0,"renderable":0},{"_id":"source/assets/net-img-1582874279332-65260fd7-5a39-4fd1-85b8-86729cc9982c-20230330213159-yohdmn5.webp","path":"assets/net-img-1582874279332-65260fd7-5a39-4fd1-85b8-86729cc9982c-20230330213159-yohdmn5.webp","modified":0,"renderable":0},{"_id":"source/assets/net-img-1582874334522-3936dfde-ef4a-4cf9-ab86-6001429fbb86-20230330213343-txdiivw.jpeg","path":"assets/net-img-1582874334522-3936dfde-ef4a-4cf9-ab86-6001429fbb86-20230330213343-txdiivw.jpeg","modified":0,"renderable":0},{"_id":"source/assets/net-img-1582874350036-1fb8d7cf-688f-4628-ae77-9a21de7c4d2e-20230330213346-aj91hqy.png","path":"assets/net-img-1582874350036-1fb8d7cf-688f-4628-ae77-9a21de7c4d2e-20230330213346-aj91hqy.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1582875290415-c052f229-8c31-4560-acef-300acae2409b-20221030135515-tme9bzx.png","path":"assets/net-img-1582875290415-c052f229-8c31-4560-acef-300acae2409b-20221030135515-tme9bzx.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1582875326094-cb5a96e7-e4c2-421d-83cf-216ca4f7f024-20221030135516-5igfhr6.png","path":"assets/net-img-1582875326094-cb5a96e7-e4c2-421d-83cf-216ca4f7f024-20221030135516-5igfhr6.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1582875326657-55738037-28bf-4de9-925a-f08034e0c722-20221030135516-j4ktjne.png","path":"assets/net-img-1582875326657-55738037-28bf-4de9-925a-f08034e0c722-20221030135516-j4ktjne.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1582875381841-0104c814-acd3-4ef3-a3bd-f5331d9a06bc-20221030135516-0716ftg.png","path":"assets/net-img-1582875381841-0104c814-acd3-4ef3-a3bd-f5331d9a06bc-20221030135516-0716ftg.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1582875390665-923c52b9-52ce-4e6f-9cee-763046546af3-20221030135517-j4zeqi7.png","path":"assets/net-img-1582875390665-923c52b9-52ce-4e6f-9cee-763046546af3-20221030135517-j4zeqi7.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1582875399701-d03e5b25-a1c9-498e-85d6-18f86f41e38f-20221030135517-a6hu6sv.png","path":"assets/net-img-1582875399701-d03e5b25-a1c9-498e-85d6-18f86f41e38f-20221030135517-a6hu6sv.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1582875452927-44c67a88-5cee-48b1-a764-a26d40a77538-20221030135540-f7dfpln.png","path":"assets/net-img-1582875452927-44c67a88-5cee-48b1-a764-a26d40a77538-20221030135540-f7dfpln.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1582875462202-61de3608-d606-44f6-b8d0-c82da3a7acd8-20221030135541-a1152vd.png","path":"assets/net-img-1582875462202-61de3608-d606-44f6-b8d0-c82da3a7acd8-20221030135541-a1152vd.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1582875470139-ea71ffbe-3cbd-44d8-8560-1e72b3a4bab4-20221030135541-hkuw6hs.png","path":"assets/net-img-1582875470139-ea71ffbe-3cbd-44d8-8560-1e72b3a4bab4-20221030135541-hkuw6hs.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1582875478351-18a69ed7-cb09-4a5a-a020-097490219718-20221030135517-0h9pq4n.png","path":"assets/net-img-1582875478351-18a69ed7-cb09-4a5a-a020-097490219718-20221030135517-0h9pq4n.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1582875574292-5a9c3846-0673-451f-8a69-409c0c8dff9c-20221030103933-qh2ia8u.png","path":"assets/net-img-1582875574292-5a9c3846-0673-451f-8a69-409c0c8dff9c-20221030103933-qh2ia8u.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1582875605484-a8880998-f9be-42d5-9997-a1c908ca05a9-20221030103933-jzsw591.webp","path":"assets/net-img-1582875605484-a8880998-f9be-42d5-9997-a1c908ca05a9-20221030103933-jzsw591.webp","modified":0,"renderable":0},{"_id":"source/assets/net-img-1591690708309-b6db1e95-1bbf-4140-b612-26fefc8d85b5-20221030132327-6s3ed7l.png","path":"assets/net-img-1591690708309-b6db1e95-1bbf-4140-b612-26fefc8d85b5-20221030132327-6s3ed7l.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1591690708399-bf1076aa-bdad-4e5f-ae30-261ccda91da5-20221030132327-4fweook.png","path":"assets/net-img-1591690708399-bf1076aa-bdad-4e5f-ae30-261ccda91da5-20221030132327-4fweook.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1591690708492-8b43720d-e8dc-4e22-9057-dcc4be2210de-20221030132325-ac88yvu.jpeg","path":"assets/net-img-1591690708492-8b43720d-e8dc-4e22-9057-dcc4be2210de-20221030132325-ac88yvu.jpeg","modified":0,"renderable":0},{"_id":"source/assets/net-img-1591690708909-03b304db-aa14-40fc-954b-2e5812e31b86-20221030132326-7iwfv9t.png","path":"assets/net-img-1591690708909-03b304db-aa14-40fc-954b-2e5812e31b86-20221030132326-7iwfv9t.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1591690908749-8d13658b-f28f-4a16-9787-5d802366b2bb-20221030132339-jhzqts2.png","path":"assets/net-img-1591690908749-8d13658b-f28f-4a16-9787-5d802366b2bb-20221030132339-jhzqts2.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1592902119376-b0ab487a-f7f3-454f-a784-aad737462ad4-20230330213502-h755rwl.png","path":"assets/net-img-1592902119376-b0ab487a-f7f3-454f-a784-aad737462ad4-20230330213502-h755rwl.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1592902119321-dda9e910-093f-47bf-890e-4719cb145075-20230527145229-565b500.png","path":"assets/net-img-1592902119321-dda9e910-093f-47bf-890e-4719cb145075-20230527145229-565b500.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1592902119376-b0ab487a-f7f3-454f-a784-aad737462ad4-20230527145229-vu7qxs4.png","path":"assets/net-img-1592902119376-b0ab487a-f7f3-454f-a784-aad737462ad4-20230527145229-vu7qxs4.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1592902120990-cffe2ea4-a4ed-4505-8bbd-c9b64730ae6e-20230527145229-4455z5v.png","path":"assets/net-img-1592902120990-cffe2ea4-a4ed-4505-8bbd-c9b64730ae6e-20230527145229-4455z5v.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1593008781064-94397bdb-4bd4-475a-b0de-25689df5598d-20230330213216-bqv0b3r.jpeg","path":"assets/net-img-1593008781064-94397bdb-4bd4-475a-b0de-25689df5598d-20230330213216-bqv0b3r.jpeg","modified":0,"renderable":0},{"_id":"source/assets/net-img-1593008911203-7a81af80-db8b-4843-a59a-755e226e2314-20230330213217-h350tsl.jpeg","path":"assets/net-img-1593008911203-7a81af80-db8b-4843-a59a-755e226e2314-20230330213217-h350tsl.jpeg","modified":0,"renderable":0},{"_id":"source/assets/net-img-1593009574123-1720bb9a-11ab-462c-9acc-83dfd40a63e3-20230330213217-8hneydr.jpeg","path":"assets/net-img-1593009574123-1720bb9a-11ab-462c-9acc-83dfd40a63e3-20230330213217-8hneydr.jpeg","modified":0,"renderable":0},{"_id":"source/assets/net-img-1593010056655-793ce18b-c4e9-4985-9ba7-ef5347134e12-20230330213219-q7hvhww.png","path":"assets/net-img-1593010056655-793ce18b-c4e9-4985-9ba7-ef5347134e12-20230330213219-q7hvhww.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1593010032163-e4fd6098-299b-4fac-adb3-b40e6ca3e534-20230330213218-jvzy0d2.png","path":"assets/net-img-1593010032163-e4fd6098-299b-4fac-adb3-b40e6ca3e534-20230330213218-jvzy0d2.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1593075294735-276336e9-41de-469d-a9e8-b4806bbdc0e9-20230330213341-wrzblbs.png","path":"assets/net-img-1593075294735-276336e9-41de-469d-a9e8-b4806bbdc0e9-20230330213341-wrzblbs.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1593075259316-cba6509a-9a9a-4282-8698-99fa1fcc0794-20230330213350-b5wkbl5.png","path":"assets/net-img-1593075259316-cba6509a-9a9a-4282-8698-99fa1fcc0794-20230330213350-b5wkbl5.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1593075298003-cebf8380-65e8-4a56-9a03-72d7f02ef65c-20230330213346-itjo56n.png","path":"assets/net-img-1593075298003-cebf8380-65e8-4a56-9a03-72d7f02ef65c-20230330213346-itjo56n.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1593075308254-c4ace563-ded0-42d8-8a4c-435a8bbe890f-20230330213356-yp75ww5.png","path":"assets/net-img-1593075308254-c4ace563-ded0-42d8-8a4c-435a8bbe890f-20230330213356-yp75ww5.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1593075466359-4fe25412-ad7b-4d12-ab59-556c6203aec3-20230330213411-owuofo8.png","path":"assets/net-img-1593075466359-4fe25412-ad7b-4d12-ab59-556c6203aec3-20230330213411-owuofo8.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1593075485480-eabde977-18f7-4a38-9f43-2a2792d14d5a-20230330213419-xbq6pfl.png","path":"assets/net-img-1593075485480-eabde977-18f7-4a38-9f43-2a2792d14d5a-20230330213419-xbq6pfl.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1593075510764-fa7e6f63-dbec-4789-a374-d8b319f98994-20230330213428-853fmb5.png","path":"assets/net-img-1593075510764-fa7e6f63-dbec-4789-a374-d8b319f98994-20230330213428-853fmb5.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1593076022539-0b41a928-a33d-4749-8e05-a629389f5b11-20230330213208-977tliz.png","path":"assets/net-img-1593076022539-0b41a928-a33d-4749-8e05-a629389f5b11-20230330213208-977tliz.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1593076049581-f084ed7e-111c-4a99-944b-bb4aadb0f33b-20230330213209-kp1deud.png","path":"assets/net-img-1593076049581-f084ed7e-111c-4a99-944b-bb4aadb0f33b-20230330213209-kp1deud.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1593076060148-a751342f-828e-49f2-a853-47b276d0fc68-20230330213209-k1w1si6.png","path":"assets/net-img-1593076060148-a751342f-828e-49f2-a853-47b276d0fc68-20230330213209-k1w1si6.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1593076076024-42ad7f21-eb2c-4c6b-8c34-802819b1fd8f-20230330213209-f5hjado.png","path":"assets/net-img-1593076076024-42ad7f21-eb2c-4c6b-8c34-802819b1fd8f-20230330213209-f5hjado.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1593076140792-4ab064fd-2370-4f64-a89e-6d7fc5bb9f39-20230330213209-drma95r.png","path":"assets/net-img-1593076140792-4ab064fd-2370-4f64-a89e-6d7fc5bb9f39-20230330213209-drma95r.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1593854466438-89baf576-0e30-4db7-934e-2781413c9510-20221030140124-w8acjeh.png","path":"assets/net-img-1593854466438-89baf576-0e30-4db7-934e-2781413c9510-20221030140124-w8acjeh.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1596005642573-853dc49e-7632-496d-9221-33e3b7879fea-20221030132325-84wdxkw.jpeg","path":"assets/net-img-1596005642573-853dc49e-7632-496d-9221-33e3b7879fea-20221030132325-84wdxkw.jpeg","modified":0,"renderable":0},{"_id":"source/assets/net-img-1596361953803-ed588642-562c-49e8-99dd-cdc0e81519b7-20230426150127-crjga75.png","path":"assets/net-img-1596361953803-ed588642-562c-49e8-99dd-cdc0e81519b7-20230426150127-crjga75.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1596249786159-92610d33-5cbb-4d46-b7a5-6f1c8d3d1d92-20221030135516-9i6hh1r.jpeg","path":"assets/net-img-1596249786159-92610d33-5cbb-4d46-b7a5-6f1c8d3d1d92-20221030135516-9i6hh1r.jpeg","modified":0,"renderable":0},{"_id":"source/assets/net-img-1596362023744-7f76e71b-8cd9-4797-87f7-bccdb93fbb3a-20221030140106-k1plvtd.jpeg","path":"assets/net-img-1596362023744-7f76e71b-8cd9-4797-87f7-bccdb93fbb3a-20221030140106-k1plvtd.jpeg","modified":0,"renderable":0},{"_id":"source/assets/net-img-1596783175795-a3a09f05-cdc6-4406-9b0a-0f3f6a28a5ff-20221030105031-64rpjno.jpeg","path":"assets/net-img-1596783175795-a3a09f05-cdc6-4406-9b0a-0f3f6a28a5ff-20221030105031-64rpjno.jpeg","modified":0,"renderable":0},{"_id":"source/assets/net-img-1596783496811-3a6ed88c-bb38-40b7-aaf3-ca98b12493f2-20221030105031-aijlekh.jpeg","path":"assets/net-img-1596783496811-3a6ed88c-bb38-40b7-aaf3-ca98b12493f2-20221030105031-aijlekh.jpeg","modified":0,"renderable":0},{"_id":"source/assets/net-img-1602123134723-ab15ac69-5397-4422-8dcf-3c43f4a10e06-20221030124512-4k4z367.png","path":"assets/net-img-1602123134723-ab15ac69-5397-4422-8dcf-3c43f4a10e06-20221030124512-4k4z367.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1602123013155-86ac51db-7d0a-4241-8094-f1fe2e16b43c-20221030124512-fqt8gu2.png","path":"assets/net-img-1602123013155-86ac51db-7d0a-4241-8094-f1fe2e16b43c-20221030124512-fqt8gu2.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1602404087657-9aa12bdc-ba61-429f-bf21-dcf0efc211fa-20221030124615-fz11c88.png","path":"assets/net-img-1602404087657-9aa12bdc-ba61-429f-bf21-dcf0efc211fa-20221030124615-fz11c88.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1602405124816-7ec65b09-2556-4ba3-b9ca-dabf0081929f-20230330213836-e0kef3p.png","path":"assets/net-img-1602405124816-7ec65b09-2556-4ba3-b9ca-dabf0081929f-20230330213836-e0kef3p.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1602510155856-cf2ddad6-d6bb-4ea0-bb8c-f9b1dc49cee8-20221030124433-3c4w0ya.png","path":"assets/net-img-1602510155856-cf2ddad6-d6bb-4ea0-bb8c-f9b1dc49cee8-20221030124433-3c4w0ya.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1602914807774-75634a6f-e238-498a-b0ce-e27f039a9646-20221030124604-ehzp01i.png","path":"assets/net-img-1602914807774-75634a6f-e238-498a-b0ce-e27f039a9646-20221030124604-ehzp01i.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1602920769113-5b1bf8b5-f2b3-4a36-948b-721849b796d7-20221030124537-xtsxn6h.png","path":"assets/net-img-1602920769113-5b1bf8b5-f2b3-4a36-948b-721849b796d7-20221030124537-xtsxn6h.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1602998399972-d63036ef-500b-49ae-a31a-84a558efb1ae-20221030124502-upt9d1p.png","path":"assets/net-img-1602998399972-d63036ef-500b-49ae-a31a-84a558efb1ae-20221030124502-upt9d1p.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1603004208800-d47ee0f7-24fa-4b06-ae5f-8ce7b97e1e34-20221030124351-wgmd1lo.png","path":"assets/net-img-1603004208800-d47ee0f7-24fa-4b06-ae5f-8ce7b97e1e34-20221030124351-wgmd1lo.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1603013197743-541a8456-5d1b-477d-9658-1b6d5c06780a-20230330213832-g2oqx3t.png","path":"assets/net-img-1603013197743-541a8456-5d1b-477d-9658-1b6d5c06780a-20230330213832-g2oqx3t.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1603013239640-a2f1a79b-35c2-4ca8-9355-5f37e9d680bb-20221030124448-sl4zele.png","path":"assets/net-img-1603013239640-a2f1a79b-35c2-4ca8-9355-5f37e9d680bb-20221030124448-sl4zele.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1603013275619-1a15e41e-436b-41ef-bce1-147db82e5a83-20221030124522-yeb4ilf.png","path":"assets/net-img-1603013275619-1a15e41e-436b-41ef-bce1-147db82e5a83-20221030124522-yeb4ilf.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1603013309762-3689744a-be23-4e8f-8487-d397b3cc7869-20221030124624-9buvwxc.png","path":"assets/net-img-1603013309762-3689744a-be23-4e8f-8487-d397b3cc7869-20221030124624-9buvwxc.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1615533992554-f7ecd3db-e7d5-4f29-b845-a22cb39dee76-20230426150127-m6xofsl.png","path":"assets/net-img-1615533992554-f7ecd3db-e7d5-4f29-b845-a22cb39dee76-20230426150127-m6xofsl.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1615535960262-7646f229-98d2-4474-be5c-3e5dd3c3e7ac-20221030140153-c14thj0.png","path":"assets/net-img-1615535960262-7646f229-98d2-4474-be5c-3e5dd3c3e7ac-20221030140153-c14thj0.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1615611389351-2cfaa4d5-b52c-4a2e-a170-c32ce97d17a6-20221030135532-u420fpk.png","path":"assets/net-img-1615611389351-2cfaa4d5-b52c-4a2e-a170-c32ce97d17a6-20221030135532-u420fpk.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1615611389351-2cfaa4d5-b52c-4a2e-a170-c32ce97d17a6-20230330213518-3fydrb9.png","path":"assets/net-img-1615611389351-2cfaa4d5-b52c-4a2e-a170-c32ce97d17a6-20230330213518-3fydrb9.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1615611419969-14ba7126-9f92-482c-a851-9898cece7e8f-20221030135532-6itdbiz.png","path":"assets/net-img-1615611419969-14ba7126-9f92-482c-a851-9898cece7e8f-20221030135532-6itdbiz.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1615611419969-14ba7126-9f92-482c-a851-9898cece7e8f-20230330213518-2ptpa3a.png","path":"assets/net-img-1615611419969-14ba7126-9f92-482c-a851-9898cece7e8f-20230330213518-2ptpa3a.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1615614053644-2e45ea92-d426-42ca-a609-91b095ff7e83-20221030135532-iwc3p25.png","path":"assets/net-img-1615614053644-2e45ea92-d426-42ca-a609-91b095ff7e83-20221030135532-iwc3p25.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1615614053644-2e45ea92-d426-42ca-a609-91b095ff7e83-20230330213519-1im5mrq.png","path":"assets/net-img-1615614053644-2e45ea92-d426-42ca-a609-91b095ff7e83-20230330213519-1im5mrq.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1615619423077-dea312ee-787e-4a28-b723-199f76a214f7-20221030135542-mx20k3e.png","path":"assets/net-img-1615619423077-dea312ee-787e-4a28-b723-199f76a214f7-20221030135542-mx20k3e.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1615619453470-bdab6e23-1385-4538-9c91-ceefcd05aa27-20221030135542-vyoxljv.png","path":"assets/net-img-1615619453470-bdab6e23-1385-4538-9c91-ceefcd05aa27-20221030135542-vyoxljv.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1623829860526-2438b2e1-de01-4c73-aa21-84e18c00d37c-20221031123408-wcse42k.png","path":"assets/net-img-1623829860526-2438b2e1-de01-4c73-aa21-84e18c00d37c-20221031123408-wcse42k.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1624106093230-4372b31c-0d0f-4640-8e80-62b7bdd258e4-20230122192859-kbq2rlz.png","path":"assets/net-img-1624106093230-4372b31c-0d0f-4640-8e80-62b7bdd258e4-20230122192859-kbq2rlz.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1624109586831-fa30fbaf-01b4-4243-bedf-eedfe9631e67-20230122192859-buewr2p.png","path":"assets/net-img-1624109586831-fa30fbaf-01b4-4243-bedf-eedfe9631e67-20230122192859-buewr2p.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1625277244322-1304b001-049b-467f-9207-4012228cca38-20221031123243-oqmq9cu.jpeg","path":"assets/net-img-1625277244322-1304b001-049b-467f-9207-4012228cca38-20221031123243-oqmq9cu.jpeg","modified":0,"renderable":0},{"_id":"source/assets/net-img-1626851086718-49fece61-64f3-4f2e-9b78-f97e17176373-20230101203426-dn382za.png","path":"assets/net-img-1626851086718-49fece61-64f3-4f2e-9b78-f97e17176373-20230101203426-dn382za.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1626851420391-9aa6cf8f-fa40-49c3-8a7a-941763583502-20230101203427-ybsosns.png","path":"assets/net-img-1626851420391-9aa6cf8f-fa40-49c3-8a7a-941763583502-20230101203427-ybsosns.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1626854477699-226d8221-ae45-44f5-b8fd-6003efd2531c-20230101203427-giho3sf.png","path":"assets/net-img-1626854477699-226d8221-ae45-44f5-b8fd-6003efd2531c-20230101203427-giho3sf.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1627291037100-eacf8101-ce28-4c56-9c4b-12e59e5a3b26-20221031123408-gsirdhu.jpeg","path":"assets/net-img-1627291037100-eacf8101-ce28-4c56-9c4b-12e59e5a3b26-20221031123408-gsirdhu.jpeg","modified":0,"renderable":0},{"_id":"source/assets/net-img-1627455003158-01c028a9-eb52-46e6-85ab-c811d640a84d-20221031123409-s3v35p9.jpeg","path":"assets/net-img-1627455003158-01c028a9-eb52-46e6-85ab-c811d640a84d-20221031123409-s3v35p9.jpeg","modified":0,"renderable":0},{"_id":"source/assets/net-img-1628324723790-e7e469c7-62d0-4076-aa53-5e937ae80bee-20230122192859-e7kchm7.jpeg","path":"assets/net-img-1628324723790-e7e469c7-62d0-4076-aa53-5e937ae80bee-20230122192859-e7kchm7.jpeg","modified":0,"renderable":0},{"_id":"source/assets/net-img-1628905841173-c32bdb25-8b61-4f16-b08e-96898d7aeefc-20221031123444-2pva1h4.png","path":"assets/net-img-1628905841173-c32bdb25-8b61-4f16-b08e-96898d7aeefc-20221031123444-2pva1h4.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1629558034184-e1fe6601-777e-4a34-afe5-df37e5a9b720-20230330213445-e5uive7.png","path":"assets/net-img-1629558034184-e1fe6601-777e-4a34-afe5-df37e5a9b720-20230330213445-e5uive7.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1629559055065-5ad8d49f-81b6-45f3-87f8-c98716f799ed-20230330213451-7nkjlzc.png","path":"assets/net-img-1629559055065-5ad8d49f-81b6-45f3-87f8-c98716f799ed-20230330213451-7nkjlzc.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1629559366006-0194df18-86f2-45fd-bd85-6f675b19bdb0-20230330213459-p7i5mm5.png","path":"assets/net-img-1629559366006-0194df18-86f2-45fd-bd85-6f675b19bdb0-20230330213459-p7i5mm5.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1629560137959-ab93eb78-c083-4c80-8283-4cfc470c8af0-20230330213504-cteixk9.png","path":"assets/net-img-1629560137959-ab93eb78-c083-4c80-8283-4cfc470c8af0-20230330213504-cteixk9.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1629870852837-ca139768-9f26-412a-8940-49ed6e38f57a-20230330213513-n1dmxgm.png","path":"assets/net-img-1629870852837-ca139768-9f26-412a-8940-49ed6e38f57a-20230330213513-n1dmxgm.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1631431982904-ce964c3b-4c64-4915-84a9-a3799dd2cf92-20230330213415-i9cgn1s.png","path":"assets/net-img-1631431982904-ce964c3b-4c64-4915-84a9-a3799dd2cf92-20230330213415-i9cgn1s.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1631436389678-e6910ed9-8e3c-4d73-93bf-362566a4ebb0-20230330213421-crfgpeh.png","path":"assets/net-img-1631436389678-e6910ed9-8e3c-4d73-93bf-362566a4ebb0-20230330213421-crfgpeh.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1639574230606-ee713d6a-1223-4275-bfaa-f60258aa6eea-20221030132914-2yfiwaf.jpeg","path":"assets/net-img-1639574230606-ee713d6a-1223-4275-bfaa-f60258aa6eea-20221030132914-2yfiwaf.jpeg","modified":0,"renderable":0},{"_id":"source/assets/net-img-1645242293838-01142675-6027-4b29-8f4d-1d872c2d6cea-20221030140106-8zicdb0.png","path":"assets/net-img-1645242293838-01142675-6027-4b29-8f4d-1d872c2d6cea-20221030140106-8zicdb0.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1646740660775-762fcaa3-26b5-4d95-ac43-5cca58540969-20230330213439-sxz1b5i.png","path":"assets/net-img-1646740660775-762fcaa3-26b5-4d95-ac43-5cca58540969-20230330213439-sxz1b5i.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1665073234010-c17ae82e-6da7-479a-ba1c-b1543abba0d5-20221111215525-80jshsc.png","path":"assets/net-img-1665073234010-c17ae82e-6da7-479a-ba1c-b1543abba0d5-20221111215525-80jshsc.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1646742883104-4eef3a95-3655-44f4-8887-2f5f1628732e-20230330213506-2xv20ln.png","path":"assets/net-img-1646742883104-4eef3a95-3655-44f4-8887-2f5f1628732e-20230330213506-2xv20ln.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1665073313636-93fb8cb7-e679-4c0f-8067-885d28f67ded-20221111215526-vcl9xfw.png","path":"assets/net-img-1665073313636-93fb8cb7-e679-4c0f-8067-885d28f67ded-20221111215526-vcl9xfw.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1665073347225-5388dfc6-3fc2-4492-902c-b7fcd02f3245-20221111215525-4h0vo0n.png","path":"assets/net-img-1665073347225-5388dfc6-3fc2-4492-902c-b7fcd02f3245-20221111215525-4h0vo0n.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1665073353104-76e6707d-af7c-4e84-97dd-7458adee7994-20221111215525-0zkzrc2.png","path":"assets/net-img-1665073353104-76e6707d-af7c-4e84-97dd-7458adee7994-20221111215525-0zkzrc2.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1665073358729-865ac7d0-89b5-4cc8-814e-a892038da58b-20221111215525-k257bcx.png","path":"assets/net-img-1665073358729-865ac7d0-89b5-4cc8-814e-a892038da58b-20221111215525-k257bcx.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1665073365265-002fd960-3cab-45d5-a547-968487191335-20221111215525-51j8yv0.png","path":"assets/net-img-1665073365265-002fd960-3cab-45d5-a547-968487191335-20221111215525-51j8yv0.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1665073370943-3b2e7f1c-7c9a-46a3-9e37-31742edea2f4-20221111215525-xb7w2cn.png","path":"assets/net-img-1665073370943-3b2e7f1c-7c9a-46a3-9e37-31742edea2f4-20221111215525-xb7w2cn.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1665073398713-d6f47c91-e7a2-407a-9cc0-de52b301cf26-20221111215526-gwi38jk.png","path":"assets/net-img-1665073398713-d6f47c91-e7a2-407a-9cc0-de52b301cf26-20221111215526-gwi38jk.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1665073405592-73518a43-9c02-4d55-baee-bafcff044efe-20221111215526-c9mhwt8.png","path":"assets/net-img-1665073405592-73518a43-9c02-4d55-baee-bafcff044efe-20221111215526-c9mhwt8.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1665073414310-928255a5-b8a0-4a7b-817f-dbabda18feef-20221111215526-c0gy94f.png","path":"assets/net-img-1665073414310-928255a5-b8a0-4a7b-817f-dbabda18feef-20221111215526-c0gy94f.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1665073424520-10dfe592-ea00-4ea5-b46e-992601919f1f-20221111215526-q1f6my9.png","path":"assets/net-img-1665073424520-10dfe592-ea00-4ea5-b46e-992601919f1f-20221111215526-q1f6my9.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1665073433573-ed1fdba5-d19f-40c2-a4f9-96a6ddbff0d2-20221111215526-5pgyp70.png","path":"assets/net-img-1665073433573-ed1fdba5-d19f-40c2-a4f9-96a6ddbff0d2-20221111215526-5pgyp70.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1665073440336-5f261660-b58b-4c06-9c1d-f21c0865e31c-20221111215526-0s6pvi9.png","path":"assets/net-img-1665073440336-5f261660-b58b-4c06-9c1d-f21c0865e31c-20221111215526-0s6pvi9.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1665073448391-a1d5eef7-134c-4b01-9c2e-2df8cc9ec893-20221111215526-gp8xqtg.png","path":"assets/net-img-1665073448391-a1d5eef7-134c-4b01-9c2e-2df8cc9ec893-20221111215526-gp8xqtg.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1665073460709-ab3783c9-f4f3-46ae-ab45-fe489a701313-20221111215526-4cnfbe6.png","path":"assets/net-img-1665073460709-ab3783c9-f4f3-46ae-ab45-fe489a701313-20221111215526-4cnfbe6.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1665073467540-2062cc90-042f-4ea8-8dbc-1afa0c8232c7-20221111215527-13hnynb.png","path":"assets/net-img-1665073467540-2062cc90-042f-4ea8-8dbc-1afa0c8232c7-20221111215527-13hnynb.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1665073473485-b4b83d79-2af4-4681-9d50-1c9096dc935c-20221111215527-zawp2eq.png","path":"assets/net-img-1665073473485-b4b83d79-2af4-4681-9d50-1c9096dc935c-20221111215527-zawp2eq.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1665073484287-631d0da3-1bb4-4881-b567-647d058f4f47-20221111215527-l67jrtu.png","path":"assets/net-img-1665073484287-631d0da3-1bb4-4881-b567-647d058f4f47-20221111215527-l67jrtu.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1665073567805-1c681335-41e9-40c3-a02a-0155e0383924-20221111215527-s7tudvn.png","path":"assets/net-img-1665073567805-1c681335-41e9-40c3-a02a-0155e0383924-20221111215527-s7tudvn.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1665073576092-3eea97da-b483-4acc-a6fd-eece98224cd0-20221111215527-fr7igf9.png","path":"assets/net-img-1665073576092-3eea97da-b483-4acc-a6fd-eece98224cd0-20221111215527-fr7igf9.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1665073584346-6bc72f6a-0e4a-412e-94bc-81d860d5b059-20221111215527-k046iu2.png","path":"assets/net-img-1665073584346-6bc72f6a-0e4a-412e-94bc-81d860d5b059-20221111215527-k046iu2.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1665073596487-2a45c98e-71a7-45e8-a0c2-ac4b06cd0cff-20221111215527-fzwff39.png","path":"assets/net-img-1665073596487-2a45c98e-71a7-45e8-a0c2-ac4b06cd0cff-20221111215527-fzwff39.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1665073607553-c63d8f6f-883c-4ce4-9acd-3861c0ffd7ff-20221111215527-e9urwmu.png","path":"assets/net-img-1665073607553-c63d8f6f-883c-4ce4-9acd-3861c0ffd7ff-20221111215527-e9urwmu.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1665073624592-674dd74d-86d2-4605-9955-7a16e09a1cb4-20221111215527-1blmix8.png","path":"assets/net-img-1665073624592-674dd74d-86d2-4605-9955-7a16e09a1cb4-20221111215527-1blmix8.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1665073630217-bd1f44be-c442-48c7-9478-62d7f8fc79ce-20221111215527-fmqia49.png","path":"assets/net-img-1665073630217-bd1f44be-c442-48c7-9478-62d7f8fc79ce-20221111215527-fmqia49.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1665073635044-265417f7-ec52-4a11-9a17-929aa008498c-20221111215527-s30ehyk.png","path":"assets/net-img-1665073635044-265417f7-ec52-4a11-9a17-929aa008498c-20221111215527-s30ehyk.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1665073657734-f1c3e079-3804-43d3-8e30-9b46530ad337-20221111215527-74wm25r.png","path":"assets/net-img-1665073657734-f1c3e079-3804-43d3-8e30-9b46530ad337-20221111215527-74wm25r.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1665073663657-eac74193-3f2d-4823-b1ce-076ee644f1ba-20221111215527-ce3yoc2.png","path":"assets/net-img-1665073663657-eac74193-3f2d-4823-b1ce-076ee644f1ba-20221111215527-ce3yoc2.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1665073671982-4bc2b9c6-228b-49a6-96ed-ab6555a1b26d-20221111215527-af0xz7y.png","path":"assets/net-img-1665073671982-4bc2b9c6-228b-49a6-96ed-ab6555a1b26d-20221111215527-af0xz7y.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1665073689906-f5db7615-5190-4e77-9d08-d177ad4026de-20221111215533-4736rjm.png","path":"assets/net-img-1665073689906-f5db7615-5190-4e77-9d08-d177ad4026de-20221111215533-4736rjm.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1665073701183-299298fc-39d3-49a7-80e3-7c1240dbf6bc-20221111215533-jaec6x0.png","path":"assets/net-img-1665073701183-299298fc-39d3-49a7-80e3-7c1240dbf6bc-20221111215533-jaec6x0.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1665073728272-8bc0096c-6425-4310-979a-28ad42d6e2c0-20221111215533-kvytuuy.png","path":"assets/net-img-1665073728272-8bc0096c-6425-4310-979a-28ad42d6e2c0-20221111215533-kvytuuy.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1665073733517-eb68002c-afc1-4746-96e4-0fa95b21bfad-20221111215533-jinki2i.png","path":"assets/net-img-1665073733517-eb68002c-afc1-4746-96e4-0fa95b21bfad-20221111215533-jinki2i.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1665073741703-3acb8484-f36b-4738-8769-c50625b23727-20221111215534-pwccic8.png","path":"assets/net-img-1665073741703-3acb8484-f36b-4738-8769-c50625b23727-20221111215534-pwccic8.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1665073776507-524d18b7-c84e-4311-a742-c02a67d7a63e-20221111215534-h1bzg7o.png","path":"assets/net-img-1665073776507-524d18b7-c84e-4311-a742-c02a67d7a63e-20221111215534-h1bzg7o.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-1665887335160-92fef518-ebb8-4a80-8bba-39f60880a491-20221030140113-ritolt8.webp","path":"assets/net-img-1665887335160-92fef518-ebb8-4a80-8bba-39f60880a491-20221030140113-ritolt8.webp","modified":0,"renderable":0},{"_id":"source/assets/net-img-1665887374286-cdf6dee1-f1f2-4de2-8fdd-0652d9e2f667-20221030140113-kzrzbzq.webp","path":"assets/net-img-1665887374286-cdf6dee1-f1f2-4de2-8fdd-0652d9e2f667-20221030140113-kzrzbzq.webp","modified":0,"renderable":0},{"_id":"source/assets/net-img-1665887401184-ef95895d-d794-43e2-8d11-46c0b6186d3a-20221030140113-0svrost.webp","path":"assets/net-img-1665887401184-ef95895d-d794-43e2-8d11-46c0b6186d3a-20221030140113-0svrost.webp","modified":0,"renderable":0},{"_id":"source/assets/net-img-4122e8fc2d6e2995074ede61ff44aef4-20230330213516-hs7yexh.svg","path":"assets/net-img-4122e8fc2d6e2995074ede61ff44aef4-20230330213516-hs7yexh.svg","modified":0,"renderable":0},{"_id":"source/assets/net-img-4122e8fc2d6e2995074ede61ff44aef4-20230527145229-bw8f49a.svg","path":"assets/net-img-4122e8fc2d6e2995074ede61ff44aef4-20230527145229-bw8f49a.svg","modified":0,"renderable":0},{"_id":"source/assets/net-img-640-20221123123914-g18ng9z.png","path":"assets/net-img-640-20221123123914-g18ng9z.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-640-20221123124059-5desc25.png","path":"assets/net-img-640-20221123124059-5desc25.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-640-20230330194058-16epkoj.png","path":"assets/net-img-640-20230330194058-16epkoj.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-JDgR0O-20221030104726-xwobg2m.jpg","path":"assets/net-img-JDgR0O-20221030104726-xwobg2m.jpg","modified":0,"renderable":0},{"_id":"source/assets/net-img-640-20230330193532-4safylx.png","path":"assets/net-img-640-20230330193532-4safylx.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-Javb7R-20221030105018-f0nmumb.jpg","path":"assets/net-img-Javb7R-20221030105018-f0nmumb.jpg","modified":0,"renderable":0},{"_id":"source/assets/net-img-NHqeHS-20221030124555-egcayk2.png","path":"assets/net-img-NHqeHS-20221030124555-egcayk2.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-NIKEYn-20221030105009-qtc7vqs.jpg","path":"assets/net-img-NIKEYn-20221030105009-qtc7vqs.jpg","modified":0,"renderable":0},{"_id":"source/assets/net-img-NILhqg-20221030105009-gkjt4x4.jpg","path":"assets/net-img-NILhqg-20221030105009-gkjt4x4.jpg","modified":0,"renderable":0},{"_id":"source/assets/net-img-Nxg2RI-20221030140124-2j3rd9u.png","path":"assets/net-img-Nxg2RI-20221030140124-2j3rd9u.png","modified":0,"renderable":0},{"_id":"source/assets/net-img-regexp-cn-20221030151436-zbahpvf.png","path":"assets/net-img-regexp-cn-20221030151436-zbahpvf.png","modified":0,"renderable":0},{"_id":"source/assets/recover1.jpg","path":"assets/recover1.jpg","modified":0,"renderable":0},{"_id":"source/assets/recover2.jpg","path":"assets/recover2.jpg","modified":0,"renderable":0},{"_id":"source/assets/微信图片_20221129215049-20221129215137-xy69pf5.jpg","path":"assets/微信图片_20221129215049-20221129215137-xy69pf5.jpg","modified":0,"renderable":0},{"_id":"source/img/svg/bilibili.svg","path":"img/svg/bilibili.svg","modified":0,"renderable":0},{"_id":"node_modules/hexo-theme-butterfly/source/css/index.styl","path":"css/index.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/css/var.styl","path":"css/var.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/img/404.jpg","path":"img/404.jpg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/img/butterfly-icon.png","path":"img/butterfly-icon.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/img/error-page.png","path":"img/error-page.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/img/favicon.ico","path":"img/favicon.ico","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/img/friend_404.gif","path":"img/friend_404.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/js/tw_cn.js","path":"js/tw_cn.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/js/search/algolia.js","path":"js/search/algolia.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-butterfly/source/js/search/local-search.js","path":"js/search/local-search.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/_data/styles.styl","hash":"9b172b1183effd328fbc67b2b0144ee248fbe538","modified":1745288519455},{"_id":"source/categories/index.md","hash":"0e44ff210f0d3bd323845111c1fdd5c393adc94c","modified":1745288519639},{"_id":"source/img/avatar.jpg","hash":"c83e297b31b2980e9754293df5fa61b550befe3a","modified":1745288519639},{"_id":"source/tags/index.md","hash":"5a6384f3f51cbe58f20dea0e8309e89618bdc6c8","modified":1745288519639},{"_id":"source/assets/0b6fcecfe53184140bb4005dd0eab836-20230127151311-0gha64i.png","hash":"bae9a3ae5487965c67494f6a8bcc29f3796a4616","modified":1745288519463},{"_id":"source/assets/20200809110444386-20230127151311-z1qxdzv.png","hash":"d1bcf5cc5016c65c1c8dfd7ef23b36e6c947b39f","modified":1745288519463},{"_id":"source/music/index.md","hash":"618ddbe3732e221ad2942f91ea9987e5c0aabac1","modified":1745288519639},{"_id":"source/assets/2d694736eb7778a548cdcb8189d6e226-20230127151312-riapszh.png","hash":"e7ad32cf02bb6f432b89c5893c6f5e185a8f95b7","modified":1745288519471},{"_id":"source/assets/327dcba48317d39b2cd0ee081d4e3fdc-20230127151312-4qigjlr.png","hash":"0f2c302d870b7f675cef1d23767307c1b18bbc14","modified":1745288519471},{"_id":"source/assets/2edff9c3d5cb698abb0e62d720ad704b-20230127151311-dy2b8hg.png","hash":"58008120a30cf8d8ca11a32bfbc8534868c780f8","modified":1745288519471},{"_id":"source/assets/39c6a500cefa6e29150c1295d3e152d1-20230127151312-5z7fqgr.png","hash":"5168db5245f5d7e11cf5c6f32608177c1562af98","modified":1745288519475},{"_id":"source/assets/640-20230404215051-pdghyi7.png","hash":"4dd1944316313ba8c5858ffd16a52eaaf9e0aac8","modified":1745288519479},{"_id":"source/assets/b5e5ca9c35421192e7f02864c4fb30bb-20230127151311-iwgg2ln.png","hash":"ee2d610a81cf1cd720b9a311c1608418049375b7","modified":1745288519479},{"_id":"source/assets/c2d8c43d5c018eb584586ad5857fbbf4-20230127151311-ml2ddae.png","hash":"e92f93c660a7069be52d2b186a4ee48e67fc611c","modified":1745288519483},{"_id":"source/assets/da55da191ca558b60531e3a6b6ce5267-20230127151311-wiqzfgo.png","hash":"89b4dcffe22aaeb612f8d8d44395dcefbf4027f9","modified":1745288519483},{"_id":"source/assets/dubbo-modules-20221214214601-dcxfz3a.jpg","hash":"a81339084c61e6e88a645df24a100f99252ee2d8","modified":1745288519483},{"_id":"source/assets/dubbo-relation-20221214214601-7hb77fv.jpg","hash":"b6d8258211efaf56f5b84c3535512ab87fd91581","modified":1745288519483},{"_id":"source/assets/ff614ca7c83414c712848a25b23e6a91-20230127151312-slrk125.png","hash":"573f477c483695ffff8716221ce4e05c028c21c3","modified":1745288519487},{"_id":"source/assets/image-20230218230318-0kn4aj5.png","hash":"961ffed68b045a0327c4de05ceba7ed9678b06c6","modified":1745288519487},{"_id":"source/assets/image-20230218230318-31t0a0v.png","hash":"eea7d51faef16c0743fda3184a5f109ab5f946f3","modified":1745288519487},{"_id":"source/assets/image-20230218230318-i0g5orx.png","hash":"7c81b3ba2f3c7031dce4944d49c26b4620fd16a3","modified":1745288519487},{"_id":"source/assets/image-20230218230318-cknlz85.png","hash":"5994bf3ba95ef539a5d93906cd954a8ad924fc84","modified":1745288519487},{"_id":"source/assets/image-20230218230318-t4i4y3l.png","hash":"61b376acb2adadd3bbaeb6d7377e7d83c1ec0c05","modified":1745288519487},{"_id":"source/assets/image-20230218230318-w95qpr6.png","hash":"0418c9a1496a70f2bc26baf91356e735f9ef538c","modified":1745288519487},{"_id":"source/assets/image-20230218230318-ybffha3.png","hash":"5e16e58c0db061654c14558b1a4c510bc6d72a4a","modified":1745288519491},{"_id":"source/assets/image-20230218230318-ye9g47h.png","hash":"168de4de61f89f23e67201c2de59b272f79b6926","modified":1745288519491},{"_id":"source/assets/image-20230218230318-ypt4n3t.png","hash":"87eb13cbc9b90a9f11dd92e7a1e3cda8fb7d4a95","modified":1745288519491},{"_id":"source/assets/image-20230218230318-nedvesv.png","hash":"45e270b26ea7b43d6e0984c300a539723416e67f","modified":1745288519487},{"_id":"source/assets/image-20230423172026-j99710c.png","hash":"883bd920611be893fe581cc2e2e53f4bd4a85525","modified":1745288519491},{"_id":"source/assets/image-20230505215709-q6pir67.png","hash":"33fd34987cb9c5c0dbf947046e6cc9a1ec9ecc9a","modified":1745288519491},{"_id":"source/assets/image-20230519215732-zz9jpqo.png","hash":"d63b938154b8b371dbcba26dea785815738dc533","modified":1745288519491},{"_id":"source/assets/image-20231119124040-5kytmcz.png","hash":"c92f258000b91edf24db4fa57248184aab5d7ff0","modified":1745288519499},{"_id":"source/assets/image-20231126161709-b35di3t.png","hash":"9af051afa303573bb95b4c559aa1b446360ef447","modified":1745288519527},{"_id":"source/assets/image-20230218230318-t9tvsgp.png","hash":"84f584278240b51e3ccc1208a8510d850714312b","modified":1745288519487},{"_id":"source/assets/net-img-1582873055902-03de6700-dcb1-42a8-927e-af658b90b6b0-20230330213228-vjyh5tl.png","hash":"02396f78d1be8b02ca4cf7efd37ec051c443be38","modified":1745288519559},{"_id":"source/assets/net-img-1582873072467-a61dd6d9-f02a-4653-bcff-eeb592deaf68-20230330213234-ppelol3.png","hash":"c4709d68ebe2880391ccb3b31edf93587b7ad822","modified":1745288519559},{"_id":"source/assets/net-img-1582873090325-a7683e68-a46d-418f-bba5-0bd6c8c7575b-20230330213237-ldsjgn2.webp","hash":"957194f1a9e698a629eff8be47cca675ee9b9082","modified":1745288519559},{"_id":"source/assets/net-img-1582873156123-9f655847-4b5d-4c84-8116-ede849af16e3-20230330213218-q1lh95h.png","hash":"c3d698b9bb8502b82b1677eeccdf1dc5179a1c12","modified":1745288519563},{"_id":"source/assets/net-img-1582873335047-0818927f-77de-4ad8-aa95-fb7d537f6700-20230330213215-9u0gs7n.webp","hash":"325753c050aeadeb41abb811db6932fcc9756cd0","modified":1745288519563},{"_id":"source/assets/net-img-1582873144333-18753191-d8b2-47e1-a610-33c7c552fdaa-20230330213217-uigw9ix.png","hash":"64e5d7a35a0fdd7b382ff036fa463edc29f1af45","modified":1745288519563},{"_id":"source/assets/net-img-1582873601269-c3ee8a62-7c38-4751-8cff-f60ddc262d41-20230330213313-8vw56oe.png","hash":"d4c6236d7806c168e159e57501764179442a6839","modified":1745288519567},{"_id":"source/assets/net-img-1582873416741-a71a0d28-b66d-49ca-8487-c0e0ceaa704c-20230330213216-jddkbfu.webp","hash":"607b6b8b44d4ebf8d11cda966f2c047942e62b47","modified":1745288519563},{"_id":"source/assets/net-img-1582873927778-b80fd046-98af-4768-bfc1-6d59761271e2-20230330213325-w0s4a7u.png","hash":"369ef2ab199332ff160f82fce185f96c7e408345","modified":1745288519567},{"_id":"source/assets/net-img-1582873954652-cd9e9eab-021c-4792-9558-291d9ec5d743-20230330213333-aijfe0m.png","hash":"a25433de852d27f730cd4abef66576122429b314","modified":1745288519567},{"_id":"source/assets/net-img-1582873104499-77f0b1b3-a218-4cc7-9cd1-c5ab317f53ce-20230330213239-aq0b92g.png","hash":"1ee2406b2b6ad8e8cdd96b301e76b353c8a9c229","modified":1745288519563},{"_id":"source/assets/net-img-1582873690823-e85d7b31-4173-4adc-b4b4-92f314fd952b-20230330213322-ngp5u86.webp","hash":"12465e7924ed4b09fe0192921b8337dae8db4b9a","modified":1745288519567},{"_id":"source/assets/net-img-1582874243939-2eae4163-881d-47f6-b75d-18c057db48ef-20230330213158-setmh7t.webp","hash":"96b5d70ff0bdab3d8180fb713dd6e8ba30d505ed","modified":1745288519571},{"_id":"source/assets/net-img-1582874168420-5865fe9a-fe6d-49b5-961a-2addc05fce6a-20230330213157-z8hfg9r.webp","hash":"cef07fcb1e58699024480d7b5c584d90aba0228b","modified":1745288519571},{"_id":"source/assets/net-img-1582874168964-bb84b249-5332-4a93-b161-842b2e6955ed-20230330213157-wrr6xqk.webp","hash":"a141b07c1984453e310c582226e442062e78ae56","modified":1745288519571},{"_id":"source/assets/net-img-1582874279332-65260fd7-5a39-4fd1-85b8-86729cc9982c-20230330213159-yohdmn5.webp","hash":"a6d62b42aebc0b63cb37a508191422a363e18ae9","modified":1745288519571},{"_id":"source/assets/net-img-1582874334522-3936dfde-ef4a-4cf9-ab86-6001429fbb86-20230330213343-txdiivw.jpeg","hash":"870924d44a9995a72ad2d1715ca8466e4f932b25","modified":1745288519571},{"_id":"source/assets/net-img-1582875290415-c052f229-8c31-4560-acef-300acae2409b-20221030135515-tme9bzx.png","hash":"8ef7b28179b9da9186474531f7739c3fff3cbd10","modified":1745288519571},{"_id":"source/assets/net-img-1582875326094-cb5a96e7-e4c2-421d-83cf-216ca4f7f024-20221030135516-5igfhr6.png","hash":"e0ff2aee5d376fb0101a542728f5909eede94315","modified":1745288519571},{"_id":"source/assets/net-img-1582875326657-55738037-28bf-4de9-925a-f08034e0c722-20221030135516-j4ktjne.png","hash":"96ee4e7065f5263abeb8d95a11ce0a18a84f494f","modified":1745288519571},{"_id":"source/assets/net-img-1582875381841-0104c814-acd3-4ef3-a3bd-f5331d9a06bc-20221030135516-0716ftg.png","hash":"80f1bf83e38d1461dc6910d6a30f79d6e2a1394b","modified":1745288519571},{"_id":"source/assets/net-img-1582874136797-a333d011-4325-4f7c-82f6-9792216b1a21-20230330213157-i9zy78v.webp","hash":"34290e221871996dca8c8375aa428da463082adb","modified":1745288519571},{"_id":"source/assets/net-img-1582874350036-1fb8d7cf-688f-4628-ae77-9a21de7c4d2e-20230330213346-aj91hqy.png","hash":"c7fad5d3499a6e0d8e4c4d560da5cddb7a36a55a","modified":1745288519571},{"_id":"source/assets/net-img-1582875452927-44c67a88-5cee-48b1-a764-a26d40a77538-20221030135540-f7dfpln.png","hash":"2daf9869605e16a37c4418c28e52afec9866c7db","modified":1745288519571},{"_id":"source/assets/net-img-1582875462202-61de3608-d606-44f6-b8d0-c82da3a7acd8-20221030135541-a1152vd.png","hash":"94df1ef507bac6d026fa641efdffa9bc09a61a13","modified":1745288519571},{"_id":"source/assets/net-img-1582875470139-ea71ffbe-3cbd-44d8-8560-1e72b3a4bab4-20221030135541-hkuw6hs.png","hash":"9d13278bb6ad5ab8a07fd25d0affc856348afbbc","modified":1745288519571},{"_id":"source/assets/net-img-1582875605484-a8880998-f9be-42d5-9997-a1c908ca05a9-20221030103933-jzsw591.webp","hash":"0dc72ecb95f0deb30a2fcd8b198821b605bd04ea","modified":1745288519575},{"_id":"source/assets/net-img-1591690708309-b6db1e95-1bbf-4140-b612-26fefc8d85b5-20221030132327-6s3ed7l.png","hash":"52f3bbca5eb07588c0f47b6cde9f9fa1745631a4","modified":1745288519575},{"_id":"source/assets/net-img-1582874272168-5169d4d6-17f9-493d-b99b-c9a678dd13da-20230330213159-jscv9ip.webp","hash":"9989009c49220d7ad185cf7e1daecdb15af6d1da","modified":1745288519571},{"_id":"source/assets/net-img-1582875399701-d03e5b25-a1c9-498e-85d6-18f86f41e38f-20221030135517-a6hu6sv.png","hash":"926070ac7bf26f22aab50a0f1b4ad414a02a22fd","modified":1745288519571},{"_id":"source/assets/net-img-1582875478351-18a69ed7-cb09-4a5a-a020-097490219718-20221030135517-0h9pq4n.png","hash":"0828e1ca982af7beedadf87586333ed1cf72fa39","modified":1745288519571},{"_id":"source/assets/net-img-1593076049581-f084ed7e-111c-4a99-944b-bb4aadb0f33b-20230330213209-kp1deud.png","hash":"572c4ff3a54622992e4754d21dc167429bcd50ff","modified":1745288519591},{"_id":"source/assets/net-img-1593076060148-a751342f-828e-49f2-a853-47b276d0fc68-20230330213209-k1w1si6.png","hash":"6ac6a432217bf88a0f8a20b143a9614ea8f078ef","modified":1745288519591},{"_id":"source/assets/net-img-1593854466438-89baf576-0e30-4db7-934e-2781413c9510-20221030140124-w8acjeh.png","hash":"aa5311b240c042132db43fd8ad7c9fd5e2684e44","modified":1745288519591},{"_id":"source/assets/net-img-1596361953803-ed588642-562c-49e8-99dd-cdc0e81519b7-20230426150127-crjga75.png","hash":"412de8e9c61132120a513b6dc1f1346c4f318f5e","modified":1745288519591},{"_id":"source/assets/net-img-1596362023744-7f76e71b-8cd9-4797-87f7-bccdb93fbb3a-20221030140106-k1plvtd.jpeg","hash":"871111348a751329bfc43b7558b117ab0fb54781","modified":1745288519591},{"_id":"source/assets/net-img-1593076076024-42ad7f21-eb2c-4c6b-8c34-802819b1fd8f-20230330213209-f5hjado.png","hash":"485de0eed404f2cdfe10a922214864646c536df1","modified":1745288519591},{"_id":"source/assets/net-img-1596783496811-3a6ed88c-bb38-40b7-aaf3-ca98b12493f2-20221030105031-aijlekh.jpeg","hash":"5bfb117e03defcf9d738674cf866591401250d25","modified":1745288519595},{"_id":"source/assets/net-img-1602123134723-ab15ac69-5397-4422-8dcf-3c43f4a10e06-20221030124512-4k4z367.png","hash":"faf44e5bbb92043e8b5781e7319f87b546001ea5","modified":1745288519595},{"_id":"source/assets/net-img-1602123013155-86ac51db-7d0a-4241-8094-f1fe2e16b43c-20221030124512-fqt8gu2.png","hash":"39b5117e13e5ec7803b99c9d8c9bd63784d09f54","modified":1745288519595},{"_id":"source/assets/net-img-1593076140792-4ab064fd-2370-4f64-a89e-6d7fc5bb9f39-20230330213209-drma95r.png","hash":"f57af1b9c0bf6dcba32d0394fc6778030f4d8147","modified":1745288519591},{"_id":"source/assets/net-img-1615533992554-f7ecd3db-e7d5-4f29-b845-a22cb39dee76-20230426150127-m6xofsl.png","hash":"99b89d8e0dc371e00ad8ca4e57c31fd470372296","modified":1745288519599},{"_id":"source/assets/net-img-1615535960262-7646f229-98d2-4474-be5c-3e5dd3c3e7ac-20221030140153-c14thj0.png","hash":"413ce886d78c230e5721a2238e703cd686208aa9","modified":1745288519599},{"_id":"source/assets/net-img-1625277244322-1304b001-049b-467f-9207-4012228cca38-20221031123243-oqmq9cu.jpeg","hash":"b715ae4a307faa63a555fef73f50a7e67219f8d2","modified":1745288519615},{"_id":"source/assets/net-img-1602510155856-cf2ddad6-d6bb-4ea0-bb8c-f9b1dc49cee8-20221030124433-3c4w0ya.png","hash":"3cd3283688af621e14353a63ae12c976b3b96cd7","modified":1745288519595},{"_id":"source/assets/net-img-1628324723790-e7e469c7-62d0-4076-aa53-5e937ae80bee-20230122192859-e7kchm7.jpeg","hash":"c564a0797766a360cb3d700344659bcb1a63a5af","modified":1745288519619},{"_id":"source/assets/net-img-1631436389678-e6910ed9-8e3c-4d73-93bf-362566a4ebb0-20230330213421-crfgpeh.png","hash":"3a084424eb7936f0e84046f2ed80e94e5a82d243","modified":1745288519623},{"_id":"source/assets/net-img-1639574230606-ee713d6a-1223-4275-bfaa-f60258aa6eea-20221030132914-2yfiwaf.jpeg","hash":"da8ff67b12daf7bc3384b335f9baa0924bb7de74","modified":1745288519623},{"_id":"source/assets/net-img-1646740660775-762fcaa3-26b5-4d95-ac43-5cca58540969-20230330213439-sxz1b5i.png","hash":"c85a97f212680ea6313e5b59dc14a4fd660bf2d9","modified":1745288519623},{"_id":"source/assets/net-img-1665073234010-c17ae82e-6da7-479a-ba1c-b1543abba0d5-20221111215525-80jshsc.png","hash":"f021b7c6e560a155d4e76284566214ce181fe201","modified":1745288519623},{"_id":"source/assets/net-img-1665073313636-93fb8cb7-e679-4c0f-8067-885d28f67ded-20221111215526-vcl9xfw.png","hash":"17f4f5b751e089a0d76b52e471ec5c9a2ceff444","modified":1745288519623},{"_id":"source/assets/net-img-1645242293838-01142675-6027-4b29-8f4d-1d872c2d6cea-20221030140106-8zicdb0.png","hash":"be0a7ca296495c45aeefa6205ee972c27fc09d3f","modified":1745288519623},{"_id":"source/assets/net-img-1665073358729-865ac7d0-89b5-4cc8-814e-a892038da58b-20221111215525-k257bcx.png","hash":"0ca686dd92e384559cc5bd7ed4110b5589a489e8","modified":1745288519623},{"_id":"source/assets/net-img-1665073365265-002fd960-3cab-45d5-a547-968487191335-20221111215525-51j8yv0.png","hash":"f021b7c6e560a155d4e76284566214ce181fe201","modified":1745288519623},{"_id":"source/assets/net-img-1665073370943-3b2e7f1c-7c9a-46a3-9e37-31742edea2f4-20221111215525-xb7w2cn.png","hash":"3ef96c77a510a92610cca91745e6818fca50f32c","modified":1745288519623},{"_id":"source/assets/net-img-1665073398713-d6f47c91-e7a2-407a-9cc0-de52b301cf26-20221111215526-gwi38jk.png","hash":"7c6c6a376b2d11bea215fa3f0396944ee98a0bf2","modified":1745288519623},{"_id":"source/assets/net-img-1665073405592-73518a43-9c02-4d55-baee-bafcff044efe-20221111215526-c9mhwt8.png","hash":"db37da8537372287a3483ee2088adbf70c908b3e","modified":1745288519623},{"_id":"source/assets/net-img-1665073414310-928255a5-b8a0-4a7b-817f-dbabda18feef-20221111215526-c0gy94f.png","hash":"03eda78dbd90f3e27b35c07b6149ebb22f80c60a","modified":1745288519623},{"_id":"source/assets/net-img-1665073424520-10dfe592-ea00-4ea5-b46e-992601919f1f-20221111215526-q1f6my9.png","hash":"5732bdd2254fc2df9b32ed878191af5c9c203857","modified":1745288519623},{"_id":"source/assets/net-img-1665073433573-ed1fdba5-d19f-40c2-a4f9-96a6ddbff0d2-20221111215526-5pgyp70.png","hash":"cd07f2413a92f7bfbc47ed997015527862cd2d26","modified":1745288519623},{"_id":"source/assets/net-img-1665073347225-5388dfc6-3fc2-4492-902c-b7fcd02f3245-20221111215525-4h0vo0n.png","hash":"11c3c24fada168360225f3da625dbf1940d1ebae","modified":1745288519623},{"_id":"source/assets/net-img-1665073353104-76e6707d-af7c-4e84-97dd-7458adee7994-20221111215525-0zkzrc2.png","hash":"3ef868230856bca16fb92c66fad7d37199561848","modified":1745288519623},{"_id":"source/assets/net-img-1665073440336-5f261660-b58b-4c06-9c1d-f21c0865e31c-20221111215526-0s6pvi9.png","hash":"fba77817166eca4d0a2606451c136c09ce22b0c0","modified":1745288519623},{"_id":"source/assets/net-img-1665073460709-ab3783c9-f4f3-46ae-ab45-fe489a701313-20221111215526-4cnfbe6.png","hash":"20ef0c0783a74dd7d0bc460949462b9502e2c060","modified":1745288519623},{"_id":"source/assets/net-img-1665073467540-2062cc90-042f-4ea8-8dbc-1afa0c8232c7-20221111215527-13hnynb.png","hash":"c84aeb21cb1986b15d68ecc274e8e73d2422e3c3","modified":1745288519623},{"_id":"source/assets/net-img-1665073484287-631d0da3-1bb4-4881-b567-647d058f4f47-20221111215527-l67jrtu.png","hash":"948d0c45ed7ffa9b202a60d247a0d1f961ecf147","modified":1745288519623},{"_id":"source/assets/net-img-1665073567805-1c681335-41e9-40c3-a02a-0155e0383924-20221111215527-s7tudvn.png","hash":"1aa5dc9f6b8ac8ab605ae58386281637ea30e2c7","modified":1745288519623},{"_id":"source/assets/net-img-1665073576092-3eea97da-b483-4acc-a6fd-eece98224cd0-20221111215527-fr7igf9.png","hash":"1dccaa650671139a972c29df9bab164cc9bd41d8","modified":1745288519623},{"_id":"source/assets/net-img-1665073596487-2a45c98e-71a7-45e8-a0c2-ac4b06cd0cff-20221111215527-fzwff39.png","hash":"4ea4eb5389253148560fe2f84be9949baf4ea1e2","modified":1745288519627},{"_id":"source/assets/net-img-1665073473485-b4b83d79-2af4-4681-9d50-1c9096dc935c-20221111215527-zawp2eq.png","hash":"f07245405e0b6c65db1543d51618afc03188b6c9","modified":1745288519623},{"_id":"source/assets/net-img-1665073448391-a1d5eef7-134c-4b01-9c2e-2df8cc9ec893-20221111215526-gp8xqtg.png","hash":"459a880bf0f7383a95471dd2fb8557743f84f7f5","modified":1745288519623},{"_id":"source/assets/net-img-1665073635044-265417f7-ec52-4a11-9a17-929aa008498c-20221111215527-s30ehyk.png","hash":"6111298420b3d37a2abdfbb525ca7a462a6eec42","modified":1745288519627},{"_id":"source/assets/net-img-1665073657734-f1c3e079-3804-43d3-8e30-9b46530ad337-20221111215527-74wm25r.png","hash":"fc0fcbcaa2176b4165d445deff78632786aba535","modified":1745288519627},{"_id":"source/assets/net-img-1665073663657-eac74193-3f2d-4823-b1ce-076ee644f1ba-20221111215527-ce3yoc2.png","hash":"c32e7b43243a7c3bba6e278596a971fcfe4c5626","modified":1745288519627},{"_id":"source/assets/net-img-1665073671982-4bc2b9c6-228b-49a6-96ed-ab6555a1b26d-20221111215527-af0xz7y.png","hash":"b5c7a29925623db00334fc81da68e7d67e9b8c30","modified":1745288519627},{"_id":"source/assets/net-img-1665073733517-eb68002c-afc1-4746-96e4-0fa95b21bfad-20221111215533-jinki2i.png","hash":"d9b4a0218a7653d5650c5820ddf7f6cb939b9255","modified":1745288519627},{"_id":"source/assets/net-img-1665073630217-bd1f44be-c442-48c7-9478-62d7f8fc79ce-20221111215527-fmqia49.png","hash":"30b83f99717332339d4fc99ad3d24b6b09fa1195","modified":1745288519627},{"_id":"source/assets/net-img-1665073624592-674dd74d-86d2-4605-9955-7a16e09a1cb4-20221111215527-1blmix8.png","hash":"476ee418d2e2e1df657a5e4c52fc46fafb7e6aeb","modified":1745288519627},{"_id":"source/assets/net-img-1665073607553-c63d8f6f-883c-4ce4-9acd-3861c0ffd7ff-20221111215527-e9urwmu.png","hash":"58792d335b56d61df03a0c719534b9ebe175ca06","modified":1745288519627},{"_id":"source/assets/net-img-1665887374286-cdf6dee1-f1f2-4de2-8fdd-0652d9e2f667-20221030140113-kzrzbzq.webp","hash":"e81b945e532f9bf366758c468c3770749ad5f729","modified":1745288519631},{"_id":"source/assets/net-img-1665887401184-ef95895d-d794-43e2-8d11-46c0b6186d3a-20221030140113-0svrost.webp","hash":"b9cc68508d12b2d5167602efd3e447eed2852a99","modified":1745288519631},{"_id":"source/assets/net-img-4122e8fc2d6e2995074ede61ff44aef4-20230330213516-hs7yexh.svg","hash":"5ccc384d0fe489f4613cfbc07a451639b26651c8","modified":1745288519631},{"_id":"source/assets/net-img-1665073776507-524d18b7-c84e-4311-a742-c02a67d7a63e-20221111215534-h1bzg7o.png","hash":"70ce12adde5768aa3d7f75fcd23c01bba60a1481","modified":1745288519631},{"_id":"source/assets/net-img-1665887335160-92fef518-ebb8-4a80-8bba-39f60880a491-20221030140113-ritolt8.webp","hash":"13169ab8c1647fc0aed80b0917e77d124ae2e772","modified":1745288519631},{"_id":"source/assets/net-img-4122e8fc2d6e2995074ede61ff44aef4-20230527145229-bw8f49a.svg","hash":"5ccc384d0fe489f4613cfbc07a451639b26651c8","modified":1745288519631},{"_id":"source/assets/net-img-640-20221123123914-g18ng9z.png","hash":"fed1d8bb65255b53f32f1dad99c958516440db00","modified":1745288519635},{"_id":"source/assets/net-img-Javb7R-20221030105018-f0nmumb.jpg","hash":"6643e83588989e0b9c562ecb62522511134180da","modified":1745288519635},{"_id":"source/assets/net-img-NIKEYn-20221030105009-qtc7vqs.jpg","hash":"96d4d9622ab94e815195a267ebd748deeca387d5","modified":1745288519635},{"_id":"source/assets/net-img-NILhqg-20221030105009-gkjt4x4.jpg","hash":"cf376bbe8f2ca07f66dba0bd27632de1d5a917b3","modified":1745288519635},{"_id":"source/assets/net-img-Nxg2RI-20221030140124-2j3rd9u.png","hash":"aae52ae2b5b8dd06bf02d43ee65d3dea3fbe1507","modified":1745288519635},{"_id":"source/assets/net-img-regexp-cn-20221030151436-zbahpvf.png","hash":"11e9763df7885e5f0102411d0d3097baac0be549","modified":1745288519639},{"_id":"source/assets/recover1.jpg","hash":"c3bed5eede5543317b5b1d1e6131510f12713d9d","modified":1745288519639},{"_id":"source/assets/recover2.jpg","hash":"6c25fad45107d0e81cfc93f6e72c8797d42fd120","modified":1745288519639},{"_id":"source/assets/net-img-NHqeHS-20221030124555-egcayk2.png","hash":"579571e4e43197309ab62b28f5b8d0298e7914b1","modified":1745288519635},{"_id":"source/_posts/java/Base.md","hash":"825cf8009cdabbbae9a4c24d263770cc2e8a9425","modified":1745288519463},{"_id":"source/_posts/java/Collection.md","hash":"d00121e46712e6e16293e65ac0e7ef4c9569ad9d","modified":1745288519463},{"_id":"source/_posts/java/JVM.md","hash":"ed476e1dd59dd4ac80527bb36dceadc06c7a198d","modified":1745288519463},{"_id":"source/_posts/java/JavaWeb.md","hash":"3190922b44dd14648caeb41e5f340da02b3c2e4c","modified":1745288519463},{"_id":"source/_posts/java/thread.md","hash":"913aa23cc3457b5011516af0472b99f148578b9f","modified":1745288519463},{"_id":"source/img/svg/bilibili.svg","hash":"badde0a67d518abd4091b07827c1d45d045873a3","modified":1745288519639},{"_id":"source/_posts/Effective-Java/01. 考虑使用静态工厂方法替代构造方法.md","hash":"bf82552d626cfeabf87e726cb2c6675ae4bd25a0","modified":1745288519455},{"_id":"source/_posts/Effective-Java/02. 当构造方法参数过多时使用builder模式.md","hash":"8120c558078a9340f4149b6b3314268a99828cde","modified":1745288519455},{"_id":"source/_posts/Effective-Java/03. 使用私有构造方法或枚类实现Singleton属性.md","hash":"f411ca4722f126d8415af856d953c0c7767a1293","modified":1745288519455},{"_id":"source/_posts/Effective-Java/04. 使用私有构造方法执行非实例化.md","hash":"0339c29d7d45b2a5302fc337fad93b8fc78a6e35","modified":1745288519455},{"_id":"source/_posts/Effective-Java/05. 依赖注入优于硬连接资源(hardwiring resources).md","hash":"85efac1482bc39b1941e556204c4a61c445340f1","modified":1745288519455},{"_id":"source/_posts/Effective-Java/06. 避免创建不必要的对象.md","hash":"6746fbd853989b4492732c7a9b88feacfa00ba0d","modified":1745288519455},{"_id":"source/_posts/Effective-Java/07. 消除过期的对象引用.md","hash":"6fc4d34463713d1668bdcec350e5ddcfa3f97226","modified":1745288519455},{"_id":"source/_posts/Effective-Java/08. 避免使用Finalizer和Cleaner机制.md","hash":"28401601e39153e760eb000c74093052d757d5bb","modified":1745288519455},{"_id":"source/_posts/Effective-Java/09. 使用try-with-resources语句替代try-finally语句.md","hash":"fad5dc2c872ad2a7f66aa033019e757658af25b1","modified":1745288519455},{"_id":"source/_posts/java/ByteBuddy.md","hash":"423a430f53d56b7c985a4323bd9c5cc0399bc0b6","modified":1745288519463},{"_id":"source/_posts/Effective-Java/10. 重写equals方法时遵守通用约定.md","hash":"cbfc0ef2445c206b6092630d7774abedd9be4ece","modified":1745288519455},{"_id":"source/assets/net-img-640-20230330193532-4safylx.png","hash":"fef4a36094e1d2d446dcd6db1bd08bde2a33afd8","modified":1745288519635},{"_id":"source/_posts/Effective-Java/13. 谨慎地重写 clone 方法.md","hash":"6ee8a68a1b242614801f25646f0c08dbdfaa94ce","modified":1745288519455},{"_id":"source/_posts/Effective-Java/14. 考虑实现Comparable接口.md","hash":"812d3cf33fe2ba9961ad6a284c7efb5dde0a1ffa","modified":1745288519455},{"_id":"source/_posts/Effective-Java/15. 使类和成员的可访问性最小化.md","hash":"aced087d4fc9f05613cacb8d7856922fa9bcd06b","modified":1745288519455},{"_id":"source/_posts/Effective-Java/16. 在公共类中使用访问方法而不是公共属性.md","hash":"9338fdff29af02f3a7560e396d754bd96f0d2f79","modified":1745288519455},{"_id":"source/_posts/Effective-Java/17. 最小化可变性.md","hash":"4af808fedf1de24405a3a8fc1d979af573f9c3e1","modified":1745288519455},{"_id":"source/_posts/Effective-Java/18. 组合优于继承.md","hash":"e2e9ab02336ae7bb850af8dfe5b6e1f96f1d5060","modified":1745288519455},{"_id":"source/_posts/Effective-Java/19. 要么设计继承并提供文档说明，要么禁用继承.md","hash":"d81c11513f2e403920bb1c2baf2f220e82b744a0","modified":1745288519455},{"_id":"source/_posts/Effective-Java/20. 接口优于抽象类.md","hash":"65d5faf545a58d67d22774561246b4ade6348d36","modified":1745288519455},{"_id":"source/_posts/Effective-Java/21. 为后代设计接口.md","hash":"3b43b9a0f2f25c3d42aa2080af8bee5b8b815ca8","modified":1745288519455},{"_id":"source/_posts/Effective-Java/22. 接口仅用来定义类型.md","hash":"90db2cbffb13ccb82a578a0adace90ff8d94594c","modified":1745288519455},{"_id":"source/_posts/Effective-Java/23. 类层次结构优于标签类.md","hash":"479947cee3105310e77a35fb0f569b6d7bb92071","modified":1745288519455},{"_id":"source/_posts/Effective-Java/24. 支持使用静态成员类而不是非静态类.md","hash":"1149464abeb6caa0723359bbc002836bde2de78a","modified":1745288519455},{"_id":"source/_posts/Effective-Java/25. 将源文件限制为单个顶级类.md","hash":"59c223128d423ea1cec024038a026870aad1676d","modified":1745288519455},{"_id":"source/_posts/Effective-Java/26. 不要使用原始类型.md","hash":"0d38f2acd1a496d5a5885aa8c7e8aa43ec3f67d3","modified":1745288519455},{"_id":"source/_posts/Effective-Java/12. 始终重写 toString 方法.md","hash":"3680b5a8dd288695c81e4a0bbf67de9056a7a6ae","modified":1745288519455},{"_id":"source/_posts/Effective-Java/28. 列表优于数组.md","hash":"a3bd075dd95392e8141a642e3cf8b080f46c3fc4","modified":1745288519455},{"_id":"source/_posts/Effective-Java/29. 优先考虑泛型.md","hash":"5a39f728e738890b83e83b20422560bd9e7c835d","modified":1745288519455},{"_id":"source/_posts/Effective-Java/30. 优先使用泛型方法.md","hash":"a47797d88179519b19f602559936e3f8e70a813f","modified":1745288519455},{"_id":"source/_posts/Effective-Java/27. 消除非检查警告.md","hash":"85735e3582edb0dd46445bd2a2e2f727f3bd2c39","modified":1745288519455},{"_id":"source/_posts/Effective-Java/31. 使用限定通配符来增加API的灵活性.md","hash":"888cde29cd1335fa1b581bf4954cc2afa0a83bd7","modified":1745288519455},{"_id":"source/_posts/Effective-Java/33. 优先考虑类型安全的异构容器.md","hash":"4d920ebf9ecec110e0fbd68e087675e273ff6617","modified":1745288519455},{"_id":"source/_posts/Effective-Java/34. 使用枚举类型替代整型常量.md","hash":"5c6eec649d269dede8fb3a09d7067207c56e6359","modified":1745288519459},{"_id":"source/_posts/Effective-Java/35. 使用实例属性替代序数.md","hash":"b44cf12f22129e65ed7396f31ac8ea05198b4d9c","modified":1745288519459},{"_id":"source/_posts/Effective-Java/36. 使用EnumSet替代位属性.md","hash":"99e60cf43ae97615138e001a09b6e8802f52ee70","modified":1745288519459},{"_id":"source/_posts/Effective-Java/37. 使用EnumMap替代序数索引.md","hash":"4990936c24b785b1e5165b5acbcb4f17c53a3b2a","modified":1745288519459},{"_id":"source/_posts/Effective-Java/38. 使用接口模拟可扩展的枚举.md","hash":"1d75b857acbd0fcaea3bd38b5bb4110d7bc1238e","modified":1745288519459},{"_id":"source/_posts/Effective-Java/39. 注解优于命名模式.md","hash":"5fb9f1404d26a22007410ccda5a6b180e0a7b6f9","modified":1745288519459},{"_id":"source/_posts/Effective-Java/40. 始终使用Override注解.md","hash":"02d80972d51ffc9084643718549f2e5ef4a4021c","modified":1745288519459},{"_id":"source/_posts/Effective-Java/41. 使用标记接口定义类型.md","hash":"8f55d00706ac87c619c0d077613f011e50a1c83d","modified":1745288519459},{"_id":"source/_posts/Effective-Java/42. lambda表达式优于匿名类.md","hash":"1b3dfed0e9711c1a4bb87491761eb20f692321ea","modified":1745288519459},{"_id":"source/_posts/Effective-Java/43. 方法引用优于lambda表达式.md","hash":"54bb636380e25042ceb3d85816035d1626a4a38a","modified":1745288519459},{"_id":"source/_posts/Effective-Java/11. 重写equals方法时同时也要重写hashcode方法.md","hash":"cdb7a1a8d9d672e57d15a166681b90a66088710f","modified":1745288519455},{"_id":"source/_posts/Effective-Java/44. 优先使用标准的函数式接口.md","hash":"82fffdc414aaeb40925ee6fc3a104fcad2e18eb5","modified":1745288519459},{"_id":"source/_posts/Effective-Java/32. 合理地结合泛型和可变参数.md","hash":"c7c775db271304c87f7eceb81885ea80a1b70675","modified":1745288519455},{"_id":"source/_posts/Effective-Java/49. 检查参数有效性.md","hash":"7de98ffc44195560e2b8970f57e8ecf03d964a62","modified":1745288519459},{"_id":"source/_posts/Effective-Java/47. 优先使用Collection而不是Stream来作为方法的返回类型.md","hash":"bc70de6759da3d920e473c55090aa8eef04b79eb","modified":1745288519459},{"_id":"source/_posts/Effective-Java/50. 必要时进行防御性拷贝.md","hash":"38aaed60f94ecd5dbd7bbfe31d7bdd0d7be7f739","modified":1745288519459},{"_id":"source/_posts/Effective-Java/51. 仔细设计方法签名.md","hash":"8916171efa5c08766b1bacd1a09781e7b1d75f90","modified":1745288519459},{"_id":"source/_posts/Effective-Java/52. 明智审慎地使用重载.md","hash":"daf4a5d3aa484325f1c449671337489cbce8666e","modified":1745288519459},{"_id":"source/_posts/Effective-Java/53. 明智审慎地使用可变参数.md","hash":"ca0dac0ae97bab0e37f0b3a3a4d22dab5a18bff0","modified":1745288519459},{"_id":"source/_posts/Effective-Java/54. 返回空的数组或集合，不要返回 null.md","hash":"cdb723fec7959808ace54a73dbfe3d3c1e26ff8e","modified":1745288519459},{"_id":"source/_posts/Effective-Java/55. 明智审慎地返回 Optional.md","hash":"729d8c069eebef73b1afc518a7320ca40c903f13","modified":1745288519459},{"_id":"source/_posts/Effective-Java/56. 为所有已公开的 API 元素编写文档注释.md","hash":"87c48400c0cb3f44a9ed4aa1cb4326bcf524a0b7","modified":1745288519459},{"_id":"source/_posts/Effective-Java/45. 明智审慎地使用Stream.md","hash":"de9b89b42eb5463311d4ddf963739abeb4f1895b","modified":1745288519459},{"_id":"source/_posts/Effective-Java/57. 最小化局部变量的作用域.md","hash":"093c42a74d1900bfe724d06081c9907e7b2df92d","modified":1745288519459},{"_id":"source/_posts/Effective-Java/59. 了解并使用库.md","hash":"068aecbebfb3142f849901cdd278300576551919","modified":1745288519459},{"_id":"source/_posts/Effective-Java/48. 谨慎使用流并行.md","hash":"f8037ba7e8fb5679abdc82b65b33e421a517a288","modified":1745288519459},{"_id":"source/_posts/Effective-Java/58. for-each 循环优于传统 for 循环.md","hash":"43a387159242012195bced6da086c9a7b566eb93","modified":1745288519459},{"_id":"source/_posts/Effective-Java/60. 若需要精确答案就应避免使用 float 和 double 类型.md","hash":"387858bb3f93fa140a729876d1c61b81c0d65175","modified":1745288519459},{"_id":"source/_posts/Effective-Java/46. 优先考虑流中无副作用的函数.md","hash":"d5d493109045592dbe6902e59b1bcc41d72a3b6a","modified":1745288519459},{"_id":"source/_posts/Effective-Java/61. 基本数据类型优于包装类.md","hash":"0629f49ca9b26ccef39746df2ef64fa234fe78c3","modified":1745288519459},{"_id":"source/_posts/Effective-Java/63. 当心字符串连接引起的性能问题.md","hash":"84d2b5361146b45c690c28654414ab97b4770bf1","modified":1745288519459},{"_id":"source/_posts/Effective-Java/62. 当使用其他类型更合适时应避免使用字符串.md","hash":"d0519186405bf5c90086f9bb998390d01d393a6c","modified":1745288519459},{"_id":"source/_posts/Effective-Java/64. 通过接口引用对象.md","hash":"aebfc8b1f213741059800b4bcc2e1947dad90d36","modified":1745288519459},{"_id":"source/_posts/Effective-Java/65. 接口优于反射.md","hash":"5244b9242369e1335e4f014dcd764fd4d82d7add","modified":1745288519459},{"_id":"source/_posts/Effective-Java/66. 明智审慎地本地方法.md","hash":"ce70eb18f625b7caf759439a62445da1360a66e6","modified":1745288519459},{"_id":"source/_posts/Effective-Java/68. 遵守被广泛认可的命名约定.md","hash":"e057a695373948ec7976995db1d50d04d723fd77","modified":1745288519459},{"_id":"source/_posts/Effective-Java/69. 只针对异常的情况下才使用异常.md","hash":"eb3731eb2bd75cce2b9a5270f8f200ba6cc02de9","modified":1745288519459},{"_id":"source/_posts/Effective-Java/67. 明智审慎地进行优化.md","hash":"d4b35b657379fab42a9cdfde2f8420fccff3b587","modified":1745288519459},{"_id":"source/_posts/Effective-Java/70. 对可恢复的情况使用受检异常，对编程错误使用运行时异常.md","hash":"1d3ca76f5ea397d7ad9595de51bdbb6a9aad89b1","modified":1745288519459},{"_id":"source/_posts/Effective-Java/71. 避免不必要的使用受检异常.md","hash":"469b2092d08d7bf47cc70ca6e496184797adae72","modified":1745288519459},{"_id":"source/_posts/Effective-Java/72. 优先使用标准的异常.md","hash":"672eb2ce27165fb007da0c8430e07ce2256481b5","modified":1745288519459},{"_id":"source/_posts/Effective-Java/73. 抛出与抽象对应的异常.md","hash":"95a1f3ff9a83a77f7a4fb449dbadd389643c2273","modified":1745288519459},{"_id":"source/_posts/Effective-Java/74. 每个方法抛出的异常都需要创建文档.md","hash":"8eb6f3c815e4b7f2b41b949c2df7485946bad057","modified":1745288519459},{"_id":"source/_posts/Effective-Java/76. 保持失败原子性.md","hash":"65d6765471e16ba4e17ef34ceaa471afc7fc0fc4","modified":1745288519459},{"_id":"source/_posts/Effective-Java/75. 在细节消息中包含失败一捕获信息.md","hash":"e663f3502b06e080f661ccdaf344768456bd0a89","modified":1745288519459},{"_id":"source/_posts/Effective-Java/77. 不要忽略异常.md","hash":"e4ec2077f4c00cf1efc363a590ef16c25fa2eb7e","modified":1745288519459},{"_id":"source/_posts/Effective-Java/78. 同步访问共享的可变数据.md","hash":"96e65c1571023b5bcca872739e918f0b3e68ed5d","modified":1745288519459},{"_id":"source/_posts/Effective-Java/79. 避免过度同步.md","hash":"0a5bf93933a4374fd2086d1360f138737fac82b3","modified":1745288519459},{"_id":"source/_posts/Effective-Java/80. executor 、task 和 stream 优先于线程.md","hash":"69ed86a33ac7eeffe52e3a0f7809c70a704110db","modified":1745288519459},{"_id":"source/_posts/Effective-Java/81. 并发工具优于 wait 和 notify.md","hash":"8a0f32cc5e543b9dd50b87c2404e6558ff818cbd","modified":1745288519459},{"_id":"source/_posts/Effective-Java/82. 文档应包含线程安全属性.md","hash":"85f2b2bf0041b445b951d90ad042d3b1919099f8","modified":1745288519459},{"_id":"source/_posts/Effective-Java/83. 明智审慎的使用延迟初始化.md","hash":"79d8ea5a4b801922034b94fd176af1b468401bec","modified":1745288519459},{"_id":"source/_posts/Effective-Java/84. 不要依赖线程调度器.md","hash":"28d253636031ebd980c88737a349c5899af7455f","modified":1745288519459},{"_id":"source/_posts/Effective-Java/85. 优先选择 Java 序列化的替代方案.md","hash":"96fa8449dd71797bf1a4fbebfebe10963b175acd","modified":1745288519463},{"_id":"source/_posts/Effective-Java/86. 非常谨慎地实现 Serializable.md","hash":"5d0844b8b7ae1abdbd37a107c0108a934e16a92d","modified":1745288519463},{"_id":"source/_posts/Effective-Java/87. 考虑使用自定义的序列化形式.md","hash":"e83efee8de2f39fbdd4735f33df8a1713dbdc962","modified":1745288519463},{"_id":"source/_posts/Effective-Java/89. 对于实例控制，枚举类型优于 readResolve.md","hash":"7c6601b666c3cbb5d3f14f62b3b841f942d072cb","modified":1745288519463},{"_id":"source/_posts/Effective-Java/88. 保护性的编写 readObject 方法.md","hash":"5bce9a33fb6ad4e6c0972cba60b62c9c70c5a016","modified":1745288519463},{"_id":"source/_posts/Effective-Java/90. 考虑用序列化代理代替序列化实例.md","hash":"43bb4d78e805b1bfdfec8f60354c92cdbfc42c01","modified":1745288519463},{"_id":"source/_posts/java/Base/JavaStream.md","hash":"0032756f75f94c22d739246d883262e760ca60d8","modified":1745288519463},{"_id":"source/_posts/java/Base/ThreadLocal.md","hash":"7a700e1234e0cbddb77c95e4c6120902a8012fb9","modified":1745288519463},{"_id":"source/_posts/java/Base/Volatile.md","hash":"37be2702511ca2b91c16e13ffd28f8a3c64d9805","modified":1745288519463},{"_id":"source/_posts/java/Collection/List.md","hash":"5595fd7d0e9844abe64c715a2cf21688d8e6b6ce","modified":1745288519463},{"_id":"source/_posts/java/Collection/Map.md","hash":"1ac815dbc44bfe442c6c55e2ed936b1bb4ad3495","modified":1745288519463},{"_id":"source/_posts/java/Collection/Queue.md","hash":"46aaa6748558c20eb2c8880c08d4944695a4331f","modified":1745288519463},{"_id":"source/_posts/java/Collection/Set.md","hash":"b64aedd90ed5a4ae5d23a9b28fa3e102f3b54b27","modified":1745288519463},{"_id":"source/_posts/java/JVM/Java虚拟机栈栈帧.md","hash":"3726a2e1c766789f4ec393be2e19a0ee90aab428","modified":1745288519463},{"_id":"source/_posts/java/JVM/垃圾回收和内存分配.md","hash":"ea4ac51df8187f3be5978407dc518f422b510b4d","modified":1745288519463},{"_id":"source/_posts/java/JVM/虚拟机中的对象.md","hash":"f0ae6b016ba13e540093264fe2ac69519ce52b36","modified":1745288519463},{"_id":"source/_posts/java/JVM/虚拟机运行时数据区域.md","hash":"407cfca277b2e3ad6ef5a2f79f9a570fa6a2064a","modified":1745288519463},{"_id":"source/_posts/java/JavaWeb/Filter拦截器.md","hash":"facb9368e3367205b974f56083b9b7fd3956481a","modified":1745288519463},{"_id":"source/_posts/java/thread/并发处理.md","hash":"156ea243d5725eb2ba1a9f357fc56ade002ef584","modified":1745288519463},{"_id":"source/_posts/java/thread/并发锁.md","hash":"b0fea9e26f9b97984c774a53e7dcba39d7cf8b62","modified":1745288519463},{"_id":"source/_posts/java/thread/线程池.md","hash":"3410126a8d975e57ded3167f3998de0f35acb0aa","modified":1745288519463},{"_id":"source/_posts/java/thread/线程间通讯.md","hash":"a12d448f120df1faf7d5e6aa88dea56c7f5d51d6","modified":1745304539513},{"_id":"source/assets/640-20230404215050-p95bson.png","hash":"0478df316349a076dfd91794b6ec861f95a5bada","modified":1745288519475},{"_id":"source/assets/net-img-1665073689906-f5db7615-5190-4e77-9d08-d177ad4026de-20221111215533-4736rjm.png","hash":"ecde750c44c0479a23f40c533748b829956a355b","modified":1745288519627},{"_id":"source/assets/640-20230404215050-qd8x4fd.png","hash":"daf1e3d27b80ee965c951c8f20b739f53215ee37","modified":1745288519475},{"_id":"source/assets/640-20230404215051-hnbb7ug.png","hash":"ecf312e7d0993fac1e8e595a5f4fa15a18e55732","modified":1745288519475},{"_id":"source/assets/640-20230404215051-lu967n5.png","hash":"befacad3f7005229202acebb0eb99f8d6185f7f9","modified":1745288519479},{"_id":"source/assets/640-20230404215051-nrxnl0j.png","hash":"4c94e2699cc8d1d8d5dd12a501c6df744d2e33a9","modified":1745288519479},{"_id":"source/assets/640-20230404215051-rx0ju25.png","hash":"98475a34df76ba664ef881b7e96101e3175650c5","modified":1745288519479},{"_id":"source/assets/6c916769e7f2450157bce49ea9438c10-20230127151312-x7ufhrj.png","hash":"bc1d3688bb55b74d18fb3bb5312e04e13ed5cb5e","modified":1745288519479},{"_id":"source/assets/704e3015827edff48d6c84777aa28006-20230127151312-jonjh5w.png","hash":"78a1c568a73ffdbd297c6f90c52738aa4427d6cd","modified":1745288519479},{"_id":"source/assets/83f121c9c340db46f955badf876220b2-20230127151311-j2wtijc.png","hash":"8c893b97511365f9a8a3cd6f142289cd4ebe5404","modified":1745288519479},{"_id":"source/assets/a0d8c504b2c17abbfb8eb40bc4d86d79-20230127151311-0azix9f.png","hash":"8d9910c06f73d0a0598f8267875b27772113da46","modified":1745288519479},{"_id":"source/assets/dubbo-export-20221214214601-bb3rzp9.jpg","hash":"1b3b5ef646a2870f664342904d7885fb7a69e493","modified":1745288519483},{"_id":"source/assets/dubbo-extension-20221214214601-56szafs.jpg","hash":"ae81b670b3781e6cecc373196218c63bebe89dad","modified":1745288519483},{"_id":"source/assets/dubbo-refer-20221214214601-20gbi94.jpg","hash":"e5c54853878b2f2e74dc1cf081808fd35c8afaab","modified":1745288519483},{"_id":"source/assets/f0b471f40aa64279914a3acbd6e2913b-20230127151312-khh42zb.png","hash":"e9a77caa9da51d1dd93a650495edd99a745ffccf","modified":1745288519487},{"_id":"source/assets/net-img-1665073701183-299298fc-39d3-49a7-80e3-7c1240dbf6bc-20221111215533-jaec6x0.png","hash":"19880cddc5c6a0b4b0bf82eec65beca6a37aee51","modified":1745288519627},{"_id":"source/assets/410360b70936d286a4df4ab2c11f28ad-20230127151311-j96gr8d.png","hash":"9716aecb984c1aa96693f8d1add945965eca9dcc","modified":1745288519475},{"_id":"source/assets/net-img-1665073728272-8bc0096c-6425-4310-979a-28ad42d6e2c0-20221111215533-kvytuuy.png","hash":"fc3ffdbd4ac7bac30b237de89866a8da823d0653","modified":1745288519627},{"_id":"source/assets/image-20230527140729-waan312.png","hash":"7eb8148e69f0cb3a939c5b3dd660545c3555e13f","modified":1745288519495},{"_id":"source/assets/image-20230527154724-v674duu.png","hash":"e57f382e17e0010d0e3684effe9260c649f9aeb1","modified":1745288519495},{"_id":"source/assets/image-20231119124615-vxa33dm.png","hash":"b2c0b04d99f9054312296f671a202c38d21f3702","modified":1745288519503},{"_id":"source/assets/net-img-0010-20230327194235-781jk47.png","hash":"d890a9ab327c0065b186eda3665a77555f66b202","modified":1745288519559},{"_id":"source/assets/net-img-1582873408415-b3e28487-6473-4fff-b4c9-b99b6b91a53a-20230330213216-4pmp0ac.webp","hash":"b22a07c71bb19493649e357ebe8ac92c1c9b80f4","modified":1745288519563},{"_id":"source/assets/net-img-1582873928532-40dd13b8-87fb-4ecd-8e07-399dbc61eeb8-20230330213331-q75g2s7.png","hash":"113b354cea75d36907ed70440faf49fdd397885b","modified":1745288519567},{"_id":"source/assets/net-img-1582874001071-2fe5ab73-14e5-45aa-b07c-81ba0fecc256-20230330213404-cm5njiz.png","hash":"211d2f540d3f18a1a692ba20c674d8cd3fb82a8a","modified":1745288519567},{"_id":"source/assets/net-img-1582874263210-a9e7bda6-4ed7-4d2d-8991-cdad8a2c292b-20230330213158-fukp6eb.png","hash":"3173c36ea570d35dd72ac5faa1a66803ad40812f","modified":1745288519571},{"_id":"source/assets/net-img-1582875390665-923c52b9-52ce-4e6f-9cee-763046546af3-20221030135517-j4zeqi7.png","hash":"112e4849845efefe49ce92bae1b850d6bc40a2d5","modified":1745288519571},{"_id":"source/assets/net-img-1591690708492-8b43720d-e8dc-4e22-9057-dcc4be2210de-20221030132325-ac88yvu.jpeg","hash":"db64f36546b2ae95739190e0994072eaa85dfb1f","modified":1745288519575},{"_id":"source/assets/net-img-1592902119376-b0ab487a-f7f3-454f-a784-aad737462ad4-20230330213502-h755rwl.png","hash":"dda2bfe438c8055100d16d9d7a132b43706e605d","modified":1745288519579},{"_id":"source/assets/net-img-1592902120990-cffe2ea4-a4ed-4505-8bbd-c9b64730ae6e-20230527145229-4455z5v.png","hash":"ad04409d1de7cdbb01b3fc6a8b7368ef80f5d80b","modified":1745288519579},{"_id":"source/assets/net-img-1593008781064-94397bdb-4bd4-475a-b0de-25689df5598d-20230330213216-bqv0b3r.jpeg","hash":"5cf37908a60979b8c0936e2d2ef0a91278f06c5a","modified":1745288519579},{"_id":"source/assets/net-img-1593008911203-7a81af80-db8b-4843-a59a-755e226e2314-20230330213217-h350tsl.jpeg","hash":"24ef0af2cd8bf480c01b58355b9d770de004b8a8","modified":1745288519583},{"_id":"source/assets/net-img-1593009574123-1720bb9a-11ab-462c-9acc-83dfd40a63e3-20230330213217-8hneydr.jpeg","hash":"7450dae97f4e6b2b24b12a60f50c88de1f3f8d99","modified":1745288519583},{"_id":"source/assets/net-img-1593010056655-793ce18b-c4e9-4985-9ba7-ef5347134e12-20230330213219-q7hvhww.png","hash":"f2af6f8b3a6ad39d3064a8c5f9cdbdedb6bf134e","modified":1745288519583},{"_id":"source/assets/net-img-1591690908749-8d13658b-f28f-4a16-9787-5d802366b2bb-20221030132339-jhzqts2.png","hash":"512a93f3e2cca50690d50a270235eabf87b47f2e","modified":1745288519579},{"_id":"source/assets/net-img-1593075259316-cba6509a-9a9a-4282-8698-99fa1fcc0794-20230330213350-b5wkbl5.png","hash":"77ef5f5fc2606eb5cf053d3987ca74886e24df95","modified":1745288519583},{"_id":"source/assets/net-img-1593075298003-cebf8380-65e8-4a56-9a03-72d7f02ef65c-20230330213346-itjo56n.png","hash":"316fdaa407fbf34ab761e6efc3597b56ee6100b7","modified":1745288519587},{"_id":"source/assets/net-img-1593075308254-c4ace563-ded0-42d8-8a4c-435a8bbe890f-20230330213356-yp75ww5.png","hash":"316fdaa407fbf34ab761e6efc3597b56ee6100b7","modified":1745288519587},{"_id":"source/assets/net-img-1593075466359-4fe25412-ad7b-4d12-ab59-556c6203aec3-20230330213411-owuofo8.png","hash":"2befb400a71425c989d9549b0e04b65214e9a716","modified":1745288519587},{"_id":"source/assets/net-img-1593075485480-eabde977-18f7-4a38-9f43-2a2792d14d5a-20230330213419-xbq6pfl.png","hash":"33763d8634927c0ea2ae44579eea5dfb9ae470e8","modified":1745288519587},{"_id":"source/assets/net-img-1593075294735-276336e9-41de-469d-a9e8-b4806bbdc0e9-20230330213341-wrzblbs.png","hash":"316fdaa407fbf34ab761e6efc3597b56ee6100b7","modified":1745288519587},{"_id":"source/assets/net-img-1592902119376-b0ab487a-f7f3-454f-a784-aad737462ad4-20230527145229-vu7qxs4.png","hash":"dda2bfe438c8055100d16d9d7a132b43706e605d","modified":1745288519579},{"_id":"source/assets/net-img-1593076022539-0b41a928-a33d-4749-8e05-a629389f5b11-20230330213208-977tliz.png","hash":"5beb1517d61fedd3981fdb6b992211c8e3e38bc0","modified":1745288519591},{"_id":"source/assets/net-img-1593075510764-fa7e6f63-dbec-4789-a374-d8b319f98994-20230330213428-853fmb5.png","hash":"f1cf27550f04d5863ee0f043848094cab3ba02fc","modified":1745288519587},{"_id":"source/assets/net-img-1596249786159-92610d33-5cbb-4d46-b7a5-6f1c8d3d1d92-20221030135516-9i6hh1r.jpeg","hash":"167542888a2ac22d16444dfffc6c7f3490afa4c5","modified":1745288519591},{"_id":"source/assets/net-img-1592902119321-dda9e910-093f-47bf-890e-4719cb145075-20230527145229-565b500.png","hash":"5339b6e9d1ca86874e2e278dd6576f48f7bca50f","modified":1745288519579},{"_id":"source/assets/net-img-1596783175795-a3a09f05-cdc6-4406-9b0a-0f3f6a28a5ff-20221030105031-64rpjno.jpeg","hash":"abdac5a591401ba625f9906a82d0151d6db649ff","modified":1745288519591},{"_id":"source/assets/net-img-1602914807774-75634a6f-e238-498a-b0ce-e27f039a9646-20221030124604-ehzp01i.png","hash":"c2fbab203e042d7575b5299d478924a0ab8e05d3","modified":1745288519595},{"_id":"source/assets/net-img-1602404087657-9aa12bdc-ba61-429f-bf21-dcf0efc211fa-20221030124615-fz11c88.png","hash":"6a5c2117715720f8a65bdaf2ae575d74a6af7f9a","modified":1745288519595},{"_id":"source/assets/net-img-1602998399972-d63036ef-500b-49ae-a31a-84a558efb1ae-20221030124502-upt9d1p.png","hash":"a4f9f093069a13bd7a44feee16f58851d8c74542","modified":1745288519595},{"_id":"source/assets/net-img-1603004208800-d47ee0f7-24fa-4b06-ae5f-8ce7b97e1e34-20221030124351-wgmd1lo.png","hash":"a869bf0b72f7dff0f0561b8c6f88fe846df28ed7","modified":1745288519599},{"_id":"source/assets/net-img-1602405124816-7ec65b09-2556-4ba3-b9ca-dabf0081929f-20230330213836-e0kef3p.png","hash":"38bf1df28a8794f922982beab6f83a5d86f728bb","modified":1745288519595},{"_id":"source/assets/net-img-1602920769113-5b1bf8b5-f2b3-4a36-948b-721849b796d7-20221030124537-xtsxn6h.png","hash":"e52d3c0fc15cfad4385dfe78e5d863b68ab4ad25","modified":1745288519595},{"_id":"source/assets/net-img-1603013275619-1a15e41e-436b-41ef-bce1-147db82e5a83-20221030124522-yeb4ilf.png","hash":"b4ea1c39bdc1604b038d114feed52f2e628f9665","modified":1745288519599},{"_id":"source/assets/net-img-1603013309762-3689744a-be23-4e8f-8487-d397b3cc7869-20221030124624-9buvwxc.png","hash":"a1bbc1affcf31dfe1308e483e928b285209e921a","modified":1745288519599},{"_id":"source/assets/net-img-1603013197743-541a8456-5d1b-477d-9658-1b6d5c06780a-20230330213832-g2oqx3t.png","hash":"4a4f123a2e54af955404aa1be763bdb3a398ffbd","modified":1745288519599},{"_id":"source/assets/net-img-1615611389351-2cfaa4d5-b52c-4a2e-a170-c32ce97d17a6-20221030135532-u420fpk.png","hash":"0ba2d08b26c612f6a89b5726f64087b5c9c84787","modified":1745288519599},{"_id":"source/assets/net-img-1615611389351-2cfaa4d5-b52c-4a2e-a170-c32ce97d17a6-20230330213518-3fydrb9.png","hash":"0ba2d08b26c612f6a89b5726f64087b5c9c84787","modified":1745288519599},{"_id":"source/assets/net-img-1615611419969-14ba7126-9f92-482c-a851-9898cece7e8f-20230330213518-2ptpa3a.png","hash":"cfc78b0e47b891d1fca9dc54d1ddd78afe90550a","modified":1745288519603},{"_id":"source/assets/net-img-1603013239640-a2f1a79b-35c2-4ca8-9355-5f37e9d680bb-20221030124448-sl4zele.png","hash":"5927bb1371fb10e84599ffcea6c902ddfd9b8439","modified":1745288519599},{"_id":"source/assets/net-img-1615611419969-14ba7126-9f92-482c-a851-9898cece7e8f-20221030135532-6itdbiz.png","hash":"cfc78b0e47b891d1fca9dc54d1ddd78afe90550a","modified":1745288519603},{"_id":"source/assets/net-img-1626851086718-49fece61-64f3-4f2e-9b78-f97e17176373-20230101203426-dn382za.png","hash":"46c374ebe93e60a9a4d8bb90d95a77021b45cb7c","modified":1745288519615},{"_id":"source/assets/net-img-1627291037100-eacf8101-ce28-4c56-9c4b-12e59e5a3b26-20221031123408-gsirdhu.jpeg","hash":"1c5326f40d22eab0e2a610f8ccc224b6b9501b76","modified":1745288519615},{"_id":"source/assets/net-img-1627455003158-01c028a9-eb52-46e6-85ab-c811d640a84d-20221031123409-s3v35p9.jpeg","hash":"56c8bddb1d453c3a47d11f847678b667770ff797","modified":1745288519619},{"_id":"source/assets/net-img-1629558034184-e1fe6601-777e-4a34-afe5-df37e5a9b720-20230330213445-e5uive7.png","hash":"550f368c0231a7e2f3021034569cc665d57a6787","modified":1745288519619},{"_id":"source/assets/net-img-1629559055065-5ad8d49f-81b6-45f3-87f8-c98716f799ed-20230330213451-7nkjlzc.png","hash":"3110a1357dfb77908084b87a5f8f8f745e16c988","modified":1745288519619},{"_id":"source/assets/net-img-1629870852837-ca139768-9f26-412a-8940-49ed6e38f57a-20230330213513-n1dmxgm.png","hash":"f5a30dac1d0f59a46c2637d318ce03b66f3121fa","modified":1745288519619},{"_id":"source/assets/net-img-1629559366006-0194df18-86f2-45fd-bd85-6f675b19bdb0-20230330213459-p7i5mm5.png","hash":"8f1be2292fcd61ed11916df32996d0c842f5868c","modified":1745288519619},{"_id":"source/assets/net-img-1631431982904-ce964c3b-4c64-4915-84a9-a3799dd2cf92-20230330213415-i9cgn1s.png","hash":"b770ae567fc87b114ec3116386d0e37edfc9a2be","modified":1745288519619},{"_id":"source/assets/net-img-1629560137959-ab93eb78-c083-4c80-8283-4cfc470c8af0-20230330213504-cteixk9.png","hash":"8a0f3c4fa62305900746a569186fe8839998f8ed","modified":1745288519619},{"_id":"source/assets/net-img-1646742883104-4eef3a95-3655-44f4-8887-2f5f1628732e-20230330213506-2xv20ln.png","hash":"1d55719d69d55b681aebfcccafda70e697684387","modified":1745288519623},{"_id":"source/assets/net-img-1626854477699-226d8221-ae45-44f5-b8fd-6003efd2531c-20230101203427-giho3sf.png","hash":"0f80ac0b2a2e4830fe7920af14fe54f5fe460552","modified":1745288519615},{"_id":"source/assets/net-img-640-20221123124059-5desc25.png","hash":"a0672bd10f97851a80294820734c8fdb8a83f76b","modified":1745288519635},{"_id":"source/assets/net-img-640-20230330194058-16epkoj.png","hash":"48e84cd029773e8adf0980b45354c56ec2e3df71","modified":1745288519635},{"_id":"source/assets/20210417191156743-20230127151311-j5awou3.png","hash":"660496d40debc115e3ecb4090bde67e518a9c6cd","modified":1745288519467},{"_id":"source/assets/20210417191245920-20230127151311-nf45pi0.png","hash":"59a93eaf67fc22a0ee5e55946fbe512406428c74","modified":1745288519467},{"_id":"source/assets/image-20221212232058-z1xl373.png","hash":"18ca78dfb60a0cf777cae7740f1c1299ea350062","modified":1745288519487},{"_id":"source/assets/image-20231117162020-0zic8ee.png","hash":"dd464a6d6f989f1ed302272194b29de04a038e68","modified":1745288519495},{"_id":"source/assets/image-20231126145713-0pou43f.png","hash":"427762194e416a4ed7a0a2cdc5ad9739a45ed666","modified":1745288519527},{"_id":"source/assets/net-img-1582873589321-1b21962d-3411-4d4f-af00-b2a82490e43c-20230330213311-i7hquya.png","hash":"fdfd6b2907a88b48a698e9051e943247d301de4e","modified":1745288519567},{"_id":"source/assets/net-img-1593010032163-e4fd6098-299b-4fac-adb3-b40e6ca3e534-20230330213218-jvzy0d2.png","hash":"69211aafe949bffe6da5649c54a6412496e2ddbe","modified":1745288519583},{"_id":"source/assets/net-img-1596005642573-853dc49e-7632-496d-9221-33e3b7879fea-20221030132325-84wdxkw.jpeg","hash":"88284c1eecce4f4b1bfc5382f8d4e08da4fccaf9","modified":1745288519591},{"_id":"source/assets/net-img-1624106093230-4372b31c-0d0f-4640-8e80-62b7bdd258e4-20230122192859-kbq2rlz.png","hash":"cb34bc60f583ed3d34b50574782211e0bab66919","modified":1745288519611},{"_id":"source/assets/net-img-1628905841173-c32bdb25-8b61-4f16-b08e-96898d7aeefc-20221031123444-2pva1h4.png","hash":"df9133d35fbddc693f913c6408a877dd58c9cd34","modified":1745288519619},{"_id":"source/assets/net-img-JDgR0O-20221030104726-xwobg2m.jpg","hash":"fa78b0c2612032e75f6b98f6509907b82332f666","modified":1745288519635},{"_id":"source/assets/20210417191226786-20230127151312-304h995.png","hash":"65b978ef856e5df70bbdc66c70b1d30e8b7b4ca4","modified":1745288519467},{"_id":"source/assets/20210417191255980-20230127151311-y6imh9a.png","hash":"69c83af75684b8f312f1255172bb7ad86f1de3b3","modified":1745288519471},{"_id":"source/assets/dubbo-framework-20221214214602-6xcgoty.jpg","hash":"956b54b92bc5c11635909a706fedde850930b89c","modified":1745288519483},{"_id":"source/assets/image-20230424141422-t5zbclo.png","hash":"83d623939686dc82dc41dca9e4815a4525816258","modified":1745288519491},{"_id":"source/assets/image-20231119124137-6apottn.png","hash":"eba7b1aeeea6dc0ee781cc54a0bfb8775bafd568","modified":1745288519499},{"_id":"source/assets/image-20230503214900-rmo1ydd.png","hash":"63d8124aaaf884e4c986b5aae4ae5db51aac6991","modified":1745288519491},{"_id":"source/assets/net-img-1582873583782-b5959bc6-9ff9-4ef1-95b3-9bc3fc1f83b9-20230330213307-m55wdql.png","hash":"e912d62b4c896916fb1eb15eb98b289666bc69b0","modified":1745288519563},{"_id":"source/assets/net-img-1582873594959-8501a655-dbe2-4983-9dcd-a33bde8f07f6-20230330213317-uu5k36v.png","hash":"a3c98651944a4bd158b0c2f5ec65dfb41b81a10c","modified":1745288519567},{"_id":"source/assets/net-img-1582875574292-5a9c3846-0673-451f-8a69-409c0c8dff9c-20221030103933-qh2ia8u.png","hash":"68c2624cfa788b453075a0902037673fffb432aa","modified":1745288519575},{"_id":"source/assets/net-img-1591690708399-bf1076aa-bdad-4e5f-ae30-261ccda91da5-20221030132327-4fweook.png","hash":"7a3f29db0804640a4084eed5e235dd6dea3ce1b6","modified":1745288519575},{"_id":"source/assets/net-img-1591690708909-03b304db-aa14-40fc-954b-2e5812e31b86-20221030132326-7iwfv9t.png","hash":"f30f62e8044d03122bcb10c1ecd936875c7864b2","modified":1745288519579},{"_id":"source/assets/net-img-1615614053644-2e45ea92-d426-42ca-a609-91b095ff7e83-20221030135532-iwc3p25.png","hash":"c593a666fb33cded85ae00413ade1c031882e5e6","modified":1745288519603},{"_id":"source/assets/net-img-1615619453470-bdab6e23-1385-4538-9c91-ceefcd05aa27-20221030135542-vyoxljv.png","hash":"30dfe5dcbbf79426f99197afbbfc3aa083e57836","modified":1745288519607},{"_id":"source/assets/net-img-1615614053644-2e45ea92-d426-42ca-a609-91b095ff7e83-20230330213519-1im5mrq.png","hash":"c593a666fb33cded85ae00413ade1c031882e5e6","modified":1745288519603},{"_id":"source/assets/net-img-1626851420391-9aa6cf8f-fa40-49c3-8a7a-941763583502-20230101203427-ybsosns.png","hash":"6c668b516ac102fc9727189230944b007d90baaf","modified":1745288519615},{"_id":"source/assets/net-img-1665073584346-6bc72f6a-0e4a-412e-94bc-81d860d5b059-20221111215527-k046iu2.png","hash":"8519cb1ad23cd866b3ba9254ad90fc4b7573732c","modified":1745288519627},{"_id":"source/assets/image-20230619222624-l98xjgi.png","hash":"cc14f495702df91cabd340194168ec55a3e3b060","modified":1745288519495},{"_id":"source/assets/image-20231117164621-qjdsktw.png","hash":"2b6cd4f708d015427be913cc191aef6258dda2dd","modified":1745288519499},{"_id":"source/assets/image-20231126155909-4zbslm1.png","hash":"0b7402beed24ffef50fb48547963e9c61644e8df","modified":1745288519527},{"_id":"source/assets/net-img-0011-20230327194235-6us5fo3.png","hash":"89253aaf65febdd684c337f9e7c82ab551a6fa73","modified":1745288519559},{"_id":"source/assets/net-img-0012-20230327194235-dpf6how.png","hash":"2176e4249b48413bbcbce7d6b9d27a34cf32a265","modified":1745288519559},{"_id":"source/assets/net-img-1582873565810-556fde0f-9973-46d5-9e8e-4853e80b6ba3-20230330213302-b5p12uc.png","hash":"52803510a8272e7507289a0acbaa5967d16c9a5f","modified":1745288519563},{"_id":"node_modules/hexo-theme-kratos-rebirth/.prettierignore","hash":"ae49ab74482bf0157ba7d30c21f5941a754ace36","modified":1745301264564},{"_id":"node_modules/hexo-theme-kratos-rebirth/.prettierrc","hash":"5f36b2ea290645ee34d943220a14b54ee5ea5be5","modified":1740119171853},{"_id":"node_modules/hexo-theme-kratos-rebirth/LICENSE","hash":"3dbbc837c7fd9be599f14a285e5fb5d48b4d8870","modified":1745301264580},{"_id":"node_modules/hexo-theme-kratos-rebirth/_config.yml","hash":"e846ad285f81a1b0af1ad76784d7b030f31249ea","modified":1745301264616},{"_id":"node_modules/hexo-theme-kratos-rebirth/ReadMe.md","hash":"8837b333650681cd3b84dc2880b7106e1beac8bf","modified":1745301264612},{"_id":"node_modules/hexo-theme-kratos-rebirth/package.json","hash":"83c1684e5162b62eb0b6869a7e5aa94f19ac772b","modified":1745301264608},{"_id":"node_modules/hexo-theme-kratos-rebirth/.husky/pre-commit","hash":"d93c558f564ea45c405fb08da13309ad3642aecb","modified":1745301264596},{"_id":"node_modules/hexo-theme-kratos-rebirth/devtools/build-once.js","hash":"60d86d0bdd3807ce33c544e2bacd8968b228e8e9","modified":1745301264604},{"_id":"node_modules/hexo-theme-kratos-rebirth/devtools/build-options.js","hash":"a433c50501cbb60b21d3e38632e59d8a2fa5276a","modified":1745301264604},{"_id":"node_modules/hexo-theme-kratos-rebirth/devtools/build-watch.js","hash":"d657fcec297bf6240f41ee442937b57d3869e18e","modified":1745301264604},{"_id":"node_modules/hexo-theme-kratos-rebirth/languages/zh-CN.yml","hash":"b77108a02d38755aedcb31a6bd900b054540c9ba","modified":1745301264616},{"_id":"node_modules/hexo-theme-kratos-rebirth/layout/archive.ejs","hash":"623ff5552eed30c929173a94495cc0408e716635","modified":1745301264600},{"_id":"node_modules/hexo-theme-kratos-rebirth/layout/category.ejs","hash":"5677b70953e6a33038a0e03eaa06e45c10ec7d73","modified":1745301264600},{"_id":"node_modules/hexo-theme-kratos-rebirth/layout/index.ejs","hash":"a8726925ebdf84617b508bf1a018a2b89ae1d4e6","modified":1745301264600},{"_id":"node_modules/hexo-theme-kratos-rebirth/layout/layout.ejs","hash":"a092091234ed2934f5eb00c1bc286a1129afcad1","modified":1745301264600},{"_id":"node_modules/hexo-theme-kratos-rebirth/layout/page.ejs","hash":"57c2d595e2dce3e4d9a6153c4a0f4c9f34bc2e44","modified":1745301264600},{"_id":"node_modules/hexo-theme-kratos-rebirth/layout/post.ejs","hash":"0e7ecca733e658f4c6c9524fdd3084f9026d16ad","modified":1745301264600},{"_id":"node_modules/hexo-theme-kratos-rebirth/layout/tag.ejs","hash":"5677b70953e6a33038a0e03eaa06e45c10ec7d73","modified":1745301264600},{"_id":"node_modules/hexo-theme-kratos-rebirth/scripts/additional-pages.js","hash":"61dcde531a4fd414fbc8c9c2b6ae92eac478db12","modified":1745301264604},{"_id":"node_modules/hexo-theme-kratos-rebirth/scripts/cdn-optimize-helpers.js","hash":"317191b128b031c3ba885c9a4dff68f28e070bfb","modified":1745301264604},{"_id":"node_modules/hexo-theme-kratos-rebirth/scripts/check-update.js","hash":"8272cd8c8dd22837f6f262c8e05b26099fdfaa87","modified":1745301264604},{"_id":"node_modules/hexo-theme-kratos-rebirth/scripts/gen-jsconfig.js","hash":"6e1aa475e99d5eac47d593ee46bf5e23543bbc3f","modified":1745301264604},{"_id":"node_modules/hexo-theme-kratos-rebirth/scripts/icon-to-html.js","hash":"d73e554f974fa8cfe702d986269e2ba46ea3a8d8","modified":1745301264604},{"_id":"node_modules/hexo-theme-kratos-rebirth/scripts/process-template.js","hash":"a0ba35be0a9b392c6f13b36c2bc127fac7ffe16d","modified":1745301264608},{"_id":"node_modules/hexo-theme-kratos-rebirth/scripts/search.js","hash":"7ca740b0f8dd084516eeda9c52b77ab04bed3a5e","modified":1745301264608},{"_id":"node_modules/hexo-theme-kratos-rebirth/scripts/tag-widgets.js","hash":"db83b945bc7c0710e085cac6f5f4985f92b411ba","modified":1745301264608},{"_id":"node_modules/hexo-theme-kratos-rebirth/.github/ISSUE_TEMPLATE/bug_report.yml","hash":"b07412f7926bd6bc9a2d327ce9c7ae67e548ba66","modified":1745301264616},{"_id":"node_modules/hexo-theme-kratos-rebirth/.github/ISSUE_TEMPLATE/feature_request.yml","hash":"7200fed1dfaaaa4d54f9c61fe1239f0ee040a6c0","modified":1745301264616},{"_id":"node_modules/hexo-theme-kratos-rebirth/.github/workflows/auto-release.yml","hash":"4fbe5b7c5aa47ea6c1116bd84de3088007ffc21b","modified":1745301264616},{"_id":"node_modules/hexo-theme-kratos-rebirth/.github/workflows/build-demo.yml","hash":"02bc61088feb85bebd4871006319c04d432b74cf","modified":1745301264616},{"_id":"node_modules/hexo-theme-kratos-rebirth/.github/workflows/build-test.yml","hash":"7ebd5e1f844b1c6cb67737566d7ff98eb843a0bd","modified":1745301264616},{"_id":"node_modules/hexo-theme-kratos-rebirth/layout/_index_style/card.ejs","hash":"ecb8a3368dadc0cf5df3c9305514f2313297f3fb","modified":1745301264600},{"_id":"node_modules/hexo-theme-kratos-rebirth/layout/_index_style/half.ejs","hash":"6ae5385151b0a9c94822087f8e316d1eb147bda4","modified":1745301264600},{"_id":"node_modules/hexo-theme-kratos-rebirth/layout/_index_style/status.ejs","hash":"5923b8dc74b161248db1f91db191c61b674c3430","modified":1745301264600},{"_id":"node_modules/hexo-theme-kratos-rebirth/layout/_modals/donate.ejs","hash":"9f4bbd3a03419c1da4a6157fc574b88846af8083","modified":1745301264600},{"_id":"node_modules/hexo-theme-kratos-rebirth/layout/_modals/share.ejs","hash":"7cea1da7c4579f6829b2f832e7d18fd730b7c258","modified":1745301264600},{"_id":"node_modules/hexo-theme-kratos-rebirth/layout/_pages/404.ejs","hash":"08babbe40015929680457cfd521832aad807dbdd","modified":1745301264596},{"_id":"node_modules/hexo-theme-kratos-rebirth/layout/_pages/categories.ejs","hash":"dd6c136ae3a28c6992500996d151a6083056797c","modified":1745301264600},{"_id":"node_modules/hexo-theme-kratos-rebirth/layout/_pages/search.ejs","hash":"dd050df8ce5a1bd3d4ac3091bacc4a24a993b7a8","modified":1745301264600},{"_id":"node_modules/hexo-theme-kratos-rebirth/layout/_partial/after-footer.ejs","hash":"7b1947b1454f106a72acc63197509141a9a5b6c0","modified":1745301264600},{"_id":"node_modules/hexo-theme-kratos-rebirth/layout/_pages/tags.ejs","hash":"6464e6a80cec58a7c517496a11e483d691f7abb0","modified":1745301264600},{"_id":"node_modules/hexo-theme-kratos-rebirth/layout/_partial/breadcrumb.ejs","hash":"deeaa93ca7513bc33a65797d7d5a66c9de6b16b4","modified":1745301264600},{"_id":"node_modules/hexo-theme-kratos-rebirth/layout/_partial/footer.ejs","hash":"676189d9fcaea6eb05c2dfa78c55205acd899302","modified":1745301264600},{"_id":"node_modules/hexo-theme-kratos-rebirth/layout/_partial/head.ejs","hash":"f25f3267b4f2caf6e66371b5a5527f97af7c9805","modified":1745301264600},{"_id":"node_modules/hexo-theme-kratos-rebirth/layout/_partial/header.ejs","hash":"9548a96fb6c1e3f37258ad3ef0817a4d9c13476d","modified":1745301264600},{"_id":"node_modules/hexo-theme-kratos-rebirth/layout/_partial/sidebar.ejs","hash":"ed0f28964cf73a8d90ba4dcaa992a66d42b13a35","modified":1745301264600},{"_id":"node_modules/hexo-theme-kratos-rebirth/layout/_widget/about.ejs","hash":"f970ca289ab43e715181cbbbe6c824d7880bf495","modified":1745301264596},{"_id":"node_modules/hexo-theme-kratos-rebirth/layout/_widget/category.ejs","hash":"b5494d86c54731125eeb93e5f93c2c978dbcc385","modified":1745301264600},{"_id":"node_modules/hexo-theme-kratos-rebirth/layout/_widget/posts.ejs","hash":"e48374fc0ca4e9ce5fe63483aa8f8504a92aa5c2","modified":1745301264600},{"_id":"node_modules/hexo-theme-kratos-rebirth/layout/_widget/tagcloud.ejs","hash":"d0f6a1f768c0145f7e76fcae9715d575a7e2c37d","modified":1745301264600},{"_id":"node_modules/hexo-theme-kratos-rebirth/layout/_widget/toc.ejs","hash":"10e8b0ca50309e9a7220edee38faa0b7321cab02","modified":1745301264604},{"_id":"node_modules/hexo-theme-kratos-rebirth/scripts/lib/cdn.js","hash":"d5ed17a54dbb710805090ca27b3bea102872da94","modified":1745301264604},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/css/kr-core.min.css","hash":"d72a0b5e296f5e1f5a09bb28cd6ca6246d50a32b","modified":1745301264596},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/404.webp","hash":"e07a240ab6ddeb77ee28a9531e0bc94077206248","modified":1745301264612},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/default.webp","hash":"6046fa3912d7001afea7e3634fc093ec7da3e7cc","modified":1745301264612},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/images/user.svg","hash":"9875dc6c4d296886d642a8ee3049db8aad406184","modified":1745301264612},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/js/kr-core.min.js","hash":"09d85de8fabc5d9d355c25b44adf8b32b3a42694","modified":1745301264604},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/js/kr-pjax.min.js","hash":"33842dc1a48f91ce3731baa6adf1969cf1443175","modified":1745301264608},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/js/kr-search.min.js","hash":"f21b03b0515aed07efa86f7103b5262bf20793f1","modified":1745301264608},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/js/kr-theme.min.js","hash":"b951ed9d6d15cc9424a49012672276543fdb935c","modified":1745301264608},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/css/kr-theme/dark.min.css","hash":"90c00f4c65f93ff5151d98d7722302944e4e3389","modified":1745301264596},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/css/kr-theme/light.min.css","hash":"3cfcb3ac03bc1349febe5cc8012fe1c67939b3fb","modified":1745301264596},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/js/kr-modal/donate.min.js","hash":"899cf6376b6a4d2d0075f81ef25c684f40a85727","modified":1745301264604},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/js/kr-modal/share.min.js","hash":"b8ce793233299bfaf6290d238ac531d328b6c4f8","modified":1745301264608},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/nprogress@0.2.0/History.md","hash":"38f837f30c75bed4b8990b36fdf540fe3c63ccd3","modified":1745301264608},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/nprogress@0.2.0/License.md","hash":"bc3e61d337e51c177534c644c20f190148d7905e","modified":1745301264612},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/nprogress@0.2.0/Notes.md","hash":"e7b5de6240b6918cbdccc708a06e4b20555966c1","modified":1745301264612},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/nprogress@0.2.0/Readme.md","hash":"63959b38ef0747eadd6f731b48d7aded7edc227b","modified":1745301264612},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/nprogress@0.2.0/bower.json","hash":"55980d38b6f24ec91f44579bcd38c667986368c5","modified":1745301264608},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/nprogress@0.2.0/component.json","hash":"ecbc4792d8583f73050dd4d918fea8073a7ded60","modified":1745301264608},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/nprogress@0.2.0/nprogress.css","hash":"17ca817a091da9dcf5fe0f2f1e1f2eea60a33149","modified":1745301264596},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/nprogress@0.2.0/nprogress.js","hash":"a7e1146d2021c42e68b599dc8bcc69d44fc31df3","modified":1745301264608},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/nprogress@0.2.0/package.json","hash":"574122118ffc8d4705e58806a13612553bc41588","modified":1745301264608},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/css/highlight/highlight.js/light.min.css","hash":"630129eab75776f1cf68122efd511a41d1ba2f71","modified":1745301264596},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/css/highlight/highlight.js/night-bright.min.css","hash":"824090a9fcbd60dbd79711c739c83c1a49d014d1","modified":1745301264596},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/css/highlight/highlight.js/night-blue.min.css","hash":"d2b9c867d6d07e2068e85229f65bcf647b0337a7","modified":1745301264596},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/css/highlight/highlight.js/night-eighties.min.css","hash":"48af974844df43711328280d72d9659a55407cac","modified":1745301264596},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/css/highlight/highlight.js/night.min.css","hash":"b62bd2c95fb37281235d2d6fa874605560cdb252","modified":1745301264596},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/css/highlight/prismjs/atom-dark.min.css","hash":"b99f782c938ebb1931ed3c7ea0aa2b16fc25ed16","modified":1745301264596},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1745301264596},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1745301264608},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1745301264596},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/nprogress@0.2.0/test/component.html","hash":"5965cc7f9bb812ada1ffcd6abec39124c20a4ef8","modified":1745301264604},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/nprogress@0.2.0/test/test.js","hash":"5c795debb89ec7d35ba1ec1e8ccbab0a7a353d78","modified":1745301264608},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/qr-code-styling@1.6.0-rc.1/lib/qr-code-styling.js","hash":"ea4d54224b3a1737c90bc1bba2d5742b75a60ee9","modified":1745301264608},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/viewerjs@1.11.6/dist/viewer.css","hash":"8cc334ada7b80acd5a4abba27eafa401955fe579","modified":1745301264596},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/viewerjs@1.11.6/dist/viewer.min.css","hash":"2e91a988d09aa17b3ee69463ec65a8b4447ae40c","modified":1745301264596},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/viewerjs@1.11.6/dist/viewer.min.js","hash":"8078b489658d7230e04069cefc84b99e1037f768","modified":1745301264608},{"_id":"source/assets/20210417191320754-20230127151312-g8jrdjp.png","hash":"dd1d3cb238af5550eef55056b50966793c34a226","modified":1745288519471},{"_id":"source/assets/image-20231117162030-ue9pyz9.png","hash":"6e9f29720c323a223db23d759b2a8c181b083ec3","modified":1745288519499},{"_id":"source/assets/image-20231119154230-3g5nidd.png","hash":"d6d544370fb3424614200bc4e507736e1232b51b","modified":1745288519503},{"_id":"source/assets/net-img-0002-20230327194009-43b76u4.png","hash":"fc814defbecf370c56170ac0d15f3e0b93b51696","modified":1745288519543},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1745301264616},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1745301264616},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/viewerjs@1.11.6/dist/viewer.common.js","hash":"d86e95961369ec9383f89341dbe31e8d20db5033","modified":1745301264608},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/viewerjs@1.11.6/dist/viewer.esm.js","hash":"1a76a6022b5c390eb786d7b3250a7e3c91d27389","modified":1745301264608},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/viewerjs@1.11.6/dist/viewer.js","hash":"471c93ce111abf02029a06661df79a4105f88408","modified":1745301264608},{"_id":"source/assets/net-img-1615619423077-dea312ee-787e-4a28-b723-199f76a214f7-20221030135542-mx20k3e.png","hash":"b4a5bed105f3d44c025b27c1b0f747b200b1fa27","modified":1745288519607},{"_id":"source/assets/微信图片_20221129215049-20221129215137-xy69pf5.jpg","hash":"49e75019313beb7dd36c03005938a4ab6dfed887","modified":1745288519639},{"_id":"source/assets/3fdc14e6be9f37b481abe633ac866a26-20230127151312-ko7ta8u.png","hash":"38a30a877028e896cb01f9ce849c88f4899a0c9e","modified":1745288519475},{"_id":"source/assets/net-img-0004-20230327194009-xusl7vj.png","hash":"4a31fef67d5662833fe069a5965459f3ad532818","modified":1745288519543},{"_id":"source/assets/net-img-0005-20230327194009-2m11zb7.png","hash":"45ecb280911ffd95feee86b4e637a127b22603ce","modified":1745288519547},{"_id":"source/assets/net-img-0007-20230327194009-obwi5jv.png","hash":"476b8a60e579a08ef8157ccece03e7a4ae3a3303","modified":1745288519551},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1745301264612},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1745301264604},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1745301264612},{"_id":"source/assets/net-img-1624109586831-fa30fbaf-01b4-4243-bedf-eedfe9631e67-20230122192859-buewr2p.png","hash":"e01f630b8f5bfefca0023ed64d4dcd7312b63643","modified":1745288519615},{"_id":"source/assets/net-img-0006-20230327194009-rdpidiy.png","hash":"90897c9c0c5369590efb4a3cb707f196222708d4","modified":1745288519547},{"_id":"source/assets/net-img-0009-20230327193706-lo1au43.jpg","hash":"b93578b5b9afce553dc98288e61d622408b19084","modified":1745288519555},{"_id":"source/assets/net-img-1623829860526-2438b2e1-de01-4c73-aa21-84e18c00d37c-20221031123408-wcse42k.png","hash":"0399712737ef6427d49e48d5d63dfbd23bf40e4d","modified":1745288519611},{"_id":"source/assets/image-20230619222818-5btwdt3.png","hash":"93d229df154b33632dc0fd6321f7d5d3348f7e08","modified":1745288519495},{"_id":"source/assets/net-img-0008-20230327194010-vj80p08.jpg","hash":"23b7ee822c099a0ba6d0236bbf138c14802582cc","modified":1745288519555},{"_id":"node_modules/hexo-theme-kratos-rebirth/source/vendors/font-awesome@4.7.0/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1745301264612},{"_id":"source/assets/net-img-1665073741703-3acb8484-f36b-4738-8769-c50625b23727-20221111215534-pwccic8.png","hash":"6a5abcd2924620571b61900f720e35f9771a1147","modified":1745288519631},{"_id":"source/assets/image-20231202123415-e2licnx.jpeg","hash":"e36fcb08b0e84f5f0ee2669fdeed9debbe0dda49","modified":1745288519539},{"_id":"source/assets/image-20231119154304-hwfdw8h.jpeg","hash":"a4f9157154e31ff5efa456ba1cda9e9dbc676bf2","modified":1745288519523},{"_id":"node_modules/hexo-theme-butterfly/LICENSE","hash":"c8bc7df08db9dd3b39c2c2259a163a36cf2f6808","modified":1745301884931},{"_id":"node_modules/hexo-theme-butterfly/README.md","hash":"e1b9096ae0c4e5ef0a911aec05dbad4a3aae3173","modified":1745301884943},{"_id":"node_modules/hexo-theme-butterfly/README_CN.md","hash":"92e45255b8725f0a00450c88fcfd51ec61e1db67","modified":1745301884943},{"_id":"node_modules/hexo-theme-butterfly/package.json","hash":"0f469650107841dc1dc716aa94b3ca2bb0721762","modified":1745301884943},{"_id":"node_modules/hexo-theme-butterfly/_config.yml","hash":"7166aff350fcf84cbc01835fad5731eb855cecd7","modified":1745301884971},{"_id":"node_modules/hexo-theme-butterfly/plugins.yml","hash":"a2704f0406484fdae3410e9992cf996f9859356e","modified":1745301884971},{"_id":"node_modules/hexo-theme-butterfly/.github/FUNDING.yml","hash":"da5e77f5e0cdb7e11b36546fb6796d10e3dfbe5d","modified":1745301884971},{"_id":"node_modules/hexo-theme-butterfly/languages/default.yml","hash":"a2c938b1ef69195aec10c90dc7d1871953548e01","modified":1745301884971},{"_id":"node_modules/hexo-theme-butterfly/languages/en.yml","hash":"a2c938b1ef69195aec10c90dc7d1871953548e01","modified":1745301884971},{"_id":"node_modules/hexo-theme-butterfly/languages/ja.yml","hash":"a281d3cc3e117e90597b783dc5569dba3976d2eb","modified":1745301884971},{"_id":"node_modules/hexo-theme-butterfly/languages/ko.yml","hash":"c7d861c58f204f47a5b4d6e118e1f1e8fb8a852f","modified":1745301884971},{"_id":"node_modules/hexo-theme-butterfly/languages/zh-CN.yml","hash":"e0bf36edf18cf3380b900be7528b536252990c26","modified":1745301884971},{"_id":"node_modules/hexo-theme-butterfly/languages/zh-HK.yml","hash":"bac3063ad2892be232f7d91361c28585a3cc7eb5","modified":1745301884971},{"_id":"node_modules/hexo-theme-butterfly/languages/zh-TW.yml","hash":"bd7ee35aa30964493d2729ef105bb86331b096c3","modified":1745301884971},{"_id":"node_modules/hexo-theme-butterfly/layout/archive.pug","hash":"bc77220dfc269b8faad0930e1a4142ebf68165e5","modified":1745301884947},{"_id":"node_modules/hexo-theme-butterfly/layout/category.pug","hash":"a7e9805a781e34e38d27462e6ce2a5821c34bb9f","modified":1745301884951},{"_id":"node_modules/hexo-theme-butterfly/layout/index.pug","hash":"a93004cc8ec8050df603d32a6e6e02cd96fd9875","modified":1745301884959},{"_id":"node_modules/hexo-theme-butterfly/layout/page.pug","hash":"7ce2a49c6c41847de4ccea377ade116339984434","modified":1745301884959},{"_id":"node_modules/hexo-theme-butterfly/layout/post.pug","hash":"65c4a49c65c3fc4d9dc88b9791a75710c698c3a1","modified":1745301884963},{"_id":"node_modules/hexo-theme-butterfly/layout/tag.pug","hash":"ca5333bd262cb58c195c844b593a0eed0c721766","modified":1745301884963},{"_id":"node_modules/hexo-theme-butterfly/.github/ISSUE_TEMPLATE/bug_report.yml","hash":"10ce05c8dbde09f53bdabe40b5388de9ccc71a31","modified":1745301884971},{"_id":"node_modules/hexo-theme-butterfly/.github/ISSUE_TEMPLATE/config.yml","hash":"63ad2249ad09fb3fe21bd5ff9adefb304a7ab24a","modified":1745301884971},{"_id":"node_modules/hexo-theme-butterfly/.github/ISSUE_TEMPLATE/feature_request.yml","hash":"6e0f9470b18bd37d4891282ac73d61676b040e8c","modified":1745301884971},{"_id":"node_modules/hexo-theme-butterfly/.github/workflows/publish.yml","hash":"e320b40c051bae1549156cd5ea4a51383cf78598","modified":1745301884971},{"_id":"node_modules/hexo-theme-butterfly/.github/workflows/stale.yml","hash":"4040c76547e270aaf184e9b219a44ca41bbb1b9f","modified":1745301884971},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/additional-js.pug","hash":"f9b02aac0dbbb2b71c037dd215e70c8b7ec7741c","modified":1745301884947},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/footer.pug","hash":"6bd41add3a45e55d5e51eab5285a2d1a909d37f3","modified":1745301884955},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head.pug","hash":"1d11e334b22dbbedcb0f751f9ee9789d4416605e","modified":1745301884955},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/layout.pug","hash":"e5e6c05a621483b3542f2884e8ba45e84b1e973a","modified":1745301884959},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/pagination.pug","hash":"bd45e6fa935ace9cb54499b0491dacfb78ccc354","modified":1745301884963},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/rightside.pug","hash":"43f951b639038f3bc01deea03368d8dcf492cbb0","modified":1745301884963},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/sidebar.pug","hash":"3e65b7bf6bccccbba7e15349f0a44f15c64c5b5e","modified":1745301884963},{"_id":"node_modules/hexo-theme-butterfly/scripts/common/postDesc.js","hash":"272613a71d16f0de6dac883be4839259f774be76","modified":1745301884943},{"_id":"node_modules/hexo-theme-butterfly/scripts/events/404.js","hash":"039fc75f363d79669b0b2177d929cdff6f2ef7a4","modified":1745301884935},{"_id":"node_modules/hexo-theme-butterfly/scripts/events/cdn.js","hash":"7864ba45716c51aef8d8b04fd4bc212e0008ce3b","modified":1745301884935},{"_id":"node_modules/hexo-theme-butterfly/scripts/events/comment.js","hash":"7b1b16e1e8e08245a345764616956be50487eb53","modified":1745301884939},{"_id":"node_modules/hexo-theme-butterfly/scripts/events/init.js","hash":"ce68e84a9ccfcf91100befbaa9afc392a0cd93bb","modified":1745301884939},{"_id":"node_modules/hexo-theme-butterfly/scripts/events/merge_config.js","hash":"10ffed853a935498f1f5da2c5b57200c957874a7","modified":1745301884939},{"_id":"node_modules/hexo-theme-butterfly/scripts/events/stylus.js","hash":"bac639c404588ea62e601ef0bcd368c3bd0119af","modified":1745301884943},{"_id":"node_modules/hexo-theme-butterfly/scripts/events/welcome.js","hash":"f59e10305fef59ea3e62a7395106c0927582879d","modified":1745301884943},{"_id":"node_modules/hexo-theme-butterfly/scripts/filters/post_lazyload.js","hash":"b23108d29fff3e32384d8689c8bcd2ab306a1ae7","modified":1745301884943},{"_id":"node_modules/hexo-theme-butterfly/scripts/filters/random_cover.js","hash":"20a6ebf63439501a4b3fc81e7a2a2ea5d103bace","modified":1745301884943},{"_id":"node_modules/hexo-theme-butterfly/scripts/helpers/aside_archives.js","hash":"3eb0bbb1288dc7b0ff82cc46ceb53bd666893416","modified":1745301884935},{"_id":"node_modules/hexo-theme-butterfly/scripts/helpers/aside_categories.js","hash":"0cdf781a8c14d7b50d309e69f282ec7b178804bb","modified":1745301884935},{"_id":"node_modules/hexo-theme-butterfly/scripts/helpers/getArchiveLength.js","hash":"bf77635e920eaf52bceebc95f87c7c87a7ca8038","modified":1745301884939},{"_id":"node_modules/hexo-theme-butterfly/scripts/helpers/inject_head_js.js","hash":"00c5742ad1c75b3c5684d02ffc6a1921399e5376","modified":1745301884939},{"_id":"node_modules/hexo-theme-butterfly/scripts/helpers/related_post.js","hash":"950b7d0966429bf0f9e6c5e1161e50e545e320b4","modified":1745301884943},{"_id":"node_modules/hexo-theme-butterfly/scripts/helpers/series.js","hash":"45367c4ce827329867dbcc750ec125da9ccb2cfd","modified":1745301884943},{"_id":"node_modules/hexo-theme-butterfly/scripts/helpers/page.js","hash":"a07b586b510aa2df953102d998e84207acc34f9b","modified":1745301884939},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/button.js","hash":"2f44e1b3ccd170b256eae178299d6fa933a8d490","modified":1745301884935},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/chartjs.js","hash":"195ba802d7e8406c155124a9c939a2318f82938b","modified":1745301884935},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/flink.js","hash":"25eefe10189caf3910a0e5d5b2f2043ae9255531","modified":1745301884939},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/gallery.js","hash":"fa3d0a64f7fce4aff7928d4ddd95548978ba001c","modified":1745301884939},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/hide.js","hash":"f02fb085a88a2c0c82aeffacc24e1b71c74bd7c0","modified":1745301884939},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/inlineImg.js","hash":"89c6c78d2db43b190055d5690741a79bab4f3e7e","modified":1745301884939},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/label.js","hash":"cf0bc17d0180231167cc6aa8a00fc64f198cb9f9","modified":1745301884939},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/mermaid.js","hash":"50d8d8fac5c5b6e26317028895d7d82a2cf46606","modified":1745301884939},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/note.js","hash":"e68d8d21f3a86e3646907a3685550ee20e8d4a9f","modified":1745301884939},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/score.js","hash":"f589fb6646bd17cf12d77a9b251dd614e1c8b899","modified":1745301884943},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/series.js","hash":"40bc9a065e3a1423e0e66f4911e00713ca9f5e9e","modified":1745301884943},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/tabs.js","hash":"3c486b149e28edd1a06843f05a5c355000991b82","modified":1745301884943},{"_id":"node_modules/hexo-theme-butterfly/scripts/tag/timeline.js","hash":"176804f07567aa80f1ed95897a968a996b155dec","modified":1745301884943},{"_id":"node_modules/hexo-theme-butterfly/source/css/index.styl","hash":"b13d96924a5534bff91d75566b196ac87b4fac22","modified":1745301884967},{"_id":"node_modules/hexo-theme-butterfly/source/css/var.styl","hash":"d1eec577074ab7b262182885576135bf1896e12c","modified":1745301884971},{"_id":"node_modules/hexo-theme-butterfly/source/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1745301884935},{"_id":"node_modules/hexo-theme-butterfly/source/img/error-page.png","hash":"d2519710498a871ca3e913c57e2ba20a805b6430","modified":1745301884947},{"_id":"node_modules/hexo-theme-butterfly/source/img/favicon.ico","hash":"455ac256580bf31a45813dbbdb87219bfc8bfb04","modified":1745301884935},{"_id":"node_modules/hexo-theme-butterfly/source/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1745301884935},{"_id":"node_modules/hexo-theme-butterfly/source/js/tw_cn.js","hash":"fdb5482d04a75bd79946ad1ed291d281d0e9362d","modified":1745301884943},{"_id":"node_modules/hexo-theme-butterfly/source/js/main.js","hash":"5a52047b8520f79864d5a4ee2379a29751aead23","modified":1745301884939},{"_id":"node_modules/hexo-theme-butterfly/source/js/utils.js","hash":"48637ad8e405306772b93837f33400bde1055819","modified":1745301884943},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/Open_Graph.pug","hash":"e93a36d3c29b5a02c7f26a23f96e1f84b063cbe8","modified":1745301884959},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/analytics.pug","hash":"e792a435afee1f9491095084a00dc77e3522c1fd","modified":1745301884947},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/config.pug","hash":"9ea75b06f19bf356f340f4a3fc1bdc0713cfe445","modified":1745301884951},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/google_adsense.pug","hash":"f29123e603cbbcc6ce277d4e8f600ba67498077c","modified":1745301884955},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/config_site.pug","hash":"56a3c32de1a15627ff38c67f1131cdd6ec5ac924","modified":1745301884951},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/preconnect.pug","hash":"1e1a69aa2cbda2e621c741b3802093244b3cc04e","modified":1745301884963},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/pwa.pug","hash":"83ed05ef1e39f2ee70c3fba2cf96e488d8ffec66","modified":1745301884963},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/site_verification.pug","hash":"5168caadc4cf541f5d6676a9c5e8ae47a948f9ad","modified":1745301884963},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/head/structured_data.pug","hash":"1b83ae33961528f128596753fd05067c672d6bff","modified":1745301884963},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/header/index.pug","hash":"44331c9db74b281b5c5c41439d3407a9076df1a1","modified":1745301884955},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/header/menu_item.pug","hash":"733184f88e3a586a5fcc9d193ad500556b6c8eed","modified":1745301884959},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/header/post-info.pug","hash":"7d799c4694adb6e265e3f4b975d7f7f6a7021a17","modified":1745301884963},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/header/social.pug","hash":"e2d31e0f450ad42c47f7ee96375799342bf2f19b","modified":1745301884963},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/header/nav.pug","hash":"18b984ce184ea53d2dff5a03cc2d0d39d2ec3406","modified":1745301884959},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/loading/fullpage-loading.pug","hash":"a2f7d69ca7ec58f24fe7d4e04ae21d5b62b01567","modified":1745301884955},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/loading/index.pug","hash":"d76ce71ba106e350670c021a3dcae57547d01830","modified":1745301884955},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/loading/pace.pug","hash":"9d2d539555bab495959b9df734ed5c43a9f9e5a9","modified":1745301884959},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/mixins/article-sort.pug","hash":"ef7afe0df7a3746744ac8185da7163b7406120ca","modified":1745301884947},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/mixins/indexPostUI.pug","hash":"f3389fa9ae4fa32e3c16573286583bc3023e57ad","modified":1745301884959},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/page/categories.pug","hash":"5276a8d2835e05bd535fedc9f593a0ce8c3e8437","modified":1745301884951},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/page/default-page.pug","hash":"efb40388e37cca0b5e7c3c66e811a42f8d32c910","modified":1745301884951},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/page/404.pug","hash":"15d32c511e4875066fcbe9cb84c3ada07b5a7c41","modified":1745301884947},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/page/flink.pug","hash":"6b0fa5f048aca8e9cbe56978301af918cf7ac34a","modified":1745301884955},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/page/shuoshuo.pug","hash":"b2423cfc57a5e3a0e1112ff7c18d5c5c720d89d5","modified":1745301884963},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/page/tags.pug","hash":"79ad31eb72a9e14007770b18a426406a25315b38","modified":1745301884963},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/post/outdate-notice.pug","hash":"b7ce9484bc5c97ea6154f0b78fb9b8951fafedbd","modified":1745301884959},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/post/post-copyright.pug","hash":"b96c232e5178d927987791d9ae386dd83679535a","modified":1745301884963},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/post/reward.pug","hash":"db92f25ff3fd061882f81bf74ca560ff66983a0c","modified":1745301884963},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/aplayer.pug","hash":"ed79fef5b5025415ea12eaed970f3fe7f6ef9596","modified":1745301884947},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/effect.pug","hash":"43014bfc63583d3ee8808d526dd165848c0ed52f","modified":1745301884955},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/pjax.pug","hash":"efe4f8019632b51c92c4f7628758538305e06e47","modified":1745301884963},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/subtitle.pug","hash":"236c3ce26dd76e80b04d457789475c42da5ac0c8","modified":1745301884963},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/prismjs.pug","hash":"88f979a0b1a19eeb0db229247833bf9c6865c3b9","modified":1745301884963},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/umami_analytics.pug","hash":"bc35a1552d26ecdeeadbf06300078dbb5128a6e5","modified":1745301884963},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_ad.pug","hash":"a8312b527493dabbadbb1280760168d3bc909a3b","modified":1745301884947},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_announcement.pug","hash":"21e019bdc3b1e796bb00976bb29af2d51f873624","modified":1745301884947},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_author.pug","hash":"1aba8aa7cd767dc96879d13a13b4c8ceb9023233","modified":1745301884947},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_bottom_self.pug","hash":"1dba77d250eeebfb6e293d504352c7e9ea31980b","modified":1745301884947},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_archives.pug","hash":"73d33b6930e7944187a4b3403daf25d27077a2dd","modified":1745301884947},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_categories.pug","hash":"66e383b4ef374951eb87dd1bf4cdb7a667193fb5","modified":1745301884947},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_newest_comment.pug","hash":"d8753772889b5d0f4d15639ed6af5e91e53b1d03","modified":1745301884947},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_post_series.pug","hash":"e0bb72fa0ce15964b11b8fe421cae3432394e35f","modified":1745301884947},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_post_toc.pug","hash":"1dd19a564320d248dbcee7f118a5b96c6466da65","modified":1745301884947},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_recent_post.pug","hash":"bb842d2aa6469d65bf06af1372f0a19a9e4ef44c","modified":1745301884947},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_tags.pug","hash":"842b772a387b576550fa127030e1c2e9bf65716d","modified":1745301884951},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_top_self.pug","hash":"7b5ae404a1205546b7de4be42291315cf918f2b3","modified":1745301884951},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/card_webinfo.pug","hash":"fcddd80cdeb6aa81f342cd9f0102302f6ba087a8","modified":1745301884951},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/widget/index.pug","hash":"45f620cd87b9ef2aa9d1e024e697ed6b4eecff34","modified":1745301884959},{"_id":"node_modules/hexo-theme-butterfly/source/css/_global/function.styl","hash":"d12340a7df4601b9a23f070e16645861aeb3bb0a","modified":1745301884967},{"_id":"node_modules/hexo-theme-butterfly/source/css/_global/index.styl","hash":"4fcb8222b9548e22f7b76f12d33e3698240cbae0","modified":1745301884967},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/highlight.styl","hash":"67062d597408068e4a59e95851e98fed34b745da","modified":1745301884967},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/theme.styl","hash":"a51edfd3e499e7d38c32241c40e8e4d371efca73","modified":1745301884971},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/aside.styl","hash":"ba174889e770ae9f6683379b9eae9d8c94253080","modified":1745301884967},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/chat.styl","hash":"4cc02bcbaa4a1933a82a9ea57a603fe2d059fc77","modified":1745301884967},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/comments.styl","hash":"fbfce4d67cacd1df22fb73d89d008693f59d9d91","modified":1745301884967},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/footer.styl","hash":"d7b988d8588207086670f39aa49fce442c429f7a","modified":1745301884967},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/head.styl","hash":"094108f2a4e351a2fa496d6bd3e2388151416b3f","modified":1745301884967},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/loading.styl","hash":"f0b01bbf321c2c24fdccaee367dd9fd448031a72","modified":1745301884971},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/pagination.styl","hash":"7d7554573c005399bc8c2264a85896d2d51be1e1","modified":1745301884971},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/relatedposts.styl","hash":"ef8e8549fe7ad4b99793844a93b4a89f77f417d5","modified":1745301884971},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/reward.styl","hash":"d9cdf564a822a585e67fd5bac8573ba87eeb3743","modified":1745301884971},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/post.styl","hash":"543eaf9c7df7e0db841e5946ee5f9082c3c46290","modified":1745301884971},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/rightside.styl","hash":"a0f5835f04358122e8b1d38dd3e8da09a1b5b431","modified":1745301884971},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/sidebar.styl","hash":"084dc4dfb41f55e237a9d6cf8c2f5dba729b83be","modified":1745301884971},{"_id":"node_modules/hexo-theme-butterfly/source/css/_layout/third-party.styl","hash":"0af7c8754f04bdd9a02a14d880774753bd2e35ee","modified":1745301884971},{"_id":"node_modules/hexo-theme-butterfly/source/css/_mode/darkmode.styl","hash":"4c9849df9c68d892c7df0ca28123aeb0dc9dc424","modified":1745301884967},{"_id":"node_modules/hexo-theme-butterfly/source/css/_mode/readmode.styl","hash":"ad66212554468b7067590308ed4cf40524fea662","modified":1745301884971},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/404.styl","hash":"205ccc7d0ec6ce1193b46bc0c9ce0385594581fb","modified":1745301884967},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/archives.styl","hash":"5abe5480d83ff8b452a780a484d50a44091475bf","modified":1745301884967},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/categories.styl","hash":"c4cda7b0c99015df29ce00fdfddd2f7679653754","modified":1745301884967},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/common.styl","hash":"dcff804c4c237e1e908481b44c1ac4e39ac0da34","modified":1745301884967},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/flink.styl","hash":"1f8d715faf3b91b53426e38195c0920afb3bfa1c","modified":1745301884967},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/homepage.styl","hash":"992d192db7d1c96e995b85ed11c20c571d33fbad","modified":1745301884967},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/shuoshuo.styl","hash":"79bb1d9a27822ed5675d1e52f5dbd0e2f5d5010a","modified":1745301884971},{"_id":"node_modules/hexo-theme-butterfly/source/css/_page/tags.styl","hash":"7543bb688876a946538d66b991c71b94b5216277","modified":1745301884971},{"_id":"node_modules/hexo-theme-butterfly/source/css/_search/algolia.styl","hash":"d8a8275a68a1421c4c09b604cf78bea16c1d0463","modified":1745301884967},{"_id":"node_modules/hexo-theme-butterfly/source/css/_search/index.styl","hash":"6c4cbdadd9a49029fe0c59e29808d873e5b6b6ee","modified":1745301884967},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/button.styl","hash":"de8437a058a315d14d7e7034066f095b7b3ed4b4","modified":1745301884967},{"_id":"node_modules/hexo-theme-butterfly/source/css/_search/local-search.styl","hash":"1f2b86df86df81c3a59377b29102314ffc73dfa6","modified":1745301884971},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/gallery.styl","hash":"30d1f809efd252ed0233d96d4374efd2b01d2292","modified":1745301884967},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/hexo.styl","hash":"985b183db7b7bfd8f9bdb60494549fb7f850348b","modified":1745301884967},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/hide.styl","hash":"d27dbccaf3de1c9158d19e4fd49a25953cb5778d","modified":1745301884967},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/inlineImg.styl","hash":"3be8d0a75e7cc96548667cae0cb6a474279bd0b5","modified":1745301884967},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/label.styl","hash":"216f52fefc2274b542b549d8470503e6f1a308fb","modified":1745301884967},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/note.styl","hash":"4929382bd60788d34752a66e2fe764ef797a72a0","modified":1745301884971},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/series.styl","hash":"0657169849bc4bf4d93b5492ade040c8f58c1901","modified":1745301884971},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/tabs.styl","hash":"3a88eedcb694da79e92581ce50cb1a430b1fb615","modified":1745301884971},{"_id":"node_modules/hexo-theme-butterfly/source/css/_tags/timeline.styl","hash":"e846ddaef494d46cdfa2379deacfe74fa1cc5264","modified":1745301884971},{"_id":"node_modules/hexo-theme-butterfly/source/css/_third-party/normalize.min.css","hash":"8549829fb7d3c21cd9e119884962e8c463a4a267","modified":1745301884935},{"_id":"node_modules/hexo-theme-butterfly/source/js/search/algolia.js","hash":"7119f2f2943de71999d3dd6ba5c60cde846f114b","modified":1745301884935},{"_id":"node_modules/hexo-theme-butterfly/source/js/search/local-search.js","hash":"a2b783230a9143de69004cfc914d9f55e6fc1660","modified":1745301884939},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/abcjs/abcjs.pug","hash":"febff991595504d8e850ced0b9cc090f02ed97f0","modified":1745301884947},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/abcjs/index.pug","hash":"f0a90d8e39915a74b16ef22e851f179415cd7eaa","modified":1745301884959},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/artalk.pug","hash":"b03ee8625149191f9d5d057bbc9824b68d8dd0c4","modified":1745301884947},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/disqus.pug","hash":"d6fff5a7f84c8b09f282f9ddc0020a68a8aac9ea","modified":1745301884955},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/fb.pug","hash":"cbfbcf34a24d21ba2b21cf9eedb76f4c3c563c5a","modified":1745301884955},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/index.pug","hash":"846cabae287ae31b3bbfac3da022475713dd5ecc","modified":1745301884959},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/twikoo.pug","hash":"b5db4203a1392385838c73549ddeae0a4be67eba","modified":1745301884963},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/valine.pug","hash":"7884883ec15792f7e54daacb3c62b851dde2b66a","modified":1745301884963},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/waline.pug","hash":"fd2320ee25507bb8ef49f932c2d170586b44ea4d","modified":1745301884967},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/chat/chatra.pug","hash":"5b29badecbbe828112c001156023fc0566045cf6","modified":1745301884951},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/chat/crisp.pug","hash":"24d094fd917947c0ca7492fa094328b1a183b873","modified":1745301884951},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/chat/index.pug","hash":"e8438941085def0591a72fc9b0d705dbf107f54f","modified":1745301884959},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/chat/tidio.pug","hash":"62466b251052cae609b6369d4cb4b6a85320757d","modified":1745301884963},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/artalk.pug","hash":"89c63a5f0c0ab6314de7158fbc8fcbc84997fc55","modified":1745301884947},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/disqus.pug","hash":"f2ea5249b3e6670f6c8c77868f4f42c502e43830","modified":1745301884955},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/disqusjs.pug","hash":"c81fa7d8a5cb96d1ae07bfa8c46b84a58161add1","modified":1745301884955},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/facebook_comments.pug","hash":"8af585e6d6f73ee57114eefad574dc6e8ea9f570","modified":1745301884955},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/giscus.pug","hash":"592b2251db6c1abeb8b0eebe3b2e6d9aa0dec445","modified":1745301884955},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/gitalk.pug","hash":"58914c58a190e3bc0aa37cb581e77e442b563501","modified":1745301884955},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/index.pug","hash":"db6713d2b90eb8183f86ac92c26761a8501c0ddb","modified":1745301884959},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/js.pug","hash":"3abbaaa4ea575c45b3cebffd40bad1acc6ffce84","modified":1745301884959},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/livere.pug","hash":"7a80231fc71822e503879383a2d9611edf1d72dd","modified":1745301884959},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/remark42.pug","hash":"84f7cfde00f929fa3dc40349bcab060ec68f1b9f","modified":1745301884963},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/twikoo.pug","hash":"53d99831f29aeb2e336ed1407d79590041f77002","modified":1745301884963},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/valine.pug","hash":"24f18b0c67803210d53abbf9c1d454c000b06eee","modified":1745301884963},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/waline.pug","hash":"e2bf15357485cd502414b3b20f5b1f762a2fd014","modified":1745301884967},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/math/chartjs.pug","hash":"732eb1118ea1a73aa5c164d639097c614f8e9953","modified":1745301884951},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/math/index.pug","hash":"af66d13204030d47537b9e31a6173e63589ce7ff","modified":1745301884959},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/math/katex.pug","hash":"b83db9fa64d42a0bfd97efb660e09be3f166a144","modified":1745301884959},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/math/mathjax.pug","hash":"db2f4fff80a1166476ea76ae004aa186df11bad3","modified":1745301884959},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/math/mermaid.pug","hash":"ca2fc5928ca292f29fd8333c73733344994096fb","modified":1745301884959},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/artalk.pug","hash":"187302dbc916852ff2fdf47061e272c061611dda","modified":1745301884947},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/common.pug","hash":"27fa75affebc6e84a487c62bceff783bde595256","modified":1745301884951},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/disqus-comment.pug","hash":"fa4b4194749d05f7249f365f2b89c0281057ce54","modified":1745301884951},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/github-issues.pug","hash":"72e2970b23570e308f8af5d8ba8e5e3321d01bbf","modified":1745301884955},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/index.pug","hash":"a7c07dbc1e970a5b247091458e1ee9b144a3366d","modified":1745301884959},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/remark42.pug","hash":"34edfebf0cace0852806be774910ccb0e0914650","modified":1745301884963},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/twikoo-comment.pug","hash":"d2e12a9fc302a4efe52c90d44896fbd73e193a1f","modified":1745301884963},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/valine.pug","hash":"d376ec17fb19fcdcf0d2ad71330190146d3af879","modified":1745301884967},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/card-post-count/remark42.pug","hash":"716dc463fe4ef5112e7018ed60804125fdfa5cad","modified":1745301884963},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/newest-comments/waline.pug","hash":"ec6c685080634ac46ffbea1b8f10313388888f43","modified":1745301884967},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/search/algolia.pug","hash":"7f0ede1cd3fed2669c94a8e1b21bc0b183f310b8","modified":1745301884947},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/search/docsearch.pug","hash":"013756ff3363344987cc00fc9bd833baf193c341","modified":1745301884955},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/search/index.pug","hash":"f8557548d2ad8dd149c562193991c6c6cda02415","modified":1745301884959},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/search/local-search.pug","hash":"2622b4cf9189fa23e4a422aaf9ef272e4f2c6137","modified":1745301884959},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/share/addtoany.pug","hash":"f5ee1c9c8ffa4bca972d30f4de69268b8d47f052","modified":1745301884947},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/share/share-js.pug","hash":"efef352c1d122409575386bf3894dce8e87032e2","modified":1745301884963},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/share/index.pug","hash":"e51e896ccb13900de38dc81cf44dc789e2418a12","modified":1745301884959},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/highlight/diff.styl","hash":"9f02598b5e4296aec6470639d4bac4c9ac46392e","modified":1745301884967},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/highlight/index.styl","hash":"ef52ebf1e8e751a412f9456fdaeee7d88afd9a72","modified":1745301884967},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/prismjs/diff.styl","hash":"077ec530831be1d80e93da380406b9f5abd0918a","modified":1745301884967},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/prismjs/index.styl","hash":"1883c91d43bff10aae55122a21e0b064b6f5c9dd","modified":1745301884967},{"_id":"node_modules/hexo-theme-butterfly/source/css/_highlight/prismjs/line-number.styl","hash":"de4bb5fc2dfca368b35e4c1109c92f7abc9e2245","modified":1745301884971},{"_id":"node_modules/hexo-theme-butterfly/layout/includes/third-party/comments/utterances.pug","hash":"30a7d157890de69deab28baa47fb7bb28b040efd","modified":1745301884963},{"_id":"node_modules/hexo-theme-butterfly/source/img/butterfly-icon.png","hash":"f5dd732fed5c3bcd4aa76bac3441bac8485fb432","modified":1745301884943},{"_id":"source/about/index.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1745302527631},{"_id":"source/_posts/java/thread/assets/net-img-1582875399701-d03e5b25-a1c9-498e-85d6-18f86f41e38f-20221030135517-a6hu6sv.png","hash":"926070ac7bf26f22aab50a0f1b4ad414a02a22fd","modified":1745304424332}],"Category":[],"Data":[],"Page":[{"title":"分类","date":"2023-03-26T06:56:21.000Z","updated":"2025-04-22T02:21:59.639Z","type":"categories","comments":1,"description":null,"keywords":null,"top_img":null,"mathjax":null,"katex":null,"aside":null,"aplayer":null,"highlight_shrink":null,"_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\ndate: 2023-03-26 14:56:21\nupdated:\ntype: \"categories\"\ncomments:\ndescription:\nkeywords:\ntop_img:\nmathjax:\nkatex:\naside:\naplayer:\nhighlight_shrink:\n---\n","path":"categories/index.html","layout":"page","_id":"cm9s3f3yk0000bfg4b9w86gjl","content":"","excerpt":"","more":""},{"title":"music","date":"2023-03-26T08:02:27.000Z","updated":"2025-04-22T02:21:59.639Z","type":null,"comments":1,"description":null,"keywords":null,"top_img":null,"mathjax":null,"katex":null,"aside":null,"aplayer":null,"highlight_shrink":null,"_content":"","source":"music/index.md","raw":"---\ntitle: music\ndate: 2023-03-26 16:02:27\nupdated:\ntype:\ncomments:\ndescription:\nkeywords:\ntop_img:\nmathjax:\nkatex:\naside:\naplayer:\nhighlight_shrink:\n---\n","path":"music/index.html","layout":"page","_id":"cm9s3f3ys0002bfg46amjefog","content":"","excerpt":"","more":""},{"title":"标签","date":"2023-03-26T06:54:25.000Z","updated":"2025-04-22T02:21:59.639Z","type":"tags","comments":1,"description":null,"keywords":null,"top_img":null,"mathjax":null,"katex":null,"aside":null,"aplayer":null,"highlight_shrink":null,"_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2023-03-26 14:54:25\nupdated:\ntype: \"tags\"\ncomments:\ndescription:\nkeywords:\ntop_img:\nmathjax:\nkatex:\naside:\naplayer:\nhighlight_shrink:\n---\n","path":"tags/index.html","layout":"page","_id":"cm9s3f3yu0004bfg411vb67bv","content":"","excerpt":"","more":""},{"_content":"","source":"about/index.md","raw":"","date":"2025-04-22T06:15:27.631Z","updated":"2025-04-22T06:15:27.631Z","path":"about/index.html","_id":"cm9s4299d0000rmg4gjo77wkg","title":"","comments":1,"layout":"page","content":"","excerpt":"","more":""}],"Post":[{"title":"Base","date":"2022-10-30T05:24:18.000Z","lastmod":"2022-10-30T05:24:18.000Z","_content":"\n# Base\n\n## String 类和常量池\n\n　　String 对象的两种创建方式：\n\n```java\nString str1 = \"abcd\";//先检查字符串常量池中有没有\"abcd\"，如果字符串常量池中没有，则创建一个，然后 str1 指向字符串常量池中的对象，如果有，则直接将 str1 指向\"abcd\"\"；\nString str2 = new String(\"abcd\");//堆中创建一个新的对象\nString str3 = new String(\"abcd\");//堆中创建一个新的对象\nSystem.out.println(str1==str2);//false\nSystem.out.println(str2==str3);//false\n```\n\n　　这两种不同的创建方法是有差别的。\n\n　　第一种方式是在常量池中拿对象,如果没有则在字符串常量池中创建一个；\n第二种方式是直接在堆内存空间创建一个新的对象。\n**注意**\n\n- 直接使用双引号声明出来的 String 对象会直接存储在常量池中\n- 如果不是用双引号声明的 String 对象，可以使用 String 提供的 intern 方法，JDK1.7之前（不包含1.7）的处理方式是在常量池中创建与此 String 内容相同的字符串，并返回常量池中创建的字符串的引用，JDK1.7以及之后的处理方式是在常量池中记录此字符串的引用，并返回该引用\n\n## StringBuffer 和 StrinBuilder 区别 ,String 为何不可变\n\n　　java8 中 String 类使用 final 关键字修饰**字符数组**来保存字符串`private final char value[]`\njava8 之后 java9 等 String 类使用 final 关键字修饰**字节数组**来保存字符串`private final byte[] value`\n\n　　`StringBuffer` 和 `StringBuilder` 继承 `AbstractStringBuilder` 而在`AbstractStringBuilder`中使用字符数组存储字符串`char[] value`并没有使用 final 关键字修饰\n\n- 从线程安全性考虑:\n  String 中对象不可变,可理解为常量,线程安全.`AbstractStringBuilder`是公共父类,定义了一些字符串基本操作.Stringbuffer 对方法添加了同步锁或对调用的方法加了同步锁,线程安全.Stringbuilder 并没有对方法加同步锁加同步锁,所以非线程安全\n- 从性能考虑:\n  每次改变 String 类型会新建一个 String 对象,让后指针指向新的 String 对象,StringBuffer 每次使用对 StringBuffer 对象本身操作,不会产生新的对象,而是改变对象的引用.而 StringBuilder 相比 StringBuffer 性能会提升一部分,但需要承担线程不安全的风险\n\n## 在 Java 中定义一个不做事且没有参数的构造方法的作用\n\n　　在执行子类构造方法时,若没有调用`super()`,则默认会调用父类的无参构造函数,若父类中没有无参构造函数,编译就会报错\n\n## 接口和抽象类的区别是什么？\n\n1. 接口的方法默认是 public，所有方法在接口中不能有实现(Java 8 开始接口方法可以有默认实现），而抽象类可以有非抽象的方法。\n2. 接口中除了 static、final 变量，不能有其他变量，而抽象类中则不一定。\n3. 一个类可以实现多个接口，但只能实现一个抽象类。接口自己本身可以通过 extends 关键字扩展多个接口。\n4. 接口方法默认修饰符是 public，抽象方法可以有 public、protected 和 default 这些修饰符（抽象方法就是为了被重写所以不能使用 private 关键字修饰！）。\n5. 从设计层面来说，抽象是对类的抽象，是一种模板设计，而接口是对行为的抽象，是一种行为的规范。\n6. 关于抽象类 JDK 1.8 以前，抽象类的方法默认访问权限为 protected JDK 1.8 时，抽象类的方法默认访问权限变为 default\n7. JDK 1.8 以前，接口中的方法必须是 public 的 JDK 1.8 时，接口中的方法可以是 public 的，也可以是 default 的\n\n## 成员变量与局部变量区别\n\n　　语法上:成员变量可以被`public``private``static`等修饰,局部变量不能被修饰.但都能被`final`所修饰\n内存中的存储方式:如果成员变量是使用`static`修饰的，那么这个成员变量是属于类的，如果没有使用`static`修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存\n生命周期:成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失\n成员变量如果没有被赋初值,则会自动以类型的默认值而赋值（一种情况例外:被 final 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。\n\n## 为什么重写 equals 时必须重写 hashCode 方法\n\n　　`==` : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不试同一个对象。\n\n　　`equals()` : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况(前面第 1 部分已详细介绍过)：\n情况 1，类没有覆盖`equals()`方法。则通过`equals()`比较该类的两个对象时，等价于通过“==”比较这两个对象。\n情况 2，类覆盖了`equals()`方法。一般，我们都覆盖`equals()`方法来两个对象的内容相等；若它们的内容相等，则返回 true(即，认为这两个对象相等)。\n分两种情况\n\n- 不会创建“类对应的散列表” 例如:不会创建该类的 HashSet 集合。\n\n　　在这种情况下`equals()`用来比较该类的两个对象是否相等。而 hashCode() 则根本没有任何作用，所以，不用理会 hashCode()。\n\n- 会创建“类对应的散列表” 例如，会创建该类的 HashSet 集合,且自定义对象为键值\n\n1. 如果两个对象相等，那么它们的 hashCode()值一定相同。这里的相等是指，通过 equals()比较两个对象时返回 true。\n2. 如果两个对象 hashCode()相等，它们并不一定相等。因为在散列表中，hashCode()相等，即两个键值对的哈希值相等。然而哈希值相等，并不一定能得出键值对相等。 **“两个不同的键值对，哈希值相等”，这就是哈希冲突。**\n\n　　散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）,如果不重写 hashcode 可能会导致相同含义的的不同对象被(hashcode 应该相等)pass 掉.而如果只重写 hashCode 不重写 equals 方法，那么 equals 只是判断两个对象是否是同一个对象\n\n## 值传递和引用传递(java 是值传递)\n\n　　值传递（pass by value）是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。\n引用传递（pass by reference）是指在调用函数时将实际参数的地址直接传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。\n\n## Java 中的异常处理\n\n　　**注意：异常和错误的区别：异常能被程序本身处理，错误是无法处理。**\n\n- try 块： 用于捕获异常。其后可接零个或多个 catch 块，如果没有 catch 块，则必须跟一个 finally 块。\n- catch 块： 用于处理 try 捕获到的异常。\n- finally 块： 无论是否捕获或处理异常，finally 块里的语句都会被执行。当在 try 块或 catch 块中遇到 return 语句时，finally 语句块将在方法返回之前被执行。\n  **在以下 4 种特殊情况下，finally 块不会被执行：**\n- 在 finally 语句块第一行发生了异常。 因为在其他行，finally 块还是会得到执行\n- 在前面的代码中用了 System.exit(int)已退出程序。 exit 是带参函数 ；若该语句在异常语句之后，finally 会执行\n- 程序所在的线程死亡。\n- 关闭 CPU。\n\n> 如果 try 语句里有 return，返回的是 try 语句块中变量值。\n> 详细执行过程如下：\n> a.如果有返回值，就把返回值保存到局部变量中；\n> b.执行 jsr 指令跳到 finally 语句里执行；\n> c.执行完 finally 语句后，返回之前保存在局部变量表里的值。\n> 如果 try，finally 语句里均有 return，忽略 try 的 return，而使用 finally 的 return.\n\n## Java 中 IO 流分为几种?\n\n　　按照流的流向分，可以分为输入流和输出流；\n按照操作单元划分，可以划分为字节流和字符流；\n按照流的角色划分为节点流和处理流。\n\n## java 异常处理\n\n- try 块： 用于捕获异常。其后可接零个或多个 catch 块，如果没有 catch 块，则必须跟一个 finally 块。\n- catch 块： 用于处理 try 捕获到的异常。\n- finally 块： 无论是否捕获或处理异常，finally 块里的语句都会被执行。当在 try 块或 catch 块中遇到 return 语句时，finally 语句块将在方法返回之前被执行。\n\n　　在以下 4 种特殊情况下，finally 块不会被执行：\n\n- 在 finally 语句块第一行发生了异常。 因为在其他行，finally 块还是会得到执行\n- 在前面的代码中用了 System.exit(int)已退出程序。 exit 是带参函数 ；若该语句在异常语句之后，finally 会执行\n- 程序所在的线程死亡。\n- 关闭 CPU。\n  **注意： 当 try 语句和 finally 语句中都有 return 语句时，在方法返回之前，finally 语句的内容将被执行，并且 finally 语句的返回值将会覆盖原始的返回值**\n\n## Java修饰符\n\n### 访问修饰符\n\n#### public\n\n#### protected\n\n#### private\n\n#### default\n\n### 非访问修饰符\n\n#### final 关键字\n\n- final 修饰的类不能被继承，final 类中的所有成员方法都会被隐式的指定为 final 方法；\n- final 修饰的方法不能被重写；\n- final 修饰的变量是常量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能让其指向另一个对象。\n\n#### static 关键字\n\n- 修饰成员变量和成员方法: 被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享，可以并且建议通过类名调用。被 static 声明的成员变量属于静态成员变量，静态变量 存放在 Java 内存区域的方法区。\n- 静态代码块: 静态代码块定义在类中方法外, 静态代码块在非静态代码块之前执行(静态代码块—>非静态代码块—>构造方法)。 该类不管创建多少对象，静态代码块只执行一次.\n- 静态内部类（static 修饰类的话只能修饰内部类）： 静态内部类与非静态内部类之间存在一个最大的区别: **非静态内部类**在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围类，但是**静态内部类**却没有。没有这个引用就意味着：1. 它的创建是不需要依赖外围类的创建。2. 它不能使用任何外围类的非 static 成员变量和方法。\n\n#### abstract\n\n#### synchronized\n\n## Object类\n\n### Object类所有方法详解\n\n　　Object中含有： registerNatives()、getClass()、hashCode()、equals()、clone()、toString()、notify()、notifyAll()、wait(long)、wait(long,int)、wait()、finalize()\n\n- registerNatives()\n  - **注册 native方法**\n- getClass()[(1)](#oJQGR)\n  - 获取类的`Class` 对象\n- hashCode()\n- equals()\n- clone()\n- toString()\n- wait()/ wait(long)/ wait(long,int)\n  - 作用是阻塞当前线程，等待其他线程调用 notify()/notifyAll()方法将其唤醒。\n  - 注意：\n    - 此方法只能在当前线程获取到对象的锁监视器之后才能调用，否则会抛出 IllegalMonitorStateException异常。\n    - 调用 wait方法，线程会将锁监视器进行释放；而 Thread.sleep，Thread.yield()并不会释放锁。\n    - wait方法会一直阻塞，直到其他线程调用当前对象的 notify()/notifyAll()方法将其唤醒；而 wait(long)是等待给定超时时间内（单位毫秒），如果还没有调用 notify()/nofiyAll()会自动唤醒； wait(long,int)如果第二个参数大于 0并且小于 999999，则第一个参数 +1作为超时时间\n- notify()/notifyAll()[(2)](#W03CQ)\n  - 调用 `wait`方法，将锁释放并阻塞；这时另一个线程获取到了此对象锁，并调用此对象的 `notify()/notifyAll()`方法将之前的线程唤醒。\n  - **注意：**\n    - 调用 notify()后，阻塞线程被唤醒，可以参与锁的竞争，但可能调用 notify()方法的线程还要继续做其他事，锁并未释放，所以我们看到的结果是，无论 notify()是在方法一开始调用，还是最后调用，阻塞线程都要等待当前线程结束才能开始。\n- finalize()\n  - 此方法是在垃圾回收之前，JVM会调用此方法来清理资源。此方法可能会将对象重新置为可达状态，导致JVM无法进行垃圾回收。\n  - finalize()方法具有如下4个特点：\n    - 永远不要主动调用某个对象的 finalize()方法，该方法由垃圾回收机制自己调用；\n    - finalize()何时被调用，是否被调用具有不确定性；\n    - 当 JVM执行可恢复对象的 finalize()可能会将此对象重新变为可达状态；\n    - 当 JVM执行 finalize()方法时出现异常，垃圾回收机制不会报告异常，程序继续执行。\n\n### \n\n## 类型转换规则\n\n### 自动类型转换\n\n- boolean类型不能与其他类型进行类型转换\n- 不相关的对象类型不能进行转换\n- 容量大的类型转换为容量小的类型必须强制进行转换\n- 浮点数转换为整数会舍弃小数部分\n- 容量小类型可自动转换为容量大的基础类型\n- char 类型\n\n　　**byte ，short ，char 进行运算会先类型提升为int**\n\n## 引用\n\n### 反射.class、class.forname() 和 getClass() 的区别\n\n- **相同：**\n  - 通过这几种方式，得到的都是java.lang.Class对象；都是类加载的产物\n  - 三种情况在生成 Class 对象的时候都会先判断内存中是否已经加载此类。\n- **不同：**\n  - 出现的时期不同：\n    - Class.forname()在运行时加载；\n    - Class.class和对象名.getClass()是在编译时加载\n  - class.forname() 会装入类并做类的静态初始化\n  - Class c = C.class；JVM将使用类C的类装载器将类C加载到内存中(前提是类C还未加载进内存)，不进行类的初始化工作，返回C的Class对象\n  - Class c = c.getClass()会对类进行静态初始化、非静态初始化，返回引用运行时真正所指的对象（因为子对象的引用可能会赋给父对象的引用变量中）所属的类的 Class 对象\n\n### 为什么 wait()/notify()方法要放到 Object中呢\n\n　　因为每个对象都可以成为锁监视器对象，所以放到 Object中，可以直接使用。\n\n###\n","source":"_posts/java/Base.md","raw":"---\ntitle: Base\ndate: 2022-10-30T13:24:18Z\nlastmod: 2022-10-30T13:24:18Z\n---\n\n# Base\n\n## String 类和常量池\n\n　　String 对象的两种创建方式：\n\n```java\nString str1 = \"abcd\";//先检查字符串常量池中有没有\"abcd\"，如果字符串常量池中没有，则创建一个，然后 str1 指向字符串常量池中的对象，如果有，则直接将 str1 指向\"abcd\"\"；\nString str2 = new String(\"abcd\");//堆中创建一个新的对象\nString str3 = new String(\"abcd\");//堆中创建一个新的对象\nSystem.out.println(str1==str2);//false\nSystem.out.println(str2==str3);//false\n```\n\n　　这两种不同的创建方法是有差别的。\n\n　　第一种方式是在常量池中拿对象,如果没有则在字符串常量池中创建一个；\n第二种方式是直接在堆内存空间创建一个新的对象。\n**注意**\n\n- 直接使用双引号声明出来的 String 对象会直接存储在常量池中\n- 如果不是用双引号声明的 String 对象，可以使用 String 提供的 intern 方法，JDK1.7之前（不包含1.7）的处理方式是在常量池中创建与此 String 内容相同的字符串，并返回常量池中创建的字符串的引用，JDK1.7以及之后的处理方式是在常量池中记录此字符串的引用，并返回该引用\n\n## StringBuffer 和 StrinBuilder 区别 ,String 为何不可变\n\n　　java8 中 String 类使用 final 关键字修饰**字符数组**来保存字符串`private final char value[]`\njava8 之后 java9 等 String 类使用 final 关键字修饰**字节数组**来保存字符串`private final byte[] value`\n\n　　`StringBuffer` 和 `StringBuilder` 继承 `AbstractStringBuilder` 而在`AbstractStringBuilder`中使用字符数组存储字符串`char[] value`并没有使用 final 关键字修饰\n\n- 从线程安全性考虑:\n  String 中对象不可变,可理解为常量,线程安全.`AbstractStringBuilder`是公共父类,定义了一些字符串基本操作.Stringbuffer 对方法添加了同步锁或对调用的方法加了同步锁,线程安全.Stringbuilder 并没有对方法加同步锁加同步锁,所以非线程安全\n- 从性能考虑:\n  每次改变 String 类型会新建一个 String 对象,让后指针指向新的 String 对象,StringBuffer 每次使用对 StringBuffer 对象本身操作,不会产生新的对象,而是改变对象的引用.而 StringBuilder 相比 StringBuffer 性能会提升一部分,但需要承担线程不安全的风险\n\n## 在 Java 中定义一个不做事且没有参数的构造方法的作用\n\n　　在执行子类构造方法时,若没有调用`super()`,则默认会调用父类的无参构造函数,若父类中没有无参构造函数,编译就会报错\n\n## 接口和抽象类的区别是什么？\n\n1. 接口的方法默认是 public，所有方法在接口中不能有实现(Java 8 开始接口方法可以有默认实现），而抽象类可以有非抽象的方法。\n2. 接口中除了 static、final 变量，不能有其他变量，而抽象类中则不一定。\n3. 一个类可以实现多个接口，但只能实现一个抽象类。接口自己本身可以通过 extends 关键字扩展多个接口。\n4. 接口方法默认修饰符是 public，抽象方法可以有 public、protected 和 default 这些修饰符（抽象方法就是为了被重写所以不能使用 private 关键字修饰！）。\n5. 从设计层面来说，抽象是对类的抽象，是一种模板设计，而接口是对行为的抽象，是一种行为的规范。\n6. 关于抽象类 JDK 1.8 以前，抽象类的方法默认访问权限为 protected JDK 1.8 时，抽象类的方法默认访问权限变为 default\n7. JDK 1.8 以前，接口中的方法必须是 public 的 JDK 1.8 时，接口中的方法可以是 public 的，也可以是 default 的\n\n## 成员变量与局部变量区别\n\n　　语法上:成员变量可以被`public``private``static`等修饰,局部变量不能被修饰.但都能被`final`所修饰\n内存中的存储方式:如果成员变量是使用`static`修饰的，那么这个成员变量是属于类的，如果没有使用`static`修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存\n生命周期:成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失\n成员变量如果没有被赋初值,则会自动以类型的默认值而赋值（一种情况例外:被 final 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。\n\n## 为什么重写 equals 时必须重写 hashCode 方法\n\n　　`==` : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不试同一个对象。\n\n　　`equals()` : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况(前面第 1 部分已详细介绍过)：\n情况 1，类没有覆盖`equals()`方法。则通过`equals()`比较该类的两个对象时，等价于通过“==”比较这两个对象。\n情况 2，类覆盖了`equals()`方法。一般，我们都覆盖`equals()`方法来两个对象的内容相等；若它们的内容相等，则返回 true(即，认为这两个对象相等)。\n分两种情况\n\n- 不会创建“类对应的散列表” 例如:不会创建该类的 HashSet 集合。\n\n　　在这种情况下`equals()`用来比较该类的两个对象是否相等。而 hashCode() 则根本没有任何作用，所以，不用理会 hashCode()。\n\n- 会创建“类对应的散列表” 例如，会创建该类的 HashSet 集合,且自定义对象为键值\n\n1. 如果两个对象相等，那么它们的 hashCode()值一定相同。这里的相等是指，通过 equals()比较两个对象时返回 true。\n2. 如果两个对象 hashCode()相等，它们并不一定相等。因为在散列表中，hashCode()相等，即两个键值对的哈希值相等。然而哈希值相等，并不一定能得出键值对相等。 **“两个不同的键值对，哈希值相等”，这就是哈希冲突。**\n\n　　散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）,如果不重写 hashcode 可能会导致相同含义的的不同对象被(hashcode 应该相等)pass 掉.而如果只重写 hashCode 不重写 equals 方法，那么 equals 只是判断两个对象是否是同一个对象\n\n## 值传递和引用传递(java 是值传递)\n\n　　值传递（pass by value）是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。\n引用传递（pass by reference）是指在调用函数时将实际参数的地址直接传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。\n\n## Java 中的异常处理\n\n　　**注意：异常和错误的区别：异常能被程序本身处理，错误是无法处理。**\n\n- try 块： 用于捕获异常。其后可接零个或多个 catch 块，如果没有 catch 块，则必须跟一个 finally 块。\n- catch 块： 用于处理 try 捕获到的异常。\n- finally 块： 无论是否捕获或处理异常，finally 块里的语句都会被执行。当在 try 块或 catch 块中遇到 return 语句时，finally 语句块将在方法返回之前被执行。\n  **在以下 4 种特殊情况下，finally 块不会被执行：**\n- 在 finally 语句块第一行发生了异常。 因为在其他行，finally 块还是会得到执行\n- 在前面的代码中用了 System.exit(int)已退出程序。 exit 是带参函数 ；若该语句在异常语句之后，finally 会执行\n- 程序所在的线程死亡。\n- 关闭 CPU。\n\n> 如果 try 语句里有 return，返回的是 try 语句块中变量值。\n> 详细执行过程如下：\n> a.如果有返回值，就把返回值保存到局部变量中；\n> b.执行 jsr 指令跳到 finally 语句里执行；\n> c.执行完 finally 语句后，返回之前保存在局部变量表里的值。\n> 如果 try，finally 语句里均有 return，忽略 try 的 return，而使用 finally 的 return.\n\n## Java 中 IO 流分为几种?\n\n　　按照流的流向分，可以分为输入流和输出流；\n按照操作单元划分，可以划分为字节流和字符流；\n按照流的角色划分为节点流和处理流。\n\n## java 异常处理\n\n- try 块： 用于捕获异常。其后可接零个或多个 catch 块，如果没有 catch 块，则必须跟一个 finally 块。\n- catch 块： 用于处理 try 捕获到的异常。\n- finally 块： 无论是否捕获或处理异常，finally 块里的语句都会被执行。当在 try 块或 catch 块中遇到 return 语句时，finally 语句块将在方法返回之前被执行。\n\n　　在以下 4 种特殊情况下，finally 块不会被执行：\n\n- 在 finally 语句块第一行发生了异常。 因为在其他行，finally 块还是会得到执行\n- 在前面的代码中用了 System.exit(int)已退出程序。 exit 是带参函数 ；若该语句在异常语句之后，finally 会执行\n- 程序所在的线程死亡。\n- 关闭 CPU。\n  **注意： 当 try 语句和 finally 语句中都有 return 语句时，在方法返回之前，finally 语句的内容将被执行，并且 finally 语句的返回值将会覆盖原始的返回值**\n\n## Java修饰符\n\n### 访问修饰符\n\n#### public\n\n#### protected\n\n#### private\n\n#### default\n\n### 非访问修饰符\n\n#### final 关键字\n\n- final 修饰的类不能被继承，final 类中的所有成员方法都会被隐式的指定为 final 方法；\n- final 修饰的方法不能被重写；\n- final 修饰的变量是常量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能让其指向另一个对象。\n\n#### static 关键字\n\n- 修饰成员变量和成员方法: 被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享，可以并且建议通过类名调用。被 static 声明的成员变量属于静态成员变量，静态变量 存放在 Java 内存区域的方法区。\n- 静态代码块: 静态代码块定义在类中方法外, 静态代码块在非静态代码块之前执行(静态代码块—>非静态代码块—>构造方法)。 该类不管创建多少对象，静态代码块只执行一次.\n- 静态内部类（static 修饰类的话只能修饰内部类）： 静态内部类与非静态内部类之间存在一个最大的区别: **非静态内部类**在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围类，但是**静态内部类**却没有。没有这个引用就意味着：1. 它的创建是不需要依赖外围类的创建。2. 它不能使用任何外围类的非 static 成员变量和方法。\n\n#### abstract\n\n#### synchronized\n\n## Object类\n\n### Object类所有方法详解\n\n　　Object中含有： registerNatives()、getClass()、hashCode()、equals()、clone()、toString()、notify()、notifyAll()、wait(long)、wait(long,int)、wait()、finalize()\n\n- registerNatives()\n  - **注册 native方法**\n- getClass()[(1)](#oJQGR)\n  - 获取类的`Class` 对象\n- hashCode()\n- equals()\n- clone()\n- toString()\n- wait()/ wait(long)/ wait(long,int)\n  - 作用是阻塞当前线程，等待其他线程调用 notify()/notifyAll()方法将其唤醒。\n  - 注意：\n    - 此方法只能在当前线程获取到对象的锁监视器之后才能调用，否则会抛出 IllegalMonitorStateException异常。\n    - 调用 wait方法，线程会将锁监视器进行释放；而 Thread.sleep，Thread.yield()并不会释放锁。\n    - wait方法会一直阻塞，直到其他线程调用当前对象的 notify()/notifyAll()方法将其唤醒；而 wait(long)是等待给定超时时间内（单位毫秒），如果还没有调用 notify()/nofiyAll()会自动唤醒； wait(long,int)如果第二个参数大于 0并且小于 999999，则第一个参数 +1作为超时时间\n- notify()/notifyAll()[(2)](#W03CQ)\n  - 调用 `wait`方法，将锁释放并阻塞；这时另一个线程获取到了此对象锁，并调用此对象的 `notify()/notifyAll()`方法将之前的线程唤醒。\n  - **注意：**\n    - 调用 notify()后，阻塞线程被唤醒，可以参与锁的竞争，但可能调用 notify()方法的线程还要继续做其他事，锁并未释放，所以我们看到的结果是，无论 notify()是在方法一开始调用，还是最后调用，阻塞线程都要等待当前线程结束才能开始。\n- finalize()\n  - 此方法是在垃圾回收之前，JVM会调用此方法来清理资源。此方法可能会将对象重新置为可达状态，导致JVM无法进行垃圾回收。\n  - finalize()方法具有如下4个特点：\n    - 永远不要主动调用某个对象的 finalize()方法，该方法由垃圾回收机制自己调用；\n    - finalize()何时被调用，是否被调用具有不确定性；\n    - 当 JVM执行可恢复对象的 finalize()可能会将此对象重新变为可达状态；\n    - 当 JVM执行 finalize()方法时出现异常，垃圾回收机制不会报告异常，程序继续执行。\n\n### \n\n## 类型转换规则\n\n### 自动类型转换\n\n- boolean类型不能与其他类型进行类型转换\n- 不相关的对象类型不能进行转换\n- 容量大的类型转换为容量小的类型必须强制进行转换\n- 浮点数转换为整数会舍弃小数部分\n- 容量小类型可自动转换为容量大的基础类型\n- char 类型\n\n　　**byte ，short ，char 进行运算会先类型提升为int**\n\n## 引用\n\n### 反射.class、class.forname() 和 getClass() 的区别\n\n- **相同：**\n  - 通过这几种方式，得到的都是java.lang.Class对象；都是类加载的产物\n  - 三种情况在生成 Class 对象的时候都会先判断内存中是否已经加载此类。\n- **不同：**\n  - 出现的时期不同：\n    - Class.forname()在运行时加载；\n    - Class.class和对象名.getClass()是在编译时加载\n  - class.forname() 会装入类并做类的静态初始化\n  - Class c = C.class；JVM将使用类C的类装载器将类C加载到内存中(前提是类C还未加载进内存)，不进行类的初始化工作，返回C的Class对象\n  - Class c = c.getClass()会对类进行静态初始化、非静态初始化，返回引用运行时真正所指的对象（因为子对象的引用可能会赋给父对象的引用变量中）所属的类的 Class 对象\n\n### 为什么 wait()/notify()方法要放到 Object中呢\n\n　　因为每个对象都可以成为锁监视器对象，所以放到 Object中，可以直接使用。\n\n###\n","slug":"java-Base","published":1,"updated":"2025-04-22T02:21:59.463Z","comments":1,"layout":"post","photos":[],"_id":"cm9s3f3yo0001bfg4gji44ji6","content":"<h1>Base</h1>\n<h2 id=\"String-类和常量池\">String 类和常量池</h2>\n<p>String 对象的两种创建方式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">str1</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;abcd&quot;</span>;<span class=\"comment\">//先检查字符串常量池中有没有&quot;abcd&quot;，如果字符串常量池中没有，则创建一个，然后 str1 指向字符串常量池中的对象，如果有，则直接将 str1 指向&quot;abcd&quot;&quot;；</span></span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">str2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(<span class=\"string\">&quot;abcd&quot;</span>);<span class=\"comment\">//堆中创建一个新的对象</span></span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">str3</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(<span class=\"string\">&quot;abcd&quot;</span>);<span class=\"comment\">//堆中创建一个新的对象</span></span><br><span class=\"line\">System.out.println(str1==str2);<span class=\"comment\">//false</span></span><br><span class=\"line\">System.out.println(str2==str3);<span class=\"comment\">//false</span></span><br></pre></td></tr></table></figure>\n<p>这两种不同的创建方法是有差别的。</p>\n<p>第一种方式是在常量池中拿对象,如果没有则在字符串常量池中创建一个；<br>\n第二种方式是直接在堆内存空间创建一个新的对象。<br>\n<strong>注意</strong></p>\n<ul>\n<li>直接使用双引号声明出来的 String 对象会直接存储在常量池中</li>\n<li>如果不是用双引号声明的 String 对象，可以使用 String 提供的 intern 方法，JDK1.7之前（不包含1.7）的处理方式是在常量池中创建与此 String 内容相同的字符串，并返回常量池中创建的字符串的引用，JDK1.7以及之后的处理方式是在常量池中记录此字符串的引用，并返回该引用</li>\n</ul>\n<h2 id=\"StringBuffer-和-StrinBuilder-区别-String-为何不可变\">StringBuffer 和 StrinBuilder 区别 ,String 为何不可变</h2>\n<p>java8 中 String 类使用 final 关键字修饰<strong>字符数组</strong>来保存字符串<code>private final char value[]</code><br>\njava8 之后 java9 等 String 类使用 final 关键字修饰<strong>字节数组</strong>来保存字符串<code>private final byte[] value</code></p>\n<p><code>StringBuffer</code> 和 <code>StringBuilder</code> 继承 <code>AbstractStringBuilder</code> 而在<code>AbstractStringBuilder</code>中使用字符数组存储字符串<code>char[] value</code>并没有使用 final 关键字修饰</p>\n<ul>\n<li>从线程安全性考虑:<br>\nString 中对象不可变,可理解为常量,线程安全.<code>AbstractStringBuilder</code>是公共父类,定义了一些字符串基本操作.Stringbuffer 对方法添加了同步锁或对调用的方法加了同步锁,线程安全.Stringbuilder 并没有对方法加同步锁加同步锁,所以非线程安全</li>\n<li>从性能考虑:<br>\n每次改变 String 类型会新建一个 String 对象,让后指针指向新的 String 对象,StringBuffer 每次使用对 StringBuffer 对象本身操作,不会产生新的对象,而是改变对象的引用.而 StringBuilder 相比 StringBuffer 性能会提升一部分,但需要承担线程不安全的风险</li>\n</ul>\n<h2 id=\"在-Java-中定义一个不做事且没有参数的构造方法的作用\">在 Java 中定义一个不做事且没有参数的构造方法的作用</h2>\n<p>在执行子类构造方法时,若没有调用<code>super()</code>,则默认会调用父类的无参构造函数,若父类中没有无参构造函数,编译就会报错</p>\n<h2 id=\"接口和抽象类的区别是什么？\">接口和抽象类的区别是什么？</h2>\n<ol>\n<li>接口的方法默认是 public，所有方法在接口中不能有实现(Java 8 开始接口方法可以有默认实现），而抽象类可以有非抽象的方法。</li>\n<li>接口中除了 static、final 变量，不能有其他变量，而抽象类中则不一定。</li>\n<li>一个类可以实现多个接口，但只能实现一个抽象类。接口自己本身可以通过 extends 关键字扩展多个接口。</li>\n<li>接口方法默认修饰符是 public，抽象方法可以有 public、protected 和 default 这些修饰符（抽象方法就是为了被重写所以不能使用 private 关键字修饰！）。</li>\n<li>从设计层面来说，抽象是对类的抽象，是一种模板设计，而接口是对行为的抽象，是一种行为的规范。</li>\n<li>关于抽象类 JDK 1.8 以前，抽象类的方法默认访问权限为 protected JDK 1.8 时，抽象类的方法默认访问权限变为 default</li>\n<li>JDK 1.8 以前，接口中的方法必须是 public 的 JDK 1.8 时，接口中的方法可以是 public 的，也可以是 default 的</li>\n</ol>\n<h2 id=\"成员变量与局部变量区别\">成员变量与局部变量区别</h2>\n<p>语法上:成员变量可以被<code>public``private``static</code>等修饰,局部变量不能被修饰.但都能被<code>final</code>所修饰<br>\n内存中的存储方式:如果成员变量是使用<code>static</code>修饰的，那么这个成员变量是属于类的，如果没有使用<code>static</code>修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存<br>\n生命周期:成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失<br>\n成员变量如果没有被赋初值,则会自动以类型的默认值而赋值（一种情况例外:被 final 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。</p>\n<h2 id=\"为什么重写-equals-时必须重写-hashCode-方法\">为什么重写 equals 时必须重写 hashCode 方法</h2>\n<p><code>==</code> : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不试同一个对象。</p>\n<p><code>equals()</code> : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况(前面第 1 部分已详细介绍过)：<br>\n情况 1，类没有覆盖<code>equals()</code>方法。则通过<code>equals()</code>比较该类的两个对象时，等价于通过“==”比较这两个对象。<br>\n情况 2，类覆盖了<code>equals()</code>方法。一般，我们都覆盖<code>equals()</code>方法来两个对象的内容相等；若它们的内容相等，则返回 true(即，认为这两个对象相等)。<br>\n分两种情况</p>\n<ul>\n<li>不会创建“类对应的散列表” 例如:不会创建该类的 HashSet 集合。</li>\n</ul>\n<p>在这种情况下<code>equals()</code>用来比较该类的两个对象是否相等。而 hashCode() 则根本没有任何作用，所以，不用理会 hashCode()。</p>\n<ul>\n<li>会创建“类对应的散列表” 例如，会创建该类的 HashSet 集合,且自定义对象为键值</li>\n</ul>\n<ol>\n<li>如果两个对象相等，那么它们的 hashCode()值一定相同。这里的相等是指，通过 equals()比较两个对象时返回 true。</li>\n<li>如果两个对象 hashCode()相等，它们并不一定相等。因为在散列表中，hashCode()相等，即两个键值对的哈希值相等。然而哈希值相等，并不一定能得出键值对相等。 <strong>“两个不同的键值对，哈希值相等”，这就是哈希冲突。</strong></li>\n</ol>\n<p>散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）,如果不重写 hashcode 可能会导致相同含义的的不同对象被(hashcode 应该相等)pass 掉.而如果只重写 hashCode 不重写 equals 方法，那么 equals 只是判断两个对象是否是同一个对象</p>\n<h2 id=\"值传递和引用传递-java-是值传递\">值传递和引用传递(java 是值传递)</h2>\n<p>值传递（pass by value）是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。<br>\n引用传递（pass by reference）是指在调用函数时将实际参数的地址直接传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。</p>\n<h2 id=\"Java-中的异常处理\">Java 中的异常处理</h2>\n<p><strong>注意：异常和错误的区别：异常能被程序本身处理，错误是无法处理。</strong></p>\n<ul>\n<li>try 块： 用于捕获异常。其后可接零个或多个 catch 块，如果没有 catch 块，则必须跟一个 finally 块。</li>\n<li>catch 块： 用于处理 try 捕获到的异常。</li>\n<li>finally 块： 无论是否捕获或处理异常，finally 块里的语句都会被执行。当在 try 块或 catch 块中遇到 return 语句时，finally 语句块将在方法返回之前被执行。<br>\n<strong>在以下 4 种特殊情况下，finally 块不会被执行：</strong></li>\n<li>在 finally 语句块第一行发生了异常。 因为在其他行，finally 块还是会得到执行</li>\n<li>在前面的代码中用了 System.exit(int)已退出程序。 exit 是带参函数 ；若该语句在异常语句之后，finally 会执行</li>\n<li>程序所在的线程死亡。</li>\n<li>关闭 CPU。</li>\n</ul>\n<blockquote>\n<p>如果 try 语句里有 return，返回的是 try 语句块中变量值。<br>\n详细执行过程如下：<br>\na.如果有返回值，就把返回值保存到局部变量中；<br>\nb.执行 jsr 指令跳到 finally 语句里执行；<br>\nc.执行完 finally 语句后，返回之前保存在局部变量表里的值。<br>\n如果 try，finally 语句里均有 return，忽略 try 的 return，而使用 finally 的 return.</p>\n</blockquote>\n<h2 id=\"Java-中-IO-流分为几种\">Java 中 IO 流分为几种?</h2>\n<p>按照流的流向分，可以分为输入流和输出流；<br>\n按照操作单元划分，可以划分为字节流和字符流；<br>\n按照流的角色划分为节点流和处理流。</p>\n<h2 id=\"java-异常处理\">java 异常处理</h2>\n<ul>\n<li>try 块： 用于捕获异常。其后可接零个或多个 catch 块，如果没有 catch 块，则必须跟一个 finally 块。</li>\n<li>catch 块： 用于处理 try 捕获到的异常。</li>\n<li>finally 块： 无论是否捕获或处理异常，finally 块里的语句都会被执行。当在 try 块或 catch 块中遇到 return 语句时，finally 语句块将在方法返回之前被执行。</li>\n</ul>\n<p>在以下 4 种特殊情况下，finally 块不会被执行：</p>\n<ul>\n<li>在 finally 语句块第一行发生了异常。 因为在其他行，finally 块还是会得到执行</li>\n<li>在前面的代码中用了 System.exit(int)已退出程序。 exit 是带参函数 ；若该语句在异常语句之后，finally 会执行</li>\n<li>程序所在的线程死亡。</li>\n<li>关闭 CPU。<br>\n<strong>注意： 当 try 语句和 finally 语句中都有 return 语句时，在方法返回之前，finally 语句的内容将被执行，并且 finally 语句的返回值将会覆盖原始的返回值</strong></li>\n</ul>\n<h2 id=\"Java修饰符\">Java修饰符</h2>\n<h3 id=\"访问修饰符\">访问修饰符</h3>\n<h4 id=\"public\">public</h4>\n<h4 id=\"protected\">protected</h4>\n<h4 id=\"private\">private</h4>\n<h4 id=\"default\">default</h4>\n<h3 id=\"非访问修饰符\">非访问修饰符</h3>\n<h4 id=\"final-关键字\">final 关键字</h4>\n<ul>\n<li>final 修饰的类不能被继承，final 类中的所有成员方法都会被隐式的指定为 final 方法；</li>\n<li>final 修饰的方法不能被重写；</li>\n<li>final 修饰的变量是常量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能让其指向另一个对象。</li>\n</ul>\n<h4 id=\"static-关键字\">static 关键字</h4>\n<ul>\n<li>修饰成员变量和成员方法: 被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享，可以并且建议通过类名调用。被 static 声明的成员变量属于静态成员变量，静态变量 存放在 Java 内存区域的方法区。</li>\n<li>静态代码块: 静态代码块定义在类中方法外, 静态代码块在非静态代码块之前执行(静态代码块—&gt;非静态代码块—&gt;构造方法)。 该类不管创建多少对象，静态代码块只执行一次.</li>\n<li>静态内部类（static 修饰类的话只能修饰内部类）： 静态内部类与非静态内部类之间存在一个最大的区别: <strong>非静态内部类</strong>在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围类，但是<strong>静态内部类</strong>却没有。没有这个引用就意味着：1. 它的创建是不需要依赖外围类的创建。2. 它不能使用任何外围类的非 static 成员变量和方法。</li>\n</ul>\n<h4 id=\"abstract\">abstract</h4>\n<h4 id=\"synchronized\">synchronized</h4>\n<h2 id=\"Object类\">Object类</h2>\n<h3 id=\"Object类所有方法详解\">Object类所有方法详解</h3>\n<p>Object中含有： registerNatives()、getClass()、hashCode()、equals()、clone()、toString()、notify()、notifyAll()、wait(long)、wait(long,int)、wait()、finalize()</p>\n<ul>\n<li>registerNatives()\n<ul>\n<li><strong>注册 native方法</strong></li>\n</ul>\n</li>\n<li>getClass()<a href=\"#oJQGR\">(1)</a>\n<ul>\n<li>获取类的<code>Class</code> 对象</li>\n</ul>\n</li>\n<li>hashCode()</li>\n<li>equals()</li>\n<li>clone()</li>\n<li>toString()</li>\n<li>wait()/ wait(long)/ wait(long,int)\n<ul>\n<li>作用是阻塞当前线程，等待其他线程调用 notify()/notifyAll()方法将其唤醒。</li>\n<li>注意：\n<ul>\n<li>此方法只能在当前线程获取到对象的锁监视器之后才能调用，否则会抛出 IllegalMonitorStateException异常。</li>\n<li>调用 wait方法，线程会将锁监视器进行释放；而 Thread.sleep，Thread.yield()并不会释放锁。</li>\n<li>wait方法会一直阻塞，直到其他线程调用当前对象的 notify()/notifyAll()方法将其唤醒；而 wait(long)是等待给定超时时间内（单位毫秒），如果还没有调用 notify()/nofiyAll()会自动唤醒； wait(long,int)如果第二个参数大于 0并且小于 999999，则第一个参数 +1作为超时时间</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>notify()/notifyAll()<a href=\"#W03CQ\">(2)</a>\n<ul>\n<li>调用 <code>wait</code>方法，将锁释放并阻塞；这时另一个线程获取到了此对象锁，并调用此对象的 <code>notify()/notifyAll()</code>方法将之前的线程唤醒。</li>\n<li><strong>注意：</strong>\n<ul>\n<li>调用 notify()后，阻塞线程被唤醒，可以参与锁的竞争，但可能调用 notify()方法的线程还要继续做其他事，锁并未释放，所以我们看到的结果是，无论 notify()是在方法一开始调用，还是最后调用，阻塞线程都要等待当前线程结束才能开始。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>finalize()\n<ul>\n<li>此方法是在垃圾回收之前，JVM会调用此方法来清理资源。此方法可能会将对象重新置为可达状态，导致JVM无法进行垃圾回收。</li>\n<li>finalize()方法具有如下4个特点：\n<ul>\n<li>永远不要主动调用某个对象的 finalize()方法，该方法由垃圾回收机制自己调用；</li>\n<li>finalize()何时被调用，是否被调用具有不确定性；</li>\n<li>当 JVM执行可恢复对象的 finalize()可能会将此对象重新变为可达状态；</li>\n<li>当 JVM执行 finalize()方法时出现异常，垃圾回收机制不会报告异常，程序继续执行。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"\"></h3>\n<h2 id=\"类型转换规则\">类型转换规则</h2>\n<h3 id=\"自动类型转换\">自动类型转换</h3>\n<ul>\n<li>boolean类型不能与其他类型进行类型转换</li>\n<li>不相关的对象类型不能进行转换</li>\n<li>容量大的类型转换为容量小的类型必须强制进行转换</li>\n<li>浮点数转换为整数会舍弃小数部分</li>\n<li>容量小类型可自动转换为容量大的基础类型</li>\n<li>char 类型</li>\n</ul>\n<p><strong>byte ，short ，char 进行运算会先类型提升为int</strong></p>\n<h2 id=\"引用\">引用</h2>\n<h3 id=\"反射-class、class-forname-和-getClass-的区别\">反射.class、class.forname() 和 getClass() 的区别</h3>\n<ul>\n<li><strong>相同：</strong>\n<ul>\n<li>通过这几种方式，得到的都是java.lang.Class对象；都是类加载的产物</li>\n<li>三种情况在生成 Class 对象的时候都会先判断内存中是否已经加载此类。</li>\n</ul>\n</li>\n<li><strong>不同：</strong>\n<ul>\n<li>出现的时期不同：\n<ul>\n<li>Class.forname()在运行时加载；</li>\n<li>Class.class和对象名.getClass()是在编译时加载</li>\n</ul>\n</li>\n<li>class.forname() 会装入类并做类的静态初始化</li>\n<li>Class c = C.class；JVM将使用类C的类装载器将类C加载到内存中(前提是类C还未加载进内存)，不进行类的初始化工作，返回C的Class对象</li>\n<li>Class c = c.getClass()会对类进行静态初始化、非静态初始化，返回引用运行时真正所指的对象（因为子对象的引用可能会赋给父对象的引用变量中）所属的类的 Class 对象</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"为什么-wait-notify-方法要放到-Object中呢\">为什么 wait()/notify()方法要放到 Object中呢</h3>\n<p>因为每个对象都可以成为锁监视器对象，所以放到 Object中，可以直接使用。</p>\n<h3 id=\"-2\"></h3>\n","excerpt":"","more":"<h1>Base</h1>\n<h2 id=\"String-类和常量池\">String 类和常量池</h2>\n<p>String 对象的两种创建方式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">str1</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;abcd&quot;</span>;<span class=\"comment\">//先检查字符串常量池中有没有&quot;abcd&quot;，如果字符串常量池中没有，则创建一个，然后 str1 指向字符串常量池中的对象，如果有，则直接将 str1 指向&quot;abcd&quot;&quot;；</span></span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">str2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(<span class=\"string\">&quot;abcd&quot;</span>);<span class=\"comment\">//堆中创建一个新的对象</span></span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">str3</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(<span class=\"string\">&quot;abcd&quot;</span>);<span class=\"comment\">//堆中创建一个新的对象</span></span><br><span class=\"line\">System.out.println(str1==str2);<span class=\"comment\">//false</span></span><br><span class=\"line\">System.out.println(str2==str3);<span class=\"comment\">//false</span></span><br></pre></td></tr></table></figure>\n<p>这两种不同的创建方法是有差别的。</p>\n<p>第一种方式是在常量池中拿对象,如果没有则在字符串常量池中创建一个；<br>\n第二种方式是直接在堆内存空间创建一个新的对象。<br>\n<strong>注意</strong></p>\n<ul>\n<li>直接使用双引号声明出来的 String 对象会直接存储在常量池中</li>\n<li>如果不是用双引号声明的 String 对象，可以使用 String 提供的 intern 方法，JDK1.7之前（不包含1.7）的处理方式是在常量池中创建与此 String 内容相同的字符串，并返回常量池中创建的字符串的引用，JDK1.7以及之后的处理方式是在常量池中记录此字符串的引用，并返回该引用</li>\n</ul>\n<h2 id=\"StringBuffer-和-StrinBuilder-区别-String-为何不可变\">StringBuffer 和 StrinBuilder 区别 ,String 为何不可变</h2>\n<p>java8 中 String 类使用 final 关键字修饰<strong>字符数组</strong>来保存字符串<code>private final char value[]</code><br>\njava8 之后 java9 等 String 类使用 final 关键字修饰<strong>字节数组</strong>来保存字符串<code>private final byte[] value</code></p>\n<p><code>StringBuffer</code> 和 <code>StringBuilder</code> 继承 <code>AbstractStringBuilder</code> 而在<code>AbstractStringBuilder</code>中使用字符数组存储字符串<code>char[] value</code>并没有使用 final 关键字修饰</p>\n<ul>\n<li>从线程安全性考虑:<br>\nString 中对象不可变,可理解为常量,线程安全.<code>AbstractStringBuilder</code>是公共父类,定义了一些字符串基本操作.Stringbuffer 对方法添加了同步锁或对调用的方法加了同步锁,线程安全.Stringbuilder 并没有对方法加同步锁加同步锁,所以非线程安全</li>\n<li>从性能考虑:<br>\n每次改变 String 类型会新建一个 String 对象,让后指针指向新的 String 对象,StringBuffer 每次使用对 StringBuffer 对象本身操作,不会产生新的对象,而是改变对象的引用.而 StringBuilder 相比 StringBuffer 性能会提升一部分,但需要承担线程不安全的风险</li>\n</ul>\n<h2 id=\"在-Java-中定义一个不做事且没有参数的构造方法的作用\">在 Java 中定义一个不做事且没有参数的构造方法的作用</h2>\n<p>在执行子类构造方法时,若没有调用<code>super()</code>,则默认会调用父类的无参构造函数,若父类中没有无参构造函数,编译就会报错</p>\n<h2 id=\"接口和抽象类的区别是什么？\">接口和抽象类的区别是什么？</h2>\n<ol>\n<li>接口的方法默认是 public，所有方法在接口中不能有实现(Java 8 开始接口方法可以有默认实现），而抽象类可以有非抽象的方法。</li>\n<li>接口中除了 static、final 变量，不能有其他变量，而抽象类中则不一定。</li>\n<li>一个类可以实现多个接口，但只能实现一个抽象类。接口自己本身可以通过 extends 关键字扩展多个接口。</li>\n<li>接口方法默认修饰符是 public，抽象方法可以有 public、protected 和 default 这些修饰符（抽象方法就是为了被重写所以不能使用 private 关键字修饰！）。</li>\n<li>从设计层面来说，抽象是对类的抽象，是一种模板设计，而接口是对行为的抽象，是一种行为的规范。</li>\n<li>关于抽象类 JDK 1.8 以前，抽象类的方法默认访问权限为 protected JDK 1.8 时，抽象类的方法默认访问权限变为 default</li>\n<li>JDK 1.8 以前，接口中的方法必须是 public 的 JDK 1.8 时，接口中的方法可以是 public 的，也可以是 default 的</li>\n</ol>\n<h2 id=\"成员变量与局部变量区别\">成员变量与局部变量区别</h2>\n<p>语法上:成员变量可以被<code>public``private``static</code>等修饰,局部变量不能被修饰.但都能被<code>final</code>所修饰<br>\n内存中的存储方式:如果成员变量是使用<code>static</code>修饰的，那么这个成员变量是属于类的，如果没有使用<code>static</code>修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存<br>\n生命周期:成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失<br>\n成员变量如果没有被赋初值,则会自动以类型的默认值而赋值（一种情况例外:被 final 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。</p>\n<h2 id=\"为什么重写-equals-时必须重写-hashCode-方法\">为什么重写 equals 时必须重写 hashCode 方法</h2>\n<p><code>==</code> : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不试同一个对象。</p>\n<p><code>equals()</code> : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况(前面第 1 部分已详细介绍过)：<br>\n情况 1，类没有覆盖<code>equals()</code>方法。则通过<code>equals()</code>比较该类的两个对象时，等价于通过“==”比较这两个对象。<br>\n情况 2，类覆盖了<code>equals()</code>方法。一般，我们都覆盖<code>equals()</code>方法来两个对象的内容相等；若它们的内容相等，则返回 true(即，认为这两个对象相等)。<br>\n分两种情况</p>\n<ul>\n<li>不会创建“类对应的散列表” 例如:不会创建该类的 HashSet 集合。</li>\n</ul>\n<p>在这种情况下<code>equals()</code>用来比较该类的两个对象是否相等。而 hashCode() 则根本没有任何作用，所以，不用理会 hashCode()。</p>\n<ul>\n<li>会创建“类对应的散列表” 例如，会创建该类的 HashSet 集合,且自定义对象为键值</li>\n</ul>\n<ol>\n<li>如果两个对象相等，那么它们的 hashCode()值一定相同。这里的相等是指，通过 equals()比较两个对象时返回 true。</li>\n<li>如果两个对象 hashCode()相等，它们并不一定相等。因为在散列表中，hashCode()相等，即两个键值对的哈希值相等。然而哈希值相等，并不一定能得出键值对相等。 <strong>“两个不同的键值对，哈希值相等”，这就是哈希冲突。</strong></li>\n</ol>\n<p>散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）,如果不重写 hashcode 可能会导致相同含义的的不同对象被(hashcode 应该相等)pass 掉.而如果只重写 hashCode 不重写 equals 方法，那么 equals 只是判断两个对象是否是同一个对象</p>\n<h2 id=\"值传递和引用传递-java-是值传递\">值传递和引用传递(java 是值传递)</h2>\n<p>值传递（pass by value）是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。<br>\n引用传递（pass by reference）是指在调用函数时将实际参数的地址直接传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。</p>\n<h2 id=\"Java-中的异常处理\">Java 中的异常处理</h2>\n<p><strong>注意：异常和错误的区别：异常能被程序本身处理，错误是无法处理。</strong></p>\n<ul>\n<li>try 块： 用于捕获异常。其后可接零个或多个 catch 块，如果没有 catch 块，则必须跟一个 finally 块。</li>\n<li>catch 块： 用于处理 try 捕获到的异常。</li>\n<li>finally 块： 无论是否捕获或处理异常，finally 块里的语句都会被执行。当在 try 块或 catch 块中遇到 return 语句时，finally 语句块将在方法返回之前被执行。<br>\n<strong>在以下 4 种特殊情况下，finally 块不会被执行：</strong></li>\n<li>在 finally 语句块第一行发生了异常。 因为在其他行，finally 块还是会得到执行</li>\n<li>在前面的代码中用了 System.exit(int)已退出程序。 exit 是带参函数 ；若该语句在异常语句之后，finally 会执行</li>\n<li>程序所在的线程死亡。</li>\n<li>关闭 CPU。</li>\n</ul>\n<blockquote>\n<p>如果 try 语句里有 return，返回的是 try 语句块中变量值。<br>\n详细执行过程如下：<br>\na.如果有返回值，就把返回值保存到局部变量中；<br>\nb.执行 jsr 指令跳到 finally 语句里执行；<br>\nc.执行完 finally 语句后，返回之前保存在局部变量表里的值。<br>\n如果 try，finally 语句里均有 return，忽略 try 的 return，而使用 finally 的 return.</p>\n</blockquote>\n<h2 id=\"Java-中-IO-流分为几种\">Java 中 IO 流分为几种?</h2>\n<p>按照流的流向分，可以分为输入流和输出流；<br>\n按照操作单元划分，可以划分为字节流和字符流；<br>\n按照流的角色划分为节点流和处理流。</p>\n<h2 id=\"java-异常处理\">java 异常处理</h2>\n<ul>\n<li>try 块： 用于捕获异常。其后可接零个或多个 catch 块，如果没有 catch 块，则必须跟一个 finally 块。</li>\n<li>catch 块： 用于处理 try 捕获到的异常。</li>\n<li>finally 块： 无论是否捕获或处理异常，finally 块里的语句都会被执行。当在 try 块或 catch 块中遇到 return 语句时，finally 语句块将在方法返回之前被执行。</li>\n</ul>\n<p>在以下 4 种特殊情况下，finally 块不会被执行：</p>\n<ul>\n<li>在 finally 语句块第一行发生了异常。 因为在其他行，finally 块还是会得到执行</li>\n<li>在前面的代码中用了 System.exit(int)已退出程序。 exit 是带参函数 ；若该语句在异常语句之后，finally 会执行</li>\n<li>程序所在的线程死亡。</li>\n<li>关闭 CPU。<br>\n<strong>注意： 当 try 语句和 finally 语句中都有 return 语句时，在方法返回之前，finally 语句的内容将被执行，并且 finally 语句的返回值将会覆盖原始的返回值</strong></li>\n</ul>\n<h2 id=\"Java修饰符\">Java修饰符</h2>\n<h3 id=\"访问修饰符\">访问修饰符</h3>\n<h4 id=\"public\">public</h4>\n<h4 id=\"protected\">protected</h4>\n<h4 id=\"private\">private</h4>\n<h4 id=\"default\">default</h4>\n<h3 id=\"非访问修饰符\">非访问修饰符</h3>\n<h4 id=\"final-关键字\">final 关键字</h4>\n<ul>\n<li>final 修饰的类不能被继承，final 类中的所有成员方法都会被隐式的指定为 final 方法；</li>\n<li>final 修饰的方法不能被重写；</li>\n<li>final 修饰的变量是常量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能让其指向另一个对象。</li>\n</ul>\n<h4 id=\"static-关键字\">static 关键字</h4>\n<ul>\n<li>修饰成员变量和成员方法: 被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享，可以并且建议通过类名调用。被 static 声明的成员变量属于静态成员变量，静态变量 存放在 Java 内存区域的方法区。</li>\n<li>静态代码块: 静态代码块定义在类中方法外, 静态代码块在非静态代码块之前执行(静态代码块—&gt;非静态代码块—&gt;构造方法)。 该类不管创建多少对象，静态代码块只执行一次.</li>\n<li>静态内部类（static 修饰类的话只能修饰内部类）： 静态内部类与非静态内部类之间存在一个最大的区别: <strong>非静态内部类</strong>在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围类，但是<strong>静态内部类</strong>却没有。没有这个引用就意味着：1. 它的创建是不需要依赖外围类的创建。2. 它不能使用任何外围类的非 static 成员变量和方法。</li>\n</ul>\n<h4 id=\"abstract\">abstract</h4>\n<h4 id=\"synchronized\">synchronized</h4>\n<h2 id=\"Object类\">Object类</h2>\n<h3 id=\"Object类所有方法详解\">Object类所有方法详解</h3>\n<p>Object中含有： registerNatives()、getClass()、hashCode()、equals()、clone()、toString()、notify()、notifyAll()、wait(long)、wait(long,int)、wait()、finalize()</p>\n<ul>\n<li>registerNatives()\n<ul>\n<li><strong>注册 native方法</strong></li>\n</ul>\n</li>\n<li>getClass()<a href=\"#oJQGR\">(1)</a>\n<ul>\n<li>获取类的<code>Class</code> 对象</li>\n</ul>\n</li>\n<li>hashCode()</li>\n<li>equals()</li>\n<li>clone()</li>\n<li>toString()</li>\n<li>wait()/ wait(long)/ wait(long,int)\n<ul>\n<li>作用是阻塞当前线程，等待其他线程调用 notify()/notifyAll()方法将其唤醒。</li>\n<li>注意：\n<ul>\n<li>此方法只能在当前线程获取到对象的锁监视器之后才能调用，否则会抛出 IllegalMonitorStateException异常。</li>\n<li>调用 wait方法，线程会将锁监视器进行释放；而 Thread.sleep，Thread.yield()并不会释放锁。</li>\n<li>wait方法会一直阻塞，直到其他线程调用当前对象的 notify()/notifyAll()方法将其唤醒；而 wait(long)是等待给定超时时间内（单位毫秒），如果还没有调用 notify()/nofiyAll()会自动唤醒； wait(long,int)如果第二个参数大于 0并且小于 999999，则第一个参数 +1作为超时时间</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>notify()/notifyAll()<a href=\"#W03CQ\">(2)</a>\n<ul>\n<li>调用 <code>wait</code>方法，将锁释放并阻塞；这时另一个线程获取到了此对象锁，并调用此对象的 <code>notify()/notifyAll()</code>方法将之前的线程唤醒。</li>\n<li><strong>注意：</strong>\n<ul>\n<li>调用 notify()后，阻塞线程被唤醒，可以参与锁的竞争，但可能调用 notify()方法的线程还要继续做其他事，锁并未释放，所以我们看到的结果是，无论 notify()是在方法一开始调用，还是最后调用，阻塞线程都要等待当前线程结束才能开始。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>finalize()\n<ul>\n<li>此方法是在垃圾回收之前，JVM会调用此方法来清理资源。此方法可能会将对象重新置为可达状态，导致JVM无法进行垃圾回收。</li>\n<li>finalize()方法具有如下4个特点：\n<ul>\n<li>永远不要主动调用某个对象的 finalize()方法，该方法由垃圾回收机制自己调用；</li>\n<li>finalize()何时被调用，是否被调用具有不确定性；</li>\n<li>当 JVM执行可恢复对象的 finalize()可能会将此对象重新变为可达状态；</li>\n<li>当 JVM执行 finalize()方法时出现异常，垃圾回收机制不会报告异常，程序继续执行。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"\"></h3>\n<h2 id=\"类型转换规则\">类型转换规则</h2>\n<h3 id=\"自动类型转换\">自动类型转换</h3>\n<ul>\n<li>boolean类型不能与其他类型进行类型转换</li>\n<li>不相关的对象类型不能进行转换</li>\n<li>容量大的类型转换为容量小的类型必须强制进行转换</li>\n<li>浮点数转换为整数会舍弃小数部分</li>\n<li>容量小类型可自动转换为容量大的基础类型</li>\n<li>char 类型</li>\n</ul>\n<p><strong>byte ，short ，char 进行运算会先类型提升为int</strong></p>\n<h2 id=\"引用\">引用</h2>\n<h3 id=\"反射-class、class-forname-和-getClass-的区别\">反射.class、class.forname() 和 getClass() 的区别</h3>\n<ul>\n<li><strong>相同：</strong>\n<ul>\n<li>通过这几种方式，得到的都是java.lang.Class对象；都是类加载的产物</li>\n<li>三种情况在生成 Class 对象的时候都会先判断内存中是否已经加载此类。</li>\n</ul>\n</li>\n<li><strong>不同：</strong>\n<ul>\n<li>出现的时期不同：\n<ul>\n<li>Class.forname()在运行时加载；</li>\n<li>Class.class和对象名.getClass()是在编译时加载</li>\n</ul>\n</li>\n<li>class.forname() 会装入类并做类的静态初始化</li>\n<li>Class c = C.class；JVM将使用类C的类装载器将类C加载到内存中(前提是类C还未加载进内存)，不进行类的初始化工作，返回C的Class对象</li>\n<li>Class c = c.getClass()会对类进行静态初始化、非静态初始化，返回引用运行时真正所指的对象（因为子对象的引用可能会赋给父对象的引用变量中）所属的类的 Class 对象</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"为什么-wait-notify-方法要放到-Object中呢\">为什么 wait()/notify()方法要放到 Object中呢</h3>\n<p>因为每个对象都可以成为锁监视器对象，所以放到 Object中，可以直接使用。</p>\n<h3 id=\"-2\"></h3>\n"},{"title":"ByteBuddy","date":"2023-06-19T14:23:00.000Z","lastmod":"2023-07-08T05:54:37.000Z","_content":"\n# ByteBuddy\n\n```\n      <dependency>\n            <groupId>net.bytebuddy</groupId>\n            <artifactId>byte-buddy</artifactId>\n            <version>1.11.12</version>\n        </dependency>\n```\n\n## Hello World\n\n```\nClass<?> dynamicType = new ByteBuddy()\n                .subclass(Object.class)\n                .method(ElementMatchers.named(\"toString\"))\n                .intercept(FixedValue.value(\"Hello World\"))\n                .make()\n                .load(HelloWorldBuddy.class.getClassLoader())\n                .getLoaded();\nObject instance = dynamicType.newInstance();\nString toString = instance.toString();\nSystem.out.println(toString);\nSystem.out.println(instance.getClass().getCanonicalName());\n```\n\n​![image](/assets/image-20230619222624-l98xjgi.png)​\n\n　　从例子可以看出，很简单就创建了一个动态类型。ByteBuddy提供了一套流式API，从ByteBuddy实例出发，可以流畅的完成所有的操作和数据定义。  \n上面的示例中\n\n* subclass 指定了新创建的类的父类\n* method 指定了 Object 的 toString 方法\n* intercept 拦截了 toString 方法并返回固定的 value\n* 最后 make 方法生产字节码，有类加载器加载到虚拟机中\n\n　　此外，Byte Buddy不仅限于创建子类和操作类，还可以转换现有代码。Byte Buddy 还提供了一个方便的 API，用于定义所谓的 Java 代理，该代理允许在任何 Java 应用程序的运行期间进行代码转换\n\n## 创建动态类\n\n```\nDynamicType.Unloaded<?> dynamicType = new ByteBuddy()\n  .subclass(Object.class)\n  .name(\"com.zlk.learning.bytebuddy.DynamicType\")\n  .make();\n```\n\n　　上面的示例代码会创建一个继承至 Object 类型的类。这个动态创建的类型与直接扩展 Object 并且没有实现任何方法、属性和构造函数的类型是等价的，如下：\n\n```\npublic class DynamicTYpe {\n\n}\n```\n\n　　在创建类的时候，还提供了更多API来支持对类的定义，包括定义字段、方法等\n\n```\n        DynamicType.Unloaded<?> dynamicType = new ByteBuddy()\n                .subclass(Object.class)\n                .name(\"com.zlk.learning.bytebuddy.DynamicType\")\n                .defineField(\"name\", String.class, 1)\n                .defineField(\"age\", Integer.class, 1)\n                .method(ElementMatchers.named(\"toString\"))\n                .intercept(FixedValue.value(\"Hello World!\"))\n                .make();\n```\n\n​![image](/assets/image-20230619222818-5btwdt3.png)​\n\n　　上面的示例代码中，我们增加了两个字段name和age，同时拦截了toString方法，使其输出固定值 “Hello World!”。\n\n　　保留父类实现的接口信息\n\n```java\n\n\n    @Override\n    public Object instantiate(BeanDefinition beanDefinition, String beanName, Constructor ctor, Object[] args) throws BeansException {\n        Class<?> beanClass = beanDefinition.getBeanClass();\n        ArrayList<TypeDescription.Generic> list = getGenerics(beanClass);\n        Class clazz = new ByteBuddy().subclass(beanClass).implement(list)\n                .make()\n                .load(getClass().getClassLoader())\n                .getLoaded();\n        try {\n            if (null == ctor) return clazz.getDeclaredConstructor().newInstance();\n            return clazz.getDeclaredConstructor(ctor.getParameterTypes()).newInstance(args);\n        } catch (NoSuchMethodException | InstantiationException | IllegalAccessException | InvocationTargetException e) {\n            throw new BeansException(\"Failed to instantiate [\" + clazz.getName() + \"]\", e);\n        }\n    }\n    //获取父类的接口信息\n    private static ArrayList<TypeDescription.Generic> getGenerics(Class<?> beanClass) {\n        ArrayList<TypeDescription.Generic> list = new ArrayList<>();\n        try {\n            Type[] genericInterfaces = beanClass.getGenericInterfaces();\n            for (Type type : genericInterfaces) {\n                Type[] typeArguments = ((ParameterizedType) type).getActualTypeArguments();\n                Class<?>[] classes = new Class[typeArguments.length];\n                for (int i = 0; i < typeArguments.length; i++) {\n                    classes[i] = Class.forName(typeArguments[i].getTypeName());\n                }\n                Class<?> aClass = Class.forName(((ParameterizedType) type).getRawType().getTypeName());\n                TypeDescription.Generic listType = TypeDescription.Generic.Builder.parameterizedType(aClass, classes).build();\n                list.add(listType);\n            }\n        } catch (ClassNotFoundException e) {\n            throw new BeansException(\"Failed to instantiate [\" + beanClass.getName() + \"]\", e);\n        }\n        return list;\n    }\n```\n\n　　‍\n\n## 加载类\n\n　　上节创建的 DynamicType.Unloaded，代表一个尚未加载的类，顾名思义，这些类型不会加载到 Java 虚拟机中，它仅仅表示创建好了类的字节码，通过 DynamicType.Unloaded 中的 getBytes 方法你可以获取到该字节码。\n\n　　在应用程序中，可能需要将该字节码保存到文件，或者注入的现在的 jar 文件中，因此该类型还提供了一个 saveIn(File) 方法，可以将类存储在给定的文件夹中； inject(File) 方法将类注入到现有的 Jar 文件中，另外你只需要将该字节码直接加载到虚拟机使用，你可以通过 ClassLoadingStrategy 来加载。\n\n　　如果不指定ClassLoadingStrategy，Byte Buffer根据你提供的ClassLoader来推导出一个策略，内置的策略定义在枚举ClassLoadingStrategy.Default中\n\n* WRAPPER：创建一个新的Wrapping类加载器\n* CHILD_FIRST：类似上面，但是子加载器优先负责加载目标类\n* INJECTION：利用反射机制注入动态类型\n\n```\n Class<?> dynamicClass = dynamicType\n                .load(Object.class.getClassLoader(), ClassLoadingStrategy.Default.WRAPPER)\n                .getLoaded();\n```\n\n　　我们使用 WRAPPER 策略来加载适合大多数情况的类，这样生产的动态类不会被ApplicationClassLoader加载到，不会影响到项目中已经存在的类  \n​`getLoaded 方法返回一个 Java Class 的实例，它就表示现在加载的动态类`​\n\n## 拦截方法\n\n　　在之前的例子中，我们拦截了toString方法，并使其输出固定值。不过在实际开发中很少会遇到如此简单的场景，我们可以通过指定拦截方法的形式来处理复杂的逻辑\n\n### 通过匹配模式拦截\n\n　　ByteBuddy 通过 net.bytebuddy.matcher.ElementMatcher 来定义配置策略，可以通过此接口实现自己定义的匹配策略\n\n```\nFoo dynamicFoo = new ByteBuddy()\n  .subclass(Foo.class)\n  // 匹配由Foo.class声明的方法\n  .method(isDeclaredBy(Foo.class)).intercept(FixedValue.value(\"One!\"))\n  // 匹配名为foo的方法\n  .method(named(\"foo\")).intercept(FixedValue.value(\"Two!\"))\n  // 匹配名为foo，入参数量为1的方法\n  .method(named(\"foo\").and(takesArguments(1))).intercept(FixedValue.value(\"Three!\"))\n  .make()\n  .load(getClass().getClassLoader())\n  .getLoaded()\n  .newInstance();\n```\n\n### 方法委托\n\n　　使用MethodDelegation可以将方法调用委托给任意POJO。Byte Buddy不要求Source（被委托类）、Target类的方法名一致\n\n```\nclass Source {\n  public String hello(String name) { return null; }\n}\n\nclass Target {\n\n  public static String hello(String name) {\n    return \"Hello \" + name + \"!\";\n  }\n}\n\nString helloWorld = new ByteBuddy()\n  .subclass(Source.class)\n  .method(named(\"hello\"))\n  // 此处委托 类只能委托静态方法  对象可使用非静态方法\n  .intercept(MethodDelegation.to(Target.class))\n  .make()\n  .load(getClass().getClassLoader())\n  .getLoaded()\n  .newInstance()\n  .hello(\"World\");\n```\n\n　　其中 Target 还可以如下实现：\n\n```\nclass Target {\n  public static String intercept(String name) { return \"Hello \" + name + \"!\"; }\n  public static String intercept(int i) { return Integer.toString(i); }\n  public static String intercept(Object o) { return o.toString(); }\n}\n```\n\n　　前一个实现因为只有一个方法，而且类型也匹配，很好理解，那么后一个呢，Byte Buddy到底会委托给哪个方法？Byte Buddy遵循一个最接近原则：\n\n* intercept(int)因为参数类型不匹配，直接Pass\n* 另外两个方法参数都匹配，但是 intercept(String)类型更加接近，因此会委托给它\n\n　　同时需要注意的是被拦截的方法需要声明为 public，否则没法进行拦截增强。除此之外，还可以使用 @RuntimeType 注解来标注方法\n\n```java\n    @RuntimeType\n    public  Object interceptor(@This Object proxy, @Origin Method method,\n                              @SuperMethod Method superMethod,\n                              @AllArguments Object[] args) throws Exception {\n        System.out.println(\"bytebuddy delegate proxy2 before sing \");\n        Object ret = superMethod.invoke(proxy, args);\n        System.out.println(\"bytebuddy delegate proxy2 after sing \");\n        return ret;\n    }\n```\n\n### 参数绑定\n\n　　可以在拦截器（Target）的拦截方法 intercept 中使用注解注入参数，ByteBuddy 会根据注解给我们注入对于的参数值。比如\n\n```\nvoid intercept(Object o1, Object o2)\n// 等同于\nvoid intercept(@Argument(0) Object o1, @Argument(1) Object o2)\n```\n\n　　常用注解有以下这些：\n\n* @Argument 绑定单个参数\n* @AllArguments 绑定所有参数的数组\n* @This 当前被拦截的、动态生成的那个对象\n* @DefaultCall 调用默认方法而非super的方法\n* @SuperCall 用于调用父类版本的方法\n* @Origin 被拦截的源方法\n* @RuntimeType 可以用在返回值、参数上，提示ByteBuddy禁用严格的类型检查\n* @Super 当前被拦截的、动态生成的那个对象的父类对象\n* @FieldValue 注入被拦截对象的一个字段的值\n\n## Agent\n\n　　Java 从 1.5 开始提供了 java.lang.instrument包，该包为检测 Java 程序提供 API，比如用于监控、收集性能信息、诊断问题。通过 java.lang.instrument 实现工具被称为 Java Agent。Java Agent 可以修改类文件的字节码，通常是，在字节码方法插入额外的字节码来完成检测\n\n　　和通过ByteBuddy实例创建动态类型一样，bytebuddy也提供了AgentBuilder类使我们在agent中更优雅地编写代码\n\n```\nclass ToStringAgent {\n  public static void premain(String arguments, Instrumentation instrumentation) {\n    new AgentBuilder.Default()\n        .type(isAnnotatedWith(ToString.class))\n        .transform(new AgentBuilder.Transformer() {\n      @Override\n      public DynamicType.Builder transform(DynamicType.Builder builder,\n                                              TypeDescription typeDescription,\n                                              ClassLoader classloader) {\n        return builder.method(named(\"toString\"))\n                      .intercept(FixedValue.value(\"transformed\"));\n      }\n    }).installOn(instrumentation);\n  }\n}\n```\n\n* type 通过ElementMatcher 来匹配我们加载的class，匹配到之后，将会使用\n* transform 指定的转换器来对匹配到的class进行操作\n\n## ElementMatcher\n\n　　ElementMatcher可以定义匹配class的规则，在bytebuddy中，ElementMatchers类提供了许多常规的匹配方式，可以按照class name、注解、类型等来进行匹配，上面的实例中就是使用注解匹配的方式\n\n　　Junction继承自ElementMatcher接口，定义了and 和 or 方法，可以使我们在定义Matcher时通过链式定义一连串的匹配规则\n\n```\n      new AgentBuilder.Default()\n                .type(ElementMatchers.isAnnotatedWith(ToString.class)).and(ElementMatchers.isSubTypeOf(DynamicClass.class)).or(ElementMatchers.named(\"DynamicClass\"))\n                .transform(new AgentBuilder.Transformer() {\n                    public DynamicType.Builder<?> transform(DynamicType.Builder<?> builder, TypeDescription typeDescription, ClassLoader classLoader, JavaModule javaModule) {\n                        return builder\n                                .method(ElementMatchers.named(\"hello\"))\n                                .intercept(MethodDelegation.to(MyServiceInterceptor.class))\n                                ;\n                    }\n                }).installOn(instrumentation);\n```\n\n## [Transformer](https://so.csdn.net/so/search?q=Transformer&spm=1001.2101.3001.7020)\n\n　　Transformer 接口定义了 transform方法，会传入DynamicType.Builder实例，通过该builder，就可以对匹配到的类进行操作，就和上面讲的 ByteBuddy创建动态类型时类似操作，可以定义字段以及对方法进行拦截操作等，上面的例子就是对匹配到的类的hello方法进行了方法委托，在调用hello方法时，将会委托给 MyServiceInterceptor类\n\n```\npublic class MyServiceInterceptor {\n\n    @RuntimeType\n    public static Object intercept(@Origin Method method, @SuperCall Callable<?> callable) throws Exception {\n        System.out.println(\"intercept：拦截了\" + method.getName());\n        return callable.call();\n    }\n  \n}\n\n```\n\n## \n\n　　‍\n\n## END\n\n　　**参考文章**  \n​`bytebuddy官方文档 https://bytebuddy.net/#/tutorial`\n\n　　`https://juejin.cn/post/6844903965553852423#heading-12`​​\n","source":"_posts/java/ByteBuddy.md","raw":"---\ntitle: ByteBuddy\ndate: 2023-06-19T22:23:00Z\nlastmod: 2023-07-08T13:54:37Z\n---\n\n# ByteBuddy\n\n```\n      <dependency>\n            <groupId>net.bytebuddy</groupId>\n            <artifactId>byte-buddy</artifactId>\n            <version>1.11.12</version>\n        </dependency>\n```\n\n## Hello World\n\n```\nClass<?> dynamicType = new ByteBuddy()\n                .subclass(Object.class)\n                .method(ElementMatchers.named(\"toString\"))\n                .intercept(FixedValue.value(\"Hello World\"))\n                .make()\n                .load(HelloWorldBuddy.class.getClassLoader())\n                .getLoaded();\nObject instance = dynamicType.newInstance();\nString toString = instance.toString();\nSystem.out.println(toString);\nSystem.out.println(instance.getClass().getCanonicalName());\n```\n\n​![image](/assets/image-20230619222624-l98xjgi.png)​\n\n　　从例子可以看出，很简单就创建了一个动态类型。ByteBuddy提供了一套流式API，从ByteBuddy实例出发，可以流畅的完成所有的操作和数据定义。  \n上面的示例中\n\n* subclass 指定了新创建的类的父类\n* method 指定了 Object 的 toString 方法\n* intercept 拦截了 toString 方法并返回固定的 value\n* 最后 make 方法生产字节码，有类加载器加载到虚拟机中\n\n　　此外，Byte Buddy不仅限于创建子类和操作类，还可以转换现有代码。Byte Buddy 还提供了一个方便的 API，用于定义所谓的 Java 代理，该代理允许在任何 Java 应用程序的运行期间进行代码转换\n\n## 创建动态类\n\n```\nDynamicType.Unloaded<?> dynamicType = new ByteBuddy()\n  .subclass(Object.class)\n  .name(\"com.zlk.learning.bytebuddy.DynamicType\")\n  .make();\n```\n\n　　上面的示例代码会创建一个继承至 Object 类型的类。这个动态创建的类型与直接扩展 Object 并且没有实现任何方法、属性和构造函数的类型是等价的，如下：\n\n```\npublic class DynamicTYpe {\n\n}\n```\n\n　　在创建类的时候，还提供了更多API来支持对类的定义，包括定义字段、方法等\n\n```\n        DynamicType.Unloaded<?> dynamicType = new ByteBuddy()\n                .subclass(Object.class)\n                .name(\"com.zlk.learning.bytebuddy.DynamicType\")\n                .defineField(\"name\", String.class, 1)\n                .defineField(\"age\", Integer.class, 1)\n                .method(ElementMatchers.named(\"toString\"))\n                .intercept(FixedValue.value(\"Hello World!\"))\n                .make();\n```\n\n​![image](/assets/image-20230619222818-5btwdt3.png)​\n\n　　上面的示例代码中，我们增加了两个字段name和age，同时拦截了toString方法，使其输出固定值 “Hello World!”。\n\n　　保留父类实现的接口信息\n\n```java\n\n\n    @Override\n    public Object instantiate(BeanDefinition beanDefinition, String beanName, Constructor ctor, Object[] args) throws BeansException {\n        Class<?> beanClass = beanDefinition.getBeanClass();\n        ArrayList<TypeDescription.Generic> list = getGenerics(beanClass);\n        Class clazz = new ByteBuddy().subclass(beanClass).implement(list)\n                .make()\n                .load(getClass().getClassLoader())\n                .getLoaded();\n        try {\n            if (null == ctor) return clazz.getDeclaredConstructor().newInstance();\n            return clazz.getDeclaredConstructor(ctor.getParameterTypes()).newInstance(args);\n        } catch (NoSuchMethodException | InstantiationException | IllegalAccessException | InvocationTargetException e) {\n            throw new BeansException(\"Failed to instantiate [\" + clazz.getName() + \"]\", e);\n        }\n    }\n    //获取父类的接口信息\n    private static ArrayList<TypeDescription.Generic> getGenerics(Class<?> beanClass) {\n        ArrayList<TypeDescription.Generic> list = new ArrayList<>();\n        try {\n            Type[] genericInterfaces = beanClass.getGenericInterfaces();\n            for (Type type : genericInterfaces) {\n                Type[] typeArguments = ((ParameterizedType) type).getActualTypeArguments();\n                Class<?>[] classes = new Class[typeArguments.length];\n                for (int i = 0; i < typeArguments.length; i++) {\n                    classes[i] = Class.forName(typeArguments[i].getTypeName());\n                }\n                Class<?> aClass = Class.forName(((ParameterizedType) type).getRawType().getTypeName());\n                TypeDescription.Generic listType = TypeDescription.Generic.Builder.parameterizedType(aClass, classes).build();\n                list.add(listType);\n            }\n        } catch (ClassNotFoundException e) {\n            throw new BeansException(\"Failed to instantiate [\" + beanClass.getName() + \"]\", e);\n        }\n        return list;\n    }\n```\n\n　　‍\n\n## 加载类\n\n　　上节创建的 DynamicType.Unloaded，代表一个尚未加载的类，顾名思义，这些类型不会加载到 Java 虚拟机中，它仅仅表示创建好了类的字节码，通过 DynamicType.Unloaded 中的 getBytes 方法你可以获取到该字节码。\n\n　　在应用程序中，可能需要将该字节码保存到文件，或者注入的现在的 jar 文件中，因此该类型还提供了一个 saveIn(File) 方法，可以将类存储在给定的文件夹中； inject(File) 方法将类注入到现有的 Jar 文件中，另外你只需要将该字节码直接加载到虚拟机使用，你可以通过 ClassLoadingStrategy 来加载。\n\n　　如果不指定ClassLoadingStrategy，Byte Buffer根据你提供的ClassLoader来推导出一个策略，内置的策略定义在枚举ClassLoadingStrategy.Default中\n\n* WRAPPER：创建一个新的Wrapping类加载器\n* CHILD_FIRST：类似上面，但是子加载器优先负责加载目标类\n* INJECTION：利用反射机制注入动态类型\n\n```\n Class<?> dynamicClass = dynamicType\n                .load(Object.class.getClassLoader(), ClassLoadingStrategy.Default.WRAPPER)\n                .getLoaded();\n```\n\n　　我们使用 WRAPPER 策略来加载适合大多数情况的类，这样生产的动态类不会被ApplicationClassLoader加载到，不会影响到项目中已经存在的类  \n​`getLoaded 方法返回一个 Java Class 的实例，它就表示现在加载的动态类`​\n\n## 拦截方法\n\n　　在之前的例子中，我们拦截了toString方法，并使其输出固定值。不过在实际开发中很少会遇到如此简单的场景，我们可以通过指定拦截方法的形式来处理复杂的逻辑\n\n### 通过匹配模式拦截\n\n　　ByteBuddy 通过 net.bytebuddy.matcher.ElementMatcher 来定义配置策略，可以通过此接口实现自己定义的匹配策略\n\n```\nFoo dynamicFoo = new ByteBuddy()\n  .subclass(Foo.class)\n  // 匹配由Foo.class声明的方法\n  .method(isDeclaredBy(Foo.class)).intercept(FixedValue.value(\"One!\"))\n  // 匹配名为foo的方法\n  .method(named(\"foo\")).intercept(FixedValue.value(\"Two!\"))\n  // 匹配名为foo，入参数量为1的方法\n  .method(named(\"foo\").and(takesArguments(1))).intercept(FixedValue.value(\"Three!\"))\n  .make()\n  .load(getClass().getClassLoader())\n  .getLoaded()\n  .newInstance();\n```\n\n### 方法委托\n\n　　使用MethodDelegation可以将方法调用委托给任意POJO。Byte Buddy不要求Source（被委托类）、Target类的方法名一致\n\n```\nclass Source {\n  public String hello(String name) { return null; }\n}\n\nclass Target {\n\n  public static String hello(String name) {\n    return \"Hello \" + name + \"!\";\n  }\n}\n\nString helloWorld = new ByteBuddy()\n  .subclass(Source.class)\n  .method(named(\"hello\"))\n  // 此处委托 类只能委托静态方法  对象可使用非静态方法\n  .intercept(MethodDelegation.to(Target.class))\n  .make()\n  .load(getClass().getClassLoader())\n  .getLoaded()\n  .newInstance()\n  .hello(\"World\");\n```\n\n　　其中 Target 还可以如下实现：\n\n```\nclass Target {\n  public static String intercept(String name) { return \"Hello \" + name + \"!\"; }\n  public static String intercept(int i) { return Integer.toString(i); }\n  public static String intercept(Object o) { return o.toString(); }\n}\n```\n\n　　前一个实现因为只有一个方法，而且类型也匹配，很好理解，那么后一个呢，Byte Buddy到底会委托给哪个方法？Byte Buddy遵循一个最接近原则：\n\n* intercept(int)因为参数类型不匹配，直接Pass\n* 另外两个方法参数都匹配，但是 intercept(String)类型更加接近，因此会委托给它\n\n　　同时需要注意的是被拦截的方法需要声明为 public，否则没法进行拦截增强。除此之外，还可以使用 @RuntimeType 注解来标注方法\n\n```java\n    @RuntimeType\n    public  Object interceptor(@This Object proxy, @Origin Method method,\n                              @SuperMethod Method superMethod,\n                              @AllArguments Object[] args) throws Exception {\n        System.out.println(\"bytebuddy delegate proxy2 before sing \");\n        Object ret = superMethod.invoke(proxy, args);\n        System.out.println(\"bytebuddy delegate proxy2 after sing \");\n        return ret;\n    }\n```\n\n### 参数绑定\n\n　　可以在拦截器（Target）的拦截方法 intercept 中使用注解注入参数，ByteBuddy 会根据注解给我们注入对于的参数值。比如\n\n```\nvoid intercept(Object o1, Object o2)\n// 等同于\nvoid intercept(@Argument(0) Object o1, @Argument(1) Object o2)\n```\n\n　　常用注解有以下这些：\n\n* @Argument 绑定单个参数\n* @AllArguments 绑定所有参数的数组\n* @This 当前被拦截的、动态生成的那个对象\n* @DefaultCall 调用默认方法而非super的方法\n* @SuperCall 用于调用父类版本的方法\n* @Origin 被拦截的源方法\n* @RuntimeType 可以用在返回值、参数上，提示ByteBuddy禁用严格的类型检查\n* @Super 当前被拦截的、动态生成的那个对象的父类对象\n* @FieldValue 注入被拦截对象的一个字段的值\n\n## Agent\n\n　　Java 从 1.5 开始提供了 java.lang.instrument包，该包为检测 Java 程序提供 API，比如用于监控、收集性能信息、诊断问题。通过 java.lang.instrument 实现工具被称为 Java Agent。Java Agent 可以修改类文件的字节码，通常是，在字节码方法插入额外的字节码来完成检测\n\n　　和通过ByteBuddy实例创建动态类型一样，bytebuddy也提供了AgentBuilder类使我们在agent中更优雅地编写代码\n\n```\nclass ToStringAgent {\n  public static void premain(String arguments, Instrumentation instrumentation) {\n    new AgentBuilder.Default()\n        .type(isAnnotatedWith(ToString.class))\n        .transform(new AgentBuilder.Transformer() {\n      @Override\n      public DynamicType.Builder transform(DynamicType.Builder builder,\n                                              TypeDescription typeDescription,\n                                              ClassLoader classloader) {\n        return builder.method(named(\"toString\"))\n                      .intercept(FixedValue.value(\"transformed\"));\n      }\n    }).installOn(instrumentation);\n  }\n}\n```\n\n* type 通过ElementMatcher 来匹配我们加载的class，匹配到之后，将会使用\n* transform 指定的转换器来对匹配到的class进行操作\n\n## ElementMatcher\n\n　　ElementMatcher可以定义匹配class的规则，在bytebuddy中，ElementMatchers类提供了许多常规的匹配方式，可以按照class name、注解、类型等来进行匹配，上面的实例中就是使用注解匹配的方式\n\n　　Junction继承自ElementMatcher接口，定义了and 和 or 方法，可以使我们在定义Matcher时通过链式定义一连串的匹配规则\n\n```\n      new AgentBuilder.Default()\n                .type(ElementMatchers.isAnnotatedWith(ToString.class)).and(ElementMatchers.isSubTypeOf(DynamicClass.class)).or(ElementMatchers.named(\"DynamicClass\"))\n                .transform(new AgentBuilder.Transformer() {\n                    public DynamicType.Builder<?> transform(DynamicType.Builder<?> builder, TypeDescription typeDescription, ClassLoader classLoader, JavaModule javaModule) {\n                        return builder\n                                .method(ElementMatchers.named(\"hello\"))\n                                .intercept(MethodDelegation.to(MyServiceInterceptor.class))\n                                ;\n                    }\n                }).installOn(instrumentation);\n```\n\n## [Transformer](https://so.csdn.net/so/search?q=Transformer&spm=1001.2101.3001.7020)\n\n　　Transformer 接口定义了 transform方法，会传入DynamicType.Builder实例，通过该builder，就可以对匹配到的类进行操作，就和上面讲的 ByteBuddy创建动态类型时类似操作，可以定义字段以及对方法进行拦截操作等，上面的例子就是对匹配到的类的hello方法进行了方法委托，在调用hello方法时，将会委托给 MyServiceInterceptor类\n\n```\npublic class MyServiceInterceptor {\n\n    @RuntimeType\n    public static Object intercept(@Origin Method method, @SuperCall Callable<?> callable) throws Exception {\n        System.out.println(\"intercept：拦截了\" + method.getName());\n        return callable.call();\n    }\n  \n}\n\n```\n\n## \n\n　　‍\n\n## END\n\n　　**参考文章**  \n​`bytebuddy官方文档 https://bytebuddy.net/#/tutorial`\n\n　　`https://juejin.cn/post/6844903965553852423#heading-12`​​\n","slug":"java-ByteBuddy","published":1,"updated":"2025-04-22T07:27:29.941Z","_id":"cm9s3f3ys0003bfg478vr1fbf","comments":1,"layout":"post","photos":[],"content":"<h1>ByteBuddy</h1>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">      &lt;groupId&gt;net.bytebuddy&lt;/groupId&gt;</span><br><span class=\"line\">      &lt;artifactId&gt;byte-buddy&lt;/artifactId&gt;</span><br><span class=\"line\">      &lt;version&gt;1.11.12&lt;/version&gt;</span><br><span class=\"line\">  &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Hello-World\">Hello World</h2>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class&lt;?&gt; dynamicType = new ByteBuddy()</span><br><span class=\"line\">                .subclass(Object.class)</span><br><span class=\"line\">                .method(ElementMatchers.named(&quot;toString&quot;))</span><br><span class=\"line\">                .intercept(FixedValue.value(&quot;Hello World&quot;))</span><br><span class=\"line\">                .make()</span><br><span class=\"line\">                .load(HelloWorldBuddy.class.getClassLoader())</span><br><span class=\"line\">                .getLoaded();</span><br><span class=\"line\">Object instance = dynamicType.newInstance();</span><br><span class=\"line\">String toString = instance.toString();</span><br><span class=\"line\">System.out.println(toString);</span><br><span class=\"line\">System.out.println(instance.getClass().getCanonicalName());</span><br></pre></td></tr></table></figure>\n<p>​<img src=\"/assets/image-20230619222624-l98xjgi.png\" alt=\"image\">​</p>\n<p>从例子可以看出，很简单就创建了一个动态类型。ByteBuddy提供了一套流式API，从ByteBuddy实例出发，可以流畅的完成所有的操作和数据定义。<br>\n上面的示例中</p>\n<ul>\n<li>subclass 指定了新创建的类的父类</li>\n<li>method 指定了 Object 的 toString 方法</li>\n<li>intercept 拦截了 toString 方法并返回固定的 value</li>\n<li>最后 make 方法生产字节码，有类加载器加载到虚拟机中</li>\n</ul>\n<p>此外，Byte Buddy不仅限于创建子类和操作类，还可以转换现有代码。Byte Buddy 还提供了一个方便的 API，用于定义所谓的 Java 代理，该代理允许在任何 Java 应用程序的运行期间进行代码转换</p>\n<h2 id=\"创建动态类\">创建动态类</h2>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DynamicType.Unloaded&lt;?&gt; dynamicType = new ByteBuddy()</span><br><span class=\"line\">  .subclass(Object.class)</span><br><span class=\"line\">  .name(&quot;com.zlk.learning.bytebuddy.DynamicType&quot;)</span><br><span class=\"line\">  .make();</span><br></pre></td></tr></table></figure>\n<p>上面的示例代码会创建一个继承至 Object 类型的类。这个动态创建的类型与直接扩展 Object 并且没有实现任何方法、属性和构造函数的类型是等价的，如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class DynamicTYpe &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在创建类的时候，还提供了更多API来支持对类的定义，包括定义字段、方法等</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DynamicType.Unloaded&lt;?&gt; dynamicType = new ByteBuddy()</span><br><span class=\"line\">        .subclass(Object.class)</span><br><span class=\"line\">        .name(&quot;com.zlk.learning.bytebuddy.DynamicType&quot;)</span><br><span class=\"line\">        .defineField(&quot;name&quot;, String.class, 1)</span><br><span class=\"line\">        .defineField(&quot;age&quot;, Integer.class, 1)</span><br><span class=\"line\">        .method(ElementMatchers.named(&quot;toString&quot;))</span><br><span class=\"line\">        .intercept(FixedValue.value(&quot;Hello World!&quot;))</span><br><span class=\"line\">        .make();</span><br></pre></td></tr></table></figure>\n<p>​<img src=\"/assets/image-20230619222818-5btwdt3.png\" alt=\"image\">​</p>\n<p>上面的示例代码中，我们增加了两个字段name和age，同时拦截了toString方法，使其输出固定值 “Hello World!”。</p>\n<p>保留父类实现的接口信息</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Object <span class=\"title function_\">instantiate</span><span class=\"params\">(BeanDefinition beanDefinition, String beanName, Constructor ctor, Object[] args)</span> <span class=\"keyword\">throws</span> BeansException &#123;</span><br><span class=\"line\">    Class&lt;?&gt; beanClass = beanDefinition.getBeanClass();</span><br><span class=\"line\">    ArrayList&lt;TypeDescription.Generic&gt; list = getGenerics(beanClass);</span><br><span class=\"line\">    <span class=\"type\">Class</span> <span class=\"variable\">clazz</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ByteBuddy</span>().subclass(beanClass).implement(list)</span><br><span class=\"line\">            .make()</span><br><span class=\"line\">            .load(getClass().getClassLoader())</span><br><span class=\"line\">            .getLoaded();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"literal\">null</span> == ctor) <span class=\"keyword\">return</span> clazz.getDeclaredConstructor().newInstance();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> clazz.getDeclaredConstructor(ctor.getParameterTypes()).newInstance(args);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (NoSuchMethodException | InstantiationException | IllegalAccessException | InvocationTargetException e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">BeansException</span>(<span class=\"string\">&quot;Failed to instantiate [&quot;</span> + clazz.getName() + <span class=\"string\">&quot;]&quot;</span>, e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//获取父类的接口信息</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> ArrayList&lt;TypeDescription.Generic&gt; getGenerics(Class&lt;?&gt; beanClass) &#123;</span><br><span class=\"line\">    ArrayList&lt;TypeDescription.Generic&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        Type[] genericInterfaces = beanClass.getGenericInterfaces();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Type type : genericInterfaces) &#123;</span><br><span class=\"line\">            Type[] typeArguments = ((ParameterizedType) type).getActualTypeArguments();</span><br><span class=\"line\">            Class&lt;?&gt;[] classes = <span class=\"keyword\">new</span> <span class=\"title class_\">Class</span>[typeArguments.length];</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; typeArguments.length; i++) &#123;</span><br><span class=\"line\">                classes[i] = Class.forName(typeArguments[i].getTypeName());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            Class&lt;?&gt; aClass = Class.forName(((ParameterizedType) type).getRawType().getTypeName());</span><br><span class=\"line\">            TypeDescription.<span class=\"type\">Generic</span> <span class=\"variable\">listType</span> <span class=\"operator\">=</span> TypeDescription.Generic.Builder.parameterizedType(aClass, classes).build();</span><br><span class=\"line\">            list.add(listType);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (ClassNotFoundException e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">BeansException</span>(<span class=\"string\">&quot;Failed to instantiate [&quot;</span> + beanClass.getName() + <span class=\"string\">&quot;]&quot;</span>, e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> list;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>‍</p>\n<h2 id=\"加载类\">加载类</h2>\n<p>上节创建的 DynamicType.Unloaded，代表一个尚未加载的类，顾名思义，这些类型不会加载到 Java 虚拟机中，它仅仅表示创建好了类的字节码，通过 DynamicType.Unloaded 中的 getBytes 方法你可以获取到该字节码。</p>\n<p>在应用程序中，可能需要将该字节码保存到文件，或者注入的现在的 jar 文件中，因此该类型还提供了一个 saveIn(File) 方法，可以将类存储在给定的文件夹中； inject(File) 方法将类注入到现有的 Jar 文件中，另外你只需要将该字节码直接加载到虚拟机使用，你可以通过 ClassLoadingStrategy 来加载。</p>\n<p>如果不指定ClassLoadingStrategy，Byte Buffer根据你提供的ClassLoader来推导出一个策略，内置的策略定义在枚举ClassLoadingStrategy.Default中</p>\n<ul>\n<li>WRAPPER：创建一个新的Wrapping类加载器</li>\n<li>CHILD_FIRST：类似上面，但是子加载器优先负责加载目标类</li>\n<li>INJECTION：利用反射机制注入动态类型</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class&lt;?&gt; dynamicClass = dynamicType</span><br><span class=\"line\">               .load(Object.class.getClassLoader(), ClassLoadingStrategy.Default.WRAPPER)</span><br><span class=\"line\">               .getLoaded();</span><br></pre></td></tr></table></figure>\n<p>我们使用 WRAPPER 策略来加载适合大多数情况的类，这样生产的动态类不会被ApplicationClassLoader加载到，不会影响到项目中已经存在的类<br>\n​<code>getLoaded 方法返回一个 Java Class 的实例，它就表示现在加载的动态类</code>​</p>\n<h2 id=\"拦截方法\">拦截方法</h2>\n<p>在之前的例子中，我们拦截了toString方法，并使其输出固定值。不过在实际开发中很少会遇到如此简单的场景，我们可以通过指定拦截方法的形式来处理复杂的逻辑</p>\n<h3 id=\"通过匹配模式拦截\">通过匹配模式拦截</h3>\n<p>ByteBuddy 通过 net.bytebuddy.matcher.ElementMatcher 来定义配置策略，可以通过此接口实现自己定义的匹配策略</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Foo dynamicFoo = new ByteBuddy()</span><br><span class=\"line\">  .subclass(Foo.class)</span><br><span class=\"line\">  // 匹配由Foo.class声明的方法</span><br><span class=\"line\">  .method(isDeclaredBy(Foo.class)).intercept(FixedValue.value(&quot;One!&quot;))</span><br><span class=\"line\">  // 匹配名为foo的方法</span><br><span class=\"line\">  .method(named(&quot;foo&quot;)).intercept(FixedValue.value(&quot;Two!&quot;))</span><br><span class=\"line\">  // 匹配名为foo，入参数量为1的方法</span><br><span class=\"line\">  .method(named(&quot;foo&quot;).and(takesArguments(1))).intercept(FixedValue.value(&quot;Three!&quot;))</span><br><span class=\"line\">  .make()</span><br><span class=\"line\">  .load(getClass().getClassLoader())</span><br><span class=\"line\">  .getLoaded()</span><br><span class=\"line\">  .newInstance();</span><br></pre></td></tr></table></figure>\n<h3 id=\"方法委托\">方法委托</h3>\n<p>使用MethodDelegation可以将方法调用委托给任意POJO。Byte Buddy不要求Source（被委托类）、Target类的方法名一致</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Source &#123;</span><br><span class=\"line\">  public String hello(String name) &#123; return null; &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class Target &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  public static String hello(String name) &#123;</span><br><span class=\"line\">    return &quot;Hello &quot; + name + &quot;!&quot;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">String helloWorld = new ByteBuddy()</span><br><span class=\"line\">  .subclass(Source.class)</span><br><span class=\"line\">  .method(named(&quot;hello&quot;))</span><br><span class=\"line\">  // 此处委托 类只能委托静态方法  对象可使用非静态方法</span><br><span class=\"line\">  .intercept(MethodDelegation.to(Target.class))</span><br><span class=\"line\">  .make()</span><br><span class=\"line\">  .load(getClass().getClassLoader())</span><br><span class=\"line\">  .getLoaded()</span><br><span class=\"line\">  .newInstance()</span><br><span class=\"line\">  .hello(&quot;World&quot;);</span><br></pre></td></tr></table></figure>\n<p>其中 Target 还可以如下实现：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Target &#123;</span><br><span class=\"line\">  public static String intercept(String name) &#123; return &quot;Hello &quot; + name + &quot;!&quot;; &#125;</span><br><span class=\"line\">  public static String intercept(int i) &#123; return Integer.toString(i); &#125;</span><br><span class=\"line\">  public static String intercept(Object o) &#123; return o.toString(); &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>前一个实现因为只有一个方法，而且类型也匹配，很好理解，那么后一个呢，Byte Buddy到底会委托给哪个方法？Byte Buddy遵循一个最接近原则：</p>\n<ul>\n<li>intercept(int)因为参数类型不匹配，直接Pass</li>\n<li>另外两个方法参数都匹配，但是 intercept(String)类型更加接近，因此会委托给它</li>\n</ul>\n<p>同时需要注意的是被拦截的方法需要声明为 public，否则没法进行拦截增强。除此之外，还可以使用 @RuntimeType 注解来标注方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RuntimeType</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>  Object <span class=\"title function_\">interceptor</span><span class=\"params\">(<span class=\"meta\">@This</span> Object proxy, <span class=\"meta\">@Origin</span> Method method,</span></span><br><span class=\"line\"><span class=\"params\">                          <span class=\"meta\">@SuperMethod</span> Method superMethod,</span></span><br><span class=\"line\"><span class=\"params\">                          <span class=\"meta\">@AllArguments</span> Object[] args)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;bytebuddy delegate proxy2 before sing &quot;</span>);</span><br><span class=\"line\">    <span class=\"type\">Object</span> <span class=\"variable\">ret</span> <span class=\"operator\">=</span> superMethod.invoke(proxy, args);</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;bytebuddy delegate proxy2 after sing &quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"参数绑定\">参数绑定</h3>\n<p>可以在拦截器（Target）的拦截方法 intercept 中使用注解注入参数，ByteBuddy 会根据注解给我们注入对于的参数值。比如</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void intercept(Object o1, Object o2)</span><br><span class=\"line\">// 等同于</span><br><span class=\"line\">void intercept(@Argument(0) Object o1, @Argument(1) Object o2)</span><br></pre></td></tr></table></figure>\n<p>常用注解有以下这些：</p>\n<ul>\n<li>@Argument 绑定单个参数</li>\n<li>@AllArguments 绑定所有参数的数组</li>\n<li>@This 当前被拦截的、动态生成的那个对象</li>\n<li>@DefaultCall 调用默认方法而非super的方法</li>\n<li>@SuperCall 用于调用父类版本的方法</li>\n<li>@Origin 被拦截的源方法</li>\n<li>@RuntimeType 可以用在返回值、参数上，提示ByteBuddy禁用严格的类型检查</li>\n<li>@Super 当前被拦截的、动态生成的那个对象的父类对象</li>\n<li>@FieldValue 注入被拦截对象的一个字段的值</li>\n</ul>\n<h2 id=\"Agent\">Agent</h2>\n<p>Java 从 1.5 开始提供了 java.lang.instrument包，该包为检测 Java 程序提供 API，比如用于监控、收集性能信息、诊断问题。通过 java.lang.instrument 实现工具被称为 Java Agent。Java Agent 可以修改类文件的字节码，通常是，在字节码方法插入额外的字节码来完成检测</p>\n<p>和通过ByteBuddy实例创建动态类型一样，bytebuddy也提供了AgentBuilder类使我们在agent中更优雅地编写代码</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class ToStringAgent &#123;</span><br><span class=\"line\">  public static void premain(String arguments, Instrumentation instrumentation) &#123;</span><br><span class=\"line\">    new AgentBuilder.Default()</span><br><span class=\"line\">        .type(isAnnotatedWith(ToString.class))</span><br><span class=\"line\">        .transform(new AgentBuilder.Transformer() &#123;</span><br><span class=\"line\">      @Override</span><br><span class=\"line\">      public DynamicType.Builder transform(DynamicType.Builder builder,</span><br><span class=\"line\">                                              TypeDescription typeDescription,</span><br><span class=\"line\">                                              ClassLoader classloader) &#123;</span><br><span class=\"line\">        return builder.method(named(&quot;toString&quot;))</span><br><span class=\"line\">                      .intercept(FixedValue.value(&quot;transformed&quot;));</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;).installOn(instrumentation);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>type 通过ElementMatcher 来匹配我们加载的class，匹配到之后，将会使用</li>\n<li>transform 指定的转换器来对匹配到的class进行操作</li>\n</ul>\n<h2 id=\"ElementMatcher\">ElementMatcher</h2>\n<p>ElementMatcher可以定义匹配class的规则，在bytebuddy中，ElementMatchers类提供了许多常规的匹配方式，可以按照class name、注解、类型等来进行匹配，上面的实例中就是使用注解匹配的方式</p>\n<p>Junction继承自ElementMatcher接口，定义了and 和 or 方法，可以使我们在定义Matcher时通过链式定义一连串的匹配规则</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new AgentBuilder.Default()</span><br><span class=\"line\">          .type(ElementMatchers.isAnnotatedWith(ToString.class)).and(ElementMatchers.isSubTypeOf(DynamicClass.class)).or(ElementMatchers.named(&quot;DynamicClass&quot;))</span><br><span class=\"line\">          .transform(new AgentBuilder.Transformer() &#123;</span><br><span class=\"line\">              public DynamicType.Builder&lt;?&gt; transform(DynamicType.Builder&lt;?&gt; builder, TypeDescription typeDescription, ClassLoader classLoader, JavaModule javaModule) &#123;</span><br><span class=\"line\">                  return builder</span><br><span class=\"line\">                          .method(ElementMatchers.named(&quot;hello&quot;))</span><br><span class=\"line\">                          .intercept(MethodDelegation.to(MyServiceInterceptor.class))</span><br><span class=\"line\">                          ;</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">          &#125;).installOn(instrumentation);</span><br></pre></td></tr></table></figure>\n<h2 id=\"Transformer\"><a href=\"https://so.csdn.net/so/search?q=Transformer&amp;spm=1001.2101.3001.7020\">Transformer</a></h2>\n<p>Transformer 接口定义了 transform方法，会传入DynamicType.Builder实例，通过该builder，就可以对匹配到的类进行操作，就和上面讲的 ByteBuddy创建动态类型时类似操作，可以定义字段以及对方法进行拦截操作等，上面的例子就是对匹配到的类的hello方法进行了方法委托，在调用hello方法时，将会委托给 MyServiceInterceptor类</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class MyServiceInterceptor &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @RuntimeType</span><br><span class=\"line\">    public static Object intercept(@Origin Method method, @SuperCall Callable&lt;?&gt; callable) throws Exception &#123;</span><br><span class=\"line\">        System.out.println(&quot;intercept：拦截了&quot; + method.getName());</span><br><span class=\"line\">        return callable.call();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"\"></h2>\n<p>‍</p>\n<h2 id=\"END\">END</h2>\n<p><strong>参考文章</strong><br>\n​<code>bytebuddy官方文档 https://bytebuddy.net/#/tutorial</code></p>\n<p><code>https://juejin.cn/post/6844903965553852423#heading-12</code>​​</p>\n","excerpt":"","more":"<h1>ByteBuddy</h1>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">      &lt;groupId&gt;net.bytebuddy&lt;/groupId&gt;</span><br><span class=\"line\">      &lt;artifactId&gt;byte-buddy&lt;/artifactId&gt;</span><br><span class=\"line\">      &lt;version&gt;1.11.12&lt;/version&gt;</span><br><span class=\"line\">  &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Hello-World\">Hello World</h2>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class&lt;?&gt; dynamicType = new ByteBuddy()</span><br><span class=\"line\">                .subclass(Object.class)</span><br><span class=\"line\">                .method(ElementMatchers.named(&quot;toString&quot;))</span><br><span class=\"line\">                .intercept(FixedValue.value(&quot;Hello World&quot;))</span><br><span class=\"line\">                .make()</span><br><span class=\"line\">                .load(HelloWorldBuddy.class.getClassLoader())</span><br><span class=\"line\">                .getLoaded();</span><br><span class=\"line\">Object instance = dynamicType.newInstance();</span><br><span class=\"line\">String toString = instance.toString();</span><br><span class=\"line\">System.out.println(toString);</span><br><span class=\"line\">System.out.println(instance.getClass().getCanonicalName());</span><br></pre></td></tr></table></figure>\n<p>​<img src=\"/assets/image-20230619222624-l98xjgi.png\" alt=\"image\">​</p>\n<p>从例子可以看出，很简单就创建了一个动态类型。ByteBuddy提供了一套流式API，从ByteBuddy实例出发，可以流畅的完成所有的操作和数据定义。<br>\n上面的示例中</p>\n<ul>\n<li>subclass 指定了新创建的类的父类</li>\n<li>method 指定了 Object 的 toString 方法</li>\n<li>intercept 拦截了 toString 方法并返回固定的 value</li>\n<li>最后 make 方法生产字节码，有类加载器加载到虚拟机中</li>\n</ul>\n<p>此外，Byte Buddy不仅限于创建子类和操作类，还可以转换现有代码。Byte Buddy 还提供了一个方便的 API，用于定义所谓的 Java 代理，该代理允许在任何 Java 应用程序的运行期间进行代码转换</p>\n<h2 id=\"创建动态类\">创建动态类</h2>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DynamicType.Unloaded&lt;?&gt; dynamicType = new ByteBuddy()</span><br><span class=\"line\">  .subclass(Object.class)</span><br><span class=\"line\">  .name(&quot;com.zlk.learning.bytebuddy.DynamicType&quot;)</span><br><span class=\"line\">  .make();</span><br></pre></td></tr></table></figure>\n<p>上面的示例代码会创建一个继承至 Object 类型的类。这个动态创建的类型与直接扩展 Object 并且没有实现任何方法、属性和构造函数的类型是等价的，如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class DynamicTYpe &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在创建类的时候，还提供了更多API来支持对类的定义，包括定义字段、方法等</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DynamicType.Unloaded&lt;?&gt; dynamicType = new ByteBuddy()</span><br><span class=\"line\">        .subclass(Object.class)</span><br><span class=\"line\">        .name(&quot;com.zlk.learning.bytebuddy.DynamicType&quot;)</span><br><span class=\"line\">        .defineField(&quot;name&quot;, String.class, 1)</span><br><span class=\"line\">        .defineField(&quot;age&quot;, Integer.class, 1)</span><br><span class=\"line\">        .method(ElementMatchers.named(&quot;toString&quot;))</span><br><span class=\"line\">        .intercept(FixedValue.value(&quot;Hello World!&quot;))</span><br><span class=\"line\">        .make();</span><br></pre></td></tr></table></figure>\n<p>​<img src=\"/assets/image-20230619222818-5btwdt3.png\" alt=\"image\">​</p>\n<p>上面的示例代码中，我们增加了两个字段name和age，同时拦截了toString方法，使其输出固定值 “Hello World!”。</p>\n<p>保留父类实现的接口信息</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Object <span class=\"title function_\">instantiate</span><span class=\"params\">(BeanDefinition beanDefinition, String beanName, Constructor ctor, Object[] args)</span> <span class=\"keyword\">throws</span> BeansException &#123;</span><br><span class=\"line\">    Class&lt;?&gt; beanClass = beanDefinition.getBeanClass();</span><br><span class=\"line\">    ArrayList&lt;TypeDescription.Generic&gt; list = getGenerics(beanClass);</span><br><span class=\"line\">    <span class=\"type\">Class</span> <span class=\"variable\">clazz</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ByteBuddy</span>().subclass(beanClass).implement(list)</span><br><span class=\"line\">            .make()</span><br><span class=\"line\">            .load(getClass().getClassLoader())</span><br><span class=\"line\">            .getLoaded();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"literal\">null</span> == ctor) <span class=\"keyword\">return</span> clazz.getDeclaredConstructor().newInstance();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> clazz.getDeclaredConstructor(ctor.getParameterTypes()).newInstance(args);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (NoSuchMethodException | InstantiationException | IllegalAccessException | InvocationTargetException e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">BeansException</span>(<span class=\"string\">&quot;Failed to instantiate [&quot;</span> + clazz.getName() + <span class=\"string\">&quot;]&quot;</span>, e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//获取父类的接口信息</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> ArrayList&lt;TypeDescription.Generic&gt; getGenerics(Class&lt;?&gt; beanClass) &#123;</span><br><span class=\"line\">    ArrayList&lt;TypeDescription.Generic&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        Type[] genericInterfaces = beanClass.getGenericInterfaces();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Type type : genericInterfaces) &#123;</span><br><span class=\"line\">            Type[] typeArguments = ((ParameterizedType) type).getActualTypeArguments();</span><br><span class=\"line\">            Class&lt;?&gt;[] classes = <span class=\"keyword\">new</span> <span class=\"title class_\">Class</span>[typeArguments.length];</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; typeArguments.length; i++) &#123;</span><br><span class=\"line\">                classes[i] = Class.forName(typeArguments[i].getTypeName());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            Class&lt;?&gt; aClass = Class.forName(((ParameterizedType) type).getRawType().getTypeName());</span><br><span class=\"line\">            TypeDescription.<span class=\"type\">Generic</span> <span class=\"variable\">listType</span> <span class=\"operator\">=</span> TypeDescription.Generic.Builder.parameterizedType(aClass, classes).build();</span><br><span class=\"line\">            list.add(listType);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (ClassNotFoundException e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">BeansException</span>(<span class=\"string\">&quot;Failed to instantiate [&quot;</span> + beanClass.getName() + <span class=\"string\">&quot;]&quot;</span>, e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> list;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>‍</p>\n<h2 id=\"加载类\">加载类</h2>\n<p>上节创建的 DynamicType.Unloaded，代表一个尚未加载的类，顾名思义，这些类型不会加载到 Java 虚拟机中，它仅仅表示创建好了类的字节码，通过 DynamicType.Unloaded 中的 getBytes 方法你可以获取到该字节码。</p>\n<p>在应用程序中，可能需要将该字节码保存到文件，或者注入的现在的 jar 文件中，因此该类型还提供了一个 saveIn(File) 方法，可以将类存储在给定的文件夹中； inject(File) 方法将类注入到现有的 Jar 文件中，另外你只需要将该字节码直接加载到虚拟机使用，你可以通过 ClassLoadingStrategy 来加载。</p>\n<p>如果不指定ClassLoadingStrategy，Byte Buffer根据你提供的ClassLoader来推导出一个策略，内置的策略定义在枚举ClassLoadingStrategy.Default中</p>\n<ul>\n<li>WRAPPER：创建一个新的Wrapping类加载器</li>\n<li>CHILD_FIRST：类似上面，但是子加载器优先负责加载目标类</li>\n<li>INJECTION：利用反射机制注入动态类型</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class&lt;?&gt; dynamicClass = dynamicType</span><br><span class=\"line\">               .load(Object.class.getClassLoader(), ClassLoadingStrategy.Default.WRAPPER)</span><br><span class=\"line\">               .getLoaded();</span><br></pre></td></tr></table></figure>\n<p>我们使用 WRAPPER 策略来加载适合大多数情况的类，这样生产的动态类不会被ApplicationClassLoader加载到，不会影响到项目中已经存在的类<br>\n​<code>getLoaded 方法返回一个 Java Class 的实例，它就表示现在加载的动态类</code>​</p>\n<h2 id=\"拦截方法\">拦截方法</h2>\n<p>在之前的例子中，我们拦截了toString方法，并使其输出固定值。不过在实际开发中很少会遇到如此简单的场景，我们可以通过指定拦截方法的形式来处理复杂的逻辑</p>\n<h3 id=\"通过匹配模式拦截\">通过匹配模式拦截</h3>\n<p>ByteBuddy 通过 net.bytebuddy.matcher.ElementMatcher 来定义配置策略，可以通过此接口实现自己定义的匹配策略</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Foo dynamicFoo = new ByteBuddy()</span><br><span class=\"line\">  .subclass(Foo.class)</span><br><span class=\"line\">  // 匹配由Foo.class声明的方法</span><br><span class=\"line\">  .method(isDeclaredBy(Foo.class)).intercept(FixedValue.value(&quot;One!&quot;))</span><br><span class=\"line\">  // 匹配名为foo的方法</span><br><span class=\"line\">  .method(named(&quot;foo&quot;)).intercept(FixedValue.value(&quot;Two!&quot;))</span><br><span class=\"line\">  // 匹配名为foo，入参数量为1的方法</span><br><span class=\"line\">  .method(named(&quot;foo&quot;).and(takesArguments(1))).intercept(FixedValue.value(&quot;Three!&quot;))</span><br><span class=\"line\">  .make()</span><br><span class=\"line\">  .load(getClass().getClassLoader())</span><br><span class=\"line\">  .getLoaded()</span><br><span class=\"line\">  .newInstance();</span><br></pre></td></tr></table></figure>\n<h3 id=\"方法委托\">方法委托</h3>\n<p>使用MethodDelegation可以将方法调用委托给任意POJO。Byte Buddy不要求Source（被委托类）、Target类的方法名一致</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Source &#123;</span><br><span class=\"line\">  public String hello(String name) &#123; return null; &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class Target &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  public static String hello(String name) &#123;</span><br><span class=\"line\">    return &quot;Hello &quot; + name + &quot;!&quot;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">String helloWorld = new ByteBuddy()</span><br><span class=\"line\">  .subclass(Source.class)</span><br><span class=\"line\">  .method(named(&quot;hello&quot;))</span><br><span class=\"line\">  // 此处委托 类只能委托静态方法  对象可使用非静态方法</span><br><span class=\"line\">  .intercept(MethodDelegation.to(Target.class))</span><br><span class=\"line\">  .make()</span><br><span class=\"line\">  .load(getClass().getClassLoader())</span><br><span class=\"line\">  .getLoaded()</span><br><span class=\"line\">  .newInstance()</span><br><span class=\"line\">  .hello(&quot;World&quot;);</span><br></pre></td></tr></table></figure>\n<p>其中 Target 还可以如下实现：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Target &#123;</span><br><span class=\"line\">  public static String intercept(String name) &#123; return &quot;Hello &quot; + name + &quot;!&quot;; &#125;</span><br><span class=\"line\">  public static String intercept(int i) &#123; return Integer.toString(i); &#125;</span><br><span class=\"line\">  public static String intercept(Object o) &#123; return o.toString(); &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>前一个实现因为只有一个方法，而且类型也匹配，很好理解，那么后一个呢，Byte Buddy到底会委托给哪个方法？Byte Buddy遵循一个最接近原则：</p>\n<ul>\n<li>intercept(int)因为参数类型不匹配，直接Pass</li>\n<li>另外两个方法参数都匹配，但是 intercept(String)类型更加接近，因此会委托给它</li>\n</ul>\n<p>同时需要注意的是被拦截的方法需要声明为 public，否则没法进行拦截增强。除此之外，还可以使用 @RuntimeType 注解来标注方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RuntimeType</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>  Object <span class=\"title function_\">interceptor</span><span class=\"params\">(<span class=\"meta\">@This</span> Object proxy, <span class=\"meta\">@Origin</span> Method method,</span></span><br><span class=\"line\"><span class=\"params\">                          <span class=\"meta\">@SuperMethod</span> Method superMethod,</span></span><br><span class=\"line\"><span class=\"params\">                          <span class=\"meta\">@AllArguments</span> Object[] args)</span> <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;bytebuddy delegate proxy2 before sing &quot;</span>);</span><br><span class=\"line\">    <span class=\"type\">Object</span> <span class=\"variable\">ret</span> <span class=\"operator\">=</span> superMethod.invoke(proxy, args);</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;bytebuddy delegate proxy2 after sing &quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"参数绑定\">参数绑定</h3>\n<p>可以在拦截器（Target）的拦截方法 intercept 中使用注解注入参数，ByteBuddy 会根据注解给我们注入对于的参数值。比如</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void intercept(Object o1, Object o2)</span><br><span class=\"line\">// 等同于</span><br><span class=\"line\">void intercept(@Argument(0) Object o1, @Argument(1) Object o2)</span><br></pre></td></tr></table></figure>\n<p>常用注解有以下这些：</p>\n<ul>\n<li>@Argument 绑定单个参数</li>\n<li>@AllArguments 绑定所有参数的数组</li>\n<li>@This 当前被拦截的、动态生成的那个对象</li>\n<li>@DefaultCall 调用默认方法而非super的方法</li>\n<li>@SuperCall 用于调用父类版本的方法</li>\n<li>@Origin 被拦截的源方法</li>\n<li>@RuntimeType 可以用在返回值、参数上，提示ByteBuddy禁用严格的类型检查</li>\n<li>@Super 当前被拦截的、动态生成的那个对象的父类对象</li>\n<li>@FieldValue 注入被拦截对象的一个字段的值</li>\n</ul>\n<h2 id=\"Agent\">Agent</h2>\n<p>Java 从 1.5 开始提供了 java.lang.instrument包，该包为检测 Java 程序提供 API，比如用于监控、收集性能信息、诊断问题。通过 java.lang.instrument 实现工具被称为 Java Agent。Java Agent 可以修改类文件的字节码，通常是，在字节码方法插入额外的字节码来完成检测</p>\n<p>和通过ByteBuddy实例创建动态类型一样，bytebuddy也提供了AgentBuilder类使我们在agent中更优雅地编写代码</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class ToStringAgent &#123;</span><br><span class=\"line\">  public static void premain(String arguments, Instrumentation instrumentation) &#123;</span><br><span class=\"line\">    new AgentBuilder.Default()</span><br><span class=\"line\">        .type(isAnnotatedWith(ToString.class))</span><br><span class=\"line\">        .transform(new AgentBuilder.Transformer() &#123;</span><br><span class=\"line\">      @Override</span><br><span class=\"line\">      public DynamicType.Builder transform(DynamicType.Builder builder,</span><br><span class=\"line\">                                              TypeDescription typeDescription,</span><br><span class=\"line\">                                              ClassLoader classloader) &#123;</span><br><span class=\"line\">        return builder.method(named(&quot;toString&quot;))</span><br><span class=\"line\">                      .intercept(FixedValue.value(&quot;transformed&quot;));</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;).installOn(instrumentation);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>type 通过ElementMatcher 来匹配我们加载的class，匹配到之后，将会使用</li>\n<li>transform 指定的转换器来对匹配到的class进行操作</li>\n</ul>\n<h2 id=\"ElementMatcher\">ElementMatcher</h2>\n<p>ElementMatcher可以定义匹配class的规则，在bytebuddy中，ElementMatchers类提供了许多常规的匹配方式，可以按照class name、注解、类型等来进行匹配，上面的实例中就是使用注解匹配的方式</p>\n<p>Junction继承自ElementMatcher接口，定义了and 和 or 方法，可以使我们在定义Matcher时通过链式定义一连串的匹配规则</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new AgentBuilder.Default()</span><br><span class=\"line\">          .type(ElementMatchers.isAnnotatedWith(ToString.class)).and(ElementMatchers.isSubTypeOf(DynamicClass.class)).or(ElementMatchers.named(&quot;DynamicClass&quot;))</span><br><span class=\"line\">          .transform(new AgentBuilder.Transformer() &#123;</span><br><span class=\"line\">              public DynamicType.Builder&lt;?&gt; transform(DynamicType.Builder&lt;?&gt; builder, TypeDescription typeDescription, ClassLoader classLoader, JavaModule javaModule) &#123;</span><br><span class=\"line\">                  return builder</span><br><span class=\"line\">                          .method(ElementMatchers.named(&quot;hello&quot;))</span><br><span class=\"line\">                          .intercept(MethodDelegation.to(MyServiceInterceptor.class))</span><br><span class=\"line\">                          ;</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">          &#125;).installOn(instrumentation);</span><br></pre></td></tr></table></figure>\n<h2 id=\"Transformer\"><a href=\"https://so.csdn.net/so/search?q=Transformer&amp;spm=1001.2101.3001.7020\">Transformer</a></h2>\n<p>Transformer 接口定义了 transform方法，会传入DynamicType.Builder实例，通过该builder，就可以对匹配到的类进行操作，就和上面讲的 ByteBuddy创建动态类型时类似操作，可以定义字段以及对方法进行拦截操作等，上面的例子就是对匹配到的类的hello方法进行了方法委托，在调用hello方法时，将会委托给 MyServiceInterceptor类</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class MyServiceInterceptor &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @RuntimeType</span><br><span class=\"line\">    public static Object intercept(@Origin Method method, @SuperCall Callable&lt;?&gt; callable) throws Exception &#123;</span><br><span class=\"line\">        System.out.println(&quot;intercept：拦截了&quot; + method.getName());</span><br><span class=\"line\">        return callable.call();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"\"></h2>\n<p>‍</p>\n<h2 id=\"END\">END</h2>\n<p><strong>参考文章</strong><br>\n​<code>bytebuddy官方文档 https://bytebuddy.net/#/tutorial</code></p>\n<p><code>https://juejin.cn/post/6844903965553852423#heading-12</code>​​</p>\n"},{"title":"Collection","date":"2022-10-30T05:21:31.000Z","lastmod":"2023-05-27T07:29:52.000Z","_content":"\n# Collection\n\n# Collection\n\n​![](/assets/net-img-1596005642573-853dc49e-7632-496d-9221-33e3b7879fea-20221030132325-84wdxkw.jpeg)​\n\n​![](/assets/net-img-1591690708492-8b43720d-e8dc-4e22-9057-dcc4be2210de-20221030132325-ac88yvu.jpeg)​\n\n- Collection 接口的接口 对象的集合\n  - List 子接口 按进入先后有序保存 可重复\n    - LinkedList(双向链表) 接口实现类 链表 插入删除 没有同步 线程不安全\n    - ArrayList(Object 数组) 接口实现类 数组 随机访问 没有同步 线程不安全\n    - Vector(Object 数组) 接口实现类 数组 同步 线程安全\n  - Set 子接口 不可重复\n    - HashSet(无序，唯一)\n    - LinkedHashSet(有序，唯一)\n      线程不安全\n    - TreeSet(有序，唯一)\n- Map 接口 键值对的集合\n  - Hashtable(链表+数组) 接口实现类 同步 线程安全\n  - HashMap(1.8 之前数组+链表，1.8 之后达到一定长度会转化为红黑树) 接口实现类 没有同步 线程不安全\n    - LinkedHashMap(在 HashMap 基础上添加一条双向链表)\n  - TreeMap(红黑树(自平衡排序二叉树))\n\n## Iterable\n\n　　**Iterator 也是一个接口，它只有三个方法：**\n\n- hasNext()\n- next()\n- remove()\n\n## ArrayList 与 LinkedList 区别\n\n- 都不保证线程安全\n- ArrayList 底层是数组，LinkedList 底层使用双向链表（1.6 之前为循环链表，1.7 之后取消循环）\n- ArrayList 采用数组存储，删除和插入的时间复杂度会受元素位置影响。LinkedList 采用链式存储，对于插入删除不受元素位置影响\n- LinkedList 不支持随机访问，ArrayList 支持元素序号访问\n- ArrayList 会在列表结尾预留一定空余空间，LinkedList 每个节点所消耗的空间比 ArrayList 大\n\n## HashMap 和 Hashtable 区别\n\n- HashMap 是非线程安全的，HashTable 是线程安全的 (如果你要保证线程安全的话就使用 ConcurrentHashMap 吧,效率比 hashtable 高)；\n- HashMap 中，null 可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为 null。。但是在 HashTable 中 put 进的键值只要有一个 null，直接抛出 NullPointerException。\n- 初始化\n  - ① 创建时如果不指定容量初始值： Hashtable 默认的**初始大小为 11**，之后每次扩充，容量变为原来的 2n+1。HashMap 默认的**初始化大小为 16**。之后每次扩充，容量变为原来的 2 倍。\n  - ② 创建时如果给定了容量初始值：Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为 2 的幂次方大小\n- JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（**将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树**）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。\n\n## ConcurrentHashMap 和 Hashtable 的区别\n\n　　ConcurrentHashMap 和 Hashtable 的区别主要体现在实现线程安全的方式上不同。\n\n- 底层数据结构： JDK1.7 的 ConcurrentHashMap 底层采用 **分段的数组+链表** 实现，JDK1.8 采用的数据结构跟 HashMap1.8 的结构一样，**数组+链表/红黑二叉树**。Hashtable 和 JDK1.8 之前的 HashMap 的底层数据结构类似都是采用 **数组+链表** 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；\n- 实现线程安全的方式（重要）：\n  - ① 在 JDK1.7 的时候，ConcurrentHashMap（分段锁） 对整个桶数组进行了分割分段(Segment)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。 到了 JDK1.8 的时候已经摒弃了 Segment 的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作。（JDK1.6 以后 对 synchronized 锁做了很多优化） 整个看起来就像是优化过且线程安全的 HashMap，虽然在 JDK1.8 中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本；\n  - ② Hashtable(同一把锁) :使用 synchronized 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。\n\n## HashTable：全表锁\n\n![](/assets/net-img-1591690708909-03b304db-aa14-40fc-954b-2e5812e31b86-20221030132326-7iwfv9t.png)\n\n## JDK7 的 ConcurrentHashMap：\n\n　　首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。\n\n　　一个 `ConcurrentHashMap` 里包含一个 `Segment(片段)` 数组。`Segment` 的结构和 `HashMap` 类似，是一种数组和链表结构，一个 `Segment` 包含一个 `HashEntry` 数组，每个 `HashEntry` 是一个链表结构的元素，每个 `Segment` 守护着一个 `HashEntry` 数组里的元素，当对 `HashEntry` 数组的数据进行修改时，必须首先获得对应的 `Segment` 的锁。\n\n　　![](/assets/net-img-1591690708399-bf1076aa-bdad-4e5f-ae30-261ccda91da5-20221030132327-4fweook.png)[https://imgchr.com/i/t2J5Kx](https://imgchr.com/i/t2J5Kx)\n\n## JDK1.8 的 ConcurrentHashMap（TreeBin: 红黑二叉树节点 Node: 链表节点）`\n\n　　​**​`1.8之前ConcurrentHashMap将hashmap数组分段，对于每个段加锁。而在1.8后几乎与hashmap类似，只是更改了put操作，在计算hash值和索引位置后会先判断数组是否正在扩容。若正在扩容则调用扩容辅助函数。没有则在判断是否为空，为空则采用csa方法放入数组，若不为空则使用synchronized锁住该节点，根据链表或红黑树选择插入方法。最后判断长度，为8则开始转换红黑树。`​** ​ `synchronized `​只锁定当前链表或红黑二叉树的首节点，这样只要 hash 不冲突，就不会产生并发，效率又提升 N 倍。\n\n​![](/assets/net-img-1591690708309-b6db1e95-1bbf-4140-b612-26fefc8d85b5-20221030132327-6s3ed7l.png)​\n\n## HashMap 和 HashSet 区别\n\n　　**HashSet 底层就是基于 HashMap 实现的**\n\n|HashMap|HashSet|\n| ----------------------------------| ------------------------------------------------------------------------|\n|实现了 Map 接口|实现 Set 接口|\n|存储键值对|仅存储对象|\n|调用 put()向 map 中添加元素|调用 add()方法向 Set 中添加元素|\n|HashMap 使用键（Key）计算 Hashcode|HashSet 使用成员对象来计算 hashcode 值，对于两个对象来说 hashcode 可能相|\n","source":"_posts/java/Collection.md","raw":"---\ntitle: Collection\ndate: 2022-10-30T13:21:31Z\nlastmod: 2023-05-27T15:29:52Z\n---\n\n# Collection\n\n# Collection\n\n​![](/assets/net-img-1596005642573-853dc49e-7632-496d-9221-33e3b7879fea-20221030132325-84wdxkw.jpeg)​\n\n​![](/assets/net-img-1591690708492-8b43720d-e8dc-4e22-9057-dcc4be2210de-20221030132325-ac88yvu.jpeg)​\n\n- Collection 接口的接口 对象的集合\n  - List 子接口 按进入先后有序保存 可重复\n    - LinkedList(双向链表) 接口实现类 链表 插入删除 没有同步 线程不安全\n    - ArrayList(Object 数组) 接口实现类 数组 随机访问 没有同步 线程不安全\n    - Vector(Object 数组) 接口实现类 数组 同步 线程安全\n  - Set 子接口 不可重复\n    - HashSet(无序，唯一)\n    - LinkedHashSet(有序，唯一)\n      线程不安全\n    - TreeSet(有序，唯一)\n- Map 接口 键值对的集合\n  - Hashtable(链表+数组) 接口实现类 同步 线程安全\n  - HashMap(1.8 之前数组+链表，1.8 之后达到一定长度会转化为红黑树) 接口实现类 没有同步 线程不安全\n    - LinkedHashMap(在 HashMap 基础上添加一条双向链表)\n  - TreeMap(红黑树(自平衡排序二叉树))\n\n## Iterable\n\n　　**Iterator 也是一个接口，它只有三个方法：**\n\n- hasNext()\n- next()\n- remove()\n\n## ArrayList 与 LinkedList 区别\n\n- 都不保证线程安全\n- ArrayList 底层是数组，LinkedList 底层使用双向链表（1.6 之前为循环链表，1.7 之后取消循环）\n- ArrayList 采用数组存储，删除和插入的时间复杂度会受元素位置影响。LinkedList 采用链式存储，对于插入删除不受元素位置影响\n- LinkedList 不支持随机访问，ArrayList 支持元素序号访问\n- ArrayList 会在列表结尾预留一定空余空间，LinkedList 每个节点所消耗的空间比 ArrayList 大\n\n## HashMap 和 Hashtable 区别\n\n- HashMap 是非线程安全的，HashTable 是线程安全的 (如果你要保证线程安全的话就使用 ConcurrentHashMap 吧,效率比 hashtable 高)；\n- HashMap 中，null 可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为 null。。但是在 HashTable 中 put 进的键值只要有一个 null，直接抛出 NullPointerException。\n- 初始化\n  - ① 创建时如果不指定容量初始值： Hashtable 默认的**初始大小为 11**，之后每次扩充，容量变为原来的 2n+1。HashMap 默认的**初始化大小为 16**。之后每次扩充，容量变为原来的 2 倍。\n  - ② 创建时如果给定了容量初始值：Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为 2 的幂次方大小\n- JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（**将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树**）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。\n\n## ConcurrentHashMap 和 Hashtable 的区别\n\n　　ConcurrentHashMap 和 Hashtable 的区别主要体现在实现线程安全的方式上不同。\n\n- 底层数据结构： JDK1.7 的 ConcurrentHashMap 底层采用 **分段的数组+链表** 实现，JDK1.8 采用的数据结构跟 HashMap1.8 的结构一样，**数组+链表/红黑二叉树**。Hashtable 和 JDK1.8 之前的 HashMap 的底层数据结构类似都是采用 **数组+链表** 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；\n- 实现线程安全的方式（重要）：\n  - ① 在 JDK1.7 的时候，ConcurrentHashMap（分段锁） 对整个桶数组进行了分割分段(Segment)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。 到了 JDK1.8 的时候已经摒弃了 Segment 的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作。（JDK1.6 以后 对 synchronized 锁做了很多优化） 整个看起来就像是优化过且线程安全的 HashMap，虽然在 JDK1.8 中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本；\n  - ② Hashtable(同一把锁) :使用 synchronized 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。\n\n## HashTable：全表锁\n\n![](/assets/net-img-1591690708909-03b304db-aa14-40fc-954b-2e5812e31b86-20221030132326-7iwfv9t.png)\n\n## JDK7 的 ConcurrentHashMap：\n\n　　首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。\n\n　　一个 `ConcurrentHashMap` 里包含一个 `Segment(片段)` 数组。`Segment` 的结构和 `HashMap` 类似，是一种数组和链表结构，一个 `Segment` 包含一个 `HashEntry` 数组，每个 `HashEntry` 是一个链表结构的元素，每个 `Segment` 守护着一个 `HashEntry` 数组里的元素，当对 `HashEntry` 数组的数据进行修改时，必须首先获得对应的 `Segment` 的锁。\n\n　　![](/assets/net-img-1591690708399-bf1076aa-bdad-4e5f-ae30-261ccda91da5-20221030132327-4fweook.png)[https://imgchr.com/i/t2J5Kx](https://imgchr.com/i/t2J5Kx)\n\n## JDK1.8 的 ConcurrentHashMap（TreeBin: 红黑二叉树节点 Node: 链表节点）`\n\n　　​**​`1.8之前ConcurrentHashMap将hashmap数组分段，对于每个段加锁。而在1.8后几乎与hashmap类似，只是更改了put操作，在计算hash值和索引位置后会先判断数组是否正在扩容。若正在扩容则调用扩容辅助函数。没有则在判断是否为空，为空则采用csa方法放入数组，若不为空则使用synchronized锁住该节点，根据链表或红黑树选择插入方法。最后判断长度，为8则开始转换红黑树。`​** ​ `synchronized `​只锁定当前链表或红黑二叉树的首节点，这样只要 hash 不冲突，就不会产生并发，效率又提升 N 倍。\n\n​![](/assets/net-img-1591690708309-b6db1e95-1bbf-4140-b612-26fefc8d85b5-20221030132327-6s3ed7l.png)​\n\n## HashMap 和 HashSet 区别\n\n　　**HashSet 底层就是基于 HashMap 实现的**\n\n|HashMap|HashSet|\n| ----------------------------------| ------------------------------------------------------------------------|\n|实现了 Map 接口|实现 Set 接口|\n|存储键值对|仅存储对象|\n|调用 put()向 map 中添加元素|调用 add()方法向 Set 中添加元素|\n|HashMap 使用键（Key）计算 Hashcode|HashSet 使用成员对象来计算 hashcode 值，对于两个对象来说 hashcode 可能相|\n","slug":"java-Collection","published":1,"updated":"2025-04-22T07:27:29.913Z","_id":"cm9s3f3yv0005bfg49hwx0b2y","comments":1,"layout":"post","photos":[],"content":"<h1>Collection</h1>\n<h1>Collection</h1>\n<p>​<img src=\"/assets/net-img-1596005642573-853dc49e-7632-496d-9221-33e3b7879fea-20221030132325-84wdxkw.jpeg\" alt=\"\">​</p>\n<p>​<img src=\"/assets/net-img-1591690708492-8b43720d-e8dc-4e22-9057-dcc4be2210de-20221030132325-ac88yvu.jpeg\" alt=\"\">​</p>\n<ul>\n<li>Collection 接口的接口 对象的集合\n<ul>\n<li>List 子接口 按进入先后有序保存 可重复\n<ul>\n<li>LinkedList(双向链表) 接口实现类 链表 插入删除 没有同步 线程不安全</li>\n<li>ArrayList(Object 数组) 接口实现类 数组 随机访问 没有同步 线程不安全</li>\n<li>Vector(Object 数组) 接口实现类 数组 同步 线程安全</li>\n</ul>\n</li>\n<li>Set 子接口 不可重复\n<ul>\n<li>HashSet(无序，唯一)</li>\n<li>LinkedHashSet(有序，唯一)<br>\n线程不安全</li>\n<li>TreeSet(有序，唯一)</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Map 接口 键值对的集合\n<ul>\n<li>Hashtable(链表+数组) 接口实现类 同步 线程安全</li>\n<li>HashMap(1.8 之前数组+链表，1.8 之后达到一定长度会转化为红黑树) 接口实现类 没有同步 线程不安全\n<ul>\n<li>LinkedHashMap(在 HashMap 基础上添加一条双向链表)</li>\n</ul>\n</li>\n<li>TreeMap(红黑树(自平衡排序二叉树))</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Iterable\">Iterable</h2>\n<p><strong>Iterator 也是一个接口，它只有三个方法：</strong></p>\n<ul>\n<li>hasNext()</li>\n<li>next()</li>\n<li>remove()</li>\n</ul>\n<h2 id=\"ArrayList-与-LinkedList-区别\">ArrayList 与 LinkedList 区别</h2>\n<ul>\n<li>都不保证线程安全</li>\n<li>ArrayList 底层是数组，LinkedList 底层使用双向链表（1.6 之前为循环链表，1.7 之后取消循环）</li>\n<li>ArrayList 采用数组存储，删除和插入的时间复杂度会受元素位置影响。LinkedList 采用链式存储，对于插入删除不受元素位置影响</li>\n<li>LinkedList 不支持随机访问，ArrayList 支持元素序号访问</li>\n<li>ArrayList 会在列表结尾预留一定空余空间，LinkedList 每个节点所消耗的空间比 ArrayList 大</li>\n</ul>\n<h2 id=\"HashMap-和-Hashtable-区别\">HashMap 和 Hashtable 区别</h2>\n<ul>\n<li>HashMap 是非线程安全的，HashTable 是线程安全的 (如果你要保证线程安全的话就使用 ConcurrentHashMap 吧,效率比 hashtable 高)；</li>\n<li>HashMap 中，null 可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为 null。。但是在 HashTable 中 put 进的键值只要有一个 null，直接抛出 NullPointerException。</li>\n<li>初始化\n<ul>\n<li>① 创建时如果不指定容量初始值： Hashtable 默认的<strong>初始大小为 11</strong>，之后每次扩充，容量变为原来的 2n+1。HashMap 默认的<strong>初始化大小为 16</strong>。之后每次扩充，容量变为原来的 2 倍。</li>\n<li>② 创建时如果给定了容量初始值：Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为 2 的幂次方大小</li>\n</ul>\n</li>\n<li>JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（<strong>将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树</strong>）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。</li>\n</ul>\n<h2 id=\"ConcurrentHashMap-和-Hashtable-的区别\">ConcurrentHashMap 和 Hashtable 的区别</h2>\n<p>ConcurrentHashMap 和 Hashtable 的区别主要体现在实现线程安全的方式上不同。</p>\n<ul>\n<li>底层数据结构： JDK1.7 的 ConcurrentHashMap 底层采用 <strong>分段的数组+链表</strong> 实现，JDK1.8 采用的数据结构跟 HashMap1.8 的结构一样，<strong>数组+链表/红黑二叉树</strong>。Hashtable 和 JDK1.8 之前的 HashMap 的底层数据结构类似都是采用 <strong>数组+链表</strong> 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；</li>\n<li>实现线程安全的方式（重要）：\n<ul>\n<li>① 在 JDK1.7 的时候，ConcurrentHashMap（分段锁） 对整个桶数组进行了分割分段(Segment)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。 到了 JDK1.8 的时候已经摒弃了 Segment 的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作。（JDK1.6 以后 对 synchronized 锁做了很多优化） 整个看起来就像是优化过且线程安全的 HashMap，虽然在 JDK1.8 中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本；</li>\n<li>② Hashtable(同一把锁) :使用 synchronized 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"HashTable：全表锁\">HashTable：全表锁</h2>\n<p><img src=\"/assets/net-img-1591690708909-03b304db-aa14-40fc-954b-2e5812e31b86-20221030132326-7iwfv9t.png\" alt=\"\"></p>\n<h2 id=\"JDK7-的-ConcurrentHashMap：\">JDK7 的 ConcurrentHashMap：</h2>\n<p>首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。</p>\n<p>一个 <code>ConcurrentHashMap</code> 里包含一个 <code>Segment(片段)</code> 数组。<code>Segment</code> 的结构和 <code>HashMap</code> 类似，是一种数组和链表结构，一个 <code>Segment</code> 包含一个 <code>HashEntry</code> 数组，每个 <code>HashEntry</code> 是一个链表结构的元素，每个 <code>Segment</code> 守护着一个 <code>HashEntry</code> 数组里的元素，当对 <code>HashEntry</code> 数组的数据进行修改时，必须首先获得对应的 <code>Segment</code> 的锁。</p>\n<p><img src=\"/assets/net-img-1591690708399-bf1076aa-bdad-4e5f-ae30-261ccda91da5-20221030132327-4fweook.png\" alt=\"\"><a href=\"https://imgchr.com/i/t2J5Kx\">https://imgchr.com/i/t2J5Kx</a></p>\n<h2 id=\"JDK1-8-的-ConcurrentHashMap（TreeBin-红黑二叉树节点-Node-链表节点）\">JDK1.8 的 ConcurrentHashMap（TreeBin: 红黑二叉树节点 Node: 链表节点）`</h2>\n<p>​<strong>​<code>1.8之前ConcurrentHashMap将hashmap数组分段，对于每个段加锁。而在1.8后几乎与hashmap类似，只是更改了put操作，在计算hash值和索引位置后会先判断数组是否正在扩容。若正在扩容则调用扩容辅助函数。没有则在判断是否为空，为空则采用csa方法放入数组，若不为空则使用synchronized锁住该节点，根据链表或红黑树选择插入方法。最后判断长度，为8则开始转换红黑树。</code>​</strong> ​ <code>synchronized </code>​只锁定当前链表或红黑二叉树的首节点，这样只要 hash 不冲突，就不会产生并发，效率又提升 N 倍。</p>\n<p>​<img src=\"/assets/net-img-1591690708309-b6db1e95-1bbf-4140-b612-26fefc8d85b5-20221030132327-6s3ed7l.png\" alt=\"\">​</p>\n<h2 id=\"HashMap-和-HashSet-区别\">HashMap 和 HashSet 区别</h2>\n<p><strong>HashSet 底层就是基于 HashMap 实现的</strong></p>\n<table>\n<thead>\n<tr>\n<th>HashMap</th>\n<th>HashSet</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>实现了 Map 接口</td>\n<td>实现 Set 接口</td>\n</tr>\n<tr>\n<td>存储键值对</td>\n<td>仅存储对象</td>\n</tr>\n<tr>\n<td>调用 put()向 map 中添加元素</td>\n<td>调用 add()方法向 Set 中添加元素</td>\n</tr>\n<tr>\n<td>HashMap 使用键（Key）计算 Hashcode</td>\n<td>HashSet 使用成员对象来计算 hashcode 值，对于两个对象来说 hashcode 可能相</td>\n</tr>\n</tbody>\n</table>\n","excerpt":"","more":"<h1>Collection</h1>\n<h1>Collection</h1>\n<p>​<img src=\"/assets/net-img-1596005642573-853dc49e-7632-496d-9221-33e3b7879fea-20221030132325-84wdxkw.jpeg\" alt=\"\">​</p>\n<p>​<img src=\"/assets/net-img-1591690708492-8b43720d-e8dc-4e22-9057-dcc4be2210de-20221030132325-ac88yvu.jpeg\" alt=\"\">​</p>\n<ul>\n<li>Collection 接口的接口 对象的集合\n<ul>\n<li>List 子接口 按进入先后有序保存 可重复\n<ul>\n<li>LinkedList(双向链表) 接口实现类 链表 插入删除 没有同步 线程不安全</li>\n<li>ArrayList(Object 数组) 接口实现类 数组 随机访问 没有同步 线程不安全</li>\n<li>Vector(Object 数组) 接口实现类 数组 同步 线程安全</li>\n</ul>\n</li>\n<li>Set 子接口 不可重复\n<ul>\n<li>HashSet(无序，唯一)</li>\n<li>LinkedHashSet(有序，唯一)<br>\n线程不安全</li>\n<li>TreeSet(有序，唯一)</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Map 接口 键值对的集合\n<ul>\n<li>Hashtable(链表+数组) 接口实现类 同步 线程安全</li>\n<li>HashMap(1.8 之前数组+链表，1.8 之后达到一定长度会转化为红黑树) 接口实现类 没有同步 线程不安全\n<ul>\n<li>LinkedHashMap(在 HashMap 基础上添加一条双向链表)</li>\n</ul>\n</li>\n<li>TreeMap(红黑树(自平衡排序二叉树))</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Iterable\">Iterable</h2>\n<p><strong>Iterator 也是一个接口，它只有三个方法：</strong></p>\n<ul>\n<li>hasNext()</li>\n<li>next()</li>\n<li>remove()</li>\n</ul>\n<h2 id=\"ArrayList-与-LinkedList-区别\">ArrayList 与 LinkedList 区别</h2>\n<ul>\n<li>都不保证线程安全</li>\n<li>ArrayList 底层是数组，LinkedList 底层使用双向链表（1.6 之前为循环链表，1.7 之后取消循环）</li>\n<li>ArrayList 采用数组存储，删除和插入的时间复杂度会受元素位置影响。LinkedList 采用链式存储，对于插入删除不受元素位置影响</li>\n<li>LinkedList 不支持随机访问，ArrayList 支持元素序号访问</li>\n<li>ArrayList 会在列表结尾预留一定空余空间，LinkedList 每个节点所消耗的空间比 ArrayList 大</li>\n</ul>\n<h2 id=\"HashMap-和-Hashtable-区别\">HashMap 和 Hashtable 区别</h2>\n<ul>\n<li>HashMap 是非线程安全的，HashTable 是线程安全的 (如果你要保证线程安全的话就使用 ConcurrentHashMap 吧,效率比 hashtable 高)；</li>\n<li>HashMap 中，null 可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为 null。。但是在 HashTable 中 put 进的键值只要有一个 null，直接抛出 NullPointerException。</li>\n<li>初始化\n<ul>\n<li>① 创建时如果不指定容量初始值： Hashtable 默认的<strong>初始大小为 11</strong>，之后每次扩充，容量变为原来的 2n+1。HashMap 默认的<strong>初始化大小为 16</strong>。之后每次扩充，容量变为原来的 2 倍。</li>\n<li>② 创建时如果给定了容量初始值：Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为 2 的幂次方大小</li>\n</ul>\n</li>\n<li>JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（<strong>将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树</strong>）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。</li>\n</ul>\n<h2 id=\"ConcurrentHashMap-和-Hashtable-的区别\">ConcurrentHashMap 和 Hashtable 的区别</h2>\n<p>ConcurrentHashMap 和 Hashtable 的区别主要体现在实现线程安全的方式上不同。</p>\n<ul>\n<li>底层数据结构： JDK1.7 的 ConcurrentHashMap 底层采用 <strong>分段的数组+链表</strong> 实现，JDK1.8 采用的数据结构跟 HashMap1.8 的结构一样，<strong>数组+链表/红黑二叉树</strong>。Hashtable 和 JDK1.8 之前的 HashMap 的底层数据结构类似都是采用 <strong>数组+链表</strong> 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；</li>\n<li>实现线程安全的方式（重要）：\n<ul>\n<li>① 在 JDK1.7 的时候，ConcurrentHashMap（分段锁） 对整个桶数组进行了分割分段(Segment)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。 到了 JDK1.8 的时候已经摒弃了 Segment 的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作。（JDK1.6 以后 对 synchronized 锁做了很多优化） 整个看起来就像是优化过且线程安全的 HashMap，虽然在 JDK1.8 中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本；</li>\n<li>② Hashtable(同一把锁) :使用 synchronized 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"HashTable：全表锁\">HashTable：全表锁</h2>\n<p><img src=\"/assets/net-img-1591690708909-03b304db-aa14-40fc-954b-2e5812e31b86-20221030132326-7iwfv9t.png\" alt=\"\"></p>\n<h2 id=\"JDK7-的-ConcurrentHashMap：\">JDK7 的 ConcurrentHashMap：</h2>\n<p>首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。</p>\n<p>一个 <code>ConcurrentHashMap</code> 里包含一个 <code>Segment(片段)</code> 数组。<code>Segment</code> 的结构和 <code>HashMap</code> 类似，是一种数组和链表结构，一个 <code>Segment</code> 包含一个 <code>HashEntry</code> 数组，每个 <code>HashEntry</code> 是一个链表结构的元素，每个 <code>Segment</code> 守护着一个 <code>HashEntry</code> 数组里的元素，当对 <code>HashEntry</code> 数组的数据进行修改时，必须首先获得对应的 <code>Segment</code> 的锁。</p>\n<p><img src=\"/assets/net-img-1591690708399-bf1076aa-bdad-4e5f-ae30-261ccda91da5-20221030132327-4fweook.png\" alt=\"\"><a href=\"https://imgchr.com/i/t2J5Kx\">https://imgchr.com/i/t2J5Kx</a></p>\n<h2 id=\"JDK1-8-的-ConcurrentHashMap（TreeBin-红黑二叉树节点-Node-链表节点）\">JDK1.8 的 ConcurrentHashMap（TreeBin: 红黑二叉树节点 Node: 链表节点）`</h2>\n<p>​<strong>​<code>1.8之前ConcurrentHashMap将hashmap数组分段，对于每个段加锁。而在1.8后几乎与hashmap类似，只是更改了put操作，在计算hash值和索引位置后会先判断数组是否正在扩容。若正在扩容则调用扩容辅助函数。没有则在判断是否为空，为空则采用csa方法放入数组，若不为空则使用synchronized锁住该节点，根据链表或红黑树选择插入方法。最后判断长度，为8则开始转换红黑树。</code>​</strong> ​ <code>synchronized </code>​只锁定当前链表或红黑二叉树的首节点，这样只要 hash 不冲突，就不会产生并发，效率又提升 N 倍。</p>\n<p>​<img src=\"/assets/net-img-1591690708309-b6db1e95-1bbf-4140-b612-26fefc8d85b5-20221030132327-6s3ed7l.png\" alt=\"\">​</p>\n<h2 id=\"HashMap-和-HashSet-区别\">HashMap 和 HashSet 区别</h2>\n<p><strong>HashSet 底层就是基于 HashMap 实现的</strong></p>\n<table>\n<thead>\n<tr>\n<th>HashMap</th>\n<th>HashSet</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>实现了 Map 接口</td>\n<td>实现 Set 接口</td>\n</tr>\n<tr>\n<td>存储键值对</td>\n<td>仅存储对象</td>\n</tr>\n<tr>\n<td>调用 put()向 map 中添加元素</td>\n<td>调用 add()方法向 Set 中添加元素</td>\n</tr>\n<tr>\n<td>HashMap 使用键（Key）计算 Hashcode</td>\n<td>HashSet 使用成员对象来计算 hashcode 值，对于两个对象来说 hashcode 可能相</td>\n</tr>\n</tbody>\n</table>\n"},{"title":"JVM","date":"2022-10-30T05:39:04.000Z","lastmod":"2023-11-26T06:54:43.000Z","_content":"\n# JVM\n\n## GC评估标准\n\n### 吞吐量\n\n> CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量 = 运行用户代码时间 /（运行用户代码时间 + 垃圾收集时间）。\n\n* 吞吐量就是比如：虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。\n\n* 这种情况下，应用程序能容忍较高的暂停时间。因此，高吞吐量的应用程序有更长的时间基准，快速响应是不必考虑的。\n\n* 吞吐量优先，意味着在单位时间内，STW的时间最短：0.2 + 0.2 = 0.4\n\n### 暂停时间\n\n> 指一个时间段内应用程序线程暂停，让GC线程执行的状态\n\n* GC期间100毫秒的暂停时间意味着在这100毫秒期间内没有应用程序线程是活动的。\n\n* 暂停时间优先，意味着尽可能让单次STW的时间最短\n\n## 为何永久代被元空间替代\n\n- 永久代有固定上限，无法进行调整，而元空间直接使用内存，受本机可用内存限制。\n- 元空间里存放的是类的元数据，加载多少类的元数据由系统的实际可用空间来控制，可以加载更多的类\n- JDK8 合并 HotSpot 和 JRockit 代码时，jrockit 不存在永久代，所以合并后没必要设置一个永生代位置\n\n## 双亲委托优点和缺点\n\n　　优点：\n\n* 避免类重复加载，确保全局唯一\n* 保护程序，防止核心api被修改\n\n　　缺点：\n\n* 检查类是否加载的委托过程是单向的，顶层的ClassLoader无法访问底层的ClassLoader所加载的类。\n\n## 双亲委派机制的破坏\n\n### 线程上下文类加载器\n\n> 通过java.lang.Thread类的setContextClassLoader()方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。\n\n​![image](/assets/image-20231117164621-qjdsktw.png)​\n\n### 热部署（热替换）\n\n> 服务不能中断，修改必须立即表现正在运行的系统之中\n\n## 类、类的加载器、类的实例之间的引用关系\n\n　　在类加载器的内部实现中，用一个Java集合来存放所加载类的引用。另一方面，一个Class对象总是会引用它的类加载器，调用Class对象的getClassLoader()方法，就能获得它的类加载器。由此可见，代表某个类的Class实例与其类的加载器之间为双向关联关系。\n\n　　一个类的实例总是引用代表这个类的Class对象。在Object类中定义了getClass()方法，这个方法返回代表对象所属类的Class对象的引用。此外，所有的Java类都有一个静态属性class，它引用代表这个类的Class对象。\n\n​![图像](/assets/image-20231119124615-vxa33dm.png)​\n\n## to区域被填满了，to区中的有的对象年龄还没被复制15次，也会被移动到年老代中吗？\n\n　　Minor GC会一直重复`from to`​的过程,直到“To”区被填满,“To”区被填满之后,会将所有对象移动到年老代中。默认情况下,如果对象年龄达到15岁,就会移动到老年代中。\n","source":"_posts/java/JVM.md","raw":"---\ntitle: JVM\ndate: 2022-10-30T13:39:04Z\nlastmod: 2023-11-26T14:54:43Z\n---\n\n# JVM\n\n## GC评估标准\n\n### 吞吐量\n\n> CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量 = 运行用户代码时间 /（运行用户代码时间 + 垃圾收集时间）。\n\n* 吞吐量就是比如：虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。\n\n* 这种情况下，应用程序能容忍较高的暂停时间。因此，高吞吐量的应用程序有更长的时间基准，快速响应是不必考虑的。\n\n* 吞吐量优先，意味着在单位时间内，STW的时间最短：0.2 + 0.2 = 0.4\n\n### 暂停时间\n\n> 指一个时间段内应用程序线程暂停，让GC线程执行的状态\n\n* GC期间100毫秒的暂停时间意味着在这100毫秒期间内没有应用程序线程是活动的。\n\n* 暂停时间优先，意味着尽可能让单次STW的时间最短\n\n## 为何永久代被元空间替代\n\n- 永久代有固定上限，无法进行调整，而元空间直接使用内存，受本机可用内存限制。\n- 元空间里存放的是类的元数据，加载多少类的元数据由系统的实际可用空间来控制，可以加载更多的类\n- JDK8 合并 HotSpot 和 JRockit 代码时，jrockit 不存在永久代，所以合并后没必要设置一个永生代位置\n\n## 双亲委托优点和缺点\n\n　　优点：\n\n* 避免类重复加载，确保全局唯一\n* 保护程序，防止核心api被修改\n\n　　缺点：\n\n* 检查类是否加载的委托过程是单向的，顶层的ClassLoader无法访问底层的ClassLoader所加载的类。\n\n## 双亲委派机制的破坏\n\n### 线程上下文类加载器\n\n> 通过java.lang.Thread类的setContextClassLoader()方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。\n\n​![image](/assets/image-20231117164621-qjdsktw.png)​\n\n### 热部署（热替换）\n\n> 服务不能中断，修改必须立即表现正在运行的系统之中\n\n## 类、类的加载器、类的实例之间的引用关系\n\n　　在类加载器的内部实现中，用一个Java集合来存放所加载类的引用。另一方面，一个Class对象总是会引用它的类加载器，调用Class对象的getClassLoader()方法，就能获得它的类加载器。由此可见，代表某个类的Class实例与其类的加载器之间为双向关联关系。\n\n　　一个类的实例总是引用代表这个类的Class对象。在Object类中定义了getClass()方法，这个方法返回代表对象所属类的Class对象的引用。此外，所有的Java类都有一个静态属性class，它引用代表这个类的Class对象。\n\n​![图像](/assets/image-20231119124615-vxa33dm.png)​\n\n## to区域被填满了，to区中的有的对象年龄还没被复制15次，也会被移动到年老代中吗？\n\n　　Minor GC会一直重复`from to`​的过程,直到“To”区被填满,“To”区被填满之后,会将所有对象移动到年老代中。默认情况下,如果对象年龄达到15岁,就会移动到老年代中。\n","slug":"java-JVM","published":1,"updated":"2025-04-22T07:27:29.941Z","_id":"cm9s3f3yv0006bfg45rn42dzz","comments":1,"layout":"post","photos":[],"content":"<h1>JVM</h1>\n<h2 id=\"GC评估标准\">GC评估标准</h2>\n<h3 id=\"吞吐量\">吞吐量</h3>\n<blockquote>\n<p>CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量 = 运行用户代码时间 /（运行用户代码时间 + 垃圾收集时间）。</p>\n</blockquote>\n<ul>\n<li>\n<p>吞吐量就是比如：虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。</p>\n</li>\n<li>\n<p>这种情况下，应用程序能容忍较高的暂停时间。因此，高吞吐量的应用程序有更长的时间基准，快速响应是不必考虑的。</p>\n</li>\n<li>\n<p>吞吐量优先，意味着在单位时间内，STW的时间最短：0.2 + 0.2 = 0.4</p>\n</li>\n</ul>\n<h3 id=\"暂停时间\">暂停时间</h3>\n<blockquote>\n<p>指一个时间段内应用程序线程暂停，让GC线程执行的状态</p>\n</blockquote>\n<ul>\n<li>\n<p>GC期间100毫秒的暂停时间意味着在这100毫秒期间内没有应用程序线程是活动的。</p>\n</li>\n<li>\n<p>暂停时间优先，意味着尽可能让单次STW的时间最短</p>\n</li>\n</ul>\n<h2 id=\"为何永久代被元空间替代\">为何永久代被元空间替代</h2>\n<ul>\n<li>永久代有固定上限，无法进行调整，而元空间直接使用内存，受本机可用内存限制。</li>\n<li>元空间里存放的是类的元数据，加载多少类的元数据由系统的实际可用空间来控制，可以加载更多的类</li>\n<li>JDK8 合并 HotSpot 和 JRockit 代码时，jrockit 不存在永久代，所以合并后没必要设置一个永生代位置</li>\n</ul>\n<h2 id=\"双亲委托优点和缺点\">双亲委托优点和缺点</h2>\n<p>优点：</p>\n<ul>\n<li>避免类重复加载，确保全局唯一</li>\n<li>保护程序，防止核心api被修改</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>检查类是否加载的委托过程是单向的，顶层的ClassLoader无法访问底层的ClassLoader所加载的类。</li>\n</ul>\n<h2 id=\"双亲委派机制的破坏\">双亲委派机制的破坏</h2>\n<h3 id=\"线程上下文类加载器\">线程上下文类加载器</h3>\n<blockquote>\n<p>通过java.lang.Thread类的setContextClassLoader()方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。</p>\n</blockquote>\n<p>​<img src=\"/assets/image-20231117164621-qjdsktw.png\" alt=\"image\">​</p>\n<h3 id=\"热部署（热替换）\">热部署（热替换）</h3>\n<blockquote>\n<p>服务不能中断，修改必须立即表现正在运行的系统之中</p>\n</blockquote>\n<h2 id=\"类、类的加载器、类的实例之间的引用关系\">类、类的加载器、类的实例之间的引用关系</h2>\n<p>在类加载器的内部实现中，用一个Java集合来存放所加载类的引用。另一方面，一个Class对象总是会引用它的类加载器，调用Class对象的getClassLoader()方法，就能获得它的类加载器。由此可见，代表某个类的Class实例与其类的加载器之间为双向关联关系。</p>\n<p>一个类的实例总是引用代表这个类的Class对象。在Object类中定义了getClass()方法，这个方法返回代表对象所属类的Class对象的引用。此外，所有的Java类都有一个静态属性class，它引用代表这个类的Class对象。</p>\n<p>​<img src=\"/assets/image-20231119124615-vxa33dm.png\" alt=\"图像\">​</p>\n<h2 id=\"to区域被填满了，to区中的有的对象年龄还没被复制15次，也会被移动到年老代中吗？\">to区域被填满了，to区中的有的对象年龄还没被复制15次，也会被移动到年老代中吗？</h2>\n<p>Minor GC会一直重复<code>from to</code>​的过程,直到“To”区被填满,“To”区被填满之后,会将所有对象移动到年老代中。默认情况下,如果对象年龄达到15岁,就会移动到老年代中。</p>\n","excerpt":"","more":"<h1>JVM</h1>\n<h2 id=\"GC评估标准\">GC评估标准</h2>\n<h3 id=\"吞吐量\">吞吐量</h3>\n<blockquote>\n<p>CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量 = 运行用户代码时间 /（运行用户代码时间 + 垃圾收集时间）。</p>\n</blockquote>\n<ul>\n<li>\n<p>吞吐量就是比如：虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。</p>\n</li>\n<li>\n<p>这种情况下，应用程序能容忍较高的暂停时间。因此，高吞吐量的应用程序有更长的时间基准，快速响应是不必考虑的。</p>\n</li>\n<li>\n<p>吞吐量优先，意味着在单位时间内，STW的时间最短：0.2 + 0.2 = 0.4</p>\n</li>\n</ul>\n<h3 id=\"暂停时间\">暂停时间</h3>\n<blockquote>\n<p>指一个时间段内应用程序线程暂停，让GC线程执行的状态</p>\n</blockquote>\n<ul>\n<li>\n<p>GC期间100毫秒的暂停时间意味着在这100毫秒期间内没有应用程序线程是活动的。</p>\n</li>\n<li>\n<p>暂停时间优先，意味着尽可能让单次STW的时间最短</p>\n</li>\n</ul>\n<h2 id=\"为何永久代被元空间替代\">为何永久代被元空间替代</h2>\n<ul>\n<li>永久代有固定上限，无法进行调整，而元空间直接使用内存，受本机可用内存限制。</li>\n<li>元空间里存放的是类的元数据，加载多少类的元数据由系统的实际可用空间来控制，可以加载更多的类</li>\n<li>JDK8 合并 HotSpot 和 JRockit 代码时，jrockit 不存在永久代，所以合并后没必要设置一个永生代位置</li>\n</ul>\n<h2 id=\"双亲委托优点和缺点\">双亲委托优点和缺点</h2>\n<p>优点：</p>\n<ul>\n<li>避免类重复加载，确保全局唯一</li>\n<li>保护程序，防止核心api被修改</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>检查类是否加载的委托过程是单向的，顶层的ClassLoader无法访问底层的ClassLoader所加载的类。</li>\n</ul>\n<h2 id=\"双亲委派机制的破坏\">双亲委派机制的破坏</h2>\n<h3 id=\"线程上下文类加载器\">线程上下文类加载器</h3>\n<blockquote>\n<p>通过java.lang.Thread类的setContextClassLoader()方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。</p>\n</blockquote>\n<p>​<img src=\"/assets/image-20231117164621-qjdsktw.png\" alt=\"image\">​</p>\n<h3 id=\"热部署（热替换）\">热部署（热替换）</h3>\n<blockquote>\n<p>服务不能中断，修改必须立即表现正在运行的系统之中</p>\n</blockquote>\n<h2 id=\"类、类的加载器、类的实例之间的引用关系\">类、类的加载器、类的实例之间的引用关系</h2>\n<p>在类加载器的内部实现中，用一个Java集合来存放所加载类的引用。另一方面，一个Class对象总是会引用它的类加载器，调用Class对象的getClassLoader()方法，就能获得它的类加载器。由此可见，代表某个类的Class实例与其类的加载器之间为双向关联关系。</p>\n<p>一个类的实例总是引用代表这个类的Class对象。在Object类中定义了getClass()方法，这个方法返回代表对象所属类的Class对象的引用。此外，所有的Java类都有一个静态属性class，它引用代表这个类的Class对象。</p>\n<p>​<img src=\"/assets/image-20231119124615-vxa33dm.png\" alt=\"图像\">​</p>\n<h2 id=\"to区域被填满了，to区中的有的对象年龄还没被复制15次，也会被移动到年老代中吗？\">to区域被填满了，to区中的有的对象年龄还没被复制15次，也会被移动到年老代中吗？</h2>\n<p>Minor GC会一直重复<code>from to</code>​的过程,直到“To”区被填满,“To”区被填满之后,会将所有对象移动到年老代中。默认情况下,如果对象年龄达到15岁,就会移动到老年代中。</p>\n"},{"title":"JavaWeb","date":"2022-10-30T05:27:30.000Z","lastmod":"2022-10-30T05:27:36.000Z","_content":"\n# JavaWeb\n\n　　‍\n\n　　‍\n","source":"_posts/java/JavaWeb.md","raw":"---\ntitle: JavaWeb\ndate: 2022-10-30T13:27:30Z\nlastmod: 2022-10-30T13:27:36Z\n---\n\n# JavaWeb\n\n　　‍\n\n　　‍\n","slug":"java-JavaWeb","published":1,"updated":"2025-04-22T02:21:59.463Z","comments":1,"layout":"post","photos":[],"_id":"cm9s3f3yx0007bfg47uroaeyi","content":"<h1>JavaWeb</h1>\n<p>‍</p>\n<p>‍</p>\n","excerpt":"","more":"<h1>JavaWeb</h1>\n<p>‍</p>\n<p>‍</p>\n"},{"title":"thread","date":"2023-05-14T14:53:28.000Z","lastmod":"2023-08-25T08:32:48.000Z","_content":"\n# thread\n\n## 概述\n\n### 并发与并行\n\n　　并行：指两个或多个事件在同一时刻发生（同时发生）。  \n并发：指两个或多个事件在同一个时间段内发生。  \n​![1-1.png](/assets/net-img-1582875290415-c052f229-8c31-4560-acef-300acae2409b-20221030135515-tme9bzx.png)​\n\n### 进程、线程\n\n> 进程是正在运行的程序的实例。  \n> 进程是线程的容器，即一个进程中可以开启多个线程。\n\n> 线程是进程内部的一个独立执行单元；  \n> 一个进程可以同时并发运行多个线程；\n\n## 线程生命周期\n\n　　​![](/assets/net-img-1596249786159-92610d33-5cbb-4d46-b7a5-6f1c8d3d1d92-20221030135516-9i6hh1r.jpeg)  1. 新建\n\n* new 关键字创建了一个线程之后，该线程就处于新建状态\n* JVM 为线程分配内存，初始化成员变量值\n\n2. 就绪\n\n    * 当线程对象调用了 start()方法之后，该线程处于就绪状态\n    * JVM 为线程创建方法栈和程序计数器，等待线程调度器调度\n3. 运行\n\n    * 就绪状态的线程获得 CPU 资源，开始运行 run()方法，该线程进入运行状态\n4. 阻塞\n\n    * 线程在等待进入临界区\n5. 无限期等待\n\n    * 处于这种状态的线程不会被分配CPU执行时间，它们要等待被显式地唤醒，否则会处于无限期等待的状态。\n6. 限期等待\n\n    * 处于这种状态的线程不会被分配CPU执行时间，不过无须无限期等待被其他线程显示地唤醒，在达到一定时间后它们会自动唤醒。\n7. 死亡\n\n    * 线程会以如下 3 种方式结束，结束后就处于死亡状态：\n    * run()或 call()方法执行完成，线程正常结束。\n    * 线程抛出一个未捕获的 Exception 或 Error。>调用该线程 stop()方法来结束该线程，该方法容易导致死锁，不推荐使用。\n\n## 死锁\n\n　　多个线程因竞争资源而造成的一种僵局(互相等待)\n\n### 死锁产生必要条件\n\n1. 互斥条件  \n    在一段时间内某资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待\n2. 不可剥夺条件  \n    进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放（只能是主动释放)。\n3. 请求与保持  \n    进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。\n4. 循环等待条件  \n    存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被 链中下一个进程所请求。即存在一个处于等待状态的进程集合{Pl, P2, …, pn}，其中 Pi 等 待的资源被 P(i+1)占有（i=0, 1, …, n-1)，Pn 等待的资源被 P0 占有，如图所示\n\n​![1-5.png](/assets/net-img-1582875326094-cb5a96e7-e4c2-421d-83cf-216ca4f7f024-20221030135516-5igfhr6.png)![1-4.png](/assets/net-img-1582875326657-55738037-28bf-4de9-925a-f08034e0c722-20221030135516-j4ktjne.png)​\n\n### 死锁处理\n\n### 死锁预防\n\n1. 破坏“互斥”条件  \n    ​`互斥`​条件是无法破坏的。因此，在死锁预防里主要是破坏其他几个必要条件，而不去涉及破坏`互斥`​条件。\n2. 破坏“占有并等待”条件  \n    系统中不允许进程在已获得某种资源的情况下，申请其他资源。即要想出一个办法，阻止进程在持有资源的同时申请其他资源\n\n    * 方法一：一次性分配资源，即创建进程时，要求它申请所需的全部资源，系统或满足其所有要求，或什么也不给它。\n    * 方法二：要求每个进程提出新的资源申请前，释放它所占有的资源。这样，一个进程在需要资源 S 时，须先把它先前占有的资源 R 释放掉，然后才能提出对 S 的申请，即使它可能很快又要用到资源 R。\n3. 破坏“不可抢占”条件  \n    破坏“不可抢占”条件就是允许对资源实行抢夺。\n\n    * 方法一：如果占有某些资源的一个进程进行进一步资源请求被拒绝，则该进程必须释放它最初占有的资源，如果有必要，可再次请求这些资源和另外的资源。\n    * 方法二：如果一个进程请求当前被另一个进程占有的一个资源，则操作系统可以抢占另一个进程，要求它释放资源。只有在任意两个进程的优先级都不相同的条件下，方法二才能预防死锁。\n4. 破坏“循环等待”条件  \n    破坏“循环等待”条件的一种方法，是将系统中的所有资源统一编号，进程可在任何时刻提出资源申请，但所有申请必须按照资源的编号顺序（升序）提出。这样做就能保证系统不出现死锁。\n\n### 死锁避免\n\n1. 有序资源分配法  \n    算法\n\n```\n必须为所有资源统一编号，\n同类资源必须一次申请完，\n不同类资源必须按顺序申请\n```\n\n2. 银行家算法  \n    银行家算法的基本思想是分配资源之前，判断系统是否是安全的；若是，才分配。它是最具有代表性的避免死锁的算法。  \n    设进程 i 提出请求 REQUEST [i]，则银行家算法按如下规则进行判断。![1-6.png](/assets/net-img-1582875381841-0104c814-acd3-4ef3-a3bd-f5331d9a06bc-20221030135516-0716ftg.png)​\n\n```\n1. 如果REQUEST [i]<= NEED[i，j]，则转（2)；否则，出错。\n2 .如果REQUEST [i]<= AVAILABLE[i]，则转（3)；否则，等待。\n3 .系统试探分配资源，修改相关数据：\n   AVAILABLE[i]-=REQUEST[i];//可用资源数-请求资源数\n   ALLOCATION[i]+=REQUEST[i];//已分配资源数+请求资源数\n   NEED[i]-=REQUEST[i];//需要资源数-请求资源数\n系统执行安全性检查，如安全，则分配成立；否则试探险性分配作废，系统恢复原状，进程等待\n```\n\n3. 顺序加锁  \n    如果能确保所有的线程都是按照相同的顺序获得锁，那么死锁就不会发生,但是，这种方式需要事先知道所有可能会用到的锁，但总有些时候是无法预知的，所以该种方式只适合特定场景\n4. 限时加锁  \n    限时加锁是线程在尝试获取锁的时候加一个超时时间，若超过这个时间则放弃对该锁请求，并回退并释放所有已经获得的锁，然后等待一段随机的时间再重试  \n    这种方式有两个缺点：\n\n```\n1) 当线程数量少时，该种方式可避免死锁，但当线程数量过多，这些线程的加锁时限相同的概率就高很多，可能会导致超时后重试的死循环。\n2) Java中不能对synchronized同步块设置超时时间。你需要创建一个自定义锁，或使用Java5中java.util.concurrent包下的工具\n```\n\n### 死锁检测\n\n　　**死锁检测算法**  \n​![1-7.png](/assets/net-img-1582875390665-923c52b9-52ce-4e6f-9cee-763046546af3-20221030135517-j4zeqi7.png)​\n\n```\nE 是现有资源向量（existing resource vector），代码每种已存在资源的总数\nA 是可用资源向量（available resource vector），那么Ai表示当前可供使用的资源数（即没有被分配的资源）\nC 是当前分配矩阵（current allocation matrix），C的第i行代表Pi当前所持有的每一种类型资源的资源数\nR 是请求矩阵（request matrix），R的每一行代表P所需要的资源的数量\n```\n\n　　**死锁检测步骤：**\n\n```\n寻找一个没有结束标记的进程Pi，对于它而言R矩阵的第i行向量小于或等于A。\n如果找到了这样一个进程，执行该进程，然后将C矩阵的第i行向量加到A中，标记该进程，并转到第1步\n如果没有这样的进程，那么算法终止\n算法结束时，所有没有标记过的进程都是死锁进程\n```\n\n### 死锁恢复\n\n* 资源剥夺法  \n  剥夺陷于死锁的进程所占用的资源，但并不撤销此进程，直至死锁解除。\n* 进程回退法  \n  根据系统保存的检查点让所有的进程回退，直到足以解除死锁，这种措施要求系统建立保存检查点、回退及重启机制。\n* 进程撤销法\n\n  * 撤销陷入死锁的所有进程，解除死锁，继续运行。\n  * 逐个撤销陷入死锁的进程，回收其资源并重新分配，直至死锁解除。\n\n## Java创建线程\n\n* 继承 Thread 类 extends Thread\n* 实现 Runnable 接口 implements Runnable\n* 实现 Callable 接口 implements Callable\n\n  * 实现 Callable 接口。 相较于实现 Runnable 接口的方式，方法可以有返回值，并且可以抛出异常。\n  * 执行 Callable 方式，需要 FutureTask 实现类的支持，用于接收运算结果。 FutureTask 是 Future 接口的实现类，线程启动 `new Thread(objectFutureTask1).start()`​\n\n> Future\n\n* cancel()方法用来取消任务，如果取消任务成功则返回true，如果取消任务失败则返回false。\n\n  * 参数mayInterruptIfRunning表示是否允许取消正在执行却没有执行完毕的任务，如果设置true，则表示可以取消正在执行过程中的任务。\n  * 如果任务已经完成，则无论mayInterruptIfRunning为true还是false，此方法肯定返回false，即如果取消已经完成的任务会返回false\n  * 如果任务正在执行，若mayInterruptIfRunning设置为true，则返回true，若mayInterruptIfRunning设置为false，则返回false；如果任务还没有执行，则无论mayInterruptIfRunning为true还是false，肯定返回true。\n* isCancelled()方法表示任务是否被取消成功，如果在任务正常完成前被取消成功，则返回 true。\n* isDone()方法表示任务是否已经完成，若任务完成，则返回true；\n* get()方法用来获取执行结果，这个方法会产生阻塞，会一直等到任务执行完毕才返回；\n* get(long timeout, TimeUnit unit)用来获取执行结果，如果在指定时间内，还没获取到结果，就直接返回null。\n\n> FutureTask\n>\n> 实现了RunnableFuture接口，而RunnableFuture接口继承了Runnable与Future接口，所以它既可以作为Runnable被线程中执行，又可以作为callable获得返回值。\n\n* 适合应用场景\n\n  * 执行多任务计算\n  * 在高并发环境下确保任务只执行一次\n\n### 小结\n\n* 实现接口和继承 Thread 类比较\n\n> 接口更适合多个相同的程序代码的线程去共享同一个资源。  \n> 接口可以避免 java 中的单继承的局限性。  \n> 接口代码可以被多个线程共享，代码和线程独立。  \n> 线程池只能放入实现 Runable 或 Callable 接口的线程，不能直接放入继承 Thread 的类。  \n> 扩充：在 java 中，每次程序运行至少启动 2 个线程。一个是 main 线程，一个是垃圾收集线程。\n\n* Runnable 和 Callable 接口比较\n\n  * 相同点：\n\n> 两者都是接口；  \n> 两者都可用来编写多线程程序；  \n> 两者都需要调用 Thread.start()启动线程；\n\n* 不同点：\n\n> 实现 Callable 接口的线程能返回执行结果；而实现 Runnable 接口的线程不能返回结果；  \n> Callable 接口的 call()方法允许抛出异常；而 Runnable 接口的 run()方法的不允许抛异常；  \n> 实现 Callable 接口的线程可以调用 Future.cancel 取消执行  ，而实现 Runnable 接口的线程不能\n\n* 注意点：\n\n> Callable 接口支持返回执行结果，此时需要调用 FutureTask.get()方法实现，此方法会阻塞主线程直到获取‘将来’结果；当不调用此方法时，主线程不会阻塞！\n>\n> 实现Runnable接口,在某些情况下可以提高性能，使用继承 Thread 类方式，每次执行一次任务，都需要新建一个独立的线程，执行完任务后线程走到生命周期的尽头被销毁，如果还想执行这个任务，就必须再新建一个继承了 Thread 类的类，如果此时执行的内容比较少，比如只是在 run() 方法里简单打印一行文字，那么它所带来的开销并不大，相比于整个线程从开始创建到执行完毕被销毁，这一系列的操作比 run() 方法打印文字本身带来的开销要大得多，相当于捡了芝麻丢了西瓜，得不偿失。如果我们使用实现 Runnable 接口的方式，就可以把任务直接传入线程池，使用一些固定的线程来完成任务，不需要每次新建销毁线程，大大降低了性能开销。\n","source":"_posts/java/thread.md","raw":"---\ntitle: thread\ndate: 2023-05-14T22:53:28Z\nlastmod: 2023-08-25T16:32:48Z\n---\n\n# thread\n\n## 概述\n\n### 并发与并行\n\n　　并行：指两个或多个事件在同一时刻发生（同时发生）。  \n并发：指两个或多个事件在同一个时间段内发生。  \n​![1-1.png](/assets/net-img-1582875290415-c052f229-8c31-4560-acef-300acae2409b-20221030135515-tme9bzx.png)​\n\n### 进程、线程\n\n> 进程是正在运行的程序的实例。  \n> 进程是线程的容器，即一个进程中可以开启多个线程。\n\n> 线程是进程内部的一个独立执行单元；  \n> 一个进程可以同时并发运行多个线程；\n\n## 线程生命周期\n\n　　​![](/assets/net-img-1596249786159-92610d33-5cbb-4d46-b7a5-6f1c8d3d1d92-20221030135516-9i6hh1r.jpeg)  1. 新建\n\n* new 关键字创建了一个线程之后，该线程就处于新建状态\n* JVM 为线程分配内存，初始化成员变量值\n\n2. 就绪\n\n    * 当线程对象调用了 start()方法之后，该线程处于就绪状态\n    * JVM 为线程创建方法栈和程序计数器，等待线程调度器调度\n3. 运行\n\n    * 就绪状态的线程获得 CPU 资源，开始运行 run()方法，该线程进入运行状态\n4. 阻塞\n\n    * 线程在等待进入临界区\n5. 无限期等待\n\n    * 处于这种状态的线程不会被分配CPU执行时间，它们要等待被显式地唤醒，否则会处于无限期等待的状态。\n6. 限期等待\n\n    * 处于这种状态的线程不会被分配CPU执行时间，不过无须无限期等待被其他线程显示地唤醒，在达到一定时间后它们会自动唤醒。\n7. 死亡\n\n    * 线程会以如下 3 种方式结束，结束后就处于死亡状态：\n    * run()或 call()方法执行完成，线程正常结束。\n    * 线程抛出一个未捕获的 Exception 或 Error。>调用该线程 stop()方法来结束该线程，该方法容易导致死锁，不推荐使用。\n\n## 死锁\n\n　　多个线程因竞争资源而造成的一种僵局(互相等待)\n\n### 死锁产生必要条件\n\n1. 互斥条件  \n    在一段时间内某资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待\n2. 不可剥夺条件  \n    进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放（只能是主动释放)。\n3. 请求与保持  \n    进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。\n4. 循环等待条件  \n    存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被 链中下一个进程所请求。即存在一个处于等待状态的进程集合{Pl, P2, …, pn}，其中 Pi 等 待的资源被 P(i+1)占有（i=0, 1, …, n-1)，Pn 等待的资源被 P0 占有，如图所示\n\n​![1-5.png](/assets/net-img-1582875326094-cb5a96e7-e4c2-421d-83cf-216ca4f7f024-20221030135516-5igfhr6.png)![1-4.png](/assets/net-img-1582875326657-55738037-28bf-4de9-925a-f08034e0c722-20221030135516-j4ktjne.png)​\n\n### 死锁处理\n\n### 死锁预防\n\n1. 破坏“互斥”条件  \n    ​`互斥`​条件是无法破坏的。因此，在死锁预防里主要是破坏其他几个必要条件，而不去涉及破坏`互斥`​条件。\n2. 破坏“占有并等待”条件  \n    系统中不允许进程在已获得某种资源的情况下，申请其他资源。即要想出一个办法，阻止进程在持有资源的同时申请其他资源\n\n    * 方法一：一次性分配资源，即创建进程时，要求它申请所需的全部资源，系统或满足其所有要求，或什么也不给它。\n    * 方法二：要求每个进程提出新的资源申请前，释放它所占有的资源。这样，一个进程在需要资源 S 时，须先把它先前占有的资源 R 释放掉，然后才能提出对 S 的申请，即使它可能很快又要用到资源 R。\n3. 破坏“不可抢占”条件  \n    破坏“不可抢占”条件就是允许对资源实行抢夺。\n\n    * 方法一：如果占有某些资源的一个进程进行进一步资源请求被拒绝，则该进程必须释放它最初占有的资源，如果有必要，可再次请求这些资源和另外的资源。\n    * 方法二：如果一个进程请求当前被另一个进程占有的一个资源，则操作系统可以抢占另一个进程，要求它释放资源。只有在任意两个进程的优先级都不相同的条件下，方法二才能预防死锁。\n4. 破坏“循环等待”条件  \n    破坏“循环等待”条件的一种方法，是将系统中的所有资源统一编号，进程可在任何时刻提出资源申请，但所有申请必须按照资源的编号顺序（升序）提出。这样做就能保证系统不出现死锁。\n\n### 死锁避免\n\n1. 有序资源分配法  \n    算法\n\n```\n必须为所有资源统一编号，\n同类资源必须一次申请完，\n不同类资源必须按顺序申请\n```\n\n2. 银行家算法  \n    银行家算法的基本思想是分配资源之前，判断系统是否是安全的；若是，才分配。它是最具有代表性的避免死锁的算法。  \n    设进程 i 提出请求 REQUEST [i]，则银行家算法按如下规则进行判断。![1-6.png](/assets/net-img-1582875381841-0104c814-acd3-4ef3-a3bd-f5331d9a06bc-20221030135516-0716ftg.png)​\n\n```\n1. 如果REQUEST [i]<= NEED[i，j]，则转（2)；否则，出错。\n2 .如果REQUEST [i]<= AVAILABLE[i]，则转（3)；否则，等待。\n3 .系统试探分配资源，修改相关数据：\n   AVAILABLE[i]-=REQUEST[i];//可用资源数-请求资源数\n   ALLOCATION[i]+=REQUEST[i];//已分配资源数+请求资源数\n   NEED[i]-=REQUEST[i];//需要资源数-请求资源数\n系统执行安全性检查，如安全，则分配成立；否则试探险性分配作废，系统恢复原状，进程等待\n```\n\n3. 顺序加锁  \n    如果能确保所有的线程都是按照相同的顺序获得锁，那么死锁就不会发生,但是，这种方式需要事先知道所有可能会用到的锁，但总有些时候是无法预知的，所以该种方式只适合特定场景\n4. 限时加锁  \n    限时加锁是线程在尝试获取锁的时候加一个超时时间，若超过这个时间则放弃对该锁请求，并回退并释放所有已经获得的锁，然后等待一段随机的时间再重试  \n    这种方式有两个缺点：\n\n```\n1) 当线程数量少时，该种方式可避免死锁，但当线程数量过多，这些线程的加锁时限相同的概率就高很多，可能会导致超时后重试的死循环。\n2) Java中不能对synchronized同步块设置超时时间。你需要创建一个自定义锁，或使用Java5中java.util.concurrent包下的工具\n```\n\n### 死锁检测\n\n　　**死锁检测算法**  \n​![1-7.png](/assets/net-img-1582875390665-923c52b9-52ce-4e6f-9cee-763046546af3-20221030135517-j4zeqi7.png)​\n\n```\nE 是现有资源向量（existing resource vector），代码每种已存在资源的总数\nA 是可用资源向量（available resource vector），那么Ai表示当前可供使用的资源数（即没有被分配的资源）\nC 是当前分配矩阵（current allocation matrix），C的第i行代表Pi当前所持有的每一种类型资源的资源数\nR 是请求矩阵（request matrix），R的每一行代表P所需要的资源的数量\n```\n\n　　**死锁检测步骤：**\n\n```\n寻找一个没有结束标记的进程Pi，对于它而言R矩阵的第i行向量小于或等于A。\n如果找到了这样一个进程，执行该进程，然后将C矩阵的第i行向量加到A中，标记该进程，并转到第1步\n如果没有这样的进程，那么算法终止\n算法结束时，所有没有标记过的进程都是死锁进程\n```\n\n### 死锁恢复\n\n* 资源剥夺法  \n  剥夺陷于死锁的进程所占用的资源，但并不撤销此进程，直至死锁解除。\n* 进程回退法  \n  根据系统保存的检查点让所有的进程回退，直到足以解除死锁，这种措施要求系统建立保存检查点、回退及重启机制。\n* 进程撤销法\n\n  * 撤销陷入死锁的所有进程，解除死锁，继续运行。\n  * 逐个撤销陷入死锁的进程，回收其资源并重新分配，直至死锁解除。\n\n## Java创建线程\n\n* 继承 Thread 类 extends Thread\n* 实现 Runnable 接口 implements Runnable\n* 实现 Callable 接口 implements Callable\n\n  * 实现 Callable 接口。 相较于实现 Runnable 接口的方式，方法可以有返回值，并且可以抛出异常。\n  * 执行 Callable 方式，需要 FutureTask 实现类的支持，用于接收运算结果。 FutureTask 是 Future 接口的实现类，线程启动 `new Thread(objectFutureTask1).start()`​\n\n> Future\n\n* cancel()方法用来取消任务，如果取消任务成功则返回true，如果取消任务失败则返回false。\n\n  * 参数mayInterruptIfRunning表示是否允许取消正在执行却没有执行完毕的任务，如果设置true，则表示可以取消正在执行过程中的任务。\n  * 如果任务已经完成，则无论mayInterruptIfRunning为true还是false，此方法肯定返回false，即如果取消已经完成的任务会返回false\n  * 如果任务正在执行，若mayInterruptIfRunning设置为true，则返回true，若mayInterruptIfRunning设置为false，则返回false；如果任务还没有执行，则无论mayInterruptIfRunning为true还是false，肯定返回true。\n* isCancelled()方法表示任务是否被取消成功，如果在任务正常完成前被取消成功，则返回 true。\n* isDone()方法表示任务是否已经完成，若任务完成，则返回true；\n* get()方法用来获取执行结果，这个方法会产生阻塞，会一直等到任务执行完毕才返回；\n* get(long timeout, TimeUnit unit)用来获取执行结果，如果在指定时间内，还没获取到结果，就直接返回null。\n\n> FutureTask\n>\n> 实现了RunnableFuture接口，而RunnableFuture接口继承了Runnable与Future接口，所以它既可以作为Runnable被线程中执行，又可以作为callable获得返回值。\n\n* 适合应用场景\n\n  * 执行多任务计算\n  * 在高并发环境下确保任务只执行一次\n\n### 小结\n\n* 实现接口和继承 Thread 类比较\n\n> 接口更适合多个相同的程序代码的线程去共享同一个资源。  \n> 接口可以避免 java 中的单继承的局限性。  \n> 接口代码可以被多个线程共享，代码和线程独立。  \n> 线程池只能放入实现 Runable 或 Callable 接口的线程，不能直接放入继承 Thread 的类。  \n> 扩充：在 java 中，每次程序运行至少启动 2 个线程。一个是 main 线程，一个是垃圾收集线程。\n\n* Runnable 和 Callable 接口比较\n\n  * 相同点：\n\n> 两者都是接口；  \n> 两者都可用来编写多线程程序；  \n> 两者都需要调用 Thread.start()启动线程；\n\n* 不同点：\n\n> 实现 Callable 接口的线程能返回执行结果；而实现 Runnable 接口的线程不能返回结果；  \n> Callable 接口的 call()方法允许抛出异常；而 Runnable 接口的 run()方法的不允许抛异常；  \n> 实现 Callable 接口的线程可以调用 Future.cancel 取消执行  ，而实现 Runnable 接口的线程不能\n\n* 注意点：\n\n> Callable 接口支持返回执行结果，此时需要调用 FutureTask.get()方法实现，此方法会阻塞主线程直到获取‘将来’结果；当不调用此方法时，主线程不会阻塞！\n>\n> 实现Runnable接口,在某些情况下可以提高性能，使用继承 Thread 类方式，每次执行一次任务，都需要新建一个独立的线程，执行完任务后线程走到生命周期的尽头被销毁，如果还想执行这个任务，就必须再新建一个继承了 Thread 类的类，如果此时执行的内容比较少，比如只是在 run() 方法里简单打印一行文字，那么它所带来的开销并不大，相比于整个线程从开始创建到执行完毕被销毁，这一系列的操作比 run() 方法打印文字本身带来的开销要大得多，相当于捡了芝麻丢了西瓜，得不偿失。如果我们使用实现 Runnable 接口的方式，就可以把任务直接传入线程池，使用一些固定的线程来完成任务，不需要每次新建销毁线程，大大降低了性能开销。\n","slug":"java-thread","published":1,"updated":"2025-04-22T07:27:29.913Z","_id":"cm9s3f3yx0008bfg4d2n5e8hf","comments":1,"layout":"post","photos":[],"content":"<h1>thread</h1>\n<h2 id=\"概述\">概述</h2>\n<h3 id=\"并发与并行\">并发与并行</h3>\n<p>并行：指两个或多个事件在同一时刻发生（同时发生）。<br>\n并发：指两个或多个事件在同一个时间段内发生。<br>\n​<img src=\"/assets/net-img-1582875290415-c052f229-8c31-4560-acef-300acae2409b-20221030135515-tme9bzx.png\" alt=\"1-1.png\">​</p>\n<h3 id=\"进程、线程\">进程、线程</h3>\n<blockquote>\n<p>进程是正在运行的程序的实例。<br>\n进程是线程的容器，即一个进程中可以开启多个线程。</p>\n</blockquote>\n<blockquote>\n<p>线程是进程内部的一个独立执行单元；<br>\n一个进程可以同时并发运行多个线程；</p>\n</blockquote>\n<h2 id=\"线程生命周期\">线程生命周期</h2>\n<p>​<img src=\"/assets/net-img-1596249786159-92610d33-5cbb-4d46-b7a5-6f1c8d3d1d92-20221030135516-9i6hh1r.jpeg\" alt=\"\">  1. 新建</p>\n<ul>\n<li>new 关键字创建了一个线程之后，该线程就处于新建状态</li>\n<li>JVM 为线程分配内存，初始化成员变量值</li>\n</ul>\n<ol start=\"2\">\n<li>\n<p>就绪</p>\n<ul>\n<li>当线程对象调用了 start()方法之后，该线程处于就绪状态</li>\n<li>JVM 为线程创建方法栈和程序计数器，等待线程调度器调度</li>\n</ul>\n</li>\n<li>\n<p>运行</p>\n<ul>\n<li>就绪状态的线程获得 CPU 资源，开始运行 run()方法，该线程进入运行状态</li>\n</ul>\n</li>\n<li>\n<p>阻塞</p>\n<ul>\n<li>线程在等待进入临界区</li>\n</ul>\n</li>\n<li>\n<p>无限期等待</p>\n<ul>\n<li>处于这种状态的线程不会被分配CPU执行时间，它们要等待被显式地唤醒，否则会处于无限期等待的状态。</li>\n</ul>\n</li>\n<li>\n<p>限期等待</p>\n<ul>\n<li>处于这种状态的线程不会被分配CPU执行时间，不过无须无限期等待被其他线程显示地唤醒，在达到一定时间后它们会自动唤醒。</li>\n</ul>\n</li>\n<li>\n<p>死亡</p>\n<ul>\n<li>线程会以如下 3 种方式结束，结束后就处于死亡状态：</li>\n<li>run()或 call()方法执行完成，线程正常结束。</li>\n<li>线程抛出一个未捕获的 Exception 或 Error。&gt;调用该线程 stop()方法来结束该线程，该方法容易导致死锁，不推荐使用。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"死锁\">死锁</h2>\n<p>多个线程因竞争资源而造成的一种僵局(互相等待)</p>\n<h3 id=\"死锁产生必要条件\">死锁产生必要条件</h3>\n<ol>\n<li>互斥条件<br>\n在一段时间内某资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待</li>\n<li>不可剥夺条件<br>\n进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放（只能是主动释放)。</li>\n<li>请求与保持<br>\n进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。</li>\n<li>循环等待条件<br>\n存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被 链中下一个进程所请求。即存在一个处于等待状态的进程集合{Pl, P2, …, pn}，其中 Pi 等 待的资源被 P(i+1)占有（i=0, 1, …, n-1)，Pn 等待的资源被 P0 占有，如图所示</li>\n</ol>\n<p>​<img src=\"/assets/net-img-1582875326094-cb5a96e7-e4c2-421d-83cf-216ca4f7f024-20221030135516-5igfhr6.png\" alt=\"1-5.png\"><img src=\"/assets/net-img-1582875326657-55738037-28bf-4de9-925a-f08034e0c722-20221030135516-j4ktjne.png\" alt=\"1-4.png\">​</p>\n<h3 id=\"死锁处理\">死锁处理</h3>\n<h3 id=\"死锁预防\">死锁预防</h3>\n<ol>\n<li>\n<p>破坏“互斥”条件<br>\n​<code>互斥</code>​条件是无法破坏的。因此，在死锁预防里主要是破坏其他几个必要条件，而不去涉及破坏<code>互斥</code>​条件。</p>\n</li>\n<li>\n<p>破坏“占有并等待”条件<br>\n系统中不允许进程在已获得某种资源的情况下，申请其他资源。即要想出一个办法，阻止进程在持有资源的同时申请其他资源</p>\n<ul>\n<li>方法一：一次性分配资源，即创建进程时，要求它申请所需的全部资源，系统或满足其所有要求，或什么也不给它。</li>\n<li>方法二：要求每个进程提出新的资源申请前，释放它所占有的资源。这样，一个进程在需要资源 S 时，须先把它先前占有的资源 R 释放掉，然后才能提出对 S 的申请，即使它可能很快又要用到资源 R。</li>\n</ul>\n</li>\n<li>\n<p>破坏“不可抢占”条件<br>\n破坏“不可抢占”条件就是允许对资源实行抢夺。</p>\n<ul>\n<li>方法一：如果占有某些资源的一个进程进行进一步资源请求被拒绝，则该进程必须释放它最初占有的资源，如果有必要，可再次请求这些资源和另外的资源。</li>\n<li>方法二：如果一个进程请求当前被另一个进程占有的一个资源，则操作系统可以抢占另一个进程，要求它释放资源。只有在任意两个进程的优先级都不相同的条件下，方法二才能预防死锁。</li>\n</ul>\n</li>\n<li>\n<p>破坏“循环等待”条件<br>\n破坏“循环等待”条件的一种方法，是将系统中的所有资源统一编号，进程可在任何时刻提出资源申请，但所有申请必须按照资源的编号顺序（升序）提出。这样做就能保证系统不出现死锁。</p>\n</li>\n</ol>\n<h3 id=\"死锁避免\">死锁避免</h3>\n<ol>\n<li>有序资源分配法<br>\n算法</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">必须为所有资源统一编号，</span><br><span class=\"line\">同类资源必须一次申请完，</span><br><span class=\"line\">不同类资源必须按顺序申请</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>银行家算法<br>\n银行家算法的基本思想是分配资源之前，判断系统是否是安全的；若是，才分配。它是最具有代表性的避免死锁的算法。<br>\n设进程 i 提出请求 REQUEST [i]，则银行家算法按如下规则进行判断。<img src=\"/assets/net-img-1582875381841-0104c814-acd3-4ef3-a3bd-f5331d9a06bc-20221030135516-0716ftg.png\" alt=\"1-6.png\">​</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 如果REQUEST [i]&lt;= NEED[i，j]，则转（2)；否则，出错。</span><br><span class=\"line\">2 .如果REQUEST [i]&lt;= AVAILABLE[i]，则转（3)；否则，等待。</span><br><span class=\"line\">3 .系统试探分配资源，修改相关数据：</span><br><span class=\"line\">   AVAILABLE[i]-=REQUEST[i];//可用资源数-请求资源数</span><br><span class=\"line\">   ALLOCATION[i]+=REQUEST[i];//已分配资源数+请求资源数</span><br><span class=\"line\">   NEED[i]-=REQUEST[i];//需要资源数-请求资源数</span><br><span class=\"line\">系统执行安全性检查，如安全，则分配成立；否则试探险性分配作废，系统恢复原状，进程等待</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>顺序加锁<br>\n如果能确保所有的线程都是按照相同的顺序获得锁，那么死锁就不会发生,但是，这种方式需要事先知道所有可能会用到的锁，但总有些时候是无法预知的，所以该种方式只适合特定场景</li>\n<li>限时加锁<br>\n限时加锁是线程在尝试获取锁的时候加一个超时时间，若超过这个时间则放弃对该锁请求，并回退并释放所有已经获得的锁，然后等待一段随机的时间再重试<br>\n这种方式有两个缺点：</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1) 当线程数量少时，该种方式可避免死锁，但当线程数量过多，这些线程的加锁时限相同的概率就高很多，可能会导致超时后重试的死循环。</span><br><span class=\"line\">2) Java中不能对synchronized同步块设置超时时间。你需要创建一个自定义锁，或使用Java5中java.util.concurrent包下的工具</span><br></pre></td></tr></table></figure>\n<h3 id=\"死锁检测\">死锁检测</h3>\n<p><strong>死锁检测算法</strong><br>\n​<img src=\"/assets/net-img-1582875390665-923c52b9-52ce-4e6f-9cee-763046546af3-20221030135517-j4zeqi7.png\" alt=\"1-7.png\">​</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">E 是现有资源向量（existing resource vector），代码每种已存在资源的总数</span><br><span class=\"line\">A 是可用资源向量（available resource vector），那么Ai表示当前可供使用的资源数（即没有被分配的资源）</span><br><span class=\"line\">C 是当前分配矩阵（current allocation matrix），C的第i行代表Pi当前所持有的每一种类型资源的资源数</span><br><span class=\"line\">R 是请求矩阵（request matrix），R的每一行代表P所需要的资源的数量</span><br></pre></td></tr></table></figure>\n<p><strong>死锁检测步骤：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">寻找一个没有结束标记的进程Pi，对于它而言R矩阵的第i行向量小于或等于A。</span><br><span class=\"line\">如果找到了这样一个进程，执行该进程，然后将C矩阵的第i行向量加到A中，标记该进程，并转到第1步</span><br><span class=\"line\">如果没有这样的进程，那么算法终止</span><br><span class=\"line\">算法结束时，所有没有标记过的进程都是死锁进程</span><br></pre></td></tr></table></figure>\n<h3 id=\"死锁恢复\">死锁恢复</h3>\n<ul>\n<li>\n<p>资源剥夺法<br>\n剥夺陷于死锁的进程所占用的资源，但并不撤销此进程，直至死锁解除。</p>\n</li>\n<li>\n<p>进程回退法<br>\n根据系统保存的检查点让所有的进程回退，直到足以解除死锁，这种措施要求系统建立保存检查点、回退及重启机制。</p>\n</li>\n<li>\n<p>进程撤销法</p>\n<ul>\n<li>撤销陷入死锁的所有进程，解除死锁，继续运行。</li>\n<li>逐个撤销陷入死锁的进程，回收其资源并重新分配，直至死锁解除。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Java创建线程\">Java创建线程</h2>\n<ul>\n<li>\n<p>继承 Thread 类 extends Thread</p>\n</li>\n<li>\n<p>实现 Runnable 接口 implements Runnable</p>\n</li>\n<li>\n<p>实现 Callable 接口 implements Callable</p>\n<ul>\n<li>实现 Callable 接口。 相较于实现 Runnable 接口的方式，方法可以有返回值，并且可以抛出异常。</li>\n<li>执行 Callable 方式，需要 FutureTask 实现类的支持，用于接收运算结果。 FutureTask 是 Future 接口的实现类，线程启动 <code>new Thread(objectFutureTask1).start()</code>​</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>Future</p>\n</blockquote>\n<ul>\n<li>\n<p>cancel()方法用来取消任务，如果取消任务成功则返回true，如果取消任务失败则返回false。</p>\n<ul>\n<li>参数mayInterruptIfRunning表示是否允许取消正在执行却没有执行完毕的任务，如果设置true，则表示可以取消正在执行过程中的任务。</li>\n<li>如果任务已经完成，则无论mayInterruptIfRunning为true还是false，此方法肯定返回false，即如果取消已经完成的任务会返回false</li>\n<li>如果任务正在执行，若mayInterruptIfRunning设置为true，则返回true，若mayInterruptIfRunning设置为false，则返回false；如果任务还没有执行，则无论mayInterruptIfRunning为true还是false，肯定返回true。</li>\n</ul>\n</li>\n<li>\n<p>isCancelled()方法表示任务是否被取消成功，如果在任务正常完成前被取消成功，则返回 true。</p>\n</li>\n<li>\n<p>isDone()方法表示任务是否已经完成，若任务完成，则返回true；</p>\n</li>\n<li>\n<p>get()方法用来获取执行结果，这个方法会产生阻塞，会一直等到任务执行完毕才返回；</p>\n</li>\n<li>\n<p>get(long timeout, TimeUnit unit)用来获取执行结果，如果在指定时间内，还没获取到结果，就直接返回null。</p>\n</li>\n</ul>\n<blockquote>\n<p>FutureTask</p>\n<p>实现了RunnableFuture接口，而RunnableFuture接口继承了Runnable与Future接口，所以它既可以作为Runnable被线程中执行，又可以作为callable获得返回值。</p>\n</blockquote>\n<ul>\n<li>\n<p>适合应用场景</p>\n<ul>\n<li>执行多任务计算</li>\n<li>在高并发环境下确保任务只执行一次</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"小结\">小结</h3>\n<ul>\n<li>实现接口和继承 Thread 类比较</li>\n</ul>\n<blockquote>\n<p>接口更适合多个相同的程序代码的线程去共享同一个资源。<br>\n接口可以避免 java 中的单继承的局限性。<br>\n接口代码可以被多个线程共享，代码和线程独立。<br>\n线程池只能放入实现 Runable 或 Callable 接口的线程，不能直接放入继承 Thread 的类。<br>\n扩充：在 java 中，每次程序运行至少启动 2 个线程。一个是 main 线程，一个是垃圾收集线程。</p>\n</blockquote>\n<ul>\n<li>\n<p>Runnable 和 Callable 接口比较</p>\n<ul>\n<li>相同点：</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>两者都是接口；<br>\n两者都可用来编写多线程程序；<br>\n两者都需要调用 Thread.start()启动线程；</p>\n</blockquote>\n<ul>\n<li>不同点：</li>\n</ul>\n<blockquote>\n<p>实现 Callable 接口的线程能返回执行结果；而实现 Runnable 接口的线程不能返回结果；<br>\nCallable 接口的 call()方法允许抛出异常；而 Runnable 接口的 run()方法的不允许抛异常；<br>\n实现 Callable 接口的线程可以调用 Future.cancel 取消执行  ，而实现 Runnable 接口的线程不能</p>\n</blockquote>\n<ul>\n<li>注意点：</li>\n</ul>\n<blockquote>\n<p>Callable 接口支持返回执行结果，此时需要调用 FutureTask.get()方法实现，此方法会阻塞主线程直到获取‘将来’结果；当不调用此方法时，主线程不会阻塞！</p>\n<p>实现Runnable接口,在某些情况下可以提高性能，使用继承 Thread 类方式，每次执行一次任务，都需要新建一个独立的线程，执行完任务后线程走到生命周期的尽头被销毁，如果还想执行这个任务，就必须再新建一个继承了 Thread 类的类，如果此时执行的内容比较少，比如只是在 run() 方法里简单打印一行文字，那么它所带来的开销并不大，相比于整个线程从开始创建到执行完毕被销毁，这一系列的操作比 run() 方法打印文字本身带来的开销要大得多，相当于捡了芝麻丢了西瓜，得不偿失。如果我们使用实现 Runnable 接口的方式，就可以把任务直接传入线程池，使用一些固定的线程来完成任务，不需要每次新建销毁线程，大大降低了性能开销。</p>\n</blockquote>\n","excerpt":"","more":"<h1>thread</h1>\n<h2 id=\"概述\">概述</h2>\n<h3 id=\"并发与并行\">并发与并行</h3>\n<p>并行：指两个或多个事件在同一时刻发生（同时发生）。<br>\n并发：指两个或多个事件在同一个时间段内发生。<br>\n​<img src=\"/assets/net-img-1582875290415-c052f229-8c31-4560-acef-300acae2409b-20221030135515-tme9bzx.png\" alt=\"1-1.png\">​</p>\n<h3 id=\"进程、线程\">进程、线程</h3>\n<blockquote>\n<p>进程是正在运行的程序的实例。<br>\n进程是线程的容器，即一个进程中可以开启多个线程。</p>\n</blockquote>\n<blockquote>\n<p>线程是进程内部的一个独立执行单元；<br>\n一个进程可以同时并发运行多个线程；</p>\n</blockquote>\n<h2 id=\"线程生命周期\">线程生命周期</h2>\n<p>​<img src=\"/assets/net-img-1596249786159-92610d33-5cbb-4d46-b7a5-6f1c8d3d1d92-20221030135516-9i6hh1r.jpeg\" alt=\"\">  1. 新建</p>\n<ul>\n<li>new 关键字创建了一个线程之后，该线程就处于新建状态</li>\n<li>JVM 为线程分配内存，初始化成员变量值</li>\n</ul>\n<ol start=\"2\">\n<li>\n<p>就绪</p>\n<ul>\n<li>当线程对象调用了 start()方法之后，该线程处于就绪状态</li>\n<li>JVM 为线程创建方法栈和程序计数器，等待线程调度器调度</li>\n</ul>\n</li>\n<li>\n<p>运行</p>\n<ul>\n<li>就绪状态的线程获得 CPU 资源，开始运行 run()方法，该线程进入运行状态</li>\n</ul>\n</li>\n<li>\n<p>阻塞</p>\n<ul>\n<li>线程在等待进入临界区</li>\n</ul>\n</li>\n<li>\n<p>无限期等待</p>\n<ul>\n<li>处于这种状态的线程不会被分配CPU执行时间，它们要等待被显式地唤醒，否则会处于无限期等待的状态。</li>\n</ul>\n</li>\n<li>\n<p>限期等待</p>\n<ul>\n<li>处于这种状态的线程不会被分配CPU执行时间，不过无须无限期等待被其他线程显示地唤醒，在达到一定时间后它们会自动唤醒。</li>\n</ul>\n</li>\n<li>\n<p>死亡</p>\n<ul>\n<li>线程会以如下 3 种方式结束，结束后就处于死亡状态：</li>\n<li>run()或 call()方法执行完成，线程正常结束。</li>\n<li>线程抛出一个未捕获的 Exception 或 Error。&gt;调用该线程 stop()方法来结束该线程，该方法容易导致死锁，不推荐使用。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"死锁\">死锁</h2>\n<p>多个线程因竞争资源而造成的一种僵局(互相等待)</p>\n<h3 id=\"死锁产生必要条件\">死锁产生必要条件</h3>\n<ol>\n<li>互斥条件<br>\n在一段时间内某资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待</li>\n<li>不可剥夺条件<br>\n进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放（只能是主动释放)。</li>\n<li>请求与保持<br>\n进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。</li>\n<li>循环等待条件<br>\n存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被 链中下一个进程所请求。即存在一个处于等待状态的进程集合{Pl, P2, …, pn}，其中 Pi 等 待的资源被 P(i+1)占有（i=0, 1, …, n-1)，Pn 等待的资源被 P0 占有，如图所示</li>\n</ol>\n<p>​<img src=\"/assets/net-img-1582875326094-cb5a96e7-e4c2-421d-83cf-216ca4f7f024-20221030135516-5igfhr6.png\" alt=\"1-5.png\"><img src=\"/assets/net-img-1582875326657-55738037-28bf-4de9-925a-f08034e0c722-20221030135516-j4ktjne.png\" alt=\"1-4.png\">​</p>\n<h3 id=\"死锁处理\">死锁处理</h3>\n<h3 id=\"死锁预防\">死锁预防</h3>\n<ol>\n<li>\n<p>破坏“互斥”条件<br>\n​<code>互斥</code>​条件是无法破坏的。因此，在死锁预防里主要是破坏其他几个必要条件，而不去涉及破坏<code>互斥</code>​条件。</p>\n</li>\n<li>\n<p>破坏“占有并等待”条件<br>\n系统中不允许进程在已获得某种资源的情况下，申请其他资源。即要想出一个办法，阻止进程在持有资源的同时申请其他资源</p>\n<ul>\n<li>方法一：一次性分配资源，即创建进程时，要求它申请所需的全部资源，系统或满足其所有要求，或什么也不给它。</li>\n<li>方法二：要求每个进程提出新的资源申请前，释放它所占有的资源。这样，一个进程在需要资源 S 时，须先把它先前占有的资源 R 释放掉，然后才能提出对 S 的申请，即使它可能很快又要用到资源 R。</li>\n</ul>\n</li>\n<li>\n<p>破坏“不可抢占”条件<br>\n破坏“不可抢占”条件就是允许对资源实行抢夺。</p>\n<ul>\n<li>方法一：如果占有某些资源的一个进程进行进一步资源请求被拒绝，则该进程必须释放它最初占有的资源，如果有必要，可再次请求这些资源和另外的资源。</li>\n<li>方法二：如果一个进程请求当前被另一个进程占有的一个资源，则操作系统可以抢占另一个进程，要求它释放资源。只有在任意两个进程的优先级都不相同的条件下，方法二才能预防死锁。</li>\n</ul>\n</li>\n<li>\n<p>破坏“循环等待”条件<br>\n破坏“循环等待”条件的一种方法，是将系统中的所有资源统一编号，进程可在任何时刻提出资源申请，但所有申请必须按照资源的编号顺序（升序）提出。这样做就能保证系统不出现死锁。</p>\n</li>\n</ol>\n<h3 id=\"死锁避免\">死锁避免</h3>\n<ol>\n<li>有序资源分配法<br>\n算法</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">必须为所有资源统一编号，</span><br><span class=\"line\">同类资源必须一次申请完，</span><br><span class=\"line\">不同类资源必须按顺序申请</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>银行家算法<br>\n银行家算法的基本思想是分配资源之前，判断系统是否是安全的；若是，才分配。它是最具有代表性的避免死锁的算法。<br>\n设进程 i 提出请求 REQUEST [i]，则银行家算法按如下规则进行判断。<img src=\"/assets/net-img-1582875381841-0104c814-acd3-4ef3-a3bd-f5331d9a06bc-20221030135516-0716ftg.png\" alt=\"1-6.png\">​</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 如果REQUEST [i]&lt;= NEED[i，j]，则转（2)；否则，出错。</span><br><span class=\"line\">2 .如果REQUEST [i]&lt;= AVAILABLE[i]，则转（3)；否则，等待。</span><br><span class=\"line\">3 .系统试探分配资源，修改相关数据：</span><br><span class=\"line\">   AVAILABLE[i]-=REQUEST[i];//可用资源数-请求资源数</span><br><span class=\"line\">   ALLOCATION[i]+=REQUEST[i];//已分配资源数+请求资源数</span><br><span class=\"line\">   NEED[i]-=REQUEST[i];//需要资源数-请求资源数</span><br><span class=\"line\">系统执行安全性检查，如安全，则分配成立；否则试探险性分配作废，系统恢复原状，进程等待</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>顺序加锁<br>\n如果能确保所有的线程都是按照相同的顺序获得锁，那么死锁就不会发生,但是，这种方式需要事先知道所有可能会用到的锁，但总有些时候是无法预知的，所以该种方式只适合特定场景</li>\n<li>限时加锁<br>\n限时加锁是线程在尝试获取锁的时候加一个超时时间，若超过这个时间则放弃对该锁请求，并回退并释放所有已经获得的锁，然后等待一段随机的时间再重试<br>\n这种方式有两个缺点：</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1) 当线程数量少时，该种方式可避免死锁，但当线程数量过多，这些线程的加锁时限相同的概率就高很多，可能会导致超时后重试的死循环。</span><br><span class=\"line\">2) Java中不能对synchronized同步块设置超时时间。你需要创建一个自定义锁，或使用Java5中java.util.concurrent包下的工具</span><br></pre></td></tr></table></figure>\n<h3 id=\"死锁检测\">死锁检测</h3>\n<p><strong>死锁检测算法</strong><br>\n​<img src=\"/assets/net-img-1582875390665-923c52b9-52ce-4e6f-9cee-763046546af3-20221030135517-j4zeqi7.png\" alt=\"1-7.png\">​</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">E 是现有资源向量（existing resource vector），代码每种已存在资源的总数</span><br><span class=\"line\">A 是可用资源向量（available resource vector），那么Ai表示当前可供使用的资源数（即没有被分配的资源）</span><br><span class=\"line\">C 是当前分配矩阵（current allocation matrix），C的第i行代表Pi当前所持有的每一种类型资源的资源数</span><br><span class=\"line\">R 是请求矩阵（request matrix），R的每一行代表P所需要的资源的数量</span><br></pre></td></tr></table></figure>\n<p><strong>死锁检测步骤：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">寻找一个没有结束标记的进程Pi，对于它而言R矩阵的第i行向量小于或等于A。</span><br><span class=\"line\">如果找到了这样一个进程，执行该进程，然后将C矩阵的第i行向量加到A中，标记该进程，并转到第1步</span><br><span class=\"line\">如果没有这样的进程，那么算法终止</span><br><span class=\"line\">算法结束时，所有没有标记过的进程都是死锁进程</span><br></pre></td></tr></table></figure>\n<h3 id=\"死锁恢复\">死锁恢复</h3>\n<ul>\n<li>\n<p>资源剥夺法<br>\n剥夺陷于死锁的进程所占用的资源，但并不撤销此进程，直至死锁解除。</p>\n</li>\n<li>\n<p>进程回退法<br>\n根据系统保存的检查点让所有的进程回退，直到足以解除死锁，这种措施要求系统建立保存检查点、回退及重启机制。</p>\n</li>\n<li>\n<p>进程撤销法</p>\n<ul>\n<li>撤销陷入死锁的所有进程，解除死锁，继续运行。</li>\n<li>逐个撤销陷入死锁的进程，回收其资源并重新分配，直至死锁解除。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Java创建线程\">Java创建线程</h2>\n<ul>\n<li>\n<p>继承 Thread 类 extends Thread</p>\n</li>\n<li>\n<p>实现 Runnable 接口 implements Runnable</p>\n</li>\n<li>\n<p>实现 Callable 接口 implements Callable</p>\n<ul>\n<li>实现 Callable 接口。 相较于实现 Runnable 接口的方式，方法可以有返回值，并且可以抛出异常。</li>\n<li>执行 Callable 方式，需要 FutureTask 实现类的支持，用于接收运算结果。 FutureTask 是 Future 接口的实现类，线程启动 <code>new Thread(objectFutureTask1).start()</code>​</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>Future</p>\n</blockquote>\n<ul>\n<li>\n<p>cancel()方法用来取消任务，如果取消任务成功则返回true，如果取消任务失败则返回false。</p>\n<ul>\n<li>参数mayInterruptIfRunning表示是否允许取消正在执行却没有执行完毕的任务，如果设置true，则表示可以取消正在执行过程中的任务。</li>\n<li>如果任务已经完成，则无论mayInterruptIfRunning为true还是false，此方法肯定返回false，即如果取消已经完成的任务会返回false</li>\n<li>如果任务正在执行，若mayInterruptIfRunning设置为true，则返回true，若mayInterruptIfRunning设置为false，则返回false；如果任务还没有执行，则无论mayInterruptIfRunning为true还是false，肯定返回true。</li>\n</ul>\n</li>\n<li>\n<p>isCancelled()方法表示任务是否被取消成功，如果在任务正常完成前被取消成功，则返回 true。</p>\n</li>\n<li>\n<p>isDone()方法表示任务是否已经完成，若任务完成，则返回true；</p>\n</li>\n<li>\n<p>get()方法用来获取执行结果，这个方法会产生阻塞，会一直等到任务执行完毕才返回；</p>\n</li>\n<li>\n<p>get(long timeout, TimeUnit unit)用来获取执行结果，如果在指定时间内，还没获取到结果，就直接返回null。</p>\n</li>\n</ul>\n<blockquote>\n<p>FutureTask</p>\n<p>实现了RunnableFuture接口，而RunnableFuture接口继承了Runnable与Future接口，所以它既可以作为Runnable被线程中执行，又可以作为callable获得返回值。</p>\n</blockquote>\n<ul>\n<li>\n<p>适合应用场景</p>\n<ul>\n<li>执行多任务计算</li>\n<li>在高并发环境下确保任务只执行一次</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"小结\">小结</h3>\n<ul>\n<li>实现接口和继承 Thread 类比较</li>\n</ul>\n<blockquote>\n<p>接口更适合多个相同的程序代码的线程去共享同一个资源。<br>\n接口可以避免 java 中的单继承的局限性。<br>\n接口代码可以被多个线程共享，代码和线程独立。<br>\n线程池只能放入实现 Runable 或 Callable 接口的线程，不能直接放入继承 Thread 的类。<br>\n扩充：在 java 中，每次程序运行至少启动 2 个线程。一个是 main 线程，一个是垃圾收集线程。</p>\n</blockquote>\n<ul>\n<li>\n<p>Runnable 和 Callable 接口比较</p>\n<ul>\n<li>相同点：</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>两者都是接口；<br>\n两者都可用来编写多线程程序；<br>\n两者都需要调用 Thread.start()启动线程；</p>\n</blockquote>\n<ul>\n<li>不同点：</li>\n</ul>\n<blockquote>\n<p>实现 Callable 接口的线程能返回执行结果；而实现 Runnable 接口的线程不能返回结果；<br>\nCallable 接口的 call()方法允许抛出异常；而 Runnable 接口的 run()方法的不允许抛异常；<br>\n实现 Callable 接口的线程可以调用 Future.cancel 取消执行  ，而实现 Runnable 接口的线程不能</p>\n</blockquote>\n<ul>\n<li>注意点：</li>\n</ul>\n<blockquote>\n<p>Callable 接口支持返回执行结果，此时需要调用 FutureTask.get()方法实现，此方法会阻塞主线程直到获取‘将来’结果；当不调用此方法时，主线程不会阻塞！</p>\n<p>实现Runnable接口,在某些情况下可以提高性能，使用继承 Thread 类方式，每次执行一次任务，都需要新建一个独立的线程，执行完任务后线程走到生命周期的尽头被销毁，如果还想执行这个任务，就必须再新建一个继承了 Thread 类的类，如果此时执行的内容比较少，比如只是在 run() 方法里简单打印一行文字，那么它所带来的开销并不大，相比于整个线程从开始创建到执行完毕被销毁，这一系列的操作比 run() 方法打印文字本身带来的开销要大得多，相当于捡了芝麻丢了西瓜，得不偿失。如果我们使用实现 Runnable 接口的方式，就可以把任务直接传入线程池，使用一些固定的线程来完成任务，不需要每次新建销毁线程，大大降低了性能开销。</p>\n</blockquote>\n"},{"title":"JavaStream","date":"2022-10-30T05:27:17.000Z","lastmod":"2023-08-25T12:01:12.000Z","_content":"\n# JavaStream\n\n### Stream\n\n> Stream（流）是一个来自数据源的元素队列并支持聚合操作\n\n- 元素是特定类型的对象，形成一个队列。 Java中的Stream并不会存储元素，而是按需计算。\n- **数据源** 流的来源。 可以是集合，数组，I/O channel， 产生器generator 等。\n- **聚合操作** 类似SQL语句一样的操作， 比如filter, map, reduce, find, match, sorted等。\n\n　　Stream还有两个特征\n\n- **Pipelining**: 中间操作都会返回流对象本身。 这样多个操作可以串联成一个管道， 如同流式风格（fluent style）。 这样做可以对操作进行优化， 比如延迟执行(laziness)和短路( short-circuiting)。\n- **内部迭代**： 以前对集合遍历都是通过Iterator或者For-Each的方式, 显式的在集合外部进行迭代， 这叫做外部迭代。 Stream提供了内部迭代的方式， 通过访问者模式(Visitor)实现。\n\n### 生成流\n\n- stream() -为集合创建串行流。\n- parallelStream() − 为集合创建并行流。\n- `Stream.of()` 从一堆对象中创建 Stream 流\n\n### 数据处理\n\n#### map\n\n> 用于映射每个元素到对应的结果，可对当前元素进行数据处理\n\n#### flatmap\n\n> 将流的每个元素, 转换为其他对象的流,入参接受一个返回对象流的函数\n\n#### filter（lamda表达式）\n\n> 用于通过设置的条件过滤出元素(过滤条件对应的是留下的元素)\n\n#### limit\n\n> 用于获取指定数量的流\n\n#### sorted\n\n> 用于对流进行排序，可以传入**Comparator**参数控制排序顺序\n\n#### distinct\n\n> 用于消除流中的重复元素\n\n#### isPrime()\n\n> 用于检测是否是质数，是留下该元素\n\n### 结束操作\n\n#### forEach(Consumer)\n\n> 遍历迭代流中的每个元素，无返回值\n\n#### `forEachOrdered(Consumer)`\n\n> 确保按照原始流的顺序执行。\n\n#### collect(Collector)\n\n> 使用 `Collector` 收集流元素到结果集合中\n\n#### `collect(Supplier, BiConsumer, BiConsumer)`\n\n> 收集流元素到结果集合中，第一个参数用于**创建一个新的结果集合**，第二个参数用于**将下一个元素加入到现有结果合集中**，第三个参数用于**将两个结果合集合并**\n\n## 匹配\n\n#### `allMatch(Predicate)` ：\n\n> 如果流的每个元素根据提供的 `Predicate` 都返回 true 时，最终结果返回为 true。这个操作将会在第一个 false 之后短路，也就是不会在发生 false 之后继续执行计算。\n\n#### `anyMatch(Predicate)`：\n\n> 如果流中的任意一个元素根据提供的 `Predicate` 返回 true 时，最终结果返回为 true。这个操作将会在第一个 true 之后短路，也就是不会在发生 true 之后继续执行计算。\n\n#### `noneMatch(Predicate)`：\n\n> 如果流的每个元素根据提供的 `Predicate` 都返回 false 时，最终结果返回为 true。这个操作将会在第一个 true 之后短路，也就是不会在发生 true 之后继续执行计算。\n","source":"_posts/java/Base/JavaStream.md","raw":"---\ntitle: JavaStream\ndate: 2022-10-30T13:27:17Z\nlastmod: 2023-08-25T20:01:12Z\n---\n\n# JavaStream\n\n### Stream\n\n> Stream（流）是一个来自数据源的元素队列并支持聚合操作\n\n- 元素是特定类型的对象，形成一个队列。 Java中的Stream并不会存储元素，而是按需计算。\n- **数据源** 流的来源。 可以是集合，数组，I/O channel， 产生器generator 等。\n- **聚合操作** 类似SQL语句一样的操作， 比如filter, map, reduce, find, match, sorted等。\n\n　　Stream还有两个特征\n\n- **Pipelining**: 中间操作都会返回流对象本身。 这样多个操作可以串联成一个管道， 如同流式风格（fluent style）。 这样做可以对操作进行优化， 比如延迟执行(laziness)和短路( short-circuiting)。\n- **内部迭代**： 以前对集合遍历都是通过Iterator或者For-Each的方式, 显式的在集合外部进行迭代， 这叫做外部迭代。 Stream提供了内部迭代的方式， 通过访问者模式(Visitor)实现。\n\n### 生成流\n\n- stream() -为集合创建串行流。\n- parallelStream() − 为集合创建并行流。\n- `Stream.of()` 从一堆对象中创建 Stream 流\n\n### 数据处理\n\n#### map\n\n> 用于映射每个元素到对应的结果，可对当前元素进行数据处理\n\n#### flatmap\n\n> 将流的每个元素, 转换为其他对象的流,入参接受一个返回对象流的函数\n\n#### filter（lamda表达式）\n\n> 用于通过设置的条件过滤出元素(过滤条件对应的是留下的元素)\n\n#### limit\n\n> 用于获取指定数量的流\n\n#### sorted\n\n> 用于对流进行排序，可以传入**Comparator**参数控制排序顺序\n\n#### distinct\n\n> 用于消除流中的重复元素\n\n#### isPrime()\n\n> 用于检测是否是质数，是留下该元素\n\n### 结束操作\n\n#### forEach(Consumer)\n\n> 遍历迭代流中的每个元素，无返回值\n\n#### `forEachOrdered(Consumer)`\n\n> 确保按照原始流的顺序执行。\n\n#### collect(Collector)\n\n> 使用 `Collector` 收集流元素到结果集合中\n\n#### `collect(Supplier, BiConsumer, BiConsumer)`\n\n> 收集流元素到结果集合中，第一个参数用于**创建一个新的结果集合**，第二个参数用于**将下一个元素加入到现有结果合集中**，第三个参数用于**将两个结果合集合并**\n\n## 匹配\n\n#### `allMatch(Predicate)` ：\n\n> 如果流的每个元素根据提供的 `Predicate` 都返回 true 时，最终结果返回为 true。这个操作将会在第一个 false 之后短路，也就是不会在发生 false 之后继续执行计算。\n\n#### `anyMatch(Predicate)`：\n\n> 如果流中的任意一个元素根据提供的 `Predicate` 返回 true 时，最终结果返回为 true。这个操作将会在第一个 true 之后短路，也就是不会在发生 true 之后继续执行计算。\n\n#### `noneMatch(Predicate)`：\n\n> 如果流的每个元素根据提供的 `Predicate` 都返回 false 时，最终结果返回为 true。这个操作将会在第一个 true 之后短路，也就是不会在发生 true 之后继续执行计算。\n","slug":"java-Base-JavaStream","published":1,"updated":"2025-04-22T02:21:59.463Z","comments":1,"layout":"post","photos":[],"_id":"cm9s3f40e002rbfg4h9fb2dxj","content":"<h1>JavaStream</h1>\n<h3 id=\"Stream\">Stream</h3>\n<blockquote>\n<p>Stream（流）是一个来自数据源的元素队列并支持聚合操作</p>\n</blockquote>\n<ul>\n<li>元素是特定类型的对象，形成一个队列。 Java中的Stream并不会存储元素，而是按需计算。</li>\n<li><strong>数据源</strong> 流的来源。 可以是集合，数组，I/O channel， 产生器generator 等。</li>\n<li><strong>聚合操作</strong> 类似SQL语句一样的操作， 比如filter, map, reduce, find, match, sorted等。</li>\n</ul>\n<p>Stream还有两个特征</p>\n<ul>\n<li><strong>Pipelining</strong>: 中间操作都会返回流对象本身。 这样多个操作可以串联成一个管道， 如同流式风格（fluent style）。 这样做可以对操作进行优化， 比如延迟执行(laziness)和短路( short-circuiting)。</li>\n<li><strong>内部迭代</strong>： 以前对集合遍历都是通过Iterator或者For-Each的方式, 显式的在集合外部进行迭代， 这叫做外部迭代。 Stream提供了内部迭代的方式， 通过访问者模式(Visitor)实现。</li>\n</ul>\n<h3 id=\"生成流\">生成流</h3>\n<ul>\n<li>stream() -为集合创建串行流。</li>\n<li>parallelStream() − 为集合创建并行流。</li>\n<li><code>Stream.of()</code> 从一堆对象中创建 Stream 流</li>\n</ul>\n<h3 id=\"数据处理\">数据处理</h3>\n<h4 id=\"map\">map</h4>\n<blockquote>\n<p>用于映射每个元素到对应的结果，可对当前元素进行数据处理</p>\n</blockquote>\n<h4 id=\"flatmap\">flatmap</h4>\n<blockquote>\n<p>将流的每个元素, 转换为其他对象的流,入参接受一个返回对象流的函数</p>\n</blockquote>\n<h4 id=\"filter（lamda表达式）\">filter（lamda表达式）</h4>\n<blockquote>\n<p>用于通过设置的条件过滤出元素(过滤条件对应的是留下的元素)</p>\n</blockquote>\n<h4 id=\"limit\">limit</h4>\n<blockquote>\n<p>用于获取指定数量的流</p>\n</blockquote>\n<h4 id=\"sorted\">sorted</h4>\n<blockquote>\n<p>用于对流进行排序，可以传入<strong>Comparator</strong>参数控制排序顺序</p>\n</blockquote>\n<h4 id=\"distinct\">distinct</h4>\n<blockquote>\n<p>用于消除流中的重复元素</p>\n</blockquote>\n<h4 id=\"isPrime\">isPrime()</h4>\n<blockquote>\n<p>用于检测是否是质数，是留下该元素</p>\n</blockquote>\n<h3 id=\"结束操作\">结束操作</h3>\n<h4 id=\"forEach-Consumer\">forEach(Consumer)</h4>\n<blockquote>\n<p>遍历迭代流中的每个元素，无返回值</p>\n</blockquote>\n<h4 id=\"forEachOrdered-Consumer\"><code>forEachOrdered(Consumer)</code></h4>\n<blockquote>\n<p>确保按照原始流的顺序执行。</p>\n</blockquote>\n<h4 id=\"collect-Collector\">collect(Collector)</h4>\n<blockquote>\n<p>使用 <code>Collector</code> 收集流元素到结果集合中</p>\n</blockquote>\n<h4 id=\"collect-Supplier-BiConsumer-BiConsumer\"><code>collect(Supplier, BiConsumer, BiConsumer)</code></h4>\n<blockquote>\n<p>收集流元素到结果集合中，第一个参数用于<strong>创建一个新的结果集合</strong>，第二个参数用于<strong>将下一个元素加入到现有结果合集中</strong>，第三个参数用于<strong>将两个结果合集合并</strong></p>\n</blockquote>\n<h2 id=\"匹配\">匹配</h2>\n<h4 id=\"allMatch-Predicate-：\"><code>allMatch(Predicate)</code> ：</h4>\n<blockquote>\n<p>如果流的每个元素根据提供的 <code>Predicate</code> 都返回 true 时，最终结果返回为 true。这个操作将会在第一个 false 之后短路，也就是不会在发生 false 之后继续执行计算。</p>\n</blockquote>\n<h4 id=\"anyMatch-Predicate-：\"><code>anyMatch(Predicate)</code>：</h4>\n<blockquote>\n<p>如果流中的任意一个元素根据提供的 <code>Predicate</code> 返回 true 时，最终结果返回为 true。这个操作将会在第一个 true 之后短路，也就是不会在发生 true 之后继续执行计算。</p>\n</blockquote>\n<h4 id=\"noneMatch-Predicate-：\"><code>noneMatch(Predicate)</code>：</h4>\n<blockquote>\n<p>如果流的每个元素根据提供的 <code>Predicate</code> 都返回 false 时，最终结果返回为 true。这个操作将会在第一个 true 之后短路，也就是不会在发生 true 之后继续执行计算。</p>\n</blockquote>\n","excerpt":"","more":"<h1>JavaStream</h1>\n<h3 id=\"Stream\">Stream</h3>\n<blockquote>\n<p>Stream（流）是一个来自数据源的元素队列并支持聚合操作</p>\n</blockquote>\n<ul>\n<li>元素是特定类型的对象，形成一个队列。 Java中的Stream并不会存储元素，而是按需计算。</li>\n<li><strong>数据源</strong> 流的来源。 可以是集合，数组，I/O channel， 产生器generator 等。</li>\n<li><strong>聚合操作</strong> 类似SQL语句一样的操作， 比如filter, map, reduce, find, match, sorted等。</li>\n</ul>\n<p>Stream还有两个特征</p>\n<ul>\n<li><strong>Pipelining</strong>: 中间操作都会返回流对象本身。 这样多个操作可以串联成一个管道， 如同流式风格（fluent style）。 这样做可以对操作进行优化， 比如延迟执行(laziness)和短路( short-circuiting)。</li>\n<li><strong>内部迭代</strong>： 以前对集合遍历都是通过Iterator或者For-Each的方式, 显式的在集合外部进行迭代， 这叫做外部迭代。 Stream提供了内部迭代的方式， 通过访问者模式(Visitor)实现。</li>\n</ul>\n<h3 id=\"生成流\">生成流</h3>\n<ul>\n<li>stream() -为集合创建串行流。</li>\n<li>parallelStream() − 为集合创建并行流。</li>\n<li><code>Stream.of()</code> 从一堆对象中创建 Stream 流</li>\n</ul>\n<h3 id=\"数据处理\">数据处理</h3>\n<h4 id=\"map\">map</h4>\n<blockquote>\n<p>用于映射每个元素到对应的结果，可对当前元素进行数据处理</p>\n</blockquote>\n<h4 id=\"flatmap\">flatmap</h4>\n<blockquote>\n<p>将流的每个元素, 转换为其他对象的流,入参接受一个返回对象流的函数</p>\n</blockquote>\n<h4 id=\"filter（lamda表达式）\">filter（lamda表达式）</h4>\n<blockquote>\n<p>用于通过设置的条件过滤出元素(过滤条件对应的是留下的元素)</p>\n</blockquote>\n<h4 id=\"limit\">limit</h4>\n<blockquote>\n<p>用于获取指定数量的流</p>\n</blockquote>\n<h4 id=\"sorted\">sorted</h4>\n<blockquote>\n<p>用于对流进行排序，可以传入<strong>Comparator</strong>参数控制排序顺序</p>\n</blockquote>\n<h4 id=\"distinct\">distinct</h4>\n<blockquote>\n<p>用于消除流中的重复元素</p>\n</blockquote>\n<h4 id=\"isPrime\">isPrime()</h4>\n<blockquote>\n<p>用于检测是否是质数，是留下该元素</p>\n</blockquote>\n<h3 id=\"结束操作\">结束操作</h3>\n<h4 id=\"forEach-Consumer\">forEach(Consumer)</h4>\n<blockquote>\n<p>遍历迭代流中的每个元素，无返回值</p>\n</blockquote>\n<h4 id=\"forEachOrdered-Consumer\"><code>forEachOrdered(Consumer)</code></h4>\n<blockquote>\n<p>确保按照原始流的顺序执行。</p>\n</blockquote>\n<h4 id=\"collect-Collector\">collect(Collector)</h4>\n<blockquote>\n<p>使用 <code>Collector</code> 收集流元素到结果集合中</p>\n</blockquote>\n<h4 id=\"collect-Supplier-BiConsumer-BiConsumer\"><code>collect(Supplier, BiConsumer, BiConsumer)</code></h4>\n<blockquote>\n<p>收集流元素到结果集合中，第一个参数用于<strong>创建一个新的结果集合</strong>，第二个参数用于<strong>将下一个元素加入到现有结果合集中</strong>，第三个参数用于<strong>将两个结果合集合并</strong></p>\n</blockquote>\n<h2 id=\"匹配\">匹配</h2>\n<h4 id=\"allMatch-Predicate-：\"><code>allMatch(Predicate)</code> ：</h4>\n<blockquote>\n<p>如果流的每个元素根据提供的 <code>Predicate</code> 都返回 true 时，最终结果返回为 true。这个操作将会在第一个 false 之后短路，也就是不会在发生 false 之后继续执行计算。</p>\n</blockquote>\n<h4 id=\"anyMatch-Predicate-：\"><code>anyMatch(Predicate)</code>：</h4>\n<blockquote>\n<p>如果流中的任意一个元素根据提供的 <code>Predicate</code> 返回 true 时，最终结果返回为 true。这个操作将会在第一个 true 之后短路，也就是不会在发生 true 之后继续执行计算。</p>\n</blockquote>\n<h4 id=\"noneMatch-Predicate-：\"><code>noneMatch(Predicate)</code>：</h4>\n<blockquote>\n<p>如果流的每个元素根据提供的 <code>Predicate</code> 都返回 false 时，最终结果返回为 true。这个操作将会在第一个 true 之后短路，也就是不会在发生 true 之后继续执行计算。</p>\n</blockquote>\n"},{"title":"ThreadLocal","date":"2023-05-27T11:29:23.000Z","lastmod":"2023-05-29T14:47:04.000Z","_content":"\n# ThreadLocal\n\n## ThreadLocal\n\n　　ThreadLocal 提供线程局部变量，即为使用相同变量的每一个线程维护一个该变量的副本。当某些数据是以线程为作用域并且不同线程具有不同的数据副本的时候，就可以考虑采用 ThreadLocal，比如数据库连接 Connection，每个请求处理线程都需要，但又不相互影响，就是用 ThreadLocal 实现。\n\n### 为何要Entry使用用弱引用\n\n　　如果使用强引用,情况会如下:\n\n* ThreadLocalMap 作为 Thread 的成员变量,会随 Thread 一直保留。\n* ThreadLocalMap 的 key 是 ThreadLocal 对象,如果使用强引用,ThreadLocal 对象会被 ThreadLocalMap 强引用,无法被回收。\n* 而 ThreadLocal 对象可能是唯一对某个对象的引用,这会导致这个对象也无法被回收,发生内存泄露。\n\n　　使用弱引用可以避免这种情况:\n\n* 当 ThreadLocal 对象没有其他强引用时,由于 ThreadLocalMap 中的引用是弱引用,ThreadLocal 对象仍然可以被垃圾回收。\n* 垃圾回收 ThreadLocal 对象后,ThreadLocalMap 中对应的 Entry 的 key 变为 null。\n* 之后 ThreadLocalMap 在执行 get、set、remove 等操作时,会忽略 key 为 null 的 Entry,达到清理作用。\n* 这样就避免了 ThreadLocal 对象由于 ThreadLocalMap 的强引用而无法被回收的问题,解决了内存泄露。\n\n### ThreadLocal 内存泄漏条件\n\n　　ThreadLocal被回收&&线程被复用&&线程复用后不再调用ThreadLocal的set/get/remove方法 才可能 发生内存泄露（条件还是相对苛刻）\n","source":"_posts/java/Base/ThreadLocal.md","raw":"---\ntitle: ThreadLocal\ndate: 2023-05-27T19:29:23Z\nlastmod: 2023-05-29T22:47:04Z\n---\n\n# ThreadLocal\n\n## ThreadLocal\n\n　　ThreadLocal 提供线程局部变量，即为使用相同变量的每一个线程维护一个该变量的副本。当某些数据是以线程为作用域并且不同线程具有不同的数据副本的时候，就可以考虑采用 ThreadLocal，比如数据库连接 Connection，每个请求处理线程都需要，但又不相互影响，就是用 ThreadLocal 实现。\n\n### 为何要Entry使用用弱引用\n\n　　如果使用强引用,情况会如下:\n\n* ThreadLocalMap 作为 Thread 的成员变量,会随 Thread 一直保留。\n* ThreadLocalMap 的 key 是 ThreadLocal 对象,如果使用强引用,ThreadLocal 对象会被 ThreadLocalMap 强引用,无法被回收。\n* 而 ThreadLocal 对象可能是唯一对某个对象的引用,这会导致这个对象也无法被回收,发生内存泄露。\n\n　　使用弱引用可以避免这种情况:\n\n* 当 ThreadLocal 对象没有其他强引用时,由于 ThreadLocalMap 中的引用是弱引用,ThreadLocal 对象仍然可以被垃圾回收。\n* 垃圾回收 ThreadLocal 对象后,ThreadLocalMap 中对应的 Entry 的 key 变为 null。\n* 之后 ThreadLocalMap 在执行 get、set、remove 等操作时,会忽略 key 为 null 的 Entry,达到清理作用。\n* 这样就避免了 ThreadLocal 对象由于 ThreadLocalMap 的强引用而无法被回收的问题,解决了内存泄露。\n\n### ThreadLocal 内存泄漏条件\n\n　　ThreadLocal被回收&&线程被复用&&线程复用后不再调用ThreadLocal的set/get/remove方法 才可能 发生内存泄露（条件还是相对苛刻）\n","slug":"java-Base-ThreadLocal","published":1,"updated":"2025-04-22T02:21:59.463Z","comments":1,"layout":"post","photos":[],"_id":"cm9s3f40f002sbfg44me58uks","content":"<h1>ThreadLocal</h1>\n<h2 id=\"ThreadLocal\">ThreadLocal</h2>\n<p>ThreadLocal 提供线程局部变量，即为使用相同变量的每一个线程维护一个该变量的副本。当某些数据是以线程为作用域并且不同线程具有不同的数据副本的时候，就可以考虑采用 ThreadLocal，比如数据库连接 Connection，每个请求处理线程都需要，但又不相互影响，就是用 ThreadLocal 实现。</p>\n<h3 id=\"为何要Entry使用用弱引用\">为何要Entry使用用弱引用</h3>\n<p>如果使用强引用,情况会如下:</p>\n<ul>\n<li>ThreadLocalMap 作为 Thread 的成员变量,会随 Thread 一直保留。</li>\n<li>ThreadLocalMap 的 key 是 ThreadLocal 对象,如果使用强引用,ThreadLocal 对象会被 ThreadLocalMap 强引用,无法被回收。</li>\n<li>而 ThreadLocal 对象可能是唯一对某个对象的引用,这会导致这个对象也无法被回收,发生内存泄露。</li>\n</ul>\n<p>使用弱引用可以避免这种情况:</p>\n<ul>\n<li>当 ThreadLocal 对象没有其他强引用时,由于 ThreadLocalMap 中的引用是弱引用,ThreadLocal 对象仍然可以被垃圾回收。</li>\n<li>垃圾回收 ThreadLocal 对象后,ThreadLocalMap 中对应的 Entry 的 key 变为 null。</li>\n<li>之后 ThreadLocalMap 在执行 get、set、remove 等操作时,会忽略 key 为 null 的 Entry,达到清理作用。</li>\n<li>这样就避免了 ThreadLocal 对象由于 ThreadLocalMap 的强引用而无法被回收的问题,解决了内存泄露。</li>\n</ul>\n<h3 id=\"ThreadLocal-内存泄漏条件\">ThreadLocal 内存泄漏条件</h3>\n<p>ThreadLocal被回收&amp;&amp;线程被复用&amp;&amp;线程复用后不再调用ThreadLocal的set/get/remove方法 才可能 发生内存泄露（条件还是相对苛刻）</p>\n","excerpt":"","more":"<h1>ThreadLocal</h1>\n<h2 id=\"ThreadLocal\">ThreadLocal</h2>\n<p>ThreadLocal 提供线程局部变量，即为使用相同变量的每一个线程维护一个该变量的副本。当某些数据是以线程为作用域并且不同线程具有不同的数据副本的时候，就可以考虑采用 ThreadLocal，比如数据库连接 Connection，每个请求处理线程都需要，但又不相互影响，就是用 ThreadLocal 实现。</p>\n<h3 id=\"为何要Entry使用用弱引用\">为何要Entry使用用弱引用</h3>\n<p>如果使用强引用,情况会如下:</p>\n<ul>\n<li>ThreadLocalMap 作为 Thread 的成员变量,会随 Thread 一直保留。</li>\n<li>ThreadLocalMap 的 key 是 ThreadLocal 对象,如果使用强引用,ThreadLocal 对象会被 ThreadLocalMap 强引用,无法被回收。</li>\n<li>而 ThreadLocal 对象可能是唯一对某个对象的引用,这会导致这个对象也无法被回收,发生内存泄露。</li>\n</ul>\n<p>使用弱引用可以避免这种情况:</p>\n<ul>\n<li>当 ThreadLocal 对象没有其他强引用时,由于 ThreadLocalMap 中的引用是弱引用,ThreadLocal 对象仍然可以被垃圾回收。</li>\n<li>垃圾回收 ThreadLocal 对象后,ThreadLocalMap 中对应的 Entry 的 key 变为 null。</li>\n<li>之后 ThreadLocalMap 在执行 get、set、remove 等操作时,会忽略 key 为 null 的 Entry,达到清理作用。</li>\n<li>这样就避免了 ThreadLocal 对象由于 ThreadLocalMap 的强引用而无法被回收的问题,解决了内存泄露。</li>\n</ul>\n<h3 id=\"ThreadLocal-内存泄漏条件\">ThreadLocal 内存泄漏条件</h3>\n<p>ThreadLocal被回收&amp;&amp;线程被复用&amp;&amp;线程复用后不再调用ThreadLocal的set/get/remove方法 才可能 发生内存泄露（条件还是相对苛刻）</p>\n"},{"title":"Volatile","date":"2022-10-30T05:27:45.000Z","lastmod":"2023-05-27T10:46:40.000Z","_content":"\n# Volatile\n\n## Volatile的可见性和指令重排是如何实现的.内存模型的相关概念\n\n### 内存模型\n\n　　计算机在执行程序过程中，每条指令都是在CPU中执行的，而在执行过程中，程序的临时数据是放在主内存上的，此时就存在一个问题，CPU执行速度很快，从内存中读取和写入数据相比于CPU执行指令的速度慢很多，因此如果任何数据操作都需要和内存交互进行，会大大降低指令执行速度，因为在CPU中引入的高速缓存。\n也就是说当程序在运行过程中会先将运算的数据从主存中复制一份到CPU高速缓存中，CPU直接从高速缓存中获取数据和写入数据，运算结束后在将高速缓存中的数据刷新到内存中。这种操作在单核CPU中没有问题，但是在多核CPU中就存在问题。\n**例如**\n\n```java\ni = i + 1;\n```\n\n　　如果同时有2个线程执行这段代码，假如初始时i的值为0，那么我们希望两个线程执行完之后i的值变为2。但是事实会是这样吗？  \n可能存在下面一种情况：初始时，两个线程分别读取i的值存入各自所在的CPU的高速缓存当中，然后线程1进行加1操作，然后把i的最新值1写入到内存。此时线程2的高速缓存当中i的值还是0，进行加1操作之后，i的值为1，然后线程2把i的值写入内存。  \n最终结果i的值是1，而不是2。这就是著名的缓存一致性问题。通常称这种被多个线程访问的变量为共享变量。  \n也就是说，如果一个变量在多个CPU中都存在缓存（一般在多线程编程时才会出现），那么就可能存在缓存不一致的问题。  \n为了解决缓存不一致性问题，通常来说有以下2种解决方法（硬件层面上提供）：  \n1）通过在总线加LOCK​锁的方式\n\n　　​2）通过缓存一致性协议​​在早期的CPU当中，是通过在总线上加LOCK​锁的形式来解决缓存不一致的问题。因为CPU和其他部件进行通信都是通过总线来进行的，如果对总线加LOCK​锁的话，也就是说阻塞了其他CPU对其他部件访问（如内存），从而使得只能有一个CPU能使用这个变量的内存。比如上面例子中 如果一个线程在执行 i = i +1，如果在执行这段代码的过程中，在总线上发出了LCOK​锁的信号，那么只有等待这段代码完全执行完毕之后，其他CPU才能从变量i所在的内存读取变量，然后进行相应的操作。这样就解决了缓存不一致的问题。  \n但是上面的方式会有一个问题，由于在锁住总线期间，其他CPU无法访问内存，导致效率低下。  \n所以就出现了缓存一致性协议。最出名的就是Intel 的MESI协议，MESI协议保证了每个缓存中使用的共享变量的副本是一致的。它核心的思想是：当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。\n\n![](/assets/net-img-1639574230606-ee713d6a-1223-4275-bfaa-f60258aa6eea-20221030132914-2yfiwaf.jpeg)\n\n### Java内存模型\n\n> Java内存模型规定所有的变量都是存在主存当中（类似于前面说的物理内存），每个线程都有自己的工作内存（类似于前面的高速缓存）。线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作。并且每个线程不能访问其他线程的工作内存。\n\n#### java为确保原子性、可见性、有序性\n\n1. 原子性\n\n　　java中对基本类型的变量的读取和赋值操作是原子性的\n\n```java\nx = 10;         //语句1\ny = x;         //语句2\nx++;           //语句3\nx = x + 1;     //语句4\n```\n\n　　除了语句1之外都非原子性操作\n语句1是直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中。\n语句2实际上包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及 将x的值写入工作内存 这2个操作都是原子性操作，但是合起来就不是原子性操作了。\n同样的，x++和 x = x+1包括3个操作：读取x的值，进行加1操作，写入新的值。\n\n　　**注 **\n\n> **jvm32位 对于64位的基础类型long和double不是原子操作，而是分成两个32位操作**\n> **jvm64位 jdk8 未确定是否是分成两次操作，测试验证64位并未出现long和double非原子性问题**\n\n2. 可见性\n\n　　当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。\n而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。\n另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。\n\n3. 有序性\n\n　　在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。\n在Java里面，可以通过volatile关键字来保证一定的“有序性”（具体原理在下一节讲述）。另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。\n另外，Java内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为 happens-before 原则。如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。\n下面就来具体介绍下happens-before原则（先行发生原则）：\n\n- 程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作\n- 锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作\n- volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作\n- 传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C\n- 线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作\n- 线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生\n- 线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行\n- 对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始\n\n### volatile关键字\n\n1. **volatile关键字的两层语义**\n\n　　一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：\n1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。\n2）禁止进行指令重排序。\n\n> 用volatile修饰之后\n> 第一：使用volatile关键字会强制将修改的值立即写入主存；\n> 第二：使用volatile关键字的话，当线程2进行修改时，会导致线程1的工作内存中缓存变量stop的缓存行无效（反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效）；\n> 第三：由于线程1的工作内存中缓存变量stop的缓存行无效，所以线程1再次读取变量stop的值时会去主存读取。\n\n2. **volatile保证原子性吗**\n3. **volatile能保证有序性吗**\n4. **volatile的原理和实现机制**\n\n　　《深入理解Java虚拟机》：“观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令”  \nlock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能：  \n1）它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；  \n2）它会强制将对缓存的修改操作立即写入主存；  \n3）如果是写操作，它会导致其他CPU中对应的缓存行无效。  \n**参考**[https://www.cnblogs.com/dolphin0520/p/3920373.html](https://www.cnblogs.com/dolphin0520/p/3920373.html)\n\n　　[https://www.zhihu.com/question/296949412/answer/747494794](https://www.zhihu.com/question/296949412/answer/747494794)\n\n　　[https://blog.csdn.net/wll1228/article/details/107775976](https://blog.csdn.net/wll1228/article/details/107775976)\n\n　　‍\n","source":"_posts/java/Base/Volatile.md","raw":"---\ntitle: Volatile\ndate: 2022-10-30T13:27:45Z\nlastmod: 2023-05-27T18:46:40Z\n---\n\n# Volatile\n\n## Volatile的可见性和指令重排是如何实现的.内存模型的相关概念\n\n### 内存模型\n\n　　计算机在执行程序过程中，每条指令都是在CPU中执行的，而在执行过程中，程序的临时数据是放在主内存上的，此时就存在一个问题，CPU执行速度很快，从内存中读取和写入数据相比于CPU执行指令的速度慢很多，因此如果任何数据操作都需要和内存交互进行，会大大降低指令执行速度，因为在CPU中引入的高速缓存。\n也就是说当程序在运行过程中会先将运算的数据从主存中复制一份到CPU高速缓存中，CPU直接从高速缓存中获取数据和写入数据，运算结束后在将高速缓存中的数据刷新到内存中。这种操作在单核CPU中没有问题，但是在多核CPU中就存在问题。\n**例如**\n\n```java\ni = i + 1;\n```\n\n　　如果同时有2个线程执行这段代码，假如初始时i的值为0，那么我们希望两个线程执行完之后i的值变为2。但是事实会是这样吗？  \n可能存在下面一种情况：初始时，两个线程分别读取i的值存入各自所在的CPU的高速缓存当中，然后线程1进行加1操作，然后把i的最新值1写入到内存。此时线程2的高速缓存当中i的值还是0，进行加1操作之后，i的值为1，然后线程2把i的值写入内存。  \n最终结果i的值是1，而不是2。这就是著名的缓存一致性问题。通常称这种被多个线程访问的变量为共享变量。  \n也就是说，如果一个变量在多个CPU中都存在缓存（一般在多线程编程时才会出现），那么就可能存在缓存不一致的问题。  \n为了解决缓存不一致性问题，通常来说有以下2种解决方法（硬件层面上提供）：  \n1）通过在总线加LOCK​锁的方式\n\n　　​2）通过缓存一致性协议​​在早期的CPU当中，是通过在总线上加LOCK​锁的形式来解决缓存不一致的问题。因为CPU和其他部件进行通信都是通过总线来进行的，如果对总线加LOCK​锁的话，也就是说阻塞了其他CPU对其他部件访问（如内存），从而使得只能有一个CPU能使用这个变量的内存。比如上面例子中 如果一个线程在执行 i = i +1，如果在执行这段代码的过程中，在总线上发出了LCOK​锁的信号，那么只有等待这段代码完全执行完毕之后，其他CPU才能从变量i所在的内存读取变量，然后进行相应的操作。这样就解决了缓存不一致的问题。  \n但是上面的方式会有一个问题，由于在锁住总线期间，其他CPU无法访问内存，导致效率低下。  \n所以就出现了缓存一致性协议。最出名的就是Intel 的MESI协议，MESI协议保证了每个缓存中使用的共享变量的副本是一致的。它核心的思想是：当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。\n\n![](/assets/net-img-1639574230606-ee713d6a-1223-4275-bfaa-f60258aa6eea-20221030132914-2yfiwaf.jpeg)\n\n### Java内存模型\n\n> Java内存模型规定所有的变量都是存在主存当中（类似于前面说的物理内存），每个线程都有自己的工作内存（类似于前面的高速缓存）。线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作。并且每个线程不能访问其他线程的工作内存。\n\n#### java为确保原子性、可见性、有序性\n\n1. 原子性\n\n　　java中对基本类型的变量的读取和赋值操作是原子性的\n\n```java\nx = 10;         //语句1\ny = x;         //语句2\nx++;           //语句3\nx = x + 1;     //语句4\n```\n\n　　除了语句1之外都非原子性操作\n语句1是直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中。\n语句2实际上包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及 将x的值写入工作内存 这2个操作都是原子性操作，但是合起来就不是原子性操作了。\n同样的，x++和 x = x+1包括3个操作：读取x的值，进行加1操作，写入新的值。\n\n　　**注 **\n\n> **jvm32位 对于64位的基础类型long和double不是原子操作，而是分成两个32位操作**\n> **jvm64位 jdk8 未确定是否是分成两次操作，测试验证64位并未出现long和double非原子性问题**\n\n2. 可见性\n\n　　当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。\n而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。\n另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。\n\n3. 有序性\n\n　　在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。\n在Java里面，可以通过volatile关键字来保证一定的“有序性”（具体原理在下一节讲述）。另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。\n另外，Java内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为 happens-before 原则。如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。\n下面就来具体介绍下happens-before原则（先行发生原则）：\n\n- 程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作\n- 锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作\n- volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作\n- 传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C\n- 线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作\n- 线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生\n- 线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行\n- 对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始\n\n### volatile关键字\n\n1. **volatile关键字的两层语义**\n\n　　一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：\n1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。\n2）禁止进行指令重排序。\n\n> 用volatile修饰之后\n> 第一：使用volatile关键字会强制将修改的值立即写入主存；\n> 第二：使用volatile关键字的话，当线程2进行修改时，会导致线程1的工作内存中缓存变量stop的缓存行无效（反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效）；\n> 第三：由于线程1的工作内存中缓存变量stop的缓存行无效，所以线程1再次读取变量stop的值时会去主存读取。\n\n2. **volatile保证原子性吗**\n3. **volatile能保证有序性吗**\n4. **volatile的原理和实现机制**\n\n　　《深入理解Java虚拟机》：“观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令”  \nlock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能：  \n1）它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；  \n2）它会强制将对缓存的修改操作立即写入主存；  \n3）如果是写操作，它会导致其他CPU中对应的缓存行无效。  \n**参考**[https://www.cnblogs.com/dolphin0520/p/3920373.html](https://www.cnblogs.com/dolphin0520/p/3920373.html)\n\n　　[https://www.zhihu.com/question/296949412/answer/747494794](https://www.zhihu.com/question/296949412/answer/747494794)\n\n　　[https://blog.csdn.net/wll1228/article/details/107775976](https://blog.csdn.net/wll1228/article/details/107775976)\n\n　　‍\n","slug":"java-Base-Volatile","published":1,"updated":"2025-04-22T07:27:29.941Z","_id":"cm9s3f40g002tbfg47ps2fa45","comments":1,"layout":"post","photos":[],"content":"<h1>Volatile</h1>\n<h2 id=\"Volatile的可见性和指令重排是如何实现的-内存模型的相关概念\">Volatile的可见性和指令重排是如何实现的.内存模型的相关概念</h2>\n<h3 id=\"内存模型\">内存模型</h3>\n<p>计算机在执行程序过程中，每条指令都是在CPU中执行的，而在执行过程中，程序的临时数据是放在主内存上的，此时就存在一个问题，CPU执行速度很快，从内存中读取和写入数据相比于CPU执行指令的速度慢很多，因此如果任何数据操作都需要和内存交互进行，会大大降低指令执行速度，因为在CPU中引入的高速缓存。<br>\n也就是说当程序在运行过程中会先将运算的数据从主存中复制一份到CPU高速缓存中，CPU直接从高速缓存中获取数据和写入数据，运算结束后在将高速缓存中的数据刷新到内存中。这种操作在单核CPU中没有问题，但是在多核CPU中就存在问题。<br>\n<strong>例如</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">i = i + <span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\n<p>如果同时有2个线程执行这段代码，假如初始时i的值为0，那么我们希望两个线程执行完之后i的值变为2。但是事实会是这样吗？<br>\n可能存在下面一种情况：初始时，两个线程分别读取i的值存入各自所在的CPU的高速缓存当中，然后线程1进行加1操作，然后把i的最新值1写入到内存。此时线程2的高速缓存当中i的值还是0，进行加1操作之后，i的值为1，然后线程2把i的值写入内存。<br>\n最终结果i的值是1，而不是2。这就是著名的缓存一致性问题。通常称这种被多个线程访问的变量为共享变量。<br>\n也就是说，如果一个变量在多个CPU中都存在缓存（一般在多线程编程时才会出现），那么就可能存在缓存不一致的问题。<br>\n为了解决缓存不一致性问题，通常来说有以下2种解决方法（硬件层面上提供）：<br>\n1）通过在总线加LOCK​锁的方式</p>\n<p>​2）通过缓存一致性协议​​在早期的CPU当中，是通过在总线上加LOCK​锁的形式来解决缓存不一致的问题。因为CPU和其他部件进行通信都是通过总线来进行的，如果对总线加LOCK​锁的话，也就是说阻塞了其他CPU对其他部件访问（如内存），从而使得只能有一个CPU能使用这个变量的内存。比如上面例子中 如果一个线程在执行 i = i +1，如果在执行这段代码的过程中，在总线上发出了LCOK​锁的信号，那么只有等待这段代码完全执行完毕之后，其他CPU才能从变量i所在的内存读取变量，然后进行相应的操作。这样就解决了缓存不一致的问题。<br>\n但是上面的方式会有一个问题，由于在锁住总线期间，其他CPU无法访问内存，导致效率低下。<br>\n所以就出现了缓存一致性协议。最出名的就是Intel 的MESI协议，MESI协议保证了每个缓存中使用的共享变量的副本是一致的。它核心的思想是：当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。</p>\n<p><img src=\"/assets/net-img-1639574230606-ee713d6a-1223-4275-bfaa-f60258aa6eea-20221030132914-2yfiwaf.jpeg\" alt=\"\"></p>\n<h3 id=\"Java内存模型\">Java内存模型</h3>\n<blockquote>\n<p>Java内存模型规定所有的变量都是存在主存当中（类似于前面说的物理内存），每个线程都有自己的工作内存（类似于前面的高速缓存）。线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作。并且每个线程不能访问其他线程的工作内存。</p>\n</blockquote>\n<h4 id=\"java为确保原子性、可见性、有序性\">java为确保原子性、可见性、有序性</h4>\n<ol>\n<li>原子性</li>\n</ol>\n<p>java中对基本类型的变量的读取和赋值操作是原子性的</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x = <span class=\"number\">10</span>;         <span class=\"comment\">//语句1</span></span><br><span class=\"line\">y = x;         <span class=\"comment\">//语句2</span></span><br><span class=\"line\">x++;           <span class=\"comment\">//语句3</span></span><br><span class=\"line\">x = x + <span class=\"number\">1</span>;     <span class=\"comment\">//语句4</span></span><br></pre></td></tr></table></figure>\n<p>除了语句1之外都非原子性操作<br>\n语句1是直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中。<br>\n语句2实际上包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及 将x的值写入工作内存 这2个操作都是原子性操作，但是合起来就不是原子性操作了。<br>\n同样的，x++和 x = x+1包括3个操作：读取x的值，进行加1操作，写入新的值。</p>\n<p>**注 **</p>\n<blockquote>\n<p><strong>jvm32位 对于64位的基础类型long和double不是原子操作，而是分成两个32位操作</strong><br>\n<strong>jvm64位 jdk8 未确定是否是分成两次操作，测试验证64位并未出现long和double非原子性问题</strong></p>\n</blockquote>\n<ol start=\"2\">\n<li>可见性</li>\n</ol>\n<p>当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。<br>\n而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。<br>\n另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。</p>\n<ol start=\"3\">\n<li>有序性</li>\n</ol>\n<p>在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。<br>\n在Java里面，可以通过volatile关键字来保证一定的“有序性”（具体原理在下一节讲述）。另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。<br>\n另外，Java内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为 happens-before 原则。如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。<br>\n下面就来具体介绍下happens-before原则（先行发生原则）：</p>\n<ul>\n<li>程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作</li>\n<li>锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作</li>\n<li>volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作</li>\n<li>传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C</li>\n<li>线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作</li>\n<li>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生</li>\n<li>线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行</li>\n<li>对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始</li>\n</ul>\n<h3 id=\"volatile关键字\">volatile关键字</h3>\n<ol>\n<li><strong>volatile关键字的两层语义</strong></li>\n</ol>\n<p>一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：<br>\n1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。<br>\n2）禁止进行指令重排序。</p>\n<blockquote>\n<p>用volatile修饰之后<br>\n第一：使用volatile关键字会强制将修改的值立即写入主存；<br>\n第二：使用volatile关键字的话，当线程2进行修改时，会导致线程1的工作内存中缓存变量stop的缓存行无效（反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效）；<br>\n第三：由于线程1的工作内存中缓存变量stop的缓存行无效，所以线程1再次读取变量stop的值时会去主存读取。</p>\n</blockquote>\n<ol start=\"2\">\n<li><strong>volatile保证原子性吗</strong></li>\n<li><strong>volatile能保证有序性吗</strong></li>\n<li><strong>volatile的原理和实现机制</strong></li>\n</ol>\n<p>《深入理解Java虚拟机》：“观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令”<br>\nlock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能：<br>\n1）它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；<br>\n2）它会强制将对缓存的修改操作立即写入主存；<br>\n3）如果是写操作，它会导致其他CPU中对应的缓存行无效。<br>\n<strong>参考</strong><a href=\"https://www.cnblogs.com/dolphin0520/p/3920373.html\">https://www.cnblogs.com/dolphin0520/p/3920373.html</a></p>\n<p><a href=\"https://www.zhihu.com/question/296949412/answer/747494794\">https://www.zhihu.com/question/296949412/answer/747494794</a></p>\n<p><a href=\"https://blog.csdn.net/wll1228/article/details/107775976\">https://blog.csdn.net/wll1228/article/details/107775976</a></p>\n<p>‍</p>\n","excerpt":"","more":"<h1>Volatile</h1>\n<h2 id=\"Volatile的可见性和指令重排是如何实现的-内存模型的相关概念\">Volatile的可见性和指令重排是如何实现的.内存模型的相关概念</h2>\n<h3 id=\"内存模型\">内存模型</h3>\n<p>计算机在执行程序过程中，每条指令都是在CPU中执行的，而在执行过程中，程序的临时数据是放在主内存上的，此时就存在一个问题，CPU执行速度很快，从内存中读取和写入数据相比于CPU执行指令的速度慢很多，因此如果任何数据操作都需要和内存交互进行，会大大降低指令执行速度，因为在CPU中引入的高速缓存。<br>\n也就是说当程序在运行过程中会先将运算的数据从主存中复制一份到CPU高速缓存中，CPU直接从高速缓存中获取数据和写入数据，运算结束后在将高速缓存中的数据刷新到内存中。这种操作在单核CPU中没有问题，但是在多核CPU中就存在问题。<br>\n<strong>例如</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">i = i + <span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\n<p>如果同时有2个线程执行这段代码，假如初始时i的值为0，那么我们希望两个线程执行完之后i的值变为2。但是事实会是这样吗？<br>\n可能存在下面一种情况：初始时，两个线程分别读取i的值存入各自所在的CPU的高速缓存当中，然后线程1进行加1操作，然后把i的最新值1写入到内存。此时线程2的高速缓存当中i的值还是0，进行加1操作之后，i的值为1，然后线程2把i的值写入内存。<br>\n最终结果i的值是1，而不是2。这就是著名的缓存一致性问题。通常称这种被多个线程访问的变量为共享变量。<br>\n也就是说，如果一个变量在多个CPU中都存在缓存（一般在多线程编程时才会出现），那么就可能存在缓存不一致的问题。<br>\n为了解决缓存不一致性问题，通常来说有以下2种解决方法（硬件层面上提供）：<br>\n1）通过在总线加LOCK​锁的方式</p>\n<p>​2）通过缓存一致性协议​​在早期的CPU当中，是通过在总线上加LOCK​锁的形式来解决缓存不一致的问题。因为CPU和其他部件进行通信都是通过总线来进行的，如果对总线加LOCK​锁的话，也就是说阻塞了其他CPU对其他部件访问（如内存），从而使得只能有一个CPU能使用这个变量的内存。比如上面例子中 如果一个线程在执行 i = i +1，如果在执行这段代码的过程中，在总线上发出了LCOK​锁的信号，那么只有等待这段代码完全执行完毕之后，其他CPU才能从变量i所在的内存读取变量，然后进行相应的操作。这样就解决了缓存不一致的问题。<br>\n但是上面的方式会有一个问题，由于在锁住总线期间，其他CPU无法访问内存，导致效率低下。<br>\n所以就出现了缓存一致性协议。最出名的就是Intel 的MESI协议，MESI协议保证了每个缓存中使用的共享变量的副本是一致的。它核心的思想是：当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。</p>\n<p><img src=\"/assets/net-img-1639574230606-ee713d6a-1223-4275-bfaa-f60258aa6eea-20221030132914-2yfiwaf.jpeg\" alt=\"\"></p>\n<h3 id=\"Java内存模型\">Java内存模型</h3>\n<blockquote>\n<p>Java内存模型规定所有的变量都是存在主存当中（类似于前面说的物理内存），每个线程都有自己的工作内存（类似于前面的高速缓存）。线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作。并且每个线程不能访问其他线程的工作内存。</p>\n</blockquote>\n<h4 id=\"java为确保原子性、可见性、有序性\">java为确保原子性、可见性、有序性</h4>\n<ol>\n<li>原子性</li>\n</ol>\n<p>java中对基本类型的变量的读取和赋值操作是原子性的</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x = <span class=\"number\">10</span>;         <span class=\"comment\">//语句1</span></span><br><span class=\"line\">y = x;         <span class=\"comment\">//语句2</span></span><br><span class=\"line\">x++;           <span class=\"comment\">//语句3</span></span><br><span class=\"line\">x = x + <span class=\"number\">1</span>;     <span class=\"comment\">//语句4</span></span><br></pre></td></tr></table></figure>\n<p>除了语句1之外都非原子性操作<br>\n语句1是直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中。<br>\n语句2实际上包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及 将x的值写入工作内存 这2个操作都是原子性操作，但是合起来就不是原子性操作了。<br>\n同样的，x++和 x = x+1包括3个操作：读取x的值，进行加1操作，写入新的值。</p>\n<p>**注 **</p>\n<blockquote>\n<p><strong>jvm32位 对于64位的基础类型long和double不是原子操作，而是分成两个32位操作</strong><br>\n<strong>jvm64位 jdk8 未确定是否是分成两次操作，测试验证64位并未出现long和double非原子性问题</strong></p>\n</blockquote>\n<ol start=\"2\">\n<li>可见性</li>\n</ol>\n<p>当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。<br>\n而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。<br>\n另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。</p>\n<ol start=\"3\">\n<li>有序性</li>\n</ol>\n<p>在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。<br>\n在Java里面，可以通过volatile关键字来保证一定的“有序性”（具体原理在下一节讲述）。另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。<br>\n另外，Java内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为 happens-before 原则。如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。<br>\n下面就来具体介绍下happens-before原则（先行发生原则）：</p>\n<ul>\n<li>程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作</li>\n<li>锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作</li>\n<li>volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作</li>\n<li>传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C</li>\n<li>线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作</li>\n<li>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生</li>\n<li>线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行</li>\n<li>对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始</li>\n</ul>\n<h3 id=\"volatile关键字\">volatile关键字</h3>\n<ol>\n<li><strong>volatile关键字的两层语义</strong></li>\n</ol>\n<p>一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：<br>\n1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。<br>\n2）禁止进行指令重排序。</p>\n<blockquote>\n<p>用volatile修饰之后<br>\n第一：使用volatile关键字会强制将修改的值立即写入主存；<br>\n第二：使用volatile关键字的话，当线程2进行修改时，会导致线程1的工作内存中缓存变量stop的缓存行无效（反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效）；<br>\n第三：由于线程1的工作内存中缓存变量stop的缓存行无效，所以线程1再次读取变量stop的值时会去主存读取。</p>\n</blockquote>\n<ol start=\"2\">\n<li><strong>volatile保证原子性吗</strong></li>\n<li><strong>volatile能保证有序性吗</strong></li>\n<li><strong>volatile的原理和实现机制</strong></li>\n</ol>\n<p>《深入理解Java虚拟机》：“观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令”<br>\nlock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能：<br>\n1）它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；<br>\n2）它会强制将对缓存的修改操作立即写入主存；<br>\n3）如果是写操作，它会导致其他CPU中对应的缓存行无效。<br>\n<strong>参考</strong><a href=\"https://www.cnblogs.com/dolphin0520/p/3920373.html\">https://www.cnblogs.com/dolphin0520/p/3920373.html</a></p>\n<p><a href=\"https://www.zhihu.com/question/296949412/answer/747494794\">https://www.zhihu.com/question/296949412/answer/747494794</a></p>\n<p><a href=\"https://blog.csdn.net/wll1228/article/details/107775976\">https://blog.csdn.net/wll1228/article/details/107775976</a></p>\n<p>‍</p>\n"},{"title":"List","date":"2022-10-30T05:22:01.000Z","lastmod":"2023-05-27T07:43:26.000Z","_content":"\n# List\n\n---\n\n　　**List 集合的三个子类：**\n\n- ArrayList :底层数据结构是数组。线程不安全\n- LinkedList :底层数据结构是链表。线程不安全\n- Vector:底层数据结构是数组。线程安全\n\n## ArrayList\n\n### 简介\n\n- ArrayList 继承了 AbstractList，实现了 List。它是一个数组队列，提供了相关的添加、删除、修改、遍历等功能。\n- ArrayList 实现了 RandomAccess 接口， RandomAccess 是一个标志接口，表明实现这个这个接口的 List 集合是支持快速随机访问的。在 ArrayList 中，我们即可以通过元素的序号快速获取元素对象，这就是快速随机访问。\n- ArrayList 实现了 Cloneable 接口，即覆盖了函数 clone()，能被克隆。\n- ArrayList 实现 java.io.Serializable 接口，这意味着 ArrayList 支持序列化，能通过序列化去传输。\n- 和 Vector 不同，ArrayList 中的操作不是线程安全的！所以，建议在单线程中才使用 ArrayList，而在多线程中可以选择 Vector 或者 CopyOnWriteArrayList。\n\n### System.arraycopy()和 Arrays.copyOf()方法\n\n#### 两者联系与区别\n\n　　**联系：**\n\n　　看两者源代码可以发现 copyOf()内部调用了 System.arraycopy()方法\n\n　　**区别：**\n\n　　arraycopy()需要目标数组，将原数组拷贝到你自己定义的数组里，而且可以选择拷贝的起点和长度以及放入新数组中的位置\n\n　　copyOf()是系统自动在内部新建一个数组，并返回该数组。\n\n　　**注意的是：**\n\n- java 中的 length 属性是针对数组说的,比如说你声明了一个数组,想知道这个数组的长度则用到了 length 这个属性.\n- java 中的 length()方法是针对字 符串 String 说的,如果想看这个字符串的长度则用到 length()这个方法.\n- java 中的 size()方法是针对泛型集合说的,如果想看这个泛型有多少个元素,就调用此方法来查看!\n\n### 细节\n\n- ArrayList 是基于动态数组实现的，在增删时候，需要数组的拷贝复制。(navite 方法由 C/C++实现)\n- ArrayList 的默认初始化容量是 10，每次扩容时候增加原先容量的一半，也就是变为原来的 1.5 倍\n- 删除元素时不会减少容量，若希望减少容量则调用 trimToSize()\n- 它不是线程安全的。它能存放 null 值。\n\n## LinkedList\n\n### 简介\n\n> 底层实现是双向链表(双向链表方便实现往前遍历)\n> LinkedList 是一个实现了 List 接口和 Deque 接口的双端链表。 LinkedList 底层的链表结构使它支持高效的插入和删除操作，另外它实现了 Deque 接口，使得 LinkedList 类也具有队列的特性; LinkedList 不是线程安全的，如果想使 LinkedList 变成线程安全的，可以调用静态类 Collections 类中的 synchronizedList 方法：\n\n## Vector：\n\n- 底层是数组，现在已少用，被 ArrayList 替代，原因有两个：\n- Vector 所有方法都是同步，有性能损失。\n- Vector 初始 length 是 10 超过 length 时 以 100%比率增长，相比于 ArrayList 更多消耗内存。\n- ArrayList 在底层数组不够用时在原来的基础上扩展 0.5 倍，Vector 是扩展 1 倍。\n\n　　**总的来说：查询多用 ArrayList，增删多用 LinkedList。**\n\n　　ArrayList 增删慢不是绝对的(在数量大的情况下，已测试)：\n\n　　如果增加元素一直是使用 add()(增加到末尾)的话，那是 ArrayList 要快\n\n　　一直删除末尾的元素也是 ArrayList 要快【不用复制移动位置】\n\n　　至于如果删除的是中间的位置的话，还是 ArrayList 要快！\n\n## SkipList\n\n## CopyOnWriteArrayList\n\n　　‍\n\n### 适用场景\n\n* **读操作可以尽可能的快，而写即使慢一些也没关系**\n\n　　在很多应用场景中，读操作可能会远远多于写操作。比如，有些系统级别的信息，往往只需要加载或者修改很少的次数，但是会被系统内所有模块频繁的访问。对于这种场景，我们最希望看到的就是读操作可以尽可能的快，而写即使慢一些也没关系。\n\n* **读多写少**\n\n　　黑名单是最典型的场景，假如我们有一个搜索网站，用户在这个网站的搜索框中，输入关键字搜索内容，但是某些关键字不允许被搜索。这些不能被搜索的关键字会被放在一个黑名单中，黑名单并不需要实时更新，可能每天晚上更新一次就可以了。当用户搜索时，会检查当前关键字在不在黑名单中，如果在，则提示不能搜索。这种读多写少的场景也很适合使用 CopyOnWrite 集合。\n\n### 读写规则\n\n* **读写锁的规则**\n\n　　读写锁的思想是：读读共享、其他都互斥（写写互斥、读写互斥、写读互斥），原因是由于读操作不会修改原有的数据，因此并发读并不会有安全问题；而写操作是危险的，所以当写操作发生时，不允许有读操作加入，也不允许第二个写线程加入。\n\n* **对读写锁规则的升级**\n\n　　CopyOnWriteArrayList 的思想比读写锁的思想又更进一步。为了将读取的性能发挥到极致，CopyOnWriteArrayList 读取是完全不用加锁的，更厉害的是，**写入也不会阻塞读取操作，也就是说你可以在写入的同时进行读取**，只有写入和写入之间需要进行同步，也就是不允许多个写入同时发生，但是在写入发生时允许读取同时发生。这样一来，读操作的性能就会大幅度提升。\n\n### 特点\n\n* **CopyOnWrite的含义**\n\n　　从 CopyOnWriteArrayList 的名字就能看出它是满足 CopyOnWrite 的 ArrayList，CopyOnWrite 的意思是说，当容器需要被修改的时候，不直接修改当前容器，而是先将当前容器进行 Copy，复制出一个新的容器，然后修改新的容器，**完成修改之后，再将原容器的引用指向新的容器**。这样就完成了整个修改过程。\n\n　　这样做的好处是，CopyOnWriteArrayList 利用了“不变性”原理，因为容器每次修改都是创建新副本，所以对于旧容器来说，其实是不可变的，也是线程安全的，无需进一步的同步操作。我们可以对 CopyOnWrite 容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素，也不会有修改。\n\n　　CopyOnWriteArrayList 的所有修改操作（add，set等）都是通过创建底层数组的新副本来实现的，所以 CopyOnWrite 容器也是一种读写分离的思想体现，读和写使用不同的容器。\n\n* **迭代期间允许修改集合内容**\n\n　　ArrayList 在迭代期间如果修改集合的内容，会抛出 ConcurrentModificationException 异常。CopyOnWriteArrayList 的迭代器在迭代的时候，如果数组内容被修改了，CopyOnWriteArrayList 不会报 ConcurrentModificationException 的异常，因为迭代器使用的依然是旧数组，只不过迭代的内容可能已经过时了\n\n### 缺点\n\n　　这些缺点不仅是针对 CopyOnWriteArrayList，其实同样也适用于其他的 CopyOnWrite 容器：\n\n* **内存占用问题**\n\n　　因为 CopyOnWrite 的写时复制机制，所以在进行写操作的时候，内存里会同时驻扎两个对象的内存，这一点会占用额外的内存空间。\n\n* **在元素较多或者复杂的情况下，复制的开销很大**\n\n　　复制过程不仅会占用双倍内存，还需要消耗 CPU 等资源，会降低整体性能。\n\n* **数据一致性问题**\n\n　　由于 CopyOnWrite 容器的修改是先修改副本，所以这次修改对于其他线程来说，并不是实时能看到的，只有在修改完之后才能体现出来。如果你希望写入的的数据马上能被其他线程看到，CopyOnWrite 容器是不适用的。\n\n　　内部使用ReentrantLock 锁，用来保证修改操作的线程安全\n","source":"_posts/java/Collection/List.md","raw":"---\ntitle: List\ndate: 2022-10-30T13:22:01Z\nlastmod: 2023-05-27T15:43:26Z\n---\n\n# List\n\n---\n\n　　**List 集合的三个子类：**\n\n- ArrayList :底层数据结构是数组。线程不安全\n- LinkedList :底层数据结构是链表。线程不安全\n- Vector:底层数据结构是数组。线程安全\n\n## ArrayList\n\n### 简介\n\n- ArrayList 继承了 AbstractList，实现了 List。它是一个数组队列，提供了相关的添加、删除、修改、遍历等功能。\n- ArrayList 实现了 RandomAccess 接口， RandomAccess 是一个标志接口，表明实现这个这个接口的 List 集合是支持快速随机访问的。在 ArrayList 中，我们即可以通过元素的序号快速获取元素对象，这就是快速随机访问。\n- ArrayList 实现了 Cloneable 接口，即覆盖了函数 clone()，能被克隆。\n- ArrayList 实现 java.io.Serializable 接口，这意味着 ArrayList 支持序列化，能通过序列化去传输。\n- 和 Vector 不同，ArrayList 中的操作不是线程安全的！所以，建议在单线程中才使用 ArrayList，而在多线程中可以选择 Vector 或者 CopyOnWriteArrayList。\n\n### System.arraycopy()和 Arrays.copyOf()方法\n\n#### 两者联系与区别\n\n　　**联系：**\n\n　　看两者源代码可以发现 copyOf()内部调用了 System.arraycopy()方法\n\n　　**区别：**\n\n　　arraycopy()需要目标数组，将原数组拷贝到你自己定义的数组里，而且可以选择拷贝的起点和长度以及放入新数组中的位置\n\n　　copyOf()是系统自动在内部新建一个数组，并返回该数组。\n\n　　**注意的是：**\n\n- java 中的 length 属性是针对数组说的,比如说你声明了一个数组,想知道这个数组的长度则用到了 length 这个属性.\n- java 中的 length()方法是针对字 符串 String 说的,如果想看这个字符串的长度则用到 length()这个方法.\n- java 中的 size()方法是针对泛型集合说的,如果想看这个泛型有多少个元素,就调用此方法来查看!\n\n### 细节\n\n- ArrayList 是基于动态数组实现的，在增删时候，需要数组的拷贝复制。(navite 方法由 C/C++实现)\n- ArrayList 的默认初始化容量是 10，每次扩容时候增加原先容量的一半，也就是变为原来的 1.5 倍\n- 删除元素时不会减少容量，若希望减少容量则调用 trimToSize()\n- 它不是线程安全的。它能存放 null 值。\n\n## LinkedList\n\n### 简介\n\n> 底层实现是双向链表(双向链表方便实现往前遍历)\n> LinkedList 是一个实现了 List 接口和 Deque 接口的双端链表。 LinkedList 底层的链表结构使它支持高效的插入和删除操作，另外它实现了 Deque 接口，使得 LinkedList 类也具有队列的特性; LinkedList 不是线程安全的，如果想使 LinkedList 变成线程安全的，可以调用静态类 Collections 类中的 synchronizedList 方法：\n\n## Vector：\n\n- 底层是数组，现在已少用，被 ArrayList 替代，原因有两个：\n- Vector 所有方法都是同步，有性能损失。\n- Vector 初始 length 是 10 超过 length 时 以 100%比率增长，相比于 ArrayList 更多消耗内存。\n- ArrayList 在底层数组不够用时在原来的基础上扩展 0.5 倍，Vector 是扩展 1 倍。\n\n　　**总的来说：查询多用 ArrayList，增删多用 LinkedList。**\n\n　　ArrayList 增删慢不是绝对的(在数量大的情况下，已测试)：\n\n　　如果增加元素一直是使用 add()(增加到末尾)的话，那是 ArrayList 要快\n\n　　一直删除末尾的元素也是 ArrayList 要快【不用复制移动位置】\n\n　　至于如果删除的是中间的位置的话，还是 ArrayList 要快！\n\n## SkipList\n\n## CopyOnWriteArrayList\n\n　　‍\n\n### 适用场景\n\n* **读操作可以尽可能的快，而写即使慢一些也没关系**\n\n　　在很多应用场景中，读操作可能会远远多于写操作。比如，有些系统级别的信息，往往只需要加载或者修改很少的次数，但是会被系统内所有模块频繁的访问。对于这种场景，我们最希望看到的就是读操作可以尽可能的快，而写即使慢一些也没关系。\n\n* **读多写少**\n\n　　黑名单是最典型的场景，假如我们有一个搜索网站，用户在这个网站的搜索框中，输入关键字搜索内容，但是某些关键字不允许被搜索。这些不能被搜索的关键字会被放在一个黑名单中，黑名单并不需要实时更新，可能每天晚上更新一次就可以了。当用户搜索时，会检查当前关键字在不在黑名单中，如果在，则提示不能搜索。这种读多写少的场景也很适合使用 CopyOnWrite 集合。\n\n### 读写规则\n\n* **读写锁的规则**\n\n　　读写锁的思想是：读读共享、其他都互斥（写写互斥、读写互斥、写读互斥），原因是由于读操作不会修改原有的数据，因此并发读并不会有安全问题；而写操作是危险的，所以当写操作发生时，不允许有读操作加入，也不允许第二个写线程加入。\n\n* **对读写锁规则的升级**\n\n　　CopyOnWriteArrayList 的思想比读写锁的思想又更进一步。为了将读取的性能发挥到极致，CopyOnWriteArrayList 读取是完全不用加锁的，更厉害的是，**写入也不会阻塞读取操作，也就是说你可以在写入的同时进行读取**，只有写入和写入之间需要进行同步，也就是不允许多个写入同时发生，但是在写入发生时允许读取同时发生。这样一来，读操作的性能就会大幅度提升。\n\n### 特点\n\n* **CopyOnWrite的含义**\n\n　　从 CopyOnWriteArrayList 的名字就能看出它是满足 CopyOnWrite 的 ArrayList，CopyOnWrite 的意思是说，当容器需要被修改的时候，不直接修改当前容器，而是先将当前容器进行 Copy，复制出一个新的容器，然后修改新的容器，**完成修改之后，再将原容器的引用指向新的容器**。这样就完成了整个修改过程。\n\n　　这样做的好处是，CopyOnWriteArrayList 利用了“不变性”原理，因为容器每次修改都是创建新副本，所以对于旧容器来说，其实是不可变的，也是线程安全的，无需进一步的同步操作。我们可以对 CopyOnWrite 容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素，也不会有修改。\n\n　　CopyOnWriteArrayList 的所有修改操作（add，set等）都是通过创建底层数组的新副本来实现的，所以 CopyOnWrite 容器也是一种读写分离的思想体现，读和写使用不同的容器。\n\n* **迭代期间允许修改集合内容**\n\n　　ArrayList 在迭代期间如果修改集合的内容，会抛出 ConcurrentModificationException 异常。CopyOnWriteArrayList 的迭代器在迭代的时候，如果数组内容被修改了，CopyOnWriteArrayList 不会报 ConcurrentModificationException 的异常，因为迭代器使用的依然是旧数组，只不过迭代的内容可能已经过时了\n\n### 缺点\n\n　　这些缺点不仅是针对 CopyOnWriteArrayList，其实同样也适用于其他的 CopyOnWrite 容器：\n\n* **内存占用问题**\n\n　　因为 CopyOnWrite 的写时复制机制，所以在进行写操作的时候，内存里会同时驻扎两个对象的内存，这一点会占用额外的内存空间。\n\n* **在元素较多或者复杂的情况下，复制的开销很大**\n\n　　复制过程不仅会占用双倍内存，还需要消耗 CPU 等资源，会降低整体性能。\n\n* **数据一致性问题**\n\n　　由于 CopyOnWrite 容器的修改是先修改副本，所以这次修改对于其他线程来说，并不是实时能看到的，只有在修改完之后才能体现出来。如果你希望写入的的数据马上能被其他线程看到，CopyOnWrite 容器是不适用的。\n\n　　内部使用ReentrantLock 锁，用来保证修改操作的线程安全\n","slug":"java-Collection-List","published":1,"updated":"2025-04-22T02:21:59.463Z","comments":1,"layout":"post","photos":[],"_id":"cm9s3f40g002ubfg45fj24j57","content":"<h1>List</h1>\n<hr>\n<p><strong>List 集合的三个子类：</strong></p>\n<ul>\n<li>ArrayList :底层数据结构是数组。线程不安全</li>\n<li>LinkedList :底层数据结构是链表。线程不安全</li>\n<li>Vector:底层数据结构是数组。线程安全</li>\n</ul>\n<h2 id=\"ArrayList\">ArrayList</h2>\n<h3 id=\"简介\">简介</h3>\n<ul>\n<li>ArrayList 继承了 AbstractList，实现了 List。它是一个数组队列，提供了相关的添加、删除、修改、遍历等功能。</li>\n<li>ArrayList 实现了 RandomAccess 接口， RandomAccess 是一个标志接口，表明实现这个这个接口的 List 集合是支持快速随机访问的。在 ArrayList 中，我们即可以通过元素的序号快速获取元素对象，这就是快速随机访问。</li>\n<li>ArrayList 实现了 Cloneable 接口，即覆盖了函数 clone()，能被克隆。</li>\n<li>ArrayList 实现 java.io.Serializable 接口，这意味着 ArrayList 支持序列化，能通过序列化去传输。</li>\n<li>和 Vector 不同，ArrayList 中的操作不是线程安全的！所以，建议在单线程中才使用 ArrayList，而在多线程中可以选择 Vector 或者 CopyOnWriteArrayList。</li>\n</ul>\n<h3 id=\"System-arraycopy-和-Arrays-copyOf-方法\">System.arraycopy()和 Arrays.copyOf()方法</h3>\n<h4 id=\"两者联系与区别\">两者联系与区别</h4>\n<p><strong>联系：</strong></p>\n<p>看两者源代码可以发现 copyOf()内部调用了 System.arraycopy()方法</p>\n<p><strong>区别：</strong></p>\n<p>arraycopy()需要目标数组，将原数组拷贝到你自己定义的数组里，而且可以选择拷贝的起点和长度以及放入新数组中的位置</p>\n<p>copyOf()是系统自动在内部新建一个数组，并返回该数组。</p>\n<p><strong>注意的是：</strong></p>\n<ul>\n<li>java 中的 length 属性是针对数组说的,比如说你声明了一个数组,想知道这个数组的长度则用到了 length 这个属性.</li>\n<li>java 中的 length()方法是针对字 符串 String 说的,如果想看这个字符串的长度则用到 length()这个方法.</li>\n<li>java 中的 size()方法是针对泛型集合说的,如果想看这个泛型有多少个元素,就调用此方法来查看!</li>\n</ul>\n<h3 id=\"细节\">细节</h3>\n<ul>\n<li>ArrayList 是基于动态数组实现的，在增删时候，需要数组的拷贝复制。(navite 方法由 C/C++实现)</li>\n<li>ArrayList 的默认初始化容量是 10，每次扩容时候增加原先容量的一半，也就是变为原来的 1.5 倍</li>\n<li>删除元素时不会减少容量，若希望减少容量则调用 trimToSize()</li>\n<li>它不是线程安全的。它能存放 null 值。</li>\n</ul>\n<h2 id=\"LinkedList\">LinkedList</h2>\n<h3 id=\"简介-2\">简介</h3>\n<blockquote>\n<p>底层实现是双向链表(双向链表方便实现往前遍历)<br>\nLinkedList 是一个实现了 List 接口和 Deque 接口的双端链表。 LinkedList 底层的链表结构使它支持高效的插入和删除操作，另外它实现了 Deque 接口，使得 LinkedList 类也具有队列的特性; LinkedList 不是线程安全的，如果想使 LinkedList 变成线程安全的，可以调用静态类 Collections 类中的 synchronizedList 方法：</p>\n</blockquote>\n<h2 id=\"Vector：\">Vector：</h2>\n<ul>\n<li>底层是数组，现在已少用，被 ArrayList 替代，原因有两个：</li>\n<li>Vector 所有方法都是同步，有性能损失。</li>\n<li>Vector 初始 length 是 10 超过 length 时 以 100%比率增长，相比于 ArrayList 更多消耗内存。</li>\n<li>ArrayList 在底层数组不够用时在原来的基础上扩展 0.5 倍，Vector 是扩展 1 倍。</li>\n</ul>\n<p><strong>总的来说：查询多用 ArrayList，增删多用 LinkedList。</strong></p>\n<p>ArrayList 增删慢不是绝对的(在数量大的情况下，已测试)：</p>\n<p>如果增加元素一直是使用 add()(增加到末尾)的话，那是 ArrayList 要快</p>\n<p>一直删除末尾的元素也是 ArrayList 要快【不用复制移动位置】</p>\n<p>至于如果删除的是中间的位置的话，还是 ArrayList 要快！</p>\n<h2 id=\"SkipList\">SkipList</h2>\n<h2 id=\"CopyOnWriteArrayList\">CopyOnWriteArrayList</h2>\n<p>‍</p>\n<h3 id=\"适用场景\">适用场景</h3>\n<ul>\n<li><strong>读操作可以尽可能的快，而写即使慢一些也没关系</strong></li>\n</ul>\n<p>在很多应用场景中，读操作可能会远远多于写操作。比如，有些系统级别的信息，往往只需要加载或者修改很少的次数，但是会被系统内所有模块频繁的访问。对于这种场景，我们最希望看到的就是读操作可以尽可能的快，而写即使慢一些也没关系。</p>\n<ul>\n<li><strong>读多写少</strong></li>\n</ul>\n<p>黑名单是最典型的场景，假如我们有一个搜索网站，用户在这个网站的搜索框中，输入关键字搜索内容，但是某些关键字不允许被搜索。这些不能被搜索的关键字会被放在一个黑名单中，黑名单并不需要实时更新，可能每天晚上更新一次就可以了。当用户搜索时，会检查当前关键字在不在黑名单中，如果在，则提示不能搜索。这种读多写少的场景也很适合使用 CopyOnWrite 集合。</p>\n<h3 id=\"读写规则\">读写规则</h3>\n<ul>\n<li><strong>读写锁的规则</strong></li>\n</ul>\n<p>读写锁的思想是：读读共享、其他都互斥（写写互斥、读写互斥、写读互斥），原因是由于读操作不会修改原有的数据，因此并发读并不会有安全问题；而写操作是危险的，所以当写操作发生时，不允许有读操作加入，也不允许第二个写线程加入。</p>\n<ul>\n<li><strong>对读写锁规则的升级</strong></li>\n</ul>\n<p>CopyOnWriteArrayList 的思想比读写锁的思想又更进一步。为了将读取的性能发挥到极致，CopyOnWriteArrayList 读取是完全不用加锁的，更厉害的是，<strong>写入也不会阻塞读取操作，也就是说你可以在写入的同时进行读取</strong>，只有写入和写入之间需要进行同步，也就是不允许多个写入同时发生，但是在写入发生时允许读取同时发生。这样一来，读操作的性能就会大幅度提升。</p>\n<h3 id=\"特点\">特点</h3>\n<ul>\n<li><strong>CopyOnWrite的含义</strong></li>\n</ul>\n<p>从 CopyOnWriteArrayList 的名字就能看出它是满足 CopyOnWrite 的 ArrayList，CopyOnWrite 的意思是说，当容器需要被修改的时候，不直接修改当前容器，而是先将当前容器进行 Copy，复制出一个新的容器，然后修改新的容器，<strong>完成修改之后，再将原容器的引用指向新的容器</strong>。这样就完成了整个修改过程。</p>\n<p>这样做的好处是，CopyOnWriteArrayList 利用了“不变性”原理，因为容器每次修改都是创建新副本，所以对于旧容器来说，其实是不可变的，也是线程安全的，无需进一步的同步操作。我们可以对 CopyOnWrite 容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素，也不会有修改。</p>\n<p>CopyOnWriteArrayList 的所有修改操作（add，set等）都是通过创建底层数组的新副本来实现的，所以 CopyOnWrite 容器也是一种读写分离的思想体现，读和写使用不同的容器。</p>\n<ul>\n<li><strong>迭代期间允许修改集合内容</strong></li>\n</ul>\n<p>ArrayList 在迭代期间如果修改集合的内容，会抛出 ConcurrentModificationException 异常。CopyOnWriteArrayList 的迭代器在迭代的时候，如果数组内容被修改了，CopyOnWriteArrayList 不会报 ConcurrentModificationException 的异常，因为迭代器使用的依然是旧数组，只不过迭代的内容可能已经过时了</p>\n<h3 id=\"缺点\">缺点</h3>\n<p>这些缺点不仅是针对 CopyOnWriteArrayList，其实同样也适用于其他的 CopyOnWrite 容器：</p>\n<ul>\n<li><strong>内存占用问题</strong></li>\n</ul>\n<p>因为 CopyOnWrite 的写时复制机制，所以在进行写操作的时候，内存里会同时驻扎两个对象的内存，这一点会占用额外的内存空间。</p>\n<ul>\n<li><strong>在元素较多或者复杂的情况下，复制的开销很大</strong></li>\n</ul>\n<p>复制过程不仅会占用双倍内存，还需要消耗 CPU 等资源，会降低整体性能。</p>\n<ul>\n<li><strong>数据一致性问题</strong></li>\n</ul>\n<p>由于 CopyOnWrite 容器的修改是先修改副本，所以这次修改对于其他线程来说，并不是实时能看到的，只有在修改完之后才能体现出来。如果你希望写入的的数据马上能被其他线程看到，CopyOnWrite 容器是不适用的。</p>\n<p>内部使用ReentrantLock 锁，用来保证修改操作的线程安全</p>\n","excerpt":"","more":"<h1>List</h1>\n<hr>\n<p><strong>List 集合的三个子类：</strong></p>\n<ul>\n<li>ArrayList :底层数据结构是数组。线程不安全</li>\n<li>LinkedList :底层数据结构是链表。线程不安全</li>\n<li>Vector:底层数据结构是数组。线程安全</li>\n</ul>\n<h2 id=\"ArrayList\">ArrayList</h2>\n<h3 id=\"简介\">简介</h3>\n<ul>\n<li>ArrayList 继承了 AbstractList，实现了 List。它是一个数组队列，提供了相关的添加、删除、修改、遍历等功能。</li>\n<li>ArrayList 实现了 RandomAccess 接口， RandomAccess 是一个标志接口，表明实现这个这个接口的 List 集合是支持快速随机访问的。在 ArrayList 中，我们即可以通过元素的序号快速获取元素对象，这就是快速随机访问。</li>\n<li>ArrayList 实现了 Cloneable 接口，即覆盖了函数 clone()，能被克隆。</li>\n<li>ArrayList 实现 java.io.Serializable 接口，这意味着 ArrayList 支持序列化，能通过序列化去传输。</li>\n<li>和 Vector 不同，ArrayList 中的操作不是线程安全的！所以，建议在单线程中才使用 ArrayList，而在多线程中可以选择 Vector 或者 CopyOnWriteArrayList。</li>\n</ul>\n<h3 id=\"System-arraycopy-和-Arrays-copyOf-方法\">System.arraycopy()和 Arrays.copyOf()方法</h3>\n<h4 id=\"两者联系与区别\">两者联系与区别</h4>\n<p><strong>联系：</strong></p>\n<p>看两者源代码可以发现 copyOf()内部调用了 System.arraycopy()方法</p>\n<p><strong>区别：</strong></p>\n<p>arraycopy()需要目标数组，将原数组拷贝到你自己定义的数组里，而且可以选择拷贝的起点和长度以及放入新数组中的位置</p>\n<p>copyOf()是系统自动在内部新建一个数组，并返回该数组。</p>\n<p><strong>注意的是：</strong></p>\n<ul>\n<li>java 中的 length 属性是针对数组说的,比如说你声明了一个数组,想知道这个数组的长度则用到了 length 这个属性.</li>\n<li>java 中的 length()方法是针对字 符串 String 说的,如果想看这个字符串的长度则用到 length()这个方法.</li>\n<li>java 中的 size()方法是针对泛型集合说的,如果想看这个泛型有多少个元素,就调用此方法来查看!</li>\n</ul>\n<h3 id=\"细节\">细节</h3>\n<ul>\n<li>ArrayList 是基于动态数组实现的，在增删时候，需要数组的拷贝复制。(navite 方法由 C/C++实现)</li>\n<li>ArrayList 的默认初始化容量是 10，每次扩容时候增加原先容量的一半，也就是变为原来的 1.5 倍</li>\n<li>删除元素时不会减少容量，若希望减少容量则调用 trimToSize()</li>\n<li>它不是线程安全的。它能存放 null 值。</li>\n</ul>\n<h2 id=\"LinkedList\">LinkedList</h2>\n<h3 id=\"简介-2\">简介</h3>\n<blockquote>\n<p>底层实现是双向链表(双向链表方便实现往前遍历)<br>\nLinkedList 是一个实现了 List 接口和 Deque 接口的双端链表。 LinkedList 底层的链表结构使它支持高效的插入和删除操作，另外它实现了 Deque 接口，使得 LinkedList 类也具有队列的特性; LinkedList 不是线程安全的，如果想使 LinkedList 变成线程安全的，可以调用静态类 Collections 类中的 synchronizedList 方法：</p>\n</blockquote>\n<h2 id=\"Vector：\">Vector：</h2>\n<ul>\n<li>底层是数组，现在已少用，被 ArrayList 替代，原因有两个：</li>\n<li>Vector 所有方法都是同步，有性能损失。</li>\n<li>Vector 初始 length 是 10 超过 length 时 以 100%比率增长，相比于 ArrayList 更多消耗内存。</li>\n<li>ArrayList 在底层数组不够用时在原来的基础上扩展 0.5 倍，Vector 是扩展 1 倍。</li>\n</ul>\n<p><strong>总的来说：查询多用 ArrayList，增删多用 LinkedList。</strong></p>\n<p>ArrayList 增删慢不是绝对的(在数量大的情况下，已测试)：</p>\n<p>如果增加元素一直是使用 add()(增加到末尾)的话，那是 ArrayList 要快</p>\n<p>一直删除末尾的元素也是 ArrayList 要快【不用复制移动位置】</p>\n<p>至于如果删除的是中间的位置的话，还是 ArrayList 要快！</p>\n<h2 id=\"SkipList\">SkipList</h2>\n<h2 id=\"CopyOnWriteArrayList\">CopyOnWriteArrayList</h2>\n<p>‍</p>\n<h3 id=\"适用场景\">适用场景</h3>\n<ul>\n<li><strong>读操作可以尽可能的快，而写即使慢一些也没关系</strong></li>\n</ul>\n<p>在很多应用场景中，读操作可能会远远多于写操作。比如，有些系统级别的信息，往往只需要加载或者修改很少的次数，但是会被系统内所有模块频繁的访问。对于这种场景，我们最希望看到的就是读操作可以尽可能的快，而写即使慢一些也没关系。</p>\n<ul>\n<li><strong>读多写少</strong></li>\n</ul>\n<p>黑名单是最典型的场景，假如我们有一个搜索网站，用户在这个网站的搜索框中，输入关键字搜索内容，但是某些关键字不允许被搜索。这些不能被搜索的关键字会被放在一个黑名单中，黑名单并不需要实时更新，可能每天晚上更新一次就可以了。当用户搜索时，会检查当前关键字在不在黑名单中，如果在，则提示不能搜索。这种读多写少的场景也很适合使用 CopyOnWrite 集合。</p>\n<h3 id=\"读写规则\">读写规则</h3>\n<ul>\n<li><strong>读写锁的规则</strong></li>\n</ul>\n<p>读写锁的思想是：读读共享、其他都互斥（写写互斥、读写互斥、写读互斥），原因是由于读操作不会修改原有的数据，因此并发读并不会有安全问题；而写操作是危险的，所以当写操作发生时，不允许有读操作加入，也不允许第二个写线程加入。</p>\n<ul>\n<li><strong>对读写锁规则的升级</strong></li>\n</ul>\n<p>CopyOnWriteArrayList 的思想比读写锁的思想又更进一步。为了将读取的性能发挥到极致，CopyOnWriteArrayList 读取是完全不用加锁的，更厉害的是，<strong>写入也不会阻塞读取操作，也就是说你可以在写入的同时进行读取</strong>，只有写入和写入之间需要进行同步，也就是不允许多个写入同时发生，但是在写入发生时允许读取同时发生。这样一来，读操作的性能就会大幅度提升。</p>\n<h3 id=\"特点\">特点</h3>\n<ul>\n<li><strong>CopyOnWrite的含义</strong></li>\n</ul>\n<p>从 CopyOnWriteArrayList 的名字就能看出它是满足 CopyOnWrite 的 ArrayList，CopyOnWrite 的意思是说，当容器需要被修改的时候，不直接修改当前容器，而是先将当前容器进行 Copy，复制出一个新的容器，然后修改新的容器，<strong>完成修改之后，再将原容器的引用指向新的容器</strong>。这样就完成了整个修改过程。</p>\n<p>这样做的好处是，CopyOnWriteArrayList 利用了“不变性”原理，因为容器每次修改都是创建新副本，所以对于旧容器来说，其实是不可变的，也是线程安全的，无需进一步的同步操作。我们可以对 CopyOnWrite 容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素，也不会有修改。</p>\n<p>CopyOnWriteArrayList 的所有修改操作（add，set等）都是通过创建底层数组的新副本来实现的，所以 CopyOnWrite 容器也是一种读写分离的思想体现，读和写使用不同的容器。</p>\n<ul>\n<li><strong>迭代期间允许修改集合内容</strong></li>\n</ul>\n<p>ArrayList 在迭代期间如果修改集合的内容，会抛出 ConcurrentModificationException 异常。CopyOnWriteArrayList 的迭代器在迭代的时候，如果数组内容被修改了，CopyOnWriteArrayList 不会报 ConcurrentModificationException 的异常，因为迭代器使用的依然是旧数组，只不过迭代的内容可能已经过时了</p>\n<h3 id=\"缺点\">缺点</h3>\n<p>这些缺点不仅是针对 CopyOnWriteArrayList，其实同样也适用于其他的 CopyOnWrite 容器：</p>\n<ul>\n<li><strong>内存占用问题</strong></li>\n</ul>\n<p>因为 CopyOnWrite 的写时复制机制，所以在进行写操作的时候，内存里会同时驻扎两个对象的内存，这一点会占用额外的内存空间。</p>\n<ul>\n<li><strong>在元素较多或者复杂的情况下，复制的开销很大</strong></li>\n</ul>\n<p>复制过程不仅会占用双倍内存，还需要消耗 CPU 等资源，会降低整体性能。</p>\n<ul>\n<li><strong>数据一致性问题</strong></li>\n</ul>\n<p>由于 CopyOnWrite 容器的修改是先修改副本，所以这次修改对于其他线程来说，并不是实时能看到的，只有在修改完之后才能体现出来。如果你希望写入的的数据马上能被其他线程看到，CopyOnWrite 容器是不适用的。</p>\n<p>内部使用ReentrantLock 锁，用来保证修改操作的线程安全</p>\n"},{"title":"Map","date":"2022-10-30T05:21:46.000Z","lastmod":"2022-10-30T05:21:46.000Z","_content":"\n# Map\n\n## HashMap\n\n　　JDK1.8 之前 HashMap 底层是 **数组和链表** 结合在一起使用也就是 **链表散列**。HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash 值，然后通过 (n - 1) & hash 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。\n\n　　所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。\n\n### JDK1.8 之前\n\n　　“拉链法” 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。\n\n### JDK1.8 之后\n\n　　当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。\n\n![](/assets/net-img-1591690908749-8d13658b-f28f-4a16-9787-5d802366b2bb-20221030132339-jhzqts2.png)\n\n> TreeMap、TreeSet 以及 JDK1.8 之后的 HashMap 底层都用到了红黑树。红黑树就是为了解决二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构。\n\n## ConcurrentHashMap\n\n　　1.8及之后\n\n> 1. 用table保存数据，锁的粒度更小，减少并发冲突的概率。采用table数组元素作为锁，从而实现了对每一行数据进行加锁，进一步减少并发冲突的概率，并发控制使用Synchronized和CAS来操作。\n> 2. 存储数据时采用了数组+ 链表+红黑树的形式。\n\n1. CurrentHashMap重要参数：\n\n```java\nprivate static final int MAXIMUM_CAPACITY = 1 << 30; // 数组的最大值 \n\nprivate static final int DEFAULT_CAPACITY = 16; // 默认数组长度 \n\nstatic final int TREEIFY_THRESHOLD = 8; // 链表转红黑树的一个条件 \n\nstatic final int UNTREEIFY_THRESHOLD = 6; // 红黑树转链表的一个条件 \n\nstatic final int MIN_TREEIFY_CAPACITY = 64; // 链表转红黑树的另一个条件\n\nstatic final int MOVED     = -1;  // 表示正在扩容转移 \n\nstatic final int TREEBIN   = -2; // 表示已经转换成树 \n\nstatic final int RESERVED  = -3; // hash for transient reservations \n\nstatic final int HASH_BITS = 0x7fffffff; // 获得hash值的辅助参数\n\ntransient volatile Node<K,V>[] table;// 默认没初始化的数组，用来保存元素 \n\nprivate transient volatile Node<K,V>[] nextTable; // 转移的时候用的数组 \n\nstatic final int NCPU = Runtime.getRuntime().availableProcessors();// 获取可用的CPU个数 \n\nprivate transient volatile Node<K,V>[] nextTable; // 连接表，用于哈希表扩容，扩容完成后会被重置为 null \n\nprivate transient volatile long baseCount; //保存着整个哈希表中存储的所有的结点的个数总和，有点类似于 HashMap 的 size 属性。\nprivate transient volatile int sizeCtl; \n//sizeCtl = 0：表示没有指定初始容量\n//sizeCtl > 0：表示初始容量(可以使用阶段)\n//sizeCtl = -1,标记作用，告知其他线程，正在初始化\n//sizeCtl = 0.75n ,扩容阈值\n//sizeCtl < 0 : 表示有其他线程正在执行扩容or初始化(不能使用阶段)\n//sizeCtl = (resizeStamp(n) << RESIZE_STAMP_SHIFT) + 2 :表示此时只有一个线程在执行扩容\n```\n\n2. 扩容机制\n\n> - nextTable: 扩容期间，将元素迁移到 nextTable 新Map, nextTable是共享变量。\n> - sizeCtl: 多线程之间，sizeCtl来判断ConcurrentHashMap当前所处的状态。\n>   - 通过CAS设置sizeCtl属性，告知其他线程ConcurrentHashMap的状态变更。\n> - transferIndex: 扩容索引，表示已经完成数据分配的table数组索引位置。\n>   - 数据转移已经到了哪个位置? 其他线程根据这个值帮助扩容从这个索引位置继续转移数据\n> - ForwardingNode节点: 标记作用,表示此节点已经扩容完毕，hash值等于-1\n>   - 数组位置的数据已经被转移到新Map中,此位置就会被设置为这个属性\n>   - 这个属性包装了新Map,可以用find方法取扩容转移后的值\n\n　　**扩容流程：**\n\n- 线程执行put操作，发现容量已经达到扩容阈值，需要进行扩容操作\n- 扩容线程A 以CAS机制修改`transferindex`值,然后按照降序迁移数据,`transferindex`是数组尾部的索引\n  - `transferindex`的初始值: 新数组的长度 - 1 -> 就是数组的最后一位\n- 迁移hash桶时，会将桶内的链表或者红黑树，按照一定算法，拆分成2份，将其插入`nextTable[i]`和`nextTable[i+n]`（n是之前table数组的长度）。\n  - 扩容后重新计算的hash值与之前hash值一样,则存放位置不变\n  - 重新计算的hash值与之前hash值不一样,则存放再索引i +n处(之前的数组长度 + 计算的索引)\n- 迁移完毕的hash桶,都会被设置成`ForwardingNode`节点，以此告知访问此桶的其他线程，此节点已经迁移完毕,但数据并没有全部迁移完成。\n- 此时线程2访问到了`ForwardingNode`节点，如果线程2执行的put或remove等写操作，那么就会先帮其扩容。\n  - 如果线程2执行的是get等读方法，则会调用`ForwardingNode`的find方法，去`nextTable`里面查找相关元素。\n\n3. put\n\n> put操作采用 CAS + synchronized 实现并发插入或更新操作\n\n```java\n// Node 节点的 hash值在HashMap中存储的就是hash值，在currenthashmap中可能有多种情况哦！\n/** Implementation for put and putIfAbsent */\n    final V putVal(K key, V value, boolean onlyIfAbsent) {\n        if (key == null || value == null) throw new NullPointerException();\n        int hash = spread(key.hashCode());// 最终hash值计算\n        int binCount = 0;\n        for (Node<K,V>[] tab = table;;) { //循环表\n            Node<K,V> f; int n, i, fh; K fk; V fv;\n            if (tab == null || (n = tab.length) == 0)\n                tab = initTable(); // 初始化表 如果为空,懒汉式\n            else if ((f = tabAt(tab, i = (n - 1) & hash)) == null) {\n                //// 如果对应桶位置为空\n                if (casTabAt(tab, i, null, new Node<K,V>(hash, key, value)))\n                    break;                    // CAS 原子性的尝试插入\n            }\n            else if ((fh = f.hash) == MOVED)\n                //f.hash == MOVED 表示为：ForwardingNode，说明其他线程正在扩容\n                //并且这个数组的位置数据已经转移到新的数组结构中\n                //但是数据还没有全部转移完成,帮助线程先扩容\n                // 如果当前节点正在扩容。还要帮着去扩容 \n                tab = helpTransfer(tab, f);\n            else if (onlyIfAbsent //jdk 检查第一个节点 是否已存在key 存在返回对应value值 check first node without acquiring lock\n                     && fh == hash\n                     && ((fk = f.key) == key || (fk != null && key.equals(fk)))\n                     && (fv = f.val) != null)\n                return fv;\n            else {\n                V oldVal = null;//桶存在数据 加锁操作进行处理\n                synchronized (f) {\n                    if (tabAt(tab, i) == f) {\n                        if (fh >= 0) {// 如果存储的是链表 存储的是节点的hash值\n                            binCount = 1;\n                            for (Node<K,V> e = f;; ++binCount) {\n                                K ek;\n                                // 遍历链表去查找，如果找到key 选择性覆盖\n                                if (e.hash == hash &&\n                                    ((ek = e.key) == key ||\n                                     (ek != null && key.equals(ek)))) {\n                                    oldVal = e.val;\n                                    if (!onlyIfAbsent)\n                                        e.val = value;\n                                    break;\n                                }\n                                Node<K,V> pred = e;\n                                if ((e = e.next) == null) {// 找到尾部插入\n                                    pred.next = new Node<K,V>(hash, key, value);\n                                    break;\n                                }\n                            }\n                        }\n                        else if (f instanceof TreeBin) {// 如果桶节点类型为TreeBin\n                            Node<K,V> p;\n                            binCount = 2;\n                            if ((p = ((TreeBin<K,V>)f).putTreeVal(hash, key,\n                                                           value)) != null) {\n                                 // 尝试红黑树插入，同时也要防止节点本来就有，选择性覆盖\n                                oldVal = p.val;\n                                if (!onlyIfAbsent)\n                                    p.val = value;\n                            }\n                        }\n                        else if (f instanceof ReservationNode)\n                            throw new IllegalStateException(\"Recursive update\");\n                    }\n                }\n                if (binCount != 0) {// 如果链表数量\n                    if (binCount >= TREEIFY_THRESHOLD)\n                        treeifyBin(tab, i);//  链表转红黑树哦！\n                    if (oldVal != null)\n                        return oldVal;\n                    break;\n                }\n            }\n        }\n        addCount(1L, binCount); // 统计大小 并且检查是否要扩容。\n        return null;\n    }\n```\n\n　　涉及到重要函数initTable、tabAt、casTabAt、helpTransfer、putTreeVal、treeifyBin、addCount函数。\n\n3. initTable\n\n>  **「只允许一个线程」** 对表进行初始化，如果不巧有其他线程进来了，那么会让其他线程交出 CPU 等待下次系统调度Thread.yield。这样，保证了表同时只会被一个线程初始化，对于table的大小，会根据sizeCtl的值进行设置，如果没有设置szieCtl的值，那么默认生成的table大小为16，否则，会根据sizeCtl的大小设置table大小。\n\n```java\n// 容器初始化 操作\nprivate final Node<K,V>[] initTable() {\n    Node<K,V>[] tab; int sc;\n    while ((tab = table)  null || tab.length  0) {\n        if ((sc = sizeCtl) < 0) // 如果正在初始化-1，-N 正在扩容。\n            Thread.yield(); // 进行线程让步等待\n     // 让掉当前线程 CPU 的时间片，使正在运行中的线程重新变成就绪状态，并重新竞争 CPU 的调度权。\n     // 它可能会获取到，也有可能被其他线程获取到。\n        else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) { \n          //  比较sizeCtl的值与sc是否相等，相等则用 -1 替换,这表明我这个线程在进行初始化了！\n            try {\n                if ((tab = table)  null || tab.length  0) {\n                    int n = (sc > 0) ? sc : DEFAULT_CAPACITY; // 默认为16\n                    @SuppressWarnings(\"unchecked\")\n                    Node<K,V>[] nt = (Node<K,V>[])new Node<?,?>[n];\n                    table = tab = nt;\n                    sc = n - (n >>> 2); \n                }\n            } finally {\n                sizeCtl = sc; //设置sizeCtl 类似threshold\n            }\n            break;\n        }\n    }\n    return tab;\n}\n```\n","source":"_posts/java/Collection/Map.md","raw":"---\ntitle: Map\ndate: 2022-10-30T13:21:46Z\nlastmod: 2022-10-30T13:21:46Z\n---\n\n# Map\n\n## HashMap\n\n　　JDK1.8 之前 HashMap 底层是 **数组和链表** 结合在一起使用也就是 **链表散列**。HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash 值，然后通过 (n - 1) & hash 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。\n\n　　所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。\n\n### JDK1.8 之前\n\n　　“拉链法” 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。\n\n### JDK1.8 之后\n\n　　当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。\n\n![](/assets/net-img-1591690908749-8d13658b-f28f-4a16-9787-5d802366b2bb-20221030132339-jhzqts2.png)\n\n> TreeMap、TreeSet 以及 JDK1.8 之后的 HashMap 底层都用到了红黑树。红黑树就是为了解决二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构。\n\n## ConcurrentHashMap\n\n　　1.8及之后\n\n> 1. 用table保存数据，锁的粒度更小，减少并发冲突的概率。采用table数组元素作为锁，从而实现了对每一行数据进行加锁，进一步减少并发冲突的概率，并发控制使用Synchronized和CAS来操作。\n> 2. 存储数据时采用了数组+ 链表+红黑树的形式。\n\n1. CurrentHashMap重要参数：\n\n```java\nprivate static final int MAXIMUM_CAPACITY = 1 << 30; // 数组的最大值 \n\nprivate static final int DEFAULT_CAPACITY = 16; // 默认数组长度 \n\nstatic final int TREEIFY_THRESHOLD = 8; // 链表转红黑树的一个条件 \n\nstatic final int UNTREEIFY_THRESHOLD = 6; // 红黑树转链表的一个条件 \n\nstatic final int MIN_TREEIFY_CAPACITY = 64; // 链表转红黑树的另一个条件\n\nstatic final int MOVED     = -1;  // 表示正在扩容转移 \n\nstatic final int TREEBIN   = -2; // 表示已经转换成树 \n\nstatic final int RESERVED  = -3; // hash for transient reservations \n\nstatic final int HASH_BITS = 0x7fffffff; // 获得hash值的辅助参数\n\ntransient volatile Node<K,V>[] table;// 默认没初始化的数组，用来保存元素 \n\nprivate transient volatile Node<K,V>[] nextTable; // 转移的时候用的数组 \n\nstatic final int NCPU = Runtime.getRuntime().availableProcessors();// 获取可用的CPU个数 \n\nprivate transient volatile Node<K,V>[] nextTable; // 连接表，用于哈希表扩容，扩容完成后会被重置为 null \n\nprivate transient volatile long baseCount; //保存着整个哈希表中存储的所有的结点的个数总和，有点类似于 HashMap 的 size 属性。\nprivate transient volatile int sizeCtl; \n//sizeCtl = 0：表示没有指定初始容量\n//sizeCtl > 0：表示初始容量(可以使用阶段)\n//sizeCtl = -1,标记作用，告知其他线程，正在初始化\n//sizeCtl = 0.75n ,扩容阈值\n//sizeCtl < 0 : 表示有其他线程正在执行扩容or初始化(不能使用阶段)\n//sizeCtl = (resizeStamp(n) << RESIZE_STAMP_SHIFT) + 2 :表示此时只有一个线程在执行扩容\n```\n\n2. 扩容机制\n\n> - nextTable: 扩容期间，将元素迁移到 nextTable 新Map, nextTable是共享变量。\n> - sizeCtl: 多线程之间，sizeCtl来判断ConcurrentHashMap当前所处的状态。\n>   - 通过CAS设置sizeCtl属性，告知其他线程ConcurrentHashMap的状态变更。\n> - transferIndex: 扩容索引，表示已经完成数据分配的table数组索引位置。\n>   - 数据转移已经到了哪个位置? 其他线程根据这个值帮助扩容从这个索引位置继续转移数据\n> - ForwardingNode节点: 标记作用,表示此节点已经扩容完毕，hash值等于-1\n>   - 数组位置的数据已经被转移到新Map中,此位置就会被设置为这个属性\n>   - 这个属性包装了新Map,可以用find方法取扩容转移后的值\n\n　　**扩容流程：**\n\n- 线程执行put操作，发现容量已经达到扩容阈值，需要进行扩容操作\n- 扩容线程A 以CAS机制修改`transferindex`值,然后按照降序迁移数据,`transferindex`是数组尾部的索引\n  - `transferindex`的初始值: 新数组的长度 - 1 -> 就是数组的最后一位\n- 迁移hash桶时，会将桶内的链表或者红黑树，按照一定算法，拆分成2份，将其插入`nextTable[i]`和`nextTable[i+n]`（n是之前table数组的长度）。\n  - 扩容后重新计算的hash值与之前hash值一样,则存放位置不变\n  - 重新计算的hash值与之前hash值不一样,则存放再索引i +n处(之前的数组长度 + 计算的索引)\n- 迁移完毕的hash桶,都会被设置成`ForwardingNode`节点，以此告知访问此桶的其他线程，此节点已经迁移完毕,但数据并没有全部迁移完成。\n- 此时线程2访问到了`ForwardingNode`节点，如果线程2执行的put或remove等写操作，那么就会先帮其扩容。\n  - 如果线程2执行的是get等读方法，则会调用`ForwardingNode`的find方法，去`nextTable`里面查找相关元素。\n\n3. put\n\n> put操作采用 CAS + synchronized 实现并发插入或更新操作\n\n```java\n// Node 节点的 hash值在HashMap中存储的就是hash值，在currenthashmap中可能有多种情况哦！\n/** Implementation for put and putIfAbsent */\n    final V putVal(K key, V value, boolean onlyIfAbsent) {\n        if (key == null || value == null) throw new NullPointerException();\n        int hash = spread(key.hashCode());// 最终hash值计算\n        int binCount = 0;\n        for (Node<K,V>[] tab = table;;) { //循环表\n            Node<K,V> f; int n, i, fh; K fk; V fv;\n            if (tab == null || (n = tab.length) == 0)\n                tab = initTable(); // 初始化表 如果为空,懒汉式\n            else if ((f = tabAt(tab, i = (n - 1) & hash)) == null) {\n                //// 如果对应桶位置为空\n                if (casTabAt(tab, i, null, new Node<K,V>(hash, key, value)))\n                    break;                    // CAS 原子性的尝试插入\n            }\n            else if ((fh = f.hash) == MOVED)\n                //f.hash == MOVED 表示为：ForwardingNode，说明其他线程正在扩容\n                //并且这个数组的位置数据已经转移到新的数组结构中\n                //但是数据还没有全部转移完成,帮助线程先扩容\n                // 如果当前节点正在扩容。还要帮着去扩容 \n                tab = helpTransfer(tab, f);\n            else if (onlyIfAbsent //jdk 检查第一个节点 是否已存在key 存在返回对应value值 check first node without acquiring lock\n                     && fh == hash\n                     && ((fk = f.key) == key || (fk != null && key.equals(fk)))\n                     && (fv = f.val) != null)\n                return fv;\n            else {\n                V oldVal = null;//桶存在数据 加锁操作进行处理\n                synchronized (f) {\n                    if (tabAt(tab, i) == f) {\n                        if (fh >= 0) {// 如果存储的是链表 存储的是节点的hash值\n                            binCount = 1;\n                            for (Node<K,V> e = f;; ++binCount) {\n                                K ek;\n                                // 遍历链表去查找，如果找到key 选择性覆盖\n                                if (e.hash == hash &&\n                                    ((ek = e.key) == key ||\n                                     (ek != null && key.equals(ek)))) {\n                                    oldVal = e.val;\n                                    if (!onlyIfAbsent)\n                                        e.val = value;\n                                    break;\n                                }\n                                Node<K,V> pred = e;\n                                if ((e = e.next) == null) {// 找到尾部插入\n                                    pred.next = new Node<K,V>(hash, key, value);\n                                    break;\n                                }\n                            }\n                        }\n                        else if (f instanceof TreeBin) {// 如果桶节点类型为TreeBin\n                            Node<K,V> p;\n                            binCount = 2;\n                            if ((p = ((TreeBin<K,V>)f).putTreeVal(hash, key,\n                                                           value)) != null) {\n                                 // 尝试红黑树插入，同时也要防止节点本来就有，选择性覆盖\n                                oldVal = p.val;\n                                if (!onlyIfAbsent)\n                                    p.val = value;\n                            }\n                        }\n                        else if (f instanceof ReservationNode)\n                            throw new IllegalStateException(\"Recursive update\");\n                    }\n                }\n                if (binCount != 0) {// 如果链表数量\n                    if (binCount >= TREEIFY_THRESHOLD)\n                        treeifyBin(tab, i);//  链表转红黑树哦！\n                    if (oldVal != null)\n                        return oldVal;\n                    break;\n                }\n            }\n        }\n        addCount(1L, binCount); // 统计大小 并且检查是否要扩容。\n        return null;\n    }\n```\n\n　　涉及到重要函数initTable、tabAt、casTabAt、helpTransfer、putTreeVal、treeifyBin、addCount函数。\n\n3. initTable\n\n>  **「只允许一个线程」** 对表进行初始化，如果不巧有其他线程进来了，那么会让其他线程交出 CPU 等待下次系统调度Thread.yield。这样，保证了表同时只会被一个线程初始化，对于table的大小，会根据sizeCtl的值进行设置，如果没有设置szieCtl的值，那么默认生成的table大小为16，否则，会根据sizeCtl的大小设置table大小。\n\n```java\n// 容器初始化 操作\nprivate final Node<K,V>[] initTable() {\n    Node<K,V>[] tab; int sc;\n    while ((tab = table)  null || tab.length  0) {\n        if ((sc = sizeCtl) < 0) // 如果正在初始化-1，-N 正在扩容。\n            Thread.yield(); // 进行线程让步等待\n     // 让掉当前线程 CPU 的时间片，使正在运行中的线程重新变成就绪状态，并重新竞争 CPU 的调度权。\n     // 它可能会获取到，也有可能被其他线程获取到。\n        else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) { \n          //  比较sizeCtl的值与sc是否相等，相等则用 -1 替换,这表明我这个线程在进行初始化了！\n            try {\n                if ((tab = table)  null || tab.length  0) {\n                    int n = (sc > 0) ? sc : DEFAULT_CAPACITY; // 默认为16\n                    @SuppressWarnings(\"unchecked\")\n                    Node<K,V>[] nt = (Node<K,V>[])new Node<?,?>[n];\n                    table = tab = nt;\n                    sc = n - (n >>> 2); \n                }\n            } finally {\n                sizeCtl = sc; //设置sizeCtl 类似threshold\n            }\n            break;\n        }\n    }\n    return tab;\n}\n```\n","slug":"java-Collection-Map","published":1,"updated":"2025-04-22T07:27:29.941Z","_id":"cm9s3f40h002vbfg4fv1oherx","comments":1,"layout":"post","photos":[],"content":"<h1>Map</h1>\n<h2 id=\"HashMap\">HashMap</h2>\n<p>JDK1.8 之前 HashMap 底层是 <strong>数组和链表</strong> 结合在一起使用也就是 <strong>链表散列</strong>。HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash 值，然后通过 (n - 1) &amp; hash 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</p>\n<p>所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。</p>\n<h3 id=\"JDK1-8-之前\">JDK1.8 之前</h3>\n<p>“拉链法” 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</p>\n<h3 id=\"JDK1-8-之后\">JDK1.8 之后</h3>\n<p>当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。</p>\n<p><img src=\"/assets/net-img-1591690908749-8d13658b-f28f-4a16-9787-5d802366b2bb-20221030132339-jhzqts2.png\" alt=\"\"></p>\n<blockquote>\n<p>TreeMap、TreeSet 以及 JDK1.8 之后的 HashMap 底层都用到了红黑树。红黑树就是为了解决二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构。</p>\n</blockquote>\n<h2 id=\"ConcurrentHashMap\">ConcurrentHashMap</h2>\n<p>1.8及之后</p>\n<blockquote>\n<ol>\n<li>用table保存数据，锁的粒度更小，减少并发冲突的概率。采用table数组元素作为锁，从而实现了对每一行数据进行加锁，进一步减少并发冲突的概率，并发控制使用Synchronized和CAS来操作。</li>\n<li>存储数据时采用了数组+ 链表+红黑树的形式。</li>\n</ol>\n</blockquote>\n<ol>\n<li>CurrentHashMap重要参数：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">MAXIMUM_CAPACITY</span> <span class=\"operator\">=</span> <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">30</span>; <span class=\"comment\">// 数组的最大值 </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">DEFAULT_CAPACITY</span> <span class=\"operator\">=</span> <span class=\"number\">16</span>; <span class=\"comment\">// 默认数组长度 </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">TREEIFY_THRESHOLD</span> <span class=\"operator\">=</span> <span class=\"number\">8</span>; <span class=\"comment\">// 链表转红黑树的一个条件 </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">UNTREEIFY_THRESHOLD</span> <span class=\"operator\">=</span> <span class=\"number\">6</span>; <span class=\"comment\">// 红黑树转链表的一个条件 </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">MIN_TREEIFY_CAPACITY</span> <span class=\"operator\">=</span> <span class=\"number\">64</span>; <span class=\"comment\">// 链表转红黑树的另一个条件</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">MOVED</span>     <span class=\"operator\">=</span> -<span class=\"number\">1</span>;  <span class=\"comment\">// 表示正在扩容转移 </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">TREEBIN</span>   <span class=\"operator\">=</span> -<span class=\"number\">2</span>; <span class=\"comment\">// 表示已经转换成树 </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">RESERVED</span>  <span class=\"operator\">=</span> -<span class=\"number\">3</span>; <span class=\"comment\">// hash for transient reservations </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">HASH_BITS</span> <span class=\"operator\">=</span> <span class=\"number\">0x7fffffff</span>; <span class=\"comment\">// 获得hash值的辅助参数</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">transient</span> <span class=\"keyword\">volatile</span> Node&lt;K,V&gt;[] table;<span class=\"comment\">// 默认没初始化的数组，用来保存元素 </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> <span class=\"keyword\">volatile</span> Node&lt;K,V&gt;[] nextTable; <span class=\"comment\">// 转移的时候用的数组 </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">NCPU</span> <span class=\"operator\">=</span> Runtime.getRuntime().availableProcessors();<span class=\"comment\">// 获取可用的CPU个数 </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> <span class=\"keyword\">volatile</span> Node&lt;K,V&gt;[] nextTable; <span class=\"comment\">// 连接表，用于哈希表扩容，扩容完成后会被重置为 null </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> <span class=\"keyword\">volatile</span> <span class=\"type\">long</span> baseCount; <span class=\"comment\">//保存着整个哈希表中存储的所有的结点的个数总和，有点类似于 HashMap 的 size 属性。</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> <span class=\"keyword\">volatile</span> <span class=\"type\">int</span> sizeCtl; </span><br><span class=\"line\"><span class=\"comment\">//sizeCtl = 0：表示没有指定初始容量</span></span><br><span class=\"line\"><span class=\"comment\">//sizeCtl &gt; 0：表示初始容量(可以使用阶段)</span></span><br><span class=\"line\"><span class=\"comment\">//sizeCtl = -1,标记作用，告知其他线程，正在初始化</span></span><br><span class=\"line\"><span class=\"comment\">//sizeCtl = 0.75n ,扩容阈值</span></span><br><span class=\"line\"><span class=\"comment\">//sizeCtl &lt; 0 : 表示有其他线程正在执行扩容or初始化(不能使用阶段)</span></span><br><span class=\"line\"><span class=\"comment\">//sizeCtl = (resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT) + 2 :表示此时只有一个线程在执行扩容</span></span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>扩容机制</li>\n</ol>\n<blockquote>\n<ul>\n<li>nextTable: 扩容期间，将元素迁移到 nextTable 新Map, nextTable是共享变量。</li>\n<li>sizeCtl: 多线程之间，sizeCtl来判断ConcurrentHashMap当前所处的状态。\n<ul>\n<li>通过CAS设置sizeCtl属性，告知其他线程ConcurrentHashMap的状态变更。</li>\n</ul>\n</li>\n<li>transferIndex: 扩容索引，表示已经完成数据分配的table数组索引位置。\n<ul>\n<li>数据转移已经到了哪个位置? 其他线程根据这个值帮助扩容从这个索引位置继续转移数据</li>\n</ul>\n</li>\n<li>ForwardingNode节点: 标记作用,表示此节点已经扩容完毕，hash值等于-1\n<ul>\n<li>数组位置的数据已经被转移到新Map中,此位置就会被设置为这个属性</li>\n<li>这个属性包装了新Map,可以用find方法取扩容转移后的值</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<p><strong>扩容流程：</strong></p>\n<ul>\n<li>线程执行put操作，发现容量已经达到扩容阈值，需要进行扩容操作</li>\n<li>扩容线程A 以CAS机制修改<code>transferindex</code>值,然后按照降序迁移数据,<code>transferindex</code>是数组尾部的索引\n<ul>\n<li><code>transferindex</code>的初始值: 新数组的长度 - 1 -&gt; 就是数组的最后一位</li>\n</ul>\n</li>\n<li>迁移hash桶时，会将桶内的链表或者红黑树，按照一定算法，拆分成2份，将其插入<code>nextTable[i]</code>和<code>nextTable[i+n]</code>（n是之前table数组的长度）。\n<ul>\n<li>扩容后重新计算的hash值与之前hash值一样,则存放位置不变</li>\n<li>重新计算的hash值与之前hash值不一样,则存放再索引i +n处(之前的数组长度 + 计算的索引)</li>\n</ul>\n</li>\n<li>迁移完毕的hash桶,都会被设置成<code>ForwardingNode</code>节点，以此告知访问此桶的其他线程，此节点已经迁移完毕,但数据并没有全部迁移完成。</li>\n<li>此时线程2访问到了<code>ForwardingNode</code>节点，如果线程2执行的put或remove等写操作，那么就会先帮其扩容。\n<ul>\n<li>如果线程2执行的是get等读方法，则会调用<code>ForwardingNode</code>的find方法，去<code>nextTable</code>里面查找相关元素。</li>\n</ul>\n</li>\n</ul>\n<ol start=\"3\">\n<li>put</li>\n</ol>\n<blockquote>\n<p>put操作采用 CAS + synchronized 实现并发插入或更新操作</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Node 节点的 hash值在HashMap中存储的就是hash值，在currenthashmap中可能有多种情况哦！</span></span><br><span class=\"line\"><span class=\"comment\">/** Implementation for put and putIfAbsent */</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> V <span class=\"title function_\">putVal</span><span class=\"params\">(K key, V value, <span class=\"type\">boolean</span> onlyIfAbsent)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (key == <span class=\"literal\">null</span> || value == <span class=\"literal\">null</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NullPointerException</span>();</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">hash</span> <span class=\"operator\">=</span> spread(key.hashCode());<span class=\"comment\">// 最终hash值计算</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">binCount</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123; <span class=\"comment\">//循环表</span></span><br><span class=\"line\">            Node&lt;K,V&gt; f; <span class=\"type\">int</span> n, i, fh; K fk; V fv;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (tab == <span class=\"literal\">null</span> || (n = tab.length) == <span class=\"number\">0</span>)</span><br><span class=\"line\">                tab = initTable(); <span class=\"comment\">// 初始化表 如果为空,懒汉式</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((f = tabAt(tab, i = (n - <span class=\"number\">1</span>) &amp; hash)) == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//// 如果对应桶位置为空</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (casTabAt(tab, i, <span class=\"literal\">null</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">Node</span>&lt;K,V&gt;(hash, key, value)))</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;                    <span class=\"comment\">// CAS 原子性的尝试插入</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((fh = f.hash) == MOVED)</span><br><span class=\"line\">                <span class=\"comment\">//f.hash == MOVED 表示为：ForwardingNode，说明其他线程正在扩容</span></span><br><span class=\"line\">                <span class=\"comment\">//并且这个数组的位置数据已经转移到新的数组结构中</span></span><br><span class=\"line\">                <span class=\"comment\">//但是数据还没有全部转移完成,帮助线程先扩容</span></span><br><span class=\"line\">                <span class=\"comment\">// 如果当前节点正在扩容。还要帮着去扩容 </span></span><br><span class=\"line\">                tab = helpTransfer(tab, f);</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (onlyIfAbsent <span class=\"comment\">//jdk 检查第一个节点 是否已存在key 存在返回对应value值 check first node without acquiring lock</span></span><br><span class=\"line\">                     &amp;&amp; fh == hash</span><br><span class=\"line\">                     &amp;&amp; ((fk = f.key) == key || (fk != <span class=\"literal\">null</span> &amp;&amp; key.equals(fk)))</span><br><span class=\"line\">                     &amp;&amp; (fv = f.val) != <span class=\"literal\">null</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> fv;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"type\">V</span> <span class=\"variable\">oldVal</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;<span class=\"comment\">//桶存在数据 加锁操作进行处理</span></span><br><span class=\"line\">                <span class=\"keyword\">synchronized</span> (f) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (fh &gt;= <span class=\"number\">0</span>) &#123;<span class=\"comment\">// 如果存储的是链表 存储的是节点的hash值</span></span><br><span class=\"line\">                            binCount = <span class=\"number\">1</span>;</span><br><span class=\"line\">                            <span class=\"keyword\">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class=\"line\">                                K ek;</span><br><span class=\"line\">                                <span class=\"comment\">// 遍历链表去查找，如果找到key 选择性覆盖</span></span><br><span class=\"line\">                                <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</span><br><span class=\"line\">                                    ((ek = e.key) == key ||</span><br><span class=\"line\">                                     (ek != <span class=\"literal\">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class=\"line\">                                    oldVal = e.val;</span><br><span class=\"line\">                                    <span class=\"keyword\">if</span> (!onlyIfAbsent)</span><br><span class=\"line\">                                        e.val = value;</span><br><span class=\"line\">                                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                                &#125;</span><br><span class=\"line\">                                Node&lt;K,V&gt; pred = e;</span><br><span class=\"line\">                                <span class=\"keyword\">if</span> ((e = e.next) == <span class=\"literal\">null</span>) &#123;<span class=\"comment\">// 找到尾部插入</span></span><br><span class=\"line\">                                    pred.next = <span class=\"keyword\">new</span> <span class=\"title class_\">Node</span>&lt;K,V&gt;(hash, key, value);</span><br><span class=\"line\">                                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                                &#125;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (f <span class=\"keyword\">instanceof</span> TreeBin) &#123;<span class=\"comment\">// 如果桶节点类型为TreeBin</span></span><br><span class=\"line\">                            Node&lt;K,V&gt; p;</span><br><span class=\"line\">                            binCount = <span class=\"number\">2</span>;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class=\"line\">                                                           value)) != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                                 <span class=\"comment\">// 尝试红黑树插入，同时也要防止节点本来就有，选择性覆盖</span></span><br><span class=\"line\">                                oldVal = p.val;</span><br><span class=\"line\">                                <span class=\"keyword\">if</span> (!onlyIfAbsent)</span><br><span class=\"line\">                                    p.val = value;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (f <span class=\"keyword\">instanceof</span> ReservationNode)</span><br><span class=\"line\">                            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalStateException</span>(<span class=\"string\">&quot;Recursive update&quot;</span>);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (binCount != <span class=\"number\">0</span>) &#123;<span class=\"comment\">// 如果链表数量</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class=\"line\">                        treeifyBin(tab, i);<span class=\"comment\">//  链表转红黑树哦！</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (oldVal != <span class=\"literal\">null</span>)</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> oldVal;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        addCount(<span class=\"number\">1L</span>, binCount); <span class=\"comment\">// 统计大小 并且检查是否要扩容。</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>涉及到重要函数initTable、tabAt、casTabAt、helpTransfer、putTreeVal、treeifyBin、addCount函数。</p>\n<ol start=\"3\">\n<li>initTable</li>\n</ol>\n<blockquote>\n<p><strong>「只允许一个线程」</strong> 对表进行初始化，如果不巧有其他线程进来了，那么会让其他线程交出 CPU 等待下次系统调度Thread.yield。这样，保证了表同时只会被一个线程初始化，对于table的大小，会根据sizeCtl的值进行设置，如果没有设置szieCtl的值，那么默认生成的table大小为16，否则，会根据sizeCtl的大小设置table大小。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 容器初始化 操作</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class=\"line\">    Node&lt;K,V&gt;[] tab; <span class=\"type\">int</span> sc;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ((tab = table)  <span class=\"literal\">null</span> || tab.length  <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((sc = sizeCtl) &lt; <span class=\"number\">0</span>) <span class=\"comment\">// 如果正在初始化-1，-N 正在扩容。</span></span><br><span class=\"line\">            Thread.<span class=\"keyword\">yield</span>(); <span class=\"comment\">// 进行线程让步等待</span></span><br><span class=\"line\">     <span class=\"comment\">// 让掉当前线程 CPU 的时间片，使正在运行中的线程重新变成就绪状态，并重新竞争 CPU 的调度权。</span></span><br><span class=\"line\">     <span class=\"comment\">// 它可能会获取到，也有可能被其他线程获取到。</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (U.compareAndSwapInt(<span class=\"built_in\">this</span>, SIZECTL, sc, -<span class=\"number\">1</span>)) &#123; </span><br><span class=\"line\">          <span class=\"comment\">//  比较sizeCtl的值与sc是否相等，相等则用 -1 替换,这表明我这个线程在进行初始化了！</span></span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((tab = table)  <span class=\"literal\">null</span> || tab.length  <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> (sc &gt; <span class=\"number\">0</span>) ? sc : DEFAULT_CAPACITY; <span class=\"comment\">// 默认为16</span></span><br><span class=\"line\">                    <span class=\"meta\">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class=\"line\">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class=\"keyword\">new</span> <span class=\"title class_\">Node</span>&lt;?,?&gt;[n];</span><br><span class=\"line\">                    table = tab = nt;</span><br><span class=\"line\">                    sc = n - (n &gt;&gt;&gt; <span class=\"number\">2</span>); </span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                sizeCtl = sc; <span class=\"comment\">//设置sizeCtl 类似threshold</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> tab;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","excerpt":"","more":"<h1>Map</h1>\n<h2 id=\"HashMap\">HashMap</h2>\n<p>JDK1.8 之前 HashMap 底层是 <strong>数组和链表</strong> 结合在一起使用也就是 <strong>链表散列</strong>。HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash 值，然后通过 (n - 1) &amp; hash 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</p>\n<p>所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。</p>\n<h3 id=\"JDK1-8-之前\">JDK1.8 之前</h3>\n<p>“拉链法” 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</p>\n<h3 id=\"JDK1-8-之后\">JDK1.8 之后</h3>\n<p>当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。</p>\n<p><img src=\"/assets/net-img-1591690908749-8d13658b-f28f-4a16-9787-5d802366b2bb-20221030132339-jhzqts2.png\" alt=\"\"></p>\n<blockquote>\n<p>TreeMap、TreeSet 以及 JDK1.8 之后的 HashMap 底层都用到了红黑树。红黑树就是为了解决二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构。</p>\n</blockquote>\n<h2 id=\"ConcurrentHashMap\">ConcurrentHashMap</h2>\n<p>1.8及之后</p>\n<blockquote>\n<ol>\n<li>用table保存数据，锁的粒度更小，减少并发冲突的概率。采用table数组元素作为锁，从而实现了对每一行数据进行加锁，进一步减少并发冲突的概率，并发控制使用Synchronized和CAS来操作。</li>\n<li>存储数据时采用了数组+ 链表+红黑树的形式。</li>\n</ol>\n</blockquote>\n<ol>\n<li>CurrentHashMap重要参数：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">MAXIMUM_CAPACITY</span> <span class=\"operator\">=</span> <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">30</span>; <span class=\"comment\">// 数组的最大值 </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">DEFAULT_CAPACITY</span> <span class=\"operator\">=</span> <span class=\"number\">16</span>; <span class=\"comment\">// 默认数组长度 </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">TREEIFY_THRESHOLD</span> <span class=\"operator\">=</span> <span class=\"number\">8</span>; <span class=\"comment\">// 链表转红黑树的一个条件 </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">UNTREEIFY_THRESHOLD</span> <span class=\"operator\">=</span> <span class=\"number\">6</span>; <span class=\"comment\">// 红黑树转链表的一个条件 </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">MIN_TREEIFY_CAPACITY</span> <span class=\"operator\">=</span> <span class=\"number\">64</span>; <span class=\"comment\">// 链表转红黑树的另一个条件</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">MOVED</span>     <span class=\"operator\">=</span> -<span class=\"number\">1</span>;  <span class=\"comment\">// 表示正在扩容转移 </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">TREEBIN</span>   <span class=\"operator\">=</span> -<span class=\"number\">2</span>; <span class=\"comment\">// 表示已经转换成树 </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">RESERVED</span>  <span class=\"operator\">=</span> -<span class=\"number\">3</span>; <span class=\"comment\">// hash for transient reservations </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">HASH_BITS</span> <span class=\"operator\">=</span> <span class=\"number\">0x7fffffff</span>; <span class=\"comment\">// 获得hash值的辅助参数</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">transient</span> <span class=\"keyword\">volatile</span> Node&lt;K,V&gt;[] table;<span class=\"comment\">// 默认没初始化的数组，用来保存元素 </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> <span class=\"keyword\">volatile</span> Node&lt;K,V&gt;[] nextTable; <span class=\"comment\">// 转移的时候用的数组 </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">NCPU</span> <span class=\"operator\">=</span> Runtime.getRuntime().availableProcessors();<span class=\"comment\">// 获取可用的CPU个数 </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> <span class=\"keyword\">volatile</span> Node&lt;K,V&gt;[] nextTable; <span class=\"comment\">// 连接表，用于哈希表扩容，扩容完成后会被重置为 null </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> <span class=\"keyword\">volatile</span> <span class=\"type\">long</span> baseCount; <span class=\"comment\">//保存着整个哈希表中存储的所有的结点的个数总和，有点类似于 HashMap 的 size 属性。</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> <span class=\"keyword\">volatile</span> <span class=\"type\">int</span> sizeCtl; </span><br><span class=\"line\"><span class=\"comment\">//sizeCtl = 0：表示没有指定初始容量</span></span><br><span class=\"line\"><span class=\"comment\">//sizeCtl &gt; 0：表示初始容量(可以使用阶段)</span></span><br><span class=\"line\"><span class=\"comment\">//sizeCtl = -1,标记作用，告知其他线程，正在初始化</span></span><br><span class=\"line\"><span class=\"comment\">//sizeCtl = 0.75n ,扩容阈值</span></span><br><span class=\"line\"><span class=\"comment\">//sizeCtl &lt; 0 : 表示有其他线程正在执行扩容or初始化(不能使用阶段)</span></span><br><span class=\"line\"><span class=\"comment\">//sizeCtl = (resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT) + 2 :表示此时只有一个线程在执行扩容</span></span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>扩容机制</li>\n</ol>\n<blockquote>\n<ul>\n<li>nextTable: 扩容期间，将元素迁移到 nextTable 新Map, nextTable是共享变量。</li>\n<li>sizeCtl: 多线程之间，sizeCtl来判断ConcurrentHashMap当前所处的状态。\n<ul>\n<li>通过CAS设置sizeCtl属性，告知其他线程ConcurrentHashMap的状态变更。</li>\n</ul>\n</li>\n<li>transferIndex: 扩容索引，表示已经完成数据分配的table数组索引位置。\n<ul>\n<li>数据转移已经到了哪个位置? 其他线程根据这个值帮助扩容从这个索引位置继续转移数据</li>\n</ul>\n</li>\n<li>ForwardingNode节点: 标记作用,表示此节点已经扩容完毕，hash值等于-1\n<ul>\n<li>数组位置的数据已经被转移到新Map中,此位置就会被设置为这个属性</li>\n<li>这个属性包装了新Map,可以用find方法取扩容转移后的值</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<p><strong>扩容流程：</strong></p>\n<ul>\n<li>线程执行put操作，发现容量已经达到扩容阈值，需要进行扩容操作</li>\n<li>扩容线程A 以CAS机制修改<code>transferindex</code>值,然后按照降序迁移数据,<code>transferindex</code>是数组尾部的索引\n<ul>\n<li><code>transferindex</code>的初始值: 新数组的长度 - 1 -&gt; 就是数组的最后一位</li>\n</ul>\n</li>\n<li>迁移hash桶时，会将桶内的链表或者红黑树，按照一定算法，拆分成2份，将其插入<code>nextTable[i]</code>和<code>nextTable[i+n]</code>（n是之前table数组的长度）。\n<ul>\n<li>扩容后重新计算的hash值与之前hash值一样,则存放位置不变</li>\n<li>重新计算的hash值与之前hash值不一样,则存放再索引i +n处(之前的数组长度 + 计算的索引)</li>\n</ul>\n</li>\n<li>迁移完毕的hash桶,都会被设置成<code>ForwardingNode</code>节点，以此告知访问此桶的其他线程，此节点已经迁移完毕,但数据并没有全部迁移完成。</li>\n<li>此时线程2访问到了<code>ForwardingNode</code>节点，如果线程2执行的put或remove等写操作，那么就会先帮其扩容。\n<ul>\n<li>如果线程2执行的是get等读方法，则会调用<code>ForwardingNode</code>的find方法，去<code>nextTable</code>里面查找相关元素。</li>\n</ul>\n</li>\n</ul>\n<ol start=\"3\">\n<li>put</li>\n</ol>\n<blockquote>\n<p>put操作采用 CAS + synchronized 实现并发插入或更新操作</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Node 节点的 hash值在HashMap中存储的就是hash值，在currenthashmap中可能有多种情况哦！</span></span><br><span class=\"line\"><span class=\"comment\">/** Implementation for put and putIfAbsent */</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> V <span class=\"title function_\">putVal</span><span class=\"params\">(K key, V value, <span class=\"type\">boolean</span> onlyIfAbsent)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (key == <span class=\"literal\">null</span> || value == <span class=\"literal\">null</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NullPointerException</span>();</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">hash</span> <span class=\"operator\">=</span> spread(key.hashCode());<span class=\"comment\">// 最终hash值计算</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">binCount</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123; <span class=\"comment\">//循环表</span></span><br><span class=\"line\">            Node&lt;K,V&gt; f; <span class=\"type\">int</span> n, i, fh; K fk; V fv;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (tab == <span class=\"literal\">null</span> || (n = tab.length) == <span class=\"number\">0</span>)</span><br><span class=\"line\">                tab = initTable(); <span class=\"comment\">// 初始化表 如果为空,懒汉式</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((f = tabAt(tab, i = (n - <span class=\"number\">1</span>) &amp; hash)) == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//// 如果对应桶位置为空</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (casTabAt(tab, i, <span class=\"literal\">null</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">Node</span>&lt;K,V&gt;(hash, key, value)))</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;                    <span class=\"comment\">// CAS 原子性的尝试插入</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((fh = f.hash) == MOVED)</span><br><span class=\"line\">                <span class=\"comment\">//f.hash == MOVED 表示为：ForwardingNode，说明其他线程正在扩容</span></span><br><span class=\"line\">                <span class=\"comment\">//并且这个数组的位置数据已经转移到新的数组结构中</span></span><br><span class=\"line\">                <span class=\"comment\">//但是数据还没有全部转移完成,帮助线程先扩容</span></span><br><span class=\"line\">                <span class=\"comment\">// 如果当前节点正在扩容。还要帮着去扩容 </span></span><br><span class=\"line\">                tab = helpTransfer(tab, f);</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (onlyIfAbsent <span class=\"comment\">//jdk 检查第一个节点 是否已存在key 存在返回对应value值 check first node without acquiring lock</span></span><br><span class=\"line\">                     &amp;&amp; fh == hash</span><br><span class=\"line\">                     &amp;&amp; ((fk = f.key) == key || (fk != <span class=\"literal\">null</span> &amp;&amp; key.equals(fk)))</span><br><span class=\"line\">                     &amp;&amp; (fv = f.val) != <span class=\"literal\">null</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> fv;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"type\">V</span> <span class=\"variable\">oldVal</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;<span class=\"comment\">//桶存在数据 加锁操作进行处理</span></span><br><span class=\"line\">                <span class=\"keyword\">synchronized</span> (f) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (fh &gt;= <span class=\"number\">0</span>) &#123;<span class=\"comment\">// 如果存储的是链表 存储的是节点的hash值</span></span><br><span class=\"line\">                            binCount = <span class=\"number\">1</span>;</span><br><span class=\"line\">                            <span class=\"keyword\">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class=\"line\">                                K ek;</span><br><span class=\"line\">                                <span class=\"comment\">// 遍历链表去查找，如果找到key 选择性覆盖</span></span><br><span class=\"line\">                                <span class=\"keyword\">if</span> (e.hash == hash &amp;&amp;</span><br><span class=\"line\">                                    ((ek = e.key) == key ||</span><br><span class=\"line\">                                     (ek != <span class=\"literal\">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class=\"line\">                                    oldVal = e.val;</span><br><span class=\"line\">                                    <span class=\"keyword\">if</span> (!onlyIfAbsent)</span><br><span class=\"line\">                                        e.val = value;</span><br><span class=\"line\">                                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                                &#125;</span><br><span class=\"line\">                                Node&lt;K,V&gt; pred = e;</span><br><span class=\"line\">                                <span class=\"keyword\">if</span> ((e = e.next) == <span class=\"literal\">null</span>) &#123;<span class=\"comment\">// 找到尾部插入</span></span><br><span class=\"line\">                                    pred.next = <span class=\"keyword\">new</span> <span class=\"title class_\">Node</span>&lt;K,V&gt;(hash, key, value);</span><br><span class=\"line\">                                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                                &#125;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (f <span class=\"keyword\">instanceof</span> TreeBin) &#123;<span class=\"comment\">// 如果桶节点类型为TreeBin</span></span><br><span class=\"line\">                            Node&lt;K,V&gt; p;</span><br><span class=\"line\">                            binCount = <span class=\"number\">2</span>;</span><br><span class=\"line\">                            <span class=\"keyword\">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class=\"line\">                                                           value)) != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                                 <span class=\"comment\">// 尝试红黑树插入，同时也要防止节点本来就有，选择性覆盖</span></span><br><span class=\"line\">                                oldVal = p.val;</span><br><span class=\"line\">                                <span class=\"keyword\">if</span> (!onlyIfAbsent)</span><br><span class=\"line\">                                    p.val = value;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (f <span class=\"keyword\">instanceof</span> ReservationNode)</span><br><span class=\"line\">                            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IllegalStateException</span>(<span class=\"string\">&quot;Recursive update&quot;</span>);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (binCount != <span class=\"number\">0</span>) &#123;<span class=\"comment\">// 如果链表数量</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class=\"line\">                        treeifyBin(tab, i);<span class=\"comment\">//  链表转红黑树哦！</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (oldVal != <span class=\"literal\">null</span>)</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> oldVal;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        addCount(<span class=\"number\">1L</span>, binCount); <span class=\"comment\">// 统计大小 并且检查是否要扩容。</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>涉及到重要函数initTable、tabAt、casTabAt、helpTransfer、putTreeVal、treeifyBin、addCount函数。</p>\n<ol start=\"3\">\n<li>initTable</li>\n</ol>\n<blockquote>\n<p><strong>「只允许一个线程」</strong> 对表进行初始化，如果不巧有其他线程进来了，那么会让其他线程交出 CPU 等待下次系统调度Thread.yield。这样，保证了表同时只会被一个线程初始化，对于table的大小，会根据sizeCtl的值进行设置，如果没有设置szieCtl的值，那么默认生成的table大小为16，否则，会根据sizeCtl的大小设置table大小。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 容器初始化 操作</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class=\"line\">    Node&lt;K,V&gt;[] tab; <span class=\"type\">int</span> sc;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ((tab = table)  <span class=\"literal\">null</span> || tab.length  <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((sc = sizeCtl) &lt; <span class=\"number\">0</span>) <span class=\"comment\">// 如果正在初始化-1，-N 正在扩容。</span></span><br><span class=\"line\">            Thread.<span class=\"keyword\">yield</span>(); <span class=\"comment\">// 进行线程让步等待</span></span><br><span class=\"line\">     <span class=\"comment\">// 让掉当前线程 CPU 的时间片，使正在运行中的线程重新变成就绪状态，并重新竞争 CPU 的调度权。</span></span><br><span class=\"line\">     <span class=\"comment\">// 它可能会获取到，也有可能被其他线程获取到。</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (U.compareAndSwapInt(<span class=\"built_in\">this</span>, SIZECTL, sc, -<span class=\"number\">1</span>)) &#123; </span><br><span class=\"line\">          <span class=\"comment\">//  比较sizeCtl的值与sc是否相等，相等则用 -1 替换,这表明我这个线程在进行初始化了！</span></span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((tab = table)  <span class=\"literal\">null</span> || tab.length  <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> (sc &gt; <span class=\"number\">0</span>) ? sc : DEFAULT_CAPACITY; <span class=\"comment\">// 默认为16</span></span><br><span class=\"line\">                    <span class=\"meta\">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class=\"line\">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class=\"keyword\">new</span> <span class=\"title class_\">Node</span>&lt;?,?&gt;[n];</span><br><span class=\"line\">                    table = tab = nt;</span><br><span class=\"line\">                    sc = n - (n &gt;&gt;&gt; <span class=\"number\">2</span>); </span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                sizeCtl = sc; <span class=\"comment\">//设置sizeCtl 类似threshold</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> tab;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Queue","date":"2022-10-30T05:22:56.000Z","lastmod":"2023-05-27T07:51:10.000Z","_content":"\n# Queue\n\n## Queue \t​![image](/assets/image-20230527154724-v674duu.png)​\n\n　　**注意：不要把 null 添加到队列中，否则 poll()方法返回 null 时，很难确定是取到了 null 元素还是队列为空。**\n\n## PriorityQueue(优先队列) `extends AbstractQueue`\n\n> 通过二叉小顶堆实现，可以用一棵完全二叉树表示\n> 优先队列的作用是能保证每次取出的元素都是队列中权值最小的\n> PriorityQueue 实现了 Queue 接口，不允许放入 null 元素；其通过堆实现，具体说是通过完全二叉树 （complete binary tree） 实现的小顶堆（任意一个非叶子节点的权值，都不大于其左右子节点的权值），也就意味着可以通过数组来作为 PriorityQueue 的底层实现\n> 放入 PriorityQueue 的元素，必须实现 Comparable 接口，PriorityQueue 会根据元素的排序顺序决定出队的优先级\n\n## Deque `extends Queue`(接口)\n\n　　**队列和 Deque 方法的比较**\n\n|队列方法|等效的 Deque 方法|\n| ---------| -----------------|\n|add(e)|addLast(e)|\n|offer(e)|offerLast(e)|\n|remove()|removeFirst()|\n|poll()|pollFirst()|\n|element()|getFirst()|\n|peek()|peekFirst()|\n\n## ArrayDeque `implements Deque` (实现接口)\n\n## ArrayBlockingQueue\n\n## SynchronousQueue\n\n## PriorityBlockingQueue\n\n## DelayQueue\n","source":"_posts/java/Collection/Queue.md","raw":"---\ntitle: Queue\ndate: 2022-10-30T13:22:56Z\nlastmod: 2023-05-27T15:51:10Z\n---\n\n# Queue\n\n## Queue \t​![image](/assets/image-20230527154724-v674duu.png)​\n\n　　**注意：不要把 null 添加到队列中，否则 poll()方法返回 null 时，很难确定是取到了 null 元素还是队列为空。**\n\n## PriorityQueue(优先队列) `extends AbstractQueue`\n\n> 通过二叉小顶堆实现，可以用一棵完全二叉树表示\n> 优先队列的作用是能保证每次取出的元素都是队列中权值最小的\n> PriorityQueue 实现了 Queue 接口，不允许放入 null 元素；其通过堆实现，具体说是通过完全二叉树 （complete binary tree） 实现的小顶堆（任意一个非叶子节点的权值，都不大于其左右子节点的权值），也就意味着可以通过数组来作为 PriorityQueue 的底层实现\n> 放入 PriorityQueue 的元素，必须实现 Comparable 接口，PriorityQueue 会根据元素的排序顺序决定出队的优先级\n\n## Deque `extends Queue`(接口)\n\n　　**队列和 Deque 方法的比较**\n\n|队列方法|等效的 Deque 方法|\n| ---------| -----------------|\n|add(e)|addLast(e)|\n|offer(e)|offerLast(e)|\n|remove()|removeFirst()|\n|poll()|pollFirst()|\n|element()|getFirst()|\n|peek()|peekFirst()|\n\n## ArrayDeque `implements Deque` (实现接口)\n\n## ArrayBlockingQueue\n\n## SynchronousQueue\n\n## PriorityBlockingQueue\n\n## DelayQueue\n","slug":"java-Collection-Queue","published":1,"updated":"2025-04-22T07:27:29.941Z","_id":"cm9s3f40i002wbfg41b4hcgsc","comments":1,"layout":"post","photos":[],"content":"<h1>Queue</h1>\n<h2 id=\"Queue-​image​\">Queue \t​<img src=\"/assets/image-20230527154724-v674duu.png\" alt=\"image\">​</h2>\n<p><strong>注意：不要把 null 添加到队列中，否则 poll()方法返回 null 时，很难确定是取到了 null 元素还是队列为空。</strong></p>\n<h2 id=\"PriorityQueue-优先队列-extends-AbstractQueue\">PriorityQueue(优先队列) <code>extends AbstractQueue</code></h2>\n<blockquote>\n<p>通过二叉小顶堆实现，可以用一棵完全二叉树表示<br>\n优先队列的作用是能保证每次取出的元素都是队列中权值最小的<br>\nPriorityQueue 实现了 Queue 接口，不允许放入 null 元素；其通过堆实现，具体说是通过完全二叉树 （complete binary tree） 实现的小顶堆（任意一个非叶子节点的权值，都不大于其左右子节点的权值），也就意味着可以通过数组来作为 PriorityQueue 的底层实现<br>\n放入 PriorityQueue 的元素，必须实现 Comparable 接口，PriorityQueue 会根据元素的排序顺序决定出队的优先级</p>\n</blockquote>\n<h2 id=\"Deque-extends-Queue-接口\">Deque <code>extends Queue</code>(接口)</h2>\n<p><strong>队列和 Deque 方法的比较</strong></p>\n<table>\n<thead>\n<tr>\n<th>队列方法</th>\n<th>等效的 Deque 方法</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>add(e)</td>\n<td>addLast(e)</td>\n</tr>\n<tr>\n<td>offer(e)</td>\n<td>offerLast(e)</td>\n</tr>\n<tr>\n<td>remove()</td>\n<td>removeFirst()</td>\n</tr>\n<tr>\n<td>poll()</td>\n<td>pollFirst()</td>\n</tr>\n<tr>\n<td>element()</td>\n<td>getFirst()</td>\n</tr>\n<tr>\n<td>peek()</td>\n<td>peekFirst()</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"ArrayDeque-implements-Deque-实现接口\">ArrayDeque <code>implements Deque</code> (实现接口)</h2>\n<h2 id=\"ArrayBlockingQueue\">ArrayBlockingQueue</h2>\n<h2 id=\"SynchronousQueue\">SynchronousQueue</h2>\n<h2 id=\"PriorityBlockingQueue\">PriorityBlockingQueue</h2>\n<h2 id=\"DelayQueue\">DelayQueue</h2>\n","excerpt":"","more":"<h1>Queue</h1>\n<h2 id=\"Queue-​image​\">Queue \t​<img src=\"/assets/image-20230527154724-v674duu.png\" alt=\"image\">​</h2>\n<p><strong>注意：不要把 null 添加到队列中，否则 poll()方法返回 null 时，很难确定是取到了 null 元素还是队列为空。</strong></p>\n<h2 id=\"PriorityQueue-优先队列-extends-AbstractQueue\">PriorityQueue(优先队列) <code>extends AbstractQueue</code></h2>\n<blockquote>\n<p>通过二叉小顶堆实现，可以用一棵完全二叉树表示<br>\n优先队列的作用是能保证每次取出的元素都是队列中权值最小的<br>\nPriorityQueue 实现了 Queue 接口，不允许放入 null 元素；其通过堆实现，具体说是通过完全二叉树 （complete binary tree） 实现的小顶堆（任意一个非叶子节点的权值，都不大于其左右子节点的权值），也就意味着可以通过数组来作为 PriorityQueue 的底层实现<br>\n放入 PriorityQueue 的元素，必须实现 Comparable 接口，PriorityQueue 会根据元素的排序顺序决定出队的优先级</p>\n</blockquote>\n<h2 id=\"Deque-extends-Queue-接口\">Deque <code>extends Queue</code>(接口)</h2>\n<p><strong>队列和 Deque 方法的比较</strong></p>\n<table>\n<thead>\n<tr>\n<th>队列方法</th>\n<th>等效的 Deque 方法</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>add(e)</td>\n<td>addLast(e)</td>\n</tr>\n<tr>\n<td>offer(e)</td>\n<td>offerLast(e)</td>\n</tr>\n<tr>\n<td>remove()</td>\n<td>removeFirst()</td>\n</tr>\n<tr>\n<td>poll()</td>\n<td>pollFirst()</td>\n</tr>\n<tr>\n<td>element()</td>\n<td>getFirst()</td>\n</tr>\n<tr>\n<td>peek()</td>\n<td>peekFirst()</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"ArrayDeque-implements-Deque-实现接口\">ArrayDeque <code>implements Deque</code> (实现接口)</h2>\n<h2 id=\"ArrayBlockingQueue\">ArrayBlockingQueue</h2>\n<h2 id=\"SynchronousQueue\">SynchronousQueue</h2>\n<h2 id=\"PriorityBlockingQueue\">PriorityBlockingQueue</h2>\n<h2 id=\"DelayQueue\">DelayQueue</h2>\n"},{"title":"Set","date":"2022-10-30T05:22:31.000Z","lastmod":"2022-10-30T05:22:31.000Z","_content":"\n# Set\n\n---\n\n## HashSet 集合\n\n> 底层数据结构是哈希表(是一个元素为链表的数组) + 红黑树\n\n　　**要点**\n\n- 实现 Set 接口\n- 不保证迭代顺序\n- 允许元素为 null\n- 底层实际上是一个 HashMap 实例\n- 非同步\n- 初始容量非常影响迭代性能\n\n　　HashSet 实际上就是封装了 HashMap，操作 HashSet 元素实际上就是操作 HashMap。这也是面向对象的一种体现，重用性贼高！\n\n　　详解见 [HashMap](map.md##HashMap)\n\n## TreeSet 集合\n\n> 底层数据结构是红黑树(是一个自平衡的二叉树)\n\n　　保证元素的排序方式\n\n　　**要点**\n\n- 实现NavigableSet接口\n- 可以实现排序功能\n- 底层实际上是一个TreeMap实例\n- 非同步\n\n## LinkedHashSet 集合\n\n> 底层数据结构由哈希表(是一个元素为链表的数组)和双向链表组成。\n","source":"_posts/java/Collection/Set.md","raw":"---\ntitle: Set\ndate: 2022-10-30T13:22:31Z\nlastmod: 2022-10-30T13:22:31Z\n---\n\n# Set\n\n---\n\n## HashSet 集合\n\n> 底层数据结构是哈希表(是一个元素为链表的数组) + 红黑树\n\n　　**要点**\n\n- 实现 Set 接口\n- 不保证迭代顺序\n- 允许元素为 null\n- 底层实际上是一个 HashMap 实例\n- 非同步\n- 初始容量非常影响迭代性能\n\n　　HashSet 实际上就是封装了 HashMap，操作 HashSet 元素实际上就是操作 HashMap。这也是面向对象的一种体现，重用性贼高！\n\n　　详解见 [HashMap](map.md##HashMap)\n\n## TreeSet 集合\n\n> 底层数据结构是红黑树(是一个自平衡的二叉树)\n\n　　保证元素的排序方式\n\n　　**要点**\n\n- 实现NavigableSet接口\n- 可以实现排序功能\n- 底层实际上是一个TreeMap实例\n- 非同步\n\n## LinkedHashSet 集合\n\n> 底层数据结构由哈希表(是一个元素为链表的数组)和双向链表组成。\n","slug":"java-Collection-Set","published":1,"updated":"2025-04-22T02:21:59.463Z","comments":1,"layout":"post","photos":[],"_id":"cm9s3f40j002xbfg44nml29lz","content":"<h1>Set</h1>\n<hr>\n<h2 id=\"HashSet-集合\">HashSet 集合</h2>\n<blockquote>\n<p>底层数据结构是哈希表(是一个元素为链表的数组) + 红黑树</p>\n</blockquote>\n<p><strong>要点</strong></p>\n<ul>\n<li>实现 Set 接口</li>\n<li>不保证迭代顺序</li>\n<li>允许元素为 null</li>\n<li>底层实际上是一个 HashMap 实例</li>\n<li>非同步</li>\n<li>初始容量非常影响迭代性能</li>\n</ul>\n<p>HashSet 实际上就是封装了 HashMap，操作 HashSet 元素实际上就是操作 HashMap。这也是面向对象的一种体现，重用性贼高！</p>\n<p>详解见 <a href=\"map.md##HashMap\">HashMap</a></p>\n<h2 id=\"TreeSet-集合\">TreeSet 集合</h2>\n<blockquote>\n<p>底层数据结构是红黑树(是一个自平衡的二叉树)</p>\n</blockquote>\n<p>保证元素的排序方式</p>\n<p><strong>要点</strong></p>\n<ul>\n<li>实现NavigableSet接口</li>\n<li>可以实现排序功能</li>\n<li>底层实际上是一个TreeMap实例</li>\n<li>非同步</li>\n</ul>\n<h2 id=\"LinkedHashSet-集合\">LinkedHashSet 集合</h2>\n<blockquote>\n<p>底层数据结构由哈希表(是一个元素为链表的数组)和双向链表组成。</p>\n</blockquote>\n","excerpt":"","more":"<h1>Set</h1>\n<hr>\n<h2 id=\"HashSet-集合\">HashSet 集合</h2>\n<blockquote>\n<p>底层数据结构是哈希表(是一个元素为链表的数组) + 红黑树</p>\n</blockquote>\n<p><strong>要点</strong></p>\n<ul>\n<li>实现 Set 接口</li>\n<li>不保证迭代顺序</li>\n<li>允许元素为 null</li>\n<li>底层实际上是一个 HashMap 实例</li>\n<li>非同步</li>\n<li>初始容量非常影响迭代性能</li>\n</ul>\n<p>HashSet 实际上就是封装了 HashMap，操作 HashSet 元素实际上就是操作 HashMap。这也是面向对象的一种体现，重用性贼高！</p>\n<p>详解见 <a href=\"map.md##HashMap\">HashMap</a></p>\n<h2 id=\"TreeSet-集合\">TreeSet 集合</h2>\n<blockquote>\n<p>底层数据结构是红黑树(是一个自平衡的二叉树)</p>\n</blockquote>\n<p>保证元素的排序方式</p>\n<p><strong>要点</strong></p>\n<ul>\n<li>实现NavigableSet接口</li>\n<li>可以实现排序功能</li>\n<li>底层实际上是一个TreeMap实例</li>\n<li>非同步</li>\n</ul>\n<h2 id=\"LinkedHashSet-集合\">LinkedHashSet 集合</h2>\n<blockquote>\n<p>底层数据结构由哈希表(是一个元素为链表的数组)和双向链表组成。</p>\n</blockquote>\n"},{"title":"Java虚拟机栈栈帧","date":"2022-10-30T05:42:05.000Z","lastmod":"2023-08-25T12:01:25.000Z","_content":"\n# Java虚拟机栈栈帧\n\n　　java虚拟机以方法作为最基本的执行单位。“栈帧”是用于支持虚拟机进行方法调用和方法执行背后的数据结构。栈帧存储了方法的局部变量表，操作数栈，动态链接和方法返回地址等信息。  \n​![image.png](/assets/net-img-1631431982904-ce964c3b-4c64-4915-84a9-a3799dd2cf92-20230330213415-i9cgn1s.png)\n\n　　***栈帧的概念结构***\n\n## 局部变量表\n\n- 局部变量表是一组变量值的存储空间，局部变量表以变量槽为单位\n- java虚拟机规范中未规定一个变量槽应该占有内存空间大小，只是有导向的说明没个变量槽都应该存放一个boolean，byte，char，short，int，float，reference，returnAddress类型的数据\n\n　　**reference 表示对一个对象的引用，java虚拟机规范中并没有明确指出reference类型的长度。** \n虚拟机至少通过这个应用确认两件事：\n\n1. 根据引用直接或间接的查找到对象在java堆中的数据存放的起始地址或索引\n2. 根据引用直接或间接的查找对象所属数据类型在方法区中的存储的类型信息\n\n　　**returnAddress现在基本很少出现**\n\n## 操作数栈\n\n　　![image.png](/assets/net-img-1631436389678-e6910ed9-8e3c-4d73-93bf-362566a4ebb0-20230330213421-crfgpeh.png)\n **_ 两个栈帧之间的数据共享  _**\n\n## 动态链接\n\n## 方法返回地址\n\n## 附加信息\n","source":"_posts/java/JVM/Java虚拟机栈栈帧.md","raw":"---\ntitle: Java虚拟机栈栈帧\ndate: 2022-10-30T13:42:05Z\nlastmod: 2023-08-25T20:01:25Z\n---\n\n# Java虚拟机栈栈帧\n\n　　java虚拟机以方法作为最基本的执行单位。“栈帧”是用于支持虚拟机进行方法调用和方法执行背后的数据结构。栈帧存储了方法的局部变量表，操作数栈，动态链接和方法返回地址等信息。  \n​![image.png](/assets/net-img-1631431982904-ce964c3b-4c64-4915-84a9-a3799dd2cf92-20230330213415-i9cgn1s.png)\n\n　　***栈帧的概念结构***\n\n## 局部变量表\n\n- 局部变量表是一组变量值的存储空间，局部变量表以变量槽为单位\n- java虚拟机规范中未规定一个变量槽应该占有内存空间大小，只是有导向的说明没个变量槽都应该存放一个boolean，byte，char，short，int，float，reference，returnAddress类型的数据\n\n　　**reference 表示对一个对象的引用，java虚拟机规范中并没有明确指出reference类型的长度。** \n虚拟机至少通过这个应用确认两件事：\n\n1. 根据引用直接或间接的查找到对象在java堆中的数据存放的起始地址或索引\n2. 根据引用直接或间接的查找对象所属数据类型在方法区中的存储的类型信息\n\n　　**returnAddress现在基本很少出现**\n\n## 操作数栈\n\n　　![image.png](/assets/net-img-1631436389678-e6910ed9-8e3c-4d73-93bf-362566a4ebb0-20230330213421-crfgpeh.png)\n **_ 两个栈帧之间的数据共享  _**\n\n## 动态链接\n\n## 方法返回地址\n\n## 附加信息\n","slug":"java-JVM-Java虚拟机栈栈帧","published":1,"updated":"2025-04-22T07:27:29.941Z","_id":"cm9s3f40j002ybfg4ezjh7een","comments":1,"layout":"post","photos":[],"content":"<h1>Java虚拟机栈栈帧</h1>\n<p>java虚拟机以方法作为最基本的执行单位。“栈帧”是用于支持虚拟机进行方法调用和方法执行背后的数据结构。栈帧存储了方法的局部变量表，操作数栈，动态链接和方法返回地址等信息。<br>\n​<img src=\"/assets/net-img-1631431982904-ce964c3b-4c64-4915-84a9-a3799dd2cf92-20230330213415-i9cgn1s.png\" alt=\"image.png\"></p>\n<p><em><strong>栈帧的概念结构</strong></em></p>\n<h2 id=\"局部变量表\">局部变量表</h2>\n<ul>\n<li>局部变量表是一组变量值的存储空间，局部变量表以变量槽为单位</li>\n<li>java虚拟机规范中未规定一个变量槽应该占有内存空间大小，只是有导向的说明没个变量槽都应该存放一个boolean，byte，char，short，int，float，reference，returnAddress类型的数据</li>\n</ul>\n<p><strong>reference 表示对一个对象的引用，java虚拟机规范中并没有明确指出reference类型的长度。</strong><br>\n虚拟机至少通过这个应用确认两件事：</p>\n<ol>\n<li>根据引用直接或间接的查找到对象在java堆中的数据存放的起始地址或索引</li>\n<li>根据引用直接或间接的查找对象所属数据类型在方法区中的存储的类型信息</li>\n</ol>\n<p><strong>returnAddress现在基本很少出现</strong></p>\n<h2 id=\"操作数栈\">操作数栈</h2>\n<p><img src=\"/assets/net-img-1631436389678-e6910ed9-8e3c-4d73-93bf-362566a4ebb0-20230330213421-crfgpeh.png\" alt=\"image.png\"><br>\n<strong>_ 两个栈帧之间的数据共享  _</strong></p>\n<h2 id=\"动态链接\">动态链接</h2>\n<h2 id=\"方法返回地址\">方法返回地址</h2>\n<h2 id=\"附加信息\">附加信息</h2>\n","excerpt":"","more":"<h1>Java虚拟机栈栈帧</h1>\n<p>java虚拟机以方法作为最基本的执行单位。“栈帧”是用于支持虚拟机进行方法调用和方法执行背后的数据结构。栈帧存储了方法的局部变量表，操作数栈，动态链接和方法返回地址等信息。<br>\n​<img src=\"/assets/net-img-1631431982904-ce964c3b-4c64-4915-84a9-a3799dd2cf92-20230330213415-i9cgn1s.png\" alt=\"image.png\"></p>\n<p><em><strong>栈帧的概念结构</strong></em></p>\n<h2 id=\"局部变量表\">局部变量表</h2>\n<ul>\n<li>局部变量表是一组变量值的存储空间，局部变量表以变量槽为单位</li>\n<li>java虚拟机规范中未规定一个变量槽应该占有内存空间大小，只是有导向的说明没个变量槽都应该存放一个boolean，byte，char，short，int，float，reference，returnAddress类型的数据</li>\n</ul>\n<p><strong>reference 表示对一个对象的引用，java虚拟机规范中并没有明确指出reference类型的长度。</strong><br>\n虚拟机至少通过这个应用确认两件事：</p>\n<ol>\n<li>根据引用直接或间接的查找到对象在java堆中的数据存放的起始地址或索引</li>\n<li>根据引用直接或间接的查找对象所属数据类型在方法区中的存储的类型信息</li>\n</ol>\n<p><strong>returnAddress现在基本很少出现</strong></p>\n<h2 id=\"操作数栈\">操作数栈</h2>\n<p><img src=\"/assets/net-img-1631436389678-e6910ed9-8e3c-4d73-93bf-362566a4ebb0-20230330213421-crfgpeh.png\" alt=\"image.png\"><br>\n<strong>_ 两个栈帧之间的数据共享  _</strong></p>\n<h2 id=\"动态链接\">动态链接</h2>\n<h2 id=\"方法返回地址\">方法返回地址</h2>\n<h2 id=\"附加信息\">附加信息</h2>\n"},{"title":"虚拟机中的对象","date":"2022-10-30T05:38:14.000Z","lastmod":"2023-12-02T04:34:15.000Z","_content":"\n# 虚拟机中的对象\n\n　　‍\n\n## 虚拟机类加载机制\n\n　　![image.png](/assets/net-img-1629870852837-ca139768-9f26-412a-8940-49ed6e38f57a-20230330213513-n1dmxgm.png)\n*类的生命周期*\n_加载，验证，准备，初始化_和_卸载_这五个顺序是可以确定的，类型的加载过成必须按照这种顺序按部就班的_**开始，** _而_解析_阶段可以在初始化阶段后再开始。（并非完成一步后再进行其他部分，通常可以交叉混合进行）\n有且只有六种情况必须对类立刻进行_**初始化**_（加载，验证等在此之前已完成）；\n\n- 遇到 new getstatic，putstatic或invokestatic四条字节码指令时，如果类型没有进行初始化，则会先出发其初始化阶段。生成该四种指令的典型java代码有：\n  - new 一个实例对象\n  - 读取或设置一个类型的静态字段（被final修饰或已在编译器把结果放入常量池的静态字段除外）\n  - 调用一个类型的静态方法的时候\n- 使用java.lang.reflect包的方法对类型进行反射调用的时候，如果类型没有进行过初始化，则需 要先触发其初始化。\n- 当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。\n- 当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先 初始化这个主类\n- 当一个接口中定义了JDK 8新加入的默认方法（被default关键字修饰的接口方法）时，如果有 这个接口的实现类发生了初始化，那该接口要在其之前被初始化。\n- ** 当使用JDK 7新加入的动态语言支持时？？？**\n\n### 加载\n\n　　 在加载阶段，Java虚拟机需要完成以下三件事情：\n\n- 通过一个类的全限定名来获取定义此类的二进制字节流。\n- 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。\n- 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入 口。\n\n### 验证\n\n- 文件格式验证：检验文件是否符合Class文件规范，从而保证输入的字节流能够正确的解析并存储于方法区内。\n  - 是否以魔数0xCAFEBABE开头。 ·主、次版本号是否在当前Java虚拟机接受范围之内。\n  - 常量池的常量中是否有不被支持的常量类型（检查常量tag标志）。\n  - 指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量。\n  - CONSTANT_Utf8_info型的常量中是否有不符合UTF-8编码的数据。\n  - Class文件中各个部分及文件本身是否有被删除的或附加的其他信息。\n  - ........ 等\n- 元数据验证：对字节码描述的信息进行语义分析\n  - 这个类是否有父类（除了java.lang.Object之外，所有的类都应当有父类）。\n  - 这个类的父类是否继承了不允许被继承的类（被final修饰的类）。\n  - 如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法。\n  - 类中的字段、方法是否与父类产生矛盾（例如覆盖了父类的final字段，或者出现不符合规则的方 法重载，例如方法参数都一致，但返回值类型却不同等）。\n  - ...........等\n- 字节码验证：主要是通过数据流分析和控制流分析，确定程序语义是否合法、符合逻辑。\n  - 保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作，例如不会出现类似于“在操作 栈放置了一个int类型的数据，使用时却按long类型来加载入本地变量表中”这样的情况。\n  - 保证任何跳转指令都不会跳转到方法体以外的字节码指令上。\n  - 保证方法体中的类型转换总是有效的，例如可以把一个子类对象赋值给父类数据类型，这是安全的，但是把父类对象赋值给子类数据类型，甚至把对象赋值给与它毫无继承关系、完全不相干的一个 数据类型，则是危险和不合法的。\n  - ……\n- 符号引用验证： 发生在虚拟机将符号引用转化为直接引用的时候。符号引用验证可以看作是对类自身以外（常量池中的各种符号 引用）的各类信息进行匹配性校验，通俗来说就是，该类是否缺少或者被禁止访问它依赖的某些外部 类、方法、字段等资源。\n  - 符号引用中通过字符串描述的全限定名是否能找到对应的类。\n  - 在指定类中是否存在符合方法的字段描述符及简单名称所描述的方法和字段。\n  - 符号引用中的类、字段、方法的可访问性（private、protected、public、）是否可被当 前类访问。\n  - …… 等\n\n### 准备\n\n　　正式为类中定义的变量（即静态变量，被static修饰的变量）分配内存并设置类变量初始值（值“通常情况”下是数据类型的零值）\n如果类字段的字段属性表中存在ConstantValue属性，那在准备阶段变量值就会被初始化为ConstantValue属性所指定的初始值。\n\n> - ConstantValue属于属性表集合中的一个属性，属性表集合中一共有21个不同属性。\n> - ConstantValue属性的使用位置：字段表；含义：final关键字定义的常量值。\n> - ConstantValue属性作用：通知虚拟机自动为静态变量赋值。\n\n　　int x =123; static int x = 123;\n\n> - 对虚拟机来说上面两种变量赋值的方式和时刻都有所不同。\n> - 非static类型变量（实例变量）\n>   - 赋值是在实例构造器<init>方法中进行的。\n> - static类型变量（类变量）\n>   - 有两种选择：在类构造器<clinit>方法或者使用ConstantValue属性。\n>     - 同时使用final 、static来修饰的变量（常量），并且这个变量的数据类型是基本类型或者String类型，就生成ConstantValue属性来进行初始化。\n>     - 没有final修饰或者并非基本类型及String类型，则选择在<clinit>方法中进行初始化。\n\n### 解析\n\n　　 将常量池内的符号引用替换为直接引用\n\n> 符号引用（Symbolic References）：符号引用以一组符号来描述所引用的目标，符号可以是任何 形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定是已经加载到虚拟机内存当中的内容。各种虚拟机实现的内存布局可以各不相同， 但是它们能接受的符号引用必须都是一致的，因为符号引用的字面量形式明确定义在《Java虚拟机规 范》的Class文件格式中。\n> ·直接引用（Direct References）：直接引用是可以直接指向目标的指针、相对偏移量或者是一个能 间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局直接相关的，同一个符号引用在不同虚 拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在虚拟机 的内存中存在。\n\n### 初始化\n\n### 卸载\n\n## 虚拟机中的对象\n\n![](/assets/net-img-4122e8fc2d6e2995074ede61ff44aef4-20230330213516-hs7yexh.svg)\n\n### 对象的创建\n\n1. 类加载\n   1. 加载\n   2. 链接\n   3. 初始化\n2. 分配空间\n   1. 指针碰撞：假设java内存绝对规整，被使用的和未使用的中间放一个指针作为分界点的指示器，分配内存时，仅需把指针挪动挪动一段和对象大小相同的距离即可。\n   2. 空闲列表：虚拟机维护一个列表，记录那些内存块是可用的，分配时从列表中获取一块足够大的空间去分配，并更新列表。\n\n> 使用Serial，ParNew等压缩整理整理过程的收集器是，系统采用指针碰撞；而是用CMS等交换算法收集器时，采用空闲列表分配空间\n\n　　内存分配（指针碰撞存在并发安全）并发问题解决方案：\n\n- CAS+重试：\n- TLAB（本地线程分配缓存）：把内存分配的动作按照线程划分在不同的空间之中进行，每个线程在JAVA堆中预先分配小块内存，只有本地缓存用完，分配新的缓存区时才需要同步锁定。\n\n> 内存分配完成，虚拟机必须将已分配的内存空间初始化零值，如果使用TLAB，初始化零值也可以提前至TLAB分配时顺便初始化零值\n\n3. 初始化零值\n   1. 将分配的空间都初始化为零值\n4. 设置对象头\n5. 执行init方法\n\n### 对象的卸载\n\n　　Java虚拟机自带的类加载器所加载的类，在整个虚拟机的生命周期中，都不会被卸载。\n用户自定义的类加载器是可以被卸载的。\n**卸载时机：**\n\n1. 该类的所有实例对象都被回收\n2. 该类的类加载器对象已经被回收\n3. 该类对应的Class对象没有被引用，无法在任何地方通过反射获取\n\n### 对象的内存布局\n\n​![图像](/assets/image-20231202123415-e2licnx.jpeg)​\n\n　　**jvm默认开启class pointer压缩 为4字节**  \n普通对象 markword 默认八个字节 instance data 若属性则为零 padding 补足被8整除  \n​![image.png](/assets/net-img-1615611389351-2cfaa4d5-b52c-4a2e-a170-c32ce97d17a6-20230330213518-3fydrb9.png)  \n数组对象  \n​![image.png](/assets/net-img-1615611419969-14ba7126-9f92-482c-a851-9898cece7e8f-20230330213518-2ptpa3a.png)  \nhotspot 虚拟机对象头markword\n\n|存储内容|标志位|状态|\n| ------------------------------------| ------| ----------------|\n|对象哈希码，对象分代年龄|01|未锁定|\n|指向锁记录的指针|00|轻量级锁状态|\n|指向重量级锁的指针|10|重量级锁状态|\n|空，不需要记录信息|11|gc标志|\n|偏向线程id、偏向时间戳、对象分代年龄|01|可偏向（偏向锁）|\n\n![image.png](/assets/net-img-1615614053644-2e45ea92-d426-42ca-a609-91b095ff7e83-20230330213519-1im5mrq.png)\n\n## 虚拟机类加载器\n\n​![image](/assets/image-20231117162020-0zic8ee.png)​\n\n​![image](/assets/image-20231117162030-ue9pyz9.png)​\n\n### jdk8\n\n1. 引导类加载器\n2. 扩展类加载器\n3. 应用类加载器\n\n### jdk9\n\n1. 引导类加载器\n2. 平台类加载器（原扩展类加载器，因兼容性被保留）\n3. 应用类加载器\n\n### jdk9后的变化\n\n　　为了保证兼容性，JDK 9没有从根本上改变三层类加载器架构和双亲委派模型，但为了模块化系统的顺利运行，仍然发生了一些值得被注意的变动。\n\n1. 扩展机制被移除，扩展类加载器由于向后兼容性的原因被保留，不过被重命名为平台类加载器（platform class loader）。可以通过ClassLoader的新方法getPlatformClassLoader()来获取。\n\n　　JDK 9 时基于模块化进行构建（原来的 rt.jar 和 tools.jar 被拆分成数十个 JMOD 文件），其中的 Java 类库就已天然地满足了可扩展的需求，那自然无须再保留 <JAVA_HOME>\\lib\\ext 目录，此前使用这个目录或者 java.ext.dirs 系统变量来扩展 JDK 功能的机制已经没有继续存在的价值了。\n\n2. 平台类加载器和应用程序类加载器都不再继承自 java.net.URLClassLoader。  \n    现在启动类加载器、平台类加载器、应用程序类加载器全都继承于 jdk.internal.loader.BuiltinClassLoader。\n\n​![image](/assets/image-20231119124040-5kytmcz.png)​\n\n　　如果有程序直接依赖了这种继承关系，或者依赖了 URLClassLoader 类的特定方法，那代码很可能会在 JDK 9 及更高版本的 JDK 中崩溃。\n\n3. 在Java 9中，类加载器有了名称。该名称在构造方法中指定，可以通过getName()方法来获取。平台类加载器的名称是platform，应用类加载器的名称是app。类加载器的名称在调试与类加载器相关的问题时会非常有用。\n4. 启动类加载器现在是在jvm内部和java类库共同协作实现的类加载器（以前是 C++实现），但为了与之前代码兼容，在获取启动类加载器的场景中仍然会返回null，而不会得到BootClassLoader实例。\n5. 类加载的委派关系也发生了变动。  \n    当平台及应用程序类加载器收到类加载请求，在委派给父加载器加载前，要先判断该类是否能够归属到某一个系统模块中，如果可以找到这样的归属关系，就要优先委派给负责那个模块的加载器完成加载。\n\n　　‍\n\n　　双亲委派模式示意图\n\n​![image](/assets/image-20231119124137-6apottn.png)​\n\n　　附加：  \n在 Java 模块化系统明确规定了三个类加载器负责各自加载的模块：  \n启动类加载器负责加载的模块  \njava.base                        java.security.sasl  \njava.datatransfer                java.xml  \njava.desktop                     jdk.httpserver  \njava.instrument                  jdk.internal.vm.ci  \njava.logging                     jdk.management  \njava.management                  jdk.management.agent  \njava.management.rmi              jdk.naming.rmi  \njava.naming                      jdk.net  \njava.prefs                       jdk.sctp  \njava.rmi                         jdk.unsupported\n\n　　平台类加载器负责加载的模块  \njava.activation*                jdk.accessibility  \njava.compiler*                  jdk.charsets  \njava.corba*                     jdk.crypto.cryptoki  \njava.scripting                  jdk.crypto.ec  \njava.se                         jdk.dynalink  \njava.se.ee                      jdk.incubator.httpclient  \njava.security.jgss              jdk.internal.vm.compiler*  \njava.smartcardio                jdk.jsobject  \njava.sql                        jdk.localedata  \njava.sql.rowset                 jdk.naming.dns  \njava.transaction*               jdk.scripting.nashorn  \njava.xml.bind*                  jdk.security.auth  \njava.xml.crypto                 jdk.security.jgss  \njava.xml.ws*                    jdk.xml.dom  \njava.xml.ws.annotation*         jdk.zipfs\n\n　　应用程序类加载器负责加载的模块  \njdk.aot                         jdk.jdeps  \njdk.attach                      jdk.jdi  \njdk.compiler                    jdk.jdwp.agent  \njdk.editpad                     jdk.jlink  \njdk.hotspot.agent               jdk.jshell  \njdk.internal.ed                 jdk.jstatd  \njdk.internal.jvmstat            jdk.pack  \njdk.internal.le                 jdk.policytool  \njdk.internal.opt                jdk.rmic  \njdk.jartool                     jdk.scripting.nashorn.shell  \njdk.javadoc                     jdk.xml.bind*  \njdk.jcmd                        jdk.xml.ws*  \njdk.jconsole\n\n　　‍\n","source":"_posts/java/JVM/虚拟机中的对象.md","raw":"---\ntitle: 虚拟机中的对象\ndate: 2022-10-30T13:38:14Z\nlastmod: 2023-12-02T12:34:15Z\n---\n\n# 虚拟机中的对象\n\n　　‍\n\n## 虚拟机类加载机制\n\n　　![image.png](/assets/net-img-1629870852837-ca139768-9f26-412a-8940-49ed6e38f57a-20230330213513-n1dmxgm.png)\n*类的生命周期*\n_加载，验证，准备，初始化_和_卸载_这五个顺序是可以确定的，类型的加载过成必须按照这种顺序按部就班的_**开始，** _而_解析_阶段可以在初始化阶段后再开始。（并非完成一步后再进行其他部分，通常可以交叉混合进行）\n有且只有六种情况必须对类立刻进行_**初始化**_（加载，验证等在此之前已完成）；\n\n- 遇到 new getstatic，putstatic或invokestatic四条字节码指令时，如果类型没有进行初始化，则会先出发其初始化阶段。生成该四种指令的典型java代码有：\n  - new 一个实例对象\n  - 读取或设置一个类型的静态字段（被final修饰或已在编译器把结果放入常量池的静态字段除外）\n  - 调用一个类型的静态方法的时候\n- 使用java.lang.reflect包的方法对类型进行反射调用的时候，如果类型没有进行过初始化，则需 要先触发其初始化。\n- 当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。\n- 当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先 初始化这个主类\n- 当一个接口中定义了JDK 8新加入的默认方法（被default关键字修饰的接口方法）时，如果有 这个接口的实现类发生了初始化，那该接口要在其之前被初始化。\n- ** 当使用JDK 7新加入的动态语言支持时？？？**\n\n### 加载\n\n　　 在加载阶段，Java虚拟机需要完成以下三件事情：\n\n- 通过一个类的全限定名来获取定义此类的二进制字节流。\n- 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。\n- 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入 口。\n\n### 验证\n\n- 文件格式验证：检验文件是否符合Class文件规范，从而保证输入的字节流能够正确的解析并存储于方法区内。\n  - 是否以魔数0xCAFEBABE开头。 ·主、次版本号是否在当前Java虚拟机接受范围之内。\n  - 常量池的常量中是否有不被支持的常量类型（检查常量tag标志）。\n  - 指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量。\n  - CONSTANT_Utf8_info型的常量中是否有不符合UTF-8编码的数据。\n  - Class文件中各个部分及文件本身是否有被删除的或附加的其他信息。\n  - ........ 等\n- 元数据验证：对字节码描述的信息进行语义分析\n  - 这个类是否有父类（除了java.lang.Object之外，所有的类都应当有父类）。\n  - 这个类的父类是否继承了不允许被继承的类（被final修饰的类）。\n  - 如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法。\n  - 类中的字段、方法是否与父类产生矛盾（例如覆盖了父类的final字段，或者出现不符合规则的方 法重载，例如方法参数都一致，但返回值类型却不同等）。\n  - ...........等\n- 字节码验证：主要是通过数据流分析和控制流分析，确定程序语义是否合法、符合逻辑。\n  - 保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作，例如不会出现类似于“在操作 栈放置了一个int类型的数据，使用时却按long类型来加载入本地变量表中”这样的情况。\n  - 保证任何跳转指令都不会跳转到方法体以外的字节码指令上。\n  - 保证方法体中的类型转换总是有效的，例如可以把一个子类对象赋值给父类数据类型，这是安全的，但是把父类对象赋值给子类数据类型，甚至把对象赋值给与它毫无继承关系、完全不相干的一个 数据类型，则是危险和不合法的。\n  - ……\n- 符号引用验证： 发生在虚拟机将符号引用转化为直接引用的时候。符号引用验证可以看作是对类自身以外（常量池中的各种符号 引用）的各类信息进行匹配性校验，通俗来说就是，该类是否缺少或者被禁止访问它依赖的某些外部 类、方法、字段等资源。\n  - 符号引用中通过字符串描述的全限定名是否能找到对应的类。\n  - 在指定类中是否存在符合方法的字段描述符及简单名称所描述的方法和字段。\n  - 符号引用中的类、字段、方法的可访问性（private、protected、public、）是否可被当 前类访问。\n  - …… 等\n\n### 准备\n\n　　正式为类中定义的变量（即静态变量，被static修饰的变量）分配内存并设置类变量初始值（值“通常情况”下是数据类型的零值）\n如果类字段的字段属性表中存在ConstantValue属性，那在准备阶段变量值就会被初始化为ConstantValue属性所指定的初始值。\n\n> - ConstantValue属于属性表集合中的一个属性，属性表集合中一共有21个不同属性。\n> - ConstantValue属性的使用位置：字段表；含义：final关键字定义的常量值。\n> - ConstantValue属性作用：通知虚拟机自动为静态变量赋值。\n\n　　int x =123; static int x = 123;\n\n> - 对虚拟机来说上面两种变量赋值的方式和时刻都有所不同。\n> - 非static类型变量（实例变量）\n>   - 赋值是在实例构造器<init>方法中进行的。\n> - static类型变量（类变量）\n>   - 有两种选择：在类构造器<clinit>方法或者使用ConstantValue属性。\n>     - 同时使用final 、static来修饰的变量（常量），并且这个变量的数据类型是基本类型或者String类型，就生成ConstantValue属性来进行初始化。\n>     - 没有final修饰或者并非基本类型及String类型，则选择在<clinit>方法中进行初始化。\n\n### 解析\n\n　　 将常量池内的符号引用替换为直接引用\n\n> 符号引用（Symbolic References）：符号引用以一组符号来描述所引用的目标，符号可以是任何 形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定是已经加载到虚拟机内存当中的内容。各种虚拟机实现的内存布局可以各不相同， 但是它们能接受的符号引用必须都是一致的，因为符号引用的字面量形式明确定义在《Java虚拟机规 范》的Class文件格式中。\n> ·直接引用（Direct References）：直接引用是可以直接指向目标的指针、相对偏移量或者是一个能 间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局直接相关的，同一个符号引用在不同虚 拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在虚拟机 的内存中存在。\n\n### 初始化\n\n### 卸载\n\n## 虚拟机中的对象\n\n![](/assets/net-img-4122e8fc2d6e2995074ede61ff44aef4-20230330213516-hs7yexh.svg)\n\n### 对象的创建\n\n1. 类加载\n   1. 加载\n   2. 链接\n   3. 初始化\n2. 分配空间\n   1. 指针碰撞：假设java内存绝对规整，被使用的和未使用的中间放一个指针作为分界点的指示器，分配内存时，仅需把指针挪动挪动一段和对象大小相同的距离即可。\n   2. 空闲列表：虚拟机维护一个列表，记录那些内存块是可用的，分配时从列表中获取一块足够大的空间去分配，并更新列表。\n\n> 使用Serial，ParNew等压缩整理整理过程的收集器是，系统采用指针碰撞；而是用CMS等交换算法收集器时，采用空闲列表分配空间\n\n　　内存分配（指针碰撞存在并发安全）并发问题解决方案：\n\n- CAS+重试：\n- TLAB（本地线程分配缓存）：把内存分配的动作按照线程划分在不同的空间之中进行，每个线程在JAVA堆中预先分配小块内存，只有本地缓存用完，分配新的缓存区时才需要同步锁定。\n\n> 内存分配完成，虚拟机必须将已分配的内存空间初始化零值，如果使用TLAB，初始化零值也可以提前至TLAB分配时顺便初始化零值\n\n3. 初始化零值\n   1. 将分配的空间都初始化为零值\n4. 设置对象头\n5. 执行init方法\n\n### 对象的卸载\n\n　　Java虚拟机自带的类加载器所加载的类，在整个虚拟机的生命周期中，都不会被卸载。\n用户自定义的类加载器是可以被卸载的。\n**卸载时机：**\n\n1. 该类的所有实例对象都被回收\n2. 该类的类加载器对象已经被回收\n3. 该类对应的Class对象没有被引用，无法在任何地方通过反射获取\n\n### 对象的内存布局\n\n​![图像](/assets/image-20231202123415-e2licnx.jpeg)​\n\n　　**jvm默认开启class pointer压缩 为4字节**  \n普通对象 markword 默认八个字节 instance data 若属性则为零 padding 补足被8整除  \n​![image.png](/assets/net-img-1615611389351-2cfaa4d5-b52c-4a2e-a170-c32ce97d17a6-20230330213518-3fydrb9.png)  \n数组对象  \n​![image.png](/assets/net-img-1615611419969-14ba7126-9f92-482c-a851-9898cece7e8f-20230330213518-2ptpa3a.png)  \nhotspot 虚拟机对象头markword\n\n|存储内容|标志位|状态|\n| ------------------------------------| ------| ----------------|\n|对象哈希码，对象分代年龄|01|未锁定|\n|指向锁记录的指针|00|轻量级锁状态|\n|指向重量级锁的指针|10|重量级锁状态|\n|空，不需要记录信息|11|gc标志|\n|偏向线程id、偏向时间戳、对象分代年龄|01|可偏向（偏向锁）|\n\n![image.png](/assets/net-img-1615614053644-2e45ea92-d426-42ca-a609-91b095ff7e83-20230330213519-1im5mrq.png)\n\n## 虚拟机类加载器\n\n​![image](/assets/image-20231117162020-0zic8ee.png)​\n\n​![image](/assets/image-20231117162030-ue9pyz9.png)​\n\n### jdk8\n\n1. 引导类加载器\n2. 扩展类加载器\n3. 应用类加载器\n\n### jdk9\n\n1. 引导类加载器\n2. 平台类加载器（原扩展类加载器，因兼容性被保留）\n3. 应用类加载器\n\n### jdk9后的变化\n\n　　为了保证兼容性，JDK 9没有从根本上改变三层类加载器架构和双亲委派模型，但为了模块化系统的顺利运行，仍然发生了一些值得被注意的变动。\n\n1. 扩展机制被移除，扩展类加载器由于向后兼容性的原因被保留，不过被重命名为平台类加载器（platform class loader）。可以通过ClassLoader的新方法getPlatformClassLoader()来获取。\n\n　　JDK 9 时基于模块化进行构建（原来的 rt.jar 和 tools.jar 被拆分成数十个 JMOD 文件），其中的 Java 类库就已天然地满足了可扩展的需求，那自然无须再保留 <JAVA_HOME>\\lib\\ext 目录，此前使用这个目录或者 java.ext.dirs 系统变量来扩展 JDK 功能的机制已经没有继续存在的价值了。\n\n2. 平台类加载器和应用程序类加载器都不再继承自 java.net.URLClassLoader。  \n    现在启动类加载器、平台类加载器、应用程序类加载器全都继承于 jdk.internal.loader.BuiltinClassLoader。\n\n​![image](/assets/image-20231119124040-5kytmcz.png)​\n\n　　如果有程序直接依赖了这种继承关系，或者依赖了 URLClassLoader 类的特定方法，那代码很可能会在 JDK 9 及更高版本的 JDK 中崩溃。\n\n3. 在Java 9中，类加载器有了名称。该名称在构造方法中指定，可以通过getName()方法来获取。平台类加载器的名称是platform，应用类加载器的名称是app。类加载器的名称在调试与类加载器相关的问题时会非常有用。\n4. 启动类加载器现在是在jvm内部和java类库共同协作实现的类加载器（以前是 C++实现），但为了与之前代码兼容，在获取启动类加载器的场景中仍然会返回null，而不会得到BootClassLoader实例。\n5. 类加载的委派关系也发生了变动。  \n    当平台及应用程序类加载器收到类加载请求，在委派给父加载器加载前，要先判断该类是否能够归属到某一个系统模块中，如果可以找到这样的归属关系，就要优先委派给负责那个模块的加载器完成加载。\n\n　　‍\n\n　　双亲委派模式示意图\n\n​![image](/assets/image-20231119124137-6apottn.png)​\n\n　　附加：  \n在 Java 模块化系统明确规定了三个类加载器负责各自加载的模块：  \n启动类加载器负责加载的模块  \njava.base                        java.security.sasl  \njava.datatransfer                java.xml  \njava.desktop                     jdk.httpserver  \njava.instrument                  jdk.internal.vm.ci  \njava.logging                     jdk.management  \njava.management                  jdk.management.agent  \njava.management.rmi              jdk.naming.rmi  \njava.naming                      jdk.net  \njava.prefs                       jdk.sctp  \njava.rmi                         jdk.unsupported\n\n　　平台类加载器负责加载的模块  \njava.activation*                jdk.accessibility  \njava.compiler*                  jdk.charsets  \njava.corba*                     jdk.crypto.cryptoki  \njava.scripting                  jdk.crypto.ec  \njava.se                         jdk.dynalink  \njava.se.ee                      jdk.incubator.httpclient  \njava.security.jgss              jdk.internal.vm.compiler*  \njava.smartcardio                jdk.jsobject  \njava.sql                        jdk.localedata  \njava.sql.rowset                 jdk.naming.dns  \njava.transaction*               jdk.scripting.nashorn  \njava.xml.bind*                  jdk.security.auth  \njava.xml.crypto                 jdk.security.jgss  \njava.xml.ws*                    jdk.xml.dom  \njava.xml.ws.annotation*         jdk.zipfs\n\n　　应用程序类加载器负责加载的模块  \njdk.aot                         jdk.jdeps  \njdk.attach                      jdk.jdi  \njdk.compiler                    jdk.jdwp.agent  \njdk.editpad                     jdk.jlink  \njdk.hotspot.agent               jdk.jshell  \njdk.internal.ed                 jdk.jstatd  \njdk.internal.jvmstat            jdk.pack  \njdk.internal.le                 jdk.policytool  \njdk.internal.opt                jdk.rmic  \njdk.jartool                     jdk.scripting.nashorn.shell  \njdk.javadoc                     jdk.xml.bind*  \njdk.jcmd                        jdk.xml.ws*  \njdk.jconsole\n\n　　‍\n","slug":"java-JVM-虚拟机中的对象","published":1,"updated":"2025-04-22T07:27:29.941Z","_id":"cm9s3f40k002zbfg47g4cdort","comments":1,"layout":"post","photos":[],"content":"<h1>虚拟机中的对象</h1>\n<p>‍</p>\n<h2 id=\"虚拟机类加载机制\">虚拟机类加载机制</h2>\n<p><img src=\"/assets/net-img-1629870852837-ca139768-9f26-412a-8940-49ed6e38f57a-20230330213513-n1dmxgm.png\" alt=\"image.png\"><br>\n<em>类的生命周期</em><br>\n<em>加载，验证，准备，初始化_和_卸载_这五个顺序是可以确定的，类型的加载过成必须按照这种顺序按部就班的</em><strong>开始，</strong> <em>而_解析_阶段可以在初始化阶段后再开始。（并非完成一步后再进行其他部分，通常可以交叉混合进行）<br>\n有且只有六种情况必须对类立刻进行</em><strong>初始化</strong>_（加载，验证等在此之前已完成）；</p>\n<ul>\n<li>遇到 new getstatic，putstatic或invokestatic四条字节码指令时，如果类型没有进行初始化，则会先出发其初始化阶段。生成该四种指令的典型java代码有：\n<ul>\n<li>new 一个实例对象</li>\n<li>读取或设置一个类型的静态字段（被final修饰或已在编译器把结果放入常量池的静态字段除外）</li>\n<li>调用一个类型的静态方法的时候</li>\n</ul>\n</li>\n<li>使用java.lang.reflect包的方法对类型进行反射调用的时候，如果类型没有进行过初始化，则需 要先触发其初始化。</li>\n<li>当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</li>\n<li>当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先 初始化这个主类</li>\n<li>当一个接口中定义了JDK 8新加入的默认方法（被default关键字修饰的接口方法）时，如果有 这个接口的实现类发生了初始化，那该接口要在其之前被初始化。</li>\n<li>** 当使用JDK 7新加入的动态语言支持时？？？**</li>\n</ul>\n<h3 id=\"加载\">加载</h3>\n<p>在加载阶段，Java虚拟机需要完成以下三件事情：</p>\n<ul>\n<li>通过一个类的全限定名来获取定义此类的二进制字节流。</li>\n<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li>\n<li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入 口。</li>\n</ul>\n<h3 id=\"验证\">验证</h3>\n<ul>\n<li>文件格式验证：检验文件是否符合Class文件规范，从而保证输入的字节流能够正确的解析并存储于方法区内。\n<ul>\n<li>是否以魔数0xCAFEBABE开头。 ·主、次版本号是否在当前Java虚拟机接受范围之内。</li>\n<li>常量池的常量中是否有不被支持的常量类型（检查常量tag标志）。</li>\n<li>指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量。</li>\n<li>CONSTANT_Utf8_info型的常量中是否有不符合UTF-8编码的数据。</li>\n<li>Class文件中各个部分及文件本身是否有被删除的或附加的其他信息。</li>\n<li>… 等</li>\n</ul>\n</li>\n<li>元数据验证：对字节码描述的信息进行语义分析\n<ul>\n<li>这个类是否有父类（除了java.lang.Object之外，所有的类都应当有父类）。</li>\n<li>这个类的父类是否继承了不允许被继承的类（被final修饰的类）。</li>\n<li>如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法。</li>\n<li>类中的字段、方法是否与父类产生矛盾（例如覆盖了父类的final字段，或者出现不符合规则的方 法重载，例如方法参数都一致，但返回值类型却不同等）。</li>\n<li>…等</li>\n</ul>\n</li>\n<li>字节码验证：主要是通过数据流分析和控制流分析，确定程序语义是否合法、符合逻辑。\n<ul>\n<li>保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作，例如不会出现类似于“在操作 栈放置了一个int类型的数据，使用时却按long类型来加载入本地变量表中”这样的情况。</li>\n<li>保证任何跳转指令都不会跳转到方法体以外的字节码指令上。</li>\n<li>保证方法体中的类型转换总是有效的，例如可以把一个子类对象赋值给父类数据类型，这是安全的，但是把父类对象赋值给子类数据类型，甚至把对象赋值给与它毫无继承关系、完全不相干的一个 数据类型，则是危险和不合法的。</li>\n<li>……</li>\n</ul>\n</li>\n<li>符号引用验证： 发生在虚拟机将符号引用转化为直接引用的时候。符号引用验证可以看作是对类自身以外（常量池中的各种符号 引用）的各类信息进行匹配性校验，通俗来说就是，该类是否缺少或者被禁止访问它依赖的某些外部 类、方法、字段等资源。\n<ul>\n<li>符号引用中通过字符串描述的全限定名是否能找到对应的类。</li>\n<li>在指定类中是否存在符合方法的字段描述符及简单名称所描述的方法和字段。</li>\n<li>符号引用中的类、字段、方法的可访问性（private、protected、public、）是否可被当 前类访问。</li>\n<li>…… 等</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"准备\">准备</h3>\n<p>正式为类中定义的变量（即静态变量，被static修饰的变量）分配内存并设置类变量初始值（值“通常情况”下是数据类型的零值）<br>\n如果类字段的字段属性表中存在ConstantValue属性，那在准备阶段变量值就会被初始化为ConstantValue属性所指定的初始值。</p>\n<blockquote>\n<ul>\n<li>ConstantValue属于属性表集合中的一个属性，属性表集合中一共有21个不同属性。</li>\n<li>ConstantValue属性的使用位置：字段表；含义：final关键字定义的常量值。</li>\n<li>ConstantValue属性作用：通知虚拟机自动为静态变量赋值。</li>\n</ul>\n</blockquote>\n<p>int x =123; static int x = 123;</p>\n<blockquote>\n<ul>\n<li>对虚拟机来说上面两种变量赋值的方式和时刻都有所不同。</li>\n<li>非static类型变量（实例变量）\n<ul>\n<li>赋值是在实例构造器<init>方法中进行的。</li>\n</ul>\n</li>\n<li>static类型变量（类变量）\n<ul>\n<li>有两种选择：在类构造器<clinit>方法或者使用ConstantValue属性。\n<ul>\n<li>同时使用final 、static来修饰的变量（常量），并且这个变量的数据类型是基本类型或者String类型，就生成ConstantValue属性来进行初始化。</li>\n<li>没有final修饰或者并非基本类型及String类型，则选择在<clinit>方法中进行初始化。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<h3 id=\"解析\">解析</h3>\n<p>将常量池内的符号引用替换为直接引用</p>\n<blockquote>\n<p>符号引用（Symbolic References）：符号引用以一组符号来描述所引用的目标，符号可以是任何 形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定是已经加载到虚拟机内存当中的内容。各种虚拟机实现的内存布局可以各不相同， 但是它们能接受的符号引用必须都是一致的，因为符号引用的字面量形式明确定义在《Java虚拟机规 范》的Class文件格式中。<br>\n·直接引用（Direct References）：直接引用是可以直接指向目标的指针、相对偏移量或者是一个能 间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局直接相关的，同一个符号引用在不同虚 拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在虚拟机 的内存中存在。</p>\n</blockquote>\n<h3 id=\"初始化\">初始化</h3>\n<h3 id=\"卸载\">卸载</h3>\n<h2 id=\"虚拟机中的对象\">虚拟机中的对象</h2>\n<p><img src=\"/assets/net-img-4122e8fc2d6e2995074ede61ff44aef4-20230330213516-hs7yexh.svg\" alt=\"\"></p>\n<h3 id=\"对象的创建\">对象的创建</h3>\n<ol>\n<li>类加载\n<ol>\n<li>加载</li>\n<li>链接</li>\n<li>初始化</li>\n</ol>\n</li>\n<li>分配空间\n<ol>\n<li>指针碰撞：假设java内存绝对规整，被使用的和未使用的中间放一个指针作为分界点的指示器，分配内存时，仅需把指针挪动挪动一段和对象大小相同的距离即可。</li>\n<li>空闲列表：虚拟机维护一个列表，记录那些内存块是可用的，分配时从列表中获取一块足够大的空间去分配，并更新列表。</li>\n</ol>\n</li>\n</ol>\n<blockquote>\n<p>使用Serial，ParNew等压缩整理整理过程的收集器是，系统采用指针碰撞；而是用CMS等交换算法收集器时，采用空闲列表分配空间</p>\n</blockquote>\n<p>内存分配（指针碰撞存在并发安全）并发问题解决方案：</p>\n<ul>\n<li>CAS+重试：</li>\n<li>TLAB（本地线程分配缓存）：把内存分配的动作按照线程划分在不同的空间之中进行，每个线程在JAVA堆中预先分配小块内存，只有本地缓存用完，分配新的缓存区时才需要同步锁定。</li>\n</ul>\n<blockquote>\n<p>内存分配完成，虚拟机必须将已分配的内存空间初始化零值，如果使用TLAB，初始化零值也可以提前至TLAB分配时顺便初始化零值</p>\n</blockquote>\n<ol start=\"3\">\n<li>初始化零值\n<ol>\n<li>将分配的空间都初始化为零值</li>\n</ol>\n</li>\n<li>设置对象头</li>\n<li>执行init方法</li>\n</ol>\n<h3 id=\"对象的卸载\">对象的卸载</h3>\n<p>Java虚拟机自带的类加载器所加载的类，在整个虚拟机的生命周期中，都不会被卸载。<br>\n用户自定义的类加载器是可以被卸载的。<br>\n<strong>卸载时机：</strong></p>\n<ol>\n<li>该类的所有实例对象都被回收</li>\n<li>该类的类加载器对象已经被回收</li>\n<li>该类对应的Class对象没有被引用，无法在任何地方通过反射获取</li>\n</ol>\n<h3 id=\"对象的内存布局\">对象的内存布局</h3>\n<p>​<img src=\"/assets/image-20231202123415-e2licnx.jpeg\" alt=\"图像\">​</p>\n<p><strong>jvm默认开启class pointer压缩 为4字节</strong><br>\n普通对象 markword 默认八个字节 instance data 若属性则为零 padding 补足被8整除<br>\n​<img src=\"/assets/net-img-1615611389351-2cfaa4d5-b52c-4a2e-a170-c32ce97d17a6-20230330213518-3fydrb9.png\" alt=\"image.png\"><br>\n数组对象<br>\n​<img src=\"/assets/net-img-1615611419969-14ba7126-9f92-482c-a851-9898cece7e8f-20230330213518-2ptpa3a.png\" alt=\"image.png\"><br>\nhotspot 虚拟机对象头markword</p>\n<table>\n<thead>\n<tr>\n<th>存储内容</th>\n<th>标志位</th>\n<th>状态</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>对象哈希码，对象分代年龄</td>\n<td>01</td>\n<td>未锁定</td>\n</tr>\n<tr>\n<td>指向锁记录的指针</td>\n<td>00</td>\n<td>轻量级锁状态</td>\n</tr>\n<tr>\n<td>指向重量级锁的指针</td>\n<td>10</td>\n<td>重量级锁状态</td>\n</tr>\n<tr>\n<td>空，不需要记录信息</td>\n<td>11</td>\n<td>gc标志</td>\n</tr>\n<tr>\n<td>偏向线程id、偏向时间戳、对象分代年龄</td>\n<td>01</td>\n<td>可偏向（偏向锁）</td>\n</tr>\n</tbody>\n</table>\n<p><img src=\"/assets/net-img-1615614053644-2e45ea92-d426-42ca-a609-91b095ff7e83-20230330213519-1im5mrq.png\" alt=\"image.png\"></p>\n<h2 id=\"虚拟机类加载器\">虚拟机类加载器</h2>\n<p>​<img src=\"/assets/image-20231117162020-0zic8ee.png\" alt=\"image\">​</p>\n<p>​<img src=\"/assets/image-20231117162030-ue9pyz9.png\" alt=\"image\">​</p>\n<h3 id=\"jdk8\">jdk8</h3>\n<ol>\n<li>引导类加载器</li>\n<li>扩展类加载器</li>\n<li>应用类加载器</li>\n</ol>\n<h3 id=\"jdk9\">jdk9</h3>\n<ol>\n<li>引导类加载器</li>\n<li>平台类加载器（原扩展类加载器，因兼容性被保留）</li>\n<li>应用类加载器</li>\n</ol>\n<h3 id=\"jdk9后的变化\">jdk9后的变化</h3>\n<p>为了保证兼容性，JDK 9没有从根本上改变三层类加载器架构和双亲委派模型，但为了模块化系统的顺利运行，仍然发生了一些值得被注意的变动。</p>\n<ol>\n<li>扩展机制被移除，扩展类加载器由于向后兼容性的原因被保留，不过被重命名为平台类加载器（platform class loader）。可以通过ClassLoader的新方法getPlatformClassLoader()来获取。</li>\n</ol>\n<p>JDK 9 时基于模块化进行构建（原来的 rt.jar 和 tools.jar 被拆分成数十个 JMOD 文件），其中的 Java 类库就已天然地满足了可扩展的需求，那自然无须再保留 &lt;JAVA_HOME&gt;\\lib\\ext 目录，此前使用这个目录或者 java.ext.dirs 系统变量来扩展 JDK 功能的机制已经没有继续存在的价值了。</p>\n<ol start=\"2\">\n<li>平台类加载器和应用程序类加载器都不再继承自 java.net.URLClassLoader。<br>\n现在启动类加载器、平台类加载器、应用程序类加载器全都继承于 jdk.internal.loader.BuiltinClassLoader。</li>\n</ol>\n<p>​<img src=\"/assets/image-20231119124040-5kytmcz.png\" alt=\"image\">​</p>\n<p>如果有程序直接依赖了这种继承关系，或者依赖了 URLClassLoader 类的特定方法，那代码很可能会在 JDK 9 及更高版本的 JDK 中崩溃。</p>\n<ol start=\"3\">\n<li>在Java 9中，类加载器有了名称。该名称在构造方法中指定，可以通过getName()方法来获取。平台类加载器的名称是platform，应用类加载器的名称是app。类加载器的名称在调试与类加载器相关的问题时会非常有用。</li>\n<li>启动类加载器现在是在jvm内部和java类库共同协作实现的类加载器（以前是 C++实现），但为了与之前代码兼容，在获取启动类加载器的场景中仍然会返回null，而不会得到BootClassLoader实例。</li>\n<li>类加载的委派关系也发生了变动。<br>\n当平台及应用程序类加载器收到类加载请求，在委派给父加载器加载前，要先判断该类是否能够归属到某一个系统模块中，如果可以找到这样的归属关系，就要优先委派给负责那个模块的加载器完成加载。</li>\n</ol>\n<p>‍</p>\n<p>双亲委派模式示意图</p>\n<p>​<img src=\"/assets/image-20231119124137-6apottn.png\" alt=\"image\">​</p>\n<p>附加：<br>\n在 Java 模块化系统明确规定了三个类加载器负责各自加载的模块：<br>\n启动类加载器负责加载的模块<br>\njava.base                        java.security.sasl<br>\njava.datatransfer                java.xml<br>\njava.desktop                     jdk.httpserver<br>\njava.instrument                  <a href=\"http://jdk.internal.vm.ci\">jdk.internal.vm.ci</a><br>\njava.logging                     jdk.management<br>\njava.management                  jdk.management.agent<br>\njava.management.rmi              jdk.naming.rmi<br>\njava.naming                      <a href=\"http://jdk.net\">jdk.net</a><br>\njava.prefs                       jdk.sctp<br>\njava.rmi                         jdk.unsupported</p>\n<p>平台类加载器负责加载的模块<br>\njava.activation*                jdk.accessibility<br>\njava.compiler*                  jdk.charsets<br>\njava.corba*                     jdk.crypto.cryptoki<br>\njava.scripting                  <a href=\"http://jdk.crypto.ec\">jdk.crypto.ec</a><br>\n<a href=\"http://java.se\">java.se</a>                         jdk.dynalink<br>\n<a href=\"http://java.se.ee\">java.se.ee</a>                      jdk.incubator.httpclient<br>\njava.security.jgss              jdk.internal.vm.compiler*<br>\njava.smartcardio                jdk.jsobject<br>\njava.sql                        jdk.localedata<br>\njava.sql.rowset                 jdk.naming.dns<br>\njava.transaction*               jdk.scripting.nashorn<br>\njava.xml.bind*                  jdk.security.auth<br>\njava.xml.crypto                 jdk.security.jgss<br>\n<a href=\"http://java.xml.ws\">java.xml.ws</a>*                    jdk.xml.dom<br>\njava.xml.ws.annotation*         jdk.zipfs</p>\n<p>应用程序类加载器负责加载的模块<br>\njdk.aot                         jdk.jdeps<br>\njdk.attach                      jdk.jdi<br>\njdk.compiler                    jdk.jdwp.agent<br>\njdk.editpad                     jdk.jlink<br>\njdk.hotspot.agent               jdk.jshell<br>\njdk.internal.ed                 jdk.jstatd<br>\njdk.internal.jvmstat            jdk.pack<br>\njdk.internal.le                 jdk.policytool<br>\njdk.internal.opt                jdk.rmic<br>\njdk.jartool                     jdk.scripting.nashorn.shell<br>\njdk.javadoc                     jdk.xml.bind*<br>\njdk.jcmd                        <a href=\"http://jdk.xml.ws\">jdk.xml.ws</a>*<br>\njdk.jconsole</p>\n<p>‍</p>\n","excerpt":"","more":"<h1>虚拟机中的对象</h1>\n<p>‍</p>\n<h2 id=\"虚拟机类加载机制\">虚拟机类加载机制</h2>\n<p><img src=\"/assets/net-img-1629870852837-ca139768-9f26-412a-8940-49ed6e38f57a-20230330213513-n1dmxgm.png\" alt=\"image.png\"><br>\n<em>类的生命周期</em><br>\n<em>加载，验证，准备，初始化_和_卸载_这五个顺序是可以确定的，类型的加载过成必须按照这种顺序按部就班的</em><strong>开始，</strong> <em>而_解析_阶段可以在初始化阶段后再开始。（并非完成一步后再进行其他部分，通常可以交叉混合进行）<br>\n有且只有六种情况必须对类立刻进行</em><strong>初始化</strong>_（加载，验证等在此之前已完成）；</p>\n<ul>\n<li>遇到 new getstatic，putstatic或invokestatic四条字节码指令时，如果类型没有进行初始化，则会先出发其初始化阶段。生成该四种指令的典型java代码有：\n<ul>\n<li>new 一个实例对象</li>\n<li>读取或设置一个类型的静态字段（被final修饰或已在编译器把结果放入常量池的静态字段除外）</li>\n<li>调用一个类型的静态方法的时候</li>\n</ul>\n</li>\n<li>使用java.lang.reflect包的方法对类型进行反射调用的时候，如果类型没有进行过初始化，则需 要先触发其初始化。</li>\n<li>当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</li>\n<li>当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先 初始化这个主类</li>\n<li>当一个接口中定义了JDK 8新加入的默认方法（被default关键字修饰的接口方法）时，如果有 这个接口的实现类发生了初始化，那该接口要在其之前被初始化。</li>\n<li>** 当使用JDK 7新加入的动态语言支持时？？？**</li>\n</ul>\n<h3 id=\"加载\">加载</h3>\n<p>在加载阶段，Java虚拟机需要完成以下三件事情：</p>\n<ul>\n<li>通过一个类的全限定名来获取定义此类的二进制字节流。</li>\n<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li>\n<li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入 口。</li>\n</ul>\n<h3 id=\"验证\">验证</h3>\n<ul>\n<li>文件格式验证：检验文件是否符合Class文件规范，从而保证输入的字节流能够正确的解析并存储于方法区内。\n<ul>\n<li>是否以魔数0xCAFEBABE开头。 ·主、次版本号是否在当前Java虚拟机接受范围之内。</li>\n<li>常量池的常量中是否有不被支持的常量类型（检查常量tag标志）。</li>\n<li>指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量。</li>\n<li>CONSTANT_Utf8_info型的常量中是否有不符合UTF-8编码的数据。</li>\n<li>Class文件中各个部分及文件本身是否有被删除的或附加的其他信息。</li>\n<li>… 等</li>\n</ul>\n</li>\n<li>元数据验证：对字节码描述的信息进行语义分析\n<ul>\n<li>这个类是否有父类（除了java.lang.Object之外，所有的类都应当有父类）。</li>\n<li>这个类的父类是否继承了不允许被继承的类（被final修饰的类）。</li>\n<li>如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法。</li>\n<li>类中的字段、方法是否与父类产生矛盾（例如覆盖了父类的final字段，或者出现不符合规则的方 法重载，例如方法参数都一致，但返回值类型却不同等）。</li>\n<li>…等</li>\n</ul>\n</li>\n<li>字节码验证：主要是通过数据流分析和控制流分析，确定程序语义是否合法、符合逻辑。\n<ul>\n<li>保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作，例如不会出现类似于“在操作 栈放置了一个int类型的数据，使用时却按long类型来加载入本地变量表中”这样的情况。</li>\n<li>保证任何跳转指令都不会跳转到方法体以外的字节码指令上。</li>\n<li>保证方法体中的类型转换总是有效的，例如可以把一个子类对象赋值给父类数据类型，这是安全的，但是把父类对象赋值给子类数据类型，甚至把对象赋值给与它毫无继承关系、完全不相干的一个 数据类型，则是危险和不合法的。</li>\n<li>……</li>\n</ul>\n</li>\n<li>符号引用验证： 发生在虚拟机将符号引用转化为直接引用的时候。符号引用验证可以看作是对类自身以外（常量池中的各种符号 引用）的各类信息进行匹配性校验，通俗来说就是，该类是否缺少或者被禁止访问它依赖的某些外部 类、方法、字段等资源。\n<ul>\n<li>符号引用中通过字符串描述的全限定名是否能找到对应的类。</li>\n<li>在指定类中是否存在符合方法的字段描述符及简单名称所描述的方法和字段。</li>\n<li>符号引用中的类、字段、方法的可访问性（private、protected、public、）是否可被当 前类访问。</li>\n<li>…… 等</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"准备\">准备</h3>\n<p>正式为类中定义的变量（即静态变量，被static修饰的变量）分配内存并设置类变量初始值（值“通常情况”下是数据类型的零值）<br>\n如果类字段的字段属性表中存在ConstantValue属性，那在准备阶段变量值就会被初始化为ConstantValue属性所指定的初始值。</p>\n<blockquote>\n<ul>\n<li>ConstantValue属于属性表集合中的一个属性，属性表集合中一共有21个不同属性。</li>\n<li>ConstantValue属性的使用位置：字段表；含义：final关键字定义的常量值。</li>\n<li>ConstantValue属性作用：通知虚拟机自动为静态变量赋值。</li>\n</ul>\n</blockquote>\n<p>int x =123; static int x = 123;</p>\n<blockquote>\n<ul>\n<li>对虚拟机来说上面两种变量赋值的方式和时刻都有所不同。</li>\n<li>非static类型变量（实例变量）\n<ul>\n<li>赋值是在实例构造器<init>方法中进行的。</li>\n</ul>\n</li>\n<li>static类型变量（类变量）\n<ul>\n<li>有两种选择：在类构造器<clinit>方法或者使用ConstantValue属性。\n<ul>\n<li>同时使用final 、static来修饰的变量（常量），并且这个变量的数据类型是基本类型或者String类型，就生成ConstantValue属性来进行初始化。</li>\n<li>没有final修饰或者并非基本类型及String类型，则选择在<clinit>方法中进行初始化。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<h3 id=\"解析\">解析</h3>\n<p>将常量池内的符号引用替换为直接引用</p>\n<blockquote>\n<p>符号引用（Symbolic References）：符号引用以一组符号来描述所引用的目标，符号可以是任何 形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定是已经加载到虚拟机内存当中的内容。各种虚拟机实现的内存布局可以各不相同， 但是它们能接受的符号引用必须都是一致的，因为符号引用的字面量形式明确定义在《Java虚拟机规 范》的Class文件格式中。<br>\n·直接引用（Direct References）：直接引用是可以直接指向目标的指针、相对偏移量或者是一个能 间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局直接相关的，同一个符号引用在不同虚 拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在虚拟机 的内存中存在。</p>\n</blockquote>\n<h3 id=\"初始化\">初始化</h3>\n<h3 id=\"卸载\">卸载</h3>\n<h2 id=\"虚拟机中的对象\">虚拟机中的对象</h2>\n<p><img src=\"/assets/net-img-4122e8fc2d6e2995074ede61ff44aef4-20230330213516-hs7yexh.svg\" alt=\"\"></p>\n<h3 id=\"对象的创建\">对象的创建</h3>\n<ol>\n<li>类加载\n<ol>\n<li>加载</li>\n<li>链接</li>\n<li>初始化</li>\n</ol>\n</li>\n<li>分配空间\n<ol>\n<li>指针碰撞：假设java内存绝对规整，被使用的和未使用的中间放一个指针作为分界点的指示器，分配内存时，仅需把指针挪动挪动一段和对象大小相同的距离即可。</li>\n<li>空闲列表：虚拟机维护一个列表，记录那些内存块是可用的，分配时从列表中获取一块足够大的空间去分配，并更新列表。</li>\n</ol>\n</li>\n</ol>\n<blockquote>\n<p>使用Serial，ParNew等压缩整理整理过程的收集器是，系统采用指针碰撞；而是用CMS等交换算法收集器时，采用空闲列表分配空间</p>\n</blockquote>\n<p>内存分配（指针碰撞存在并发安全）并发问题解决方案：</p>\n<ul>\n<li>CAS+重试：</li>\n<li>TLAB（本地线程分配缓存）：把内存分配的动作按照线程划分在不同的空间之中进行，每个线程在JAVA堆中预先分配小块内存，只有本地缓存用完，分配新的缓存区时才需要同步锁定。</li>\n</ul>\n<blockquote>\n<p>内存分配完成，虚拟机必须将已分配的内存空间初始化零值，如果使用TLAB，初始化零值也可以提前至TLAB分配时顺便初始化零值</p>\n</blockquote>\n<ol start=\"3\">\n<li>初始化零值\n<ol>\n<li>将分配的空间都初始化为零值</li>\n</ol>\n</li>\n<li>设置对象头</li>\n<li>执行init方法</li>\n</ol>\n<h3 id=\"对象的卸载\">对象的卸载</h3>\n<p>Java虚拟机自带的类加载器所加载的类，在整个虚拟机的生命周期中，都不会被卸载。<br>\n用户自定义的类加载器是可以被卸载的。<br>\n<strong>卸载时机：</strong></p>\n<ol>\n<li>该类的所有实例对象都被回收</li>\n<li>该类的类加载器对象已经被回收</li>\n<li>该类对应的Class对象没有被引用，无法在任何地方通过反射获取</li>\n</ol>\n<h3 id=\"对象的内存布局\">对象的内存布局</h3>\n<p>​<img src=\"/assets/image-20231202123415-e2licnx.jpeg\" alt=\"图像\">​</p>\n<p><strong>jvm默认开启class pointer压缩 为4字节</strong><br>\n普通对象 markword 默认八个字节 instance data 若属性则为零 padding 补足被8整除<br>\n​<img src=\"/assets/net-img-1615611389351-2cfaa4d5-b52c-4a2e-a170-c32ce97d17a6-20230330213518-3fydrb9.png\" alt=\"image.png\"><br>\n数组对象<br>\n​<img src=\"/assets/net-img-1615611419969-14ba7126-9f92-482c-a851-9898cece7e8f-20230330213518-2ptpa3a.png\" alt=\"image.png\"><br>\nhotspot 虚拟机对象头markword</p>\n<table>\n<thead>\n<tr>\n<th>存储内容</th>\n<th>标志位</th>\n<th>状态</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>对象哈希码，对象分代年龄</td>\n<td>01</td>\n<td>未锁定</td>\n</tr>\n<tr>\n<td>指向锁记录的指针</td>\n<td>00</td>\n<td>轻量级锁状态</td>\n</tr>\n<tr>\n<td>指向重量级锁的指针</td>\n<td>10</td>\n<td>重量级锁状态</td>\n</tr>\n<tr>\n<td>空，不需要记录信息</td>\n<td>11</td>\n<td>gc标志</td>\n</tr>\n<tr>\n<td>偏向线程id、偏向时间戳、对象分代年龄</td>\n<td>01</td>\n<td>可偏向（偏向锁）</td>\n</tr>\n</tbody>\n</table>\n<p><img src=\"/assets/net-img-1615614053644-2e45ea92-d426-42ca-a609-91b095ff7e83-20230330213519-1im5mrq.png\" alt=\"image.png\"></p>\n<h2 id=\"虚拟机类加载器\">虚拟机类加载器</h2>\n<p>​<img src=\"/assets/image-20231117162020-0zic8ee.png\" alt=\"image\">​</p>\n<p>​<img src=\"/assets/image-20231117162030-ue9pyz9.png\" alt=\"image\">​</p>\n<h3 id=\"jdk8\">jdk8</h3>\n<ol>\n<li>引导类加载器</li>\n<li>扩展类加载器</li>\n<li>应用类加载器</li>\n</ol>\n<h3 id=\"jdk9\">jdk9</h3>\n<ol>\n<li>引导类加载器</li>\n<li>平台类加载器（原扩展类加载器，因兼容性被保留）</li>\n<li>应用类加载器</li>\n</ol>\n<h3 id=\"jdk9后的变化\">jdk9后的变化</h3>\n<p>为了保证兼容性，JDK 9没有从根本上改变三层类加载器架构和双亲委派模型，但为了模块化系统的顺利运行，仍然发生了一些值得被注意的变动。</p>\n<ol>\n<li>扩展机制被移除，扩展类加载器由于向后兼容性的原因被保留，不过被重命名为平台类加载器（platform class loader）。可以通过ClassLoader的新方法getPlatformClassLoader()来获取。</li>\n</ol>\n<p>JDK 9 时基于模块化进行构建（原来的 rt.jar 和 tools.jar 被拆分成数十个 JMOD 文件），其中的 Java 类库就已天然地满足了可扩展的需求，那自然无须再保留 &lt;JAVA_HOME&gt;\\lib\\ext 目录，此前使用这个目录或者 java.ext.dirs 系统变量来扩展 JDK 功能的机制已经没有继续存在的价值了。</p>\n<ol start=\"2\">\n<li>平台类加载器和应用程序类加载器都不再继承自 java.net.URLClassLoader。<br>\n现在启动类加载器、平台类加载器、应用程序类加载器全都继承于 jdk.internal.loader.BuiltinClassLoader。</li>\n</ol>\n<p>​<img src=\"/assets/image-20231119124040-5kytmcz.png\" alt=\"image\">​</p>\n<p>如果有程序直接依赖了这种继承关系，或者依赖了 URLClassLoader 类的特定方法，那代码很可能会在 JDK 9 及更高版本的 JDK 中崩溃。</p>\n<ol start=\"3\">\n<li>在Java 9中，类加载器有了名称。该名称在构造方法中指定，可以通过getName()方法来获取。平台类加载器的名称是platform，应用类加载器的名称是app。类加载器的名称在调试与类加载器相关的问题时会非常有用。</li>\n<li>启动类加载器现在是在jvm内部和java类库共同协作实现的类加载器（以前是 C++实现），但为了与之前代码兼容，在获取启动类加载器的场景中仍然会返回null，而不会得到BootClassLoader实例。</li>\n<li>类加载的委派关系也发生了变动。<br>\n当平台及应用程序类加载器收到类加载请求，在委派给父加载器加载前，要先判断该类是否能够归属到某一个系统模块中，如果可以找到这样的归属关系，就要优先委派给负责那个模块的加载器完成加载。</li>\n</ol>\n<p>‍</p>\n<p>双亲委派模式示意图</p>\n<p>​<img src=\"/assets/image-20231119124137-6apottn.png\" alt=\"image\">​</p>\n<p>附加：<br>\n在 Java 模块化系统明确规定了三个类加载器负责各自加载的模块：<br>\n启动类加载器负责加载的模块<br>\njava.base                        java.security.sasl<br>\njava.datatransfer                java.xml<br>\njava.desktop                     jdk.httpserver<br>\njava.instrument                  <a href=\"http://jdk.internal.vm.ci\">jdk.internal.vm.ci</a><br>\njava.logging                     jdk.management<br>\njava.management                  jdk.management.agent<br>\njava.management.rmi              jdk.naming.rmi<br>\njava.naming                      <a href=\"http://jdk.net\">jdk.net</a><br>\njava.prefs                       jdk.sctp<br>\njava.rmi                         jdk.unsupported</p>\n<p>平台类加载器负责加载的模块<br>\njava.activation*                jdk.accessibility<br>\njava.compiler*                  jdk.charsets<br>\njava.corba*                     jdk.crypto.cryptoki<br>\njava.scripting                  <a href=\"http://jdk.crypto.ec\">jdk.crypto.ec</a><br>\n<a href=\"http://java.se\">java.se</a>                         jdk.dynalink<br>\n<a href=\"http://java.se.ee\">java.se.ee</a>                      jdk.incubator.httpclient<br>\njava.security.jgss              jdk.internal.vm.compiler*<br>\njava.smartcardio                jdk.jsobject<br>\njava.sql                        jdk.localedata<br>\njava.sql.rowset                 jdk.naming.dns<br>\njava.transaction*               jdk.scripting.nashorn<br>\njava.xml.bind*                  jdk.security.auth<br>\njava.xml.crypto                 jdk.security.jgss<br>\n<a href=\"http://java.xml.ws\">java.xml.ws</a>*                    jdk.xml.dom<br>\njava.xml.ws.annotation*         jdk.zipfs</p>\n<p>应用程序类加载器负责加载的模块<br>\njdk.aot                         jdk.jdeps<br>\njdk.attach                      jdk.jdi<br>\njdk.compiler                    jdk.jdwp.agent<br>\njdk.editpad                     jdk.jlink<br>\njdk.hotspot.agent               jdk.jshell<br>\njdk.internal.ed                 jdk.jstatd<br>\njdk.internal.jvmstat            jdk.pack<br>\njdk.internal.le                 jdk.policytool<br>\njdk.internal.opt                jdk.rmic<br>\njdk.jartool                     jdk.scripting.nashorn.shell<br>\njdk.javadoc                     jdk.xml.bind*<br>\njdk.jcmd                        <a href=\"http://jdk.xml.ws\">jdk.xml.ws</a>*<br>\njdk.jconsole</p>\n<p>‍</p>\n"},{"title":"垃圾回收和内存分配","date":"2022-10-30T05:40:49.000Z","lastmod":"2023-11-26T08:16:40.000Z","_content":"\n# 垃圾回收和内存分配\n\n## 垃圾回收\n\n### 垃圾判别算法\n\n#### 引用计数法\n\n> 一个对象A，只要有任何一个对象引用了A ，则A 的引用计数器就加1，当引用失效时，引用计数器就减1。只要对象A 的引用计数器的值为0，即表示对象A不可能再被使用，可进行回收。\n\n* 优点\n\n  * 实现简单，垃圾对象便于辨识；判定效率高，回收没有延迟性。\n* 缺点\n\n  * 需要单独的字段存储计数器，增加了存储空间的开销。\n  * 每次赋值伴随着计数器的增减，增加时间开销。\n  * 无法处理循环依赖的问题\n\n#### 可达性分析 \n\n> 将对象及其引用关系看作一个图，选定活动的对象作为 GC Roots，然后跟踪引用链条，如果一个对象和GC Roots之间不可达，也就是不存在引用链条，那么即可认为是可回收对象。\n\n　　基本思路：\n\n* 可达性分析算法是以根对象集合(GC Roots)为起始点，按照从上至下的方式搜索被根对象集合所连接的目标对象是否可达。\n* 使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索所走过的路径称为引用链(Reference Chain)\n* 如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象己经死亡，可以标记为垃圾对象。\n* 在可达性分析算法中，只有能够被根对象集合直接或者间接连接的对象才是存活对象。\n\n　　可作为\"GC Roots\"的对象\n\n* 虚拟机栈（栈帧中的本地变量表）中引用的对象，例如各个线程调用的方法堆中的参数，局部变量，临时变量。\n* 方法区中类静态属性引用的对象，例如java 类中的引用类型的静态变量\n* 方法区中常量引用的对象，例如字符串常量池中的引用\n* 本地方法栈中JNI（Native方法）引用的对象\n* Java虚拟机内部的引用，例如基础类型对应的Class对象，一些常驻的异常对象，还有系统类加载器\n* 所有被同步锁持有的对象。\n* 反应java虚拟机内部情况的JMXBean，JVMTI中的注册的回调，本地代码缓存等（？？？）\n\n　　注：如果要使用可达性分析算法来判断内存是否可回收，那么分析工作必须在一个能保障*一致性的快照*中进行，这点也是导致GC进行时必须“Stop The World”的一个重要原因。\n\n### 垃圾回收算法\n\n#### 标记清除\n\n> 标记：Collector从引用根节点开始遍历，标记所有被引用的对象。一般是在对象的Header中记录为可达对象。  \n> 清除：Collector对堆内存从头到尾进行线性的遍历，如果发现某个对象在其Header中没有标记为可达对象，则将其回收。\n\n* 效率比较低：递归与全堆对象遍历两次\n* 在进行GC的时候，需要停止整个应用程序，导致用户体验差\n* 这种方式清理出来的空闲内存是不连续的，产生内存碎片。\n\n#### 标记复制\n\n> 将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收。\n\n* 优点\n\n  * 不会造成空间碎片。\n* 缺点\n\n  * 需要两倍的内存空间\n  * 对于G1这种分拆成为大量region的GC，复制而不是移动，意味着GC需要维护region之间对象引用关系，不管是内存占用或者时间开销也不小。\n\n　　注：如果系统中的存活对象很多，复制算法不会很理想。因为复制算法需要复制的存活对象数量并不会太大,或者说非常低才行。\n\n#### 标记整理\n\n> 从根节点开始标记所有被引用对象  \n> 将所有的存活对象压缩到内存的一端，按顺序排放，清理边界外所有的空间。\n\n* 优点\n\n  * 消除了标记/清除算法当中，内存区域分散的缺点，我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可。\n  * 消除了复制算法当中，内存减半的高额代价。\n* 缺点\n\n  * 效率不高，不仅要标记所有存活对象，还要整理所有存活对象的引用地址。\n  * 对于老年代每次都有大量对象存活的区域来说，极为负重。\n  * 移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址。\n  * 移动过程中，需要全程暂停用户应用程序。即：STW\n\n#### 分代收集\n\n> 基于这样一个事实：不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点使用不同的回收算法，以提高垃圾回收的效率。\n\n#### 增量回收\n\n> 垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。\n\n　　注：线程上下文切换频繁，是的垃圾回收成本上升，导致吞吐量上升\n\n#### 分区算法\n\n> 将按照对象的生命周期长短划分成两个部分，分区算法将整个堆空间划分成连续的不同小区间。每一个小区间都独立使用，独立回收。\n\n### JVM四种引用\n\n#### 强引用\n\n　　特点：GC时，永远不会被回收  \n使用场景\n\n> new 对象\n\n#### 软引用SoftReference<Object>(obj);\n\n　　特点：内存不足时（自动触发GC），会被回收  \n使用场景\n\n> 缓存\n\n#### 弱引用WeakReference<Object>(obj)\n\n　　特点：无论内存是否充足，只要进行GC，都会被回收  \n使用场景\n\n> 内部对象为弱引用 WeakReference为强引用\n\n#### 虚引用PhantomReference<>(new Object(),new ReferenceQueue<>())\n\n　　特点：如同虚设，和没有引用没什么区别  \n使用场景\n\n> 1. 管理堆外面的引用\n\n> 首先标记出所需要回收的对象，在标记完成后，统一回收掉所有被标记的对象\n\n> 将可用内存划分为两部分，每次只使用其中一块，当一块内存用完时，将还存活对象复制到另外一块上面，然后再把已使用的内存空间清理一遍\n\n> 标记出所需要回收的对象，将所有需要存活的对象都向内存空间的一端移动，然后直接清理掉边界以外的内存\n\n## JVM GC 流程\n\n> [JVM堆的内存分布](https://www.yuque.com/pride_yang/blog/qsgy0z#vfjXH)\n\n> Minor GC  新生代GC\n\n> Major GC/Full GC\n\n1. 开始时，对象会先分配到eden区\n2. 引用运行，越来越多对象分配在eden区域\n3. 当eden区域放不下时，就会发生minor GC(young GC),利用可达性分析标记出垃圾对象，然后将有用对象移动到survivor0区域，将标记出来的垃圾对象全部清除，此时eden区域就全部清理干净了。整个过程使用了 mark-sweep（标记整理）方法回收eden区，使用mark-copy（标记复制） 方法将可用对象移动到 survivor0区域。\n4. 随着时间推移，eden如果又满了，再次触发minor GC，同样还是先做标记，这时eden和s0区可能都有垃圾对象了，注意：这时s1（即：to）区是空的，S0区和eden区的存活对象（S0 区域满了），将直接搬到s1区。然后将eden和S0区的垃圾清理掉，这一轮minor GC后，eden和S0区就变成了空的了。\n5. 随着对象的不断分配，eden空可能又满了，这时会重复刚才的minor GC过程，不过要注意的是，这时候s0是空的，所以s0与s1的角色其实会互换，即：存活的对象，会从eden和s1区，向s0区移动。然后再把eden和s1区中的垃圾清除，这一轮完成后，eden与s1区变成空的\n6. 对于那些比较“长寿”的对象一直在s0与s1中挪来挪去，一来很占地方，而且也会造成一定开销，降低gc效率，于是有了“代龄(age)”及“晋升”。对象在年青代的3个区(eden,s0,s1)之间，每次从1个区移到另1区，年龄+1，在young区达到一定的年龄阈值(-XX:MaxTenuringThreshold（默认15）)后，将晋升到老年代。\n7. 如果老年代，最终也放满了，就会发生major GC（即Full GC），由于老年代的的对象通常会比较多，因为标记-清理-整理（压缩）的耗时通常会比较长，会让应用出现卡顿的现象，\n\n​![](/assets/net-img-1646740660775-762fcaa3-26b5-4d95-ac43-5cca58540969-20230330213439-sxz1b5i.png)​\n\n## 垃圾收集器\n\n​![图像](.//assets/image-20231126145713-0pou43f.png)​\n\n1. 两个收集器间有连线，表明它们可以搭配使用：  \n    Serial/Serial Old、Serial/CMS、ParNew/Serial Old、ParNew/CMS、Parallel Scavenge/Serial Old、Parallel Scavenge/Parallel Old、G1；\n2. 其中Serial Old作为CMS出现\"Concurrent Mode Failure\"失败的后备预案。\n3. (红色虚线)由于维护和兼容性测试的成本，在JDK 8时将Serial+CMS、ParNew+Serial Old这两个组合声明为废弃（JEP 173），并在JDK 9中完全取消了这些组合的支持（JEP214），即：移除。\n4. (绿色虚线)JDK 14中：弃用Parallel Scavenge和SerialOld GC组合 （JEP 366）\n5. (青色虚线)JDK 14中：删除CMS垃圾回收器 （JEP 363）\n\n### 经典垃圾收集器\n\n#### Serial 收集器/Serial Old 收集器\n\n> 简单高效，占用内存小 适合客户端\n\n![image.png](/assets/net-img-1629558034184-e1fe6601-777e-4a34-afe5-df37e5a9b720-20230330213445-e5uive7.png \"运行示意图\")\n\n#### ParNew 收集器/Serial Old 收集器\n\n> 适合多核CPU 单核由于上下文切换，收集并不理想\n\n![image.png](/assets/net-img-1629559055065-5ad8d49f-81b6-45f3-87f8-c98716f799ed-20230330213451-7nkjlzc.png \"运行示意图\")\n\n#### Parallel Scavenge/Parallel Old收集器\n\n> 吞吐量优先的垃圾收集器，有自适应调节策略 jdk8的默认垃圾收集器\n\n![image.png](/assets/net-img-1629559366006-0194df18-86f2-45fd-bd85-6f675b19bdb0-20230330213459-p7i5mm5.png \"运行示意图\")\n\n#### CMS收集器（老年代）\n\n> CMS是基于Mark-Sweep实现的，对于对象的回收效率很高。\n>\n> 对于碎片问题，CMS采用基于Mark-Compact算法的Serial Old回收器作为补偿措施：当内存回收不佳（碎片导致的Concurrent Mode Failure时），将采用Serial Old执行Full GC以达到对老年代内存的整理\n\n![image.png](/assets/net-img-1629560137959-ab93eb78-c083-4c80-8283-4cfc470c8af0-20230330213504-cteixk9.png \"运行示意图\")\n\n* 初始标记（STW）：暂时时间非常短，标记与GC Roots直接关联的对象。\n* 并发标记（最耗时）：从GC Roots开始遍历整个对象图的过程。不会停顿用户线程\n* 重新标记：（STW）：修复并发标记环节，因为用户线程的执行，导致数据的不一致性问题\n* 并发清理（最耗时）：清理删除掉标记阶段判断的已经死亡的对象，释放内存空间。由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的。\n\n#### G1 收集器\n\n> 主要针对配备多核CPU及大容量内存的机器，以极高概率满足GC停顿时间的同时，还兼具高吞吐量，JDK9 以后的默认收集器\n\n![图像](/assets/image-20231126155909-4zbslm1.png)\n\n##### 回收过程\n\n1. 年轻代GC （Young GC）\n\n    1. ‍\n\n2. 老年代并发标记过程 （Concurrent Marking）\n\n3. 混合回收（Mixed GC）\n\n4. 如果需要，单线程、独占式、高强度的Full GC还是继续存在的。它针对GC的评估失败提供了一种失败保护机制，即强力回收。\n\n![图像 (2)](/assets/image-20231126161709-b35di3t.png)\n\n　　顺时针，young gc -> young gc + concurrent mark-> Mixed GC顺序，进行垃圾回收。\n\n##### 特点\n\n*  \n\n  * 并发性：G1拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此，一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况\n\n  **并行与并发**\n\n  * 并行性：G1在回收期间，可以有多个GC线程同时工作，有效利用多核计算能力。此时用户线程STW\n\n* **分代收集**\n\n  * 从分代上看，G1依然属于分代型垃圾回收器，它会区分年轻代和老年代，年轻代依然有Eden区和Survivor区。但从堆的结构上看，它不要求整个Eden区、年轻代或者老年代都是连续的，也不再坚持固定大小和固定数量。\n  * 将堆空间分为若干个区域（Region）,这些区域中包含了逻辑上的年轻代和老年代。\n  * 和之前的各类回收器不同，它同时兼顾年轻代和老年代。对比其他回收器，或者工作在年轻代，或者工作在老年代；\n\n* 空间整合\n\n  * CMS：“标记-清除”算法、内存碎片、若干次GC后进行一次碎片整理\n  * G1将内存划分为一个个的region。内存的回收是以region作为基本单位的。Region之间是复制算法，但整体上实际可看作是标记-压缩（Mark-Compact）算法，两种算法都可以避免内存碎片。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次 GC。尤其是当Java堆非常大的时候，G1的优势更加明显。\n* 可预测的停顿时间模型\n\n  * 由于分区的原因，G1可以只选取部分区域进行内存回收，这样缩小了回收的范围，因此对于全局停顿情况的发生也能得到较好的控制。\n  * G1 跟踪各个 Region 里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。保证了 G1 收集器在有限的时间内可以获取尽可能高的收集效率。\n  * 相比于CMS GC，G1未必能做到CMS在最好情况下的延时停顿，但是最差情况要好很多。\n\n　　**注：G1无论是为了垃圾收集产生的内存占用（Footprint）还是程序运行时的额外执行负载（Overload）都要比CMS要高。在小内存应用上CMS的表现大概率会优于G1，而G1在大内存应用上则发挥其优势。平衡点在6-8GB之间。**\n\n　　‍\n","source":"_posts/java/JVM/垃圾回收和内存分配.md","raw":"---\ntitle: 垃圾回收和内存分配\ndate: 2022-10-30T13:40:49Z\nlastmod: 2023-11-26T16:16:40Z\n---\n\n# 垃圾回收和内存分配\n\n## 垃圾回收\n\n### 垃圾判别算法\n\n#### 引用计数法\n\n> 一个对象A，只要有任何一个对象引用了A ，则A 的引用计数器就加1，当引用失效时，引用计数器就减1。只要对象A 的引用计数器的值为0，即表示对象A不可能再被使用，可进行回收。\n\n* 优点\n\n  * 实现简单，垃圾对象便于辨识；判定效率高，回收没有延迟性。\n* 缺点\n\n  * 需要单独的字段存储计数器，增加了存储空间的开销。\n  * 每次赋值伴随着计数器的增减，增加时间开销。\n  * 无法处理循环依赖的问题\n\n#### 可达性分析 \n\n> 将对象及其引用关系看作一个图，选定活动的对象作为 GC Roots，然后跟踪引用链条，如果一个对象和GC Roots之间不可达，也就是不存在引用链条，那么即可认为是可回收对象。\n\n　　基本思路：\n\n* 可达性分析算法是以根对象集合(GC Roots)为起始点，按照从上至下的方式搜索被根对象集合所连接的目标对象是否可达。\n* 使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索所走过的路径称为引用链(Reference Chain)\n* 如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象己经死亡，可以标记为垃圾对象。\n* 在可达性分析算法中，只有能够被根对象集合直接或者间接连接的对象才是存活对象。\n\n　　可作为\"GC Roots\"的对象\n\n* 虚拟机栈（栈帧中的本地变量表）中引用的对象，例如各个线程调用的方法堆中的参数，局部变量，临时变量。\n* 方法区中类静态属性引用的对象，例如java 类中的引用类型的静态变量\n* 方法区中常量引用的对象，例如字符串常量池中的引用\n* 本地方法栈中JNI（Native方法）引用的对象\n* Java虚拟机内部的引用，例如基础类型对应的Class对象，一些常驻的异常对象，还有系统类加载器\n* 所有被同步锁持有的对象。\n* 反应java虚拟机内部情况的JMXBean，JVMTI中的注册的回调，本地代码缓存等（？？？）\n\n　　注：如果要使用可达性分析算法来判断内存是否可回收，那么分析工作必须在一个能保障*一致性的快照*中进行，这点也是导致GC进行时必须“Stop The World”的一个重要原因。\n\n### 垃圾回收算法\n\n#### 标记清除\n\n> 标记：Collector从引用根节点开始遍历，标记所有被引用的对象。一般是在对象的Header中记录为可达对象。  \n> 清除：Collector对堆内存从头到尾进行线性的遍历，如果发现某个对象在其Header中没有标记为可达对象，则将其回收。\n\n* 效率比较低：递归与全堆对象遍历两次\n* 在进行GC的时候，需要停止整个应用程序，导致用户体验差\n* 这种方式清理出来的空闲内存是不连续的，产生内存碎片。\n\n#### 标记复制\n\n> 将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收。\n\n* 优点\n\n  * 不会造成空间碎片。\n* 缺点\n\n  * 需要两倍的内存空间\n  * 对于G1这种分拆成为大量region的GC，复制而不是移动，意味着GC需要维护region之间对象引用关系，不管是内存占用或者时间开销也不小。\n\n　　注：如果系统中的存活对象很多，复制算法不会很理想。因为复制算法需要复制的存活对象数量并不会太大,或者说非常低才行。\n\n#### 标记整理\n\n> 从根节点开始标记所有被引用对象  \n> 将所有的存活对象压缩到内存的一端，按顺序排放，清理边界外所有的空间。\n\n* 优点\n\n  * 消除了标记/清除算法当中，内存区域分散的缺点，我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可。\n  * 消除了复制算法当中，内存减半的高额代价。\n* 缺点\n\n  * 效率不高，不仅要标记所有存活对象，还要整理所有存活对象的引用地址。\n  * 对于老年代每次都有大量对象存活的区域来说，极为负重。\n  * 移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址。\n  * 移动过程中，需要全程暂停用户应用程序。即：STW\n\n#### 分代收集\n\n> 基于这样一个事实：不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点使用不同的回收算法，以提高垃圾回收的效率。\n\n#### 增量回收\n\n> 垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。\n\n　　注：线程上下文切换频繁，是的垃圾回收成本上升，导致吞吐量上升\n\n#### 分区算法\n\n> 将按照对象的生命周期长短划分成两个部分，分区算法将整个堆空间划分成连续的不同小区间。每一个小区间都独立使用，独立回收。\n\n### JVM四种引用\n\n#### 强引用\n\n　　特点：GC时，永远不会被回收  \n使用场景\n\n> new 对象\n\n#### 软引用SoftReference<Object>(obj);\n\n　　特点：内存不足时（自动触发GC），会被回收  \n使用场景\n\n> 缓存\n\n#### 弱引用WeakReference<Object>(obj)\n\n　　特点：无论内存是否充足，只要进行GC，都会被回收  \n使用场景\n\n> 内部对象为弱引用 WeakReference为强引用\n\n#### 虚引用PhantomReference<>(new Object(),new ReferenceQueue<>())\n\n　　特点：如同虚设，和没有引用没什么区别  \n使用场景\n\n> 1. 管理堆外面的引用\n\n> 首先标记出所需要回收的对象，在标记完成后，统一回收掉所有被标记的对象\n\n> 将可用内存划分为两部分，每次只使用其中一块，当一块内存用完时，将还存活对象复制到另外一块上面，然后再把已使用的内存空间清理一遍\n\n> 标记出所需要回收的对象，将所有需要存活的对象都向内存空间的一端移动，然后直接清理掉边界以外的内存\n\n## JVM GC 流程\n\n> [JVM堆的内存分布](https://www.yuque.com/pride_yang/blog/qsgy0z#vfjXH)\n\n> Minor GC  新生代GC\n\n> Major GC/Full GC\n\n1. 开始时，对象会先分配到eden区\n2. 引用运行，越来越多对象分配在eden区域\n3. 当eden区域放不下时，就会发生minor GC(young GC),利用可达性分析标记出垃圾对象，然后将有用对象移动到survivor0区域，将标记出来的垃圾对象全部清除，此时eden区域就全部清理干净了。整个过程使用了 mark-sweep（标记整理）方法回收eden区，使用mark-copy（标记复制） 方法将可用对象移动到 survivor0区域。\n4. 随着时间推移，eden如果又满了，再次触发minor GC，同样还是先做标记，这时eden和s0区可能都有垃圾对象了，注意：这时s1（即：to）区是空的，S0区和eden区的存活对象（S0 区域满了），将直接搬到s1区。然后将eden和S0区的垃圾清理掉，这一轮minor GC后，eden和S0区就变成了空的了。\n5. 随着对象的不断分配，eden空可能又满了，这时会重复刚才的minor GC过程，不过要注意的是，这时候s0是空的，所以s0与s1的角色其实会互换，即：存活的对象，会从eden和s1区，向s0区移动。然后再把eden和s1区中的垃圾清除，这一轮完成后，eden与s1区变成空的\n6. 对于那些比较“长寿”的对象一直在s0与s1中挪来挪去，一来很占地方，而且也会造成一定开销，降低gc效率，于是有了“代龄(age)”及“晋升”。对象在年青代的3个区(eden,s0,s1)之间，每次从1个区移到另1区，年龄+1，在young区达到一定的年龄阈值(-XX:MaxTenuringThreshold（默认15）)后，将晋升到老年代。\n7. 如果老年代，最终也放满了，就会发生major GC（即Full GC），由于老年代的的对象通常会比较多，因为标记-清理-整理（压缩）的耗时通常会比较长，会让应用出现卡顿的现象，\n\n​![](/assets/net-img-1646740660775-762fcaa3-26b5-4d95-ac43-5cca58540969-20230330213439-sxz1b5i.png)​\n\n## 垃圾收集器\n\n​![图像](.//assets/image-20231126145713-0pou43f.png)​\n\n1. 两个收集器间有连线，表明它们可以搭配使用：  \n    Serial/Serial Old、Serial/CMS、ParNew/Serial Old、ParNew/CMS、Parallel Scavenge/Serial Old、Parallel Scavenge/Parallel Old、G1；\n2. 其中Serial Old作为CMS出现\"Concurrent Mode Failure\"失败的后备预案。\n3. (红色虚线)由于维护和兼容性测试的成本，在JDK 8时将Serial+CMS、ParNew+Serial Old这两个组合声明为废弃（JEP 173），并在JDK 9中完全取消了这些组合的支持（JEP214），即：移除。\n4. (绿色虚线)JDK 14中：弃用Parallel Scavenge和SerialOld GC组合 （JEP 366）\n5. (青色虚线)JDK 14中：删除CMS垃圾回收器 （JEP 363）\n\n### 经典垃圾收集器\n\n#### Serial 收集器/Serial Old 收集器\n\n> 简单高效，占用内存小 适合客户端\n\n![image.png](/assets/net-img-1629558034184-e1fe6601-777e-4a34-afe5-df37e5a9b720-20230330213445-e5uive7.png \"运行示意图\")\n\n#### ParNew 收集器/Serial Old 收集器\n\n> 适合多核CPU 单核由于上下文切换，收集并不理想\n\n![image.png](/assets/net-img-1629559055065-5ad8d49f-81b6-45f3-87f8-c98716f799ed-20230330213451-7nkjlzc.png \"运行示意图\")\n\n#### Parallel Scavenge/Parallel Old收集器\n\n> 吞吐量优先的垃圾收集器，有自适应调节策略 jdk8的默认垃圾收集器\n\n![image.png](/assets/net-img-1629559366006-0194df18-86f2-45fd-bd85-6f675b19bdb0-20230330213459-p7i5mm5.png \"运行示意图\")\n\n#### CMS收集器（老年代）\n\n> CMS是基于Mark-Sweep实现的，对于对象的回收效率很高。\n>\n> 对于碎片问题，CMS采用基于Mark-Compact算法的Serial Old回收器作为补偿措施：当内存回收不佳（碎片导致的Concurrent Mode Failure时），将采用Serial Old执行Full GC以达到对老年代内存的整理\n\n![image.png](/assets/net-img-1629560137959-ab93eb78-c083-4c80-8283-4cfc470c8af0-20230330213504-cteixk9.png \"运行示意图\")\n\n* 初始标记（STW）：暂时时间非常短，标记与GC Roots直接关联的对象。\n* 并发标记（最耗时）：从GC Roots开始遍历整个对象图的过程。不会停顿用户线程\n* 重新标记：（STW）：修复并发标记环节，因为用户线程的执行，导致数据的不一致性问题\n* 并发清理（最耗时）：清理删除掉标记阶段判断的已经死亡的对象，释放内存空间。由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的。\n\n#### G1 收集器\n\n> 主要针对配备多核CPU及大容量内存的机器，以极高概率满足GC停顿时间的同时，还兼具高吞吐量，JDK9 以后的默认收集器\n\n![图像](/assets/image-20231126155909-4zbslm1.png)\n\n##### 回收过程\n\n1. 年轻代GC （Young GC）\n\n    1. ‍\n\n2. 老年代并发标记过程 （Concurrent Marking）\n\n3. 混合回收（Mixed GC）\n\n4. 如果需要，单线程、独占式、高强度的Full GC还是继续存在的。它针对GC的评估失败提供了一种失败保护机制，即强力回收。\n\n![图像 (2)](/assets/image-20231126161709-b35di3t.png)\n\n　　顺时针，young gc -> young gc + concurrent mark-> Mixed GC顺序，进行垃圾回收。\n\n##### 特点\n\n*  \n\n  * 并发性：G1拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此，一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况\n\n  **并行与并发**\n\n  * 并行性：G1在回收期间，可以有多个GC线程同时工作，有效利用多核计算能力。此时用户线程STW\n\n* **分代收集**\n\n  * 从分代上看，G1依然属于分代型垃圾回收器，它会区分年轻代和老年代，年轻代依然有Eden区和Survivor区。但从堆的结构上看，它不要求整个Eden区、年轻代或者老年代都是连续的，也不再坚持固定大小和固定数量。\n  * 将堆空间分为若干个区域（Region）,这些区域中包含了逻辑上的年轻代和老年代。\n  * 和之前的各类回收器不同，它同时兼顾年轻代和老年代。对比其他回收器，或者工作在年轻代，或者工作在老年代；\n\n* 空间整合\n\n  * CMS：“标记-清除”算法、内存碎片、若干次GC后进行一次碎片整理\n  * G1将内存划分为一个个的region。内存的回收是以region作为基本单位的。Region之间是复制算法，但整体上实际可看作是标记-压缩（Mark-Compact）算法，两种算法都可以避免内存碎片。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次 GC。尤其是当Java堆非常大的时候，G1的优势更加明显。\n* 可预测的停顿时间模型\n\n  * 由于分区的原因，G1可以只选取部分区域进行内存回收，这样缩小了回收的范围，因此对于全局停顿情况的发生也能得到较好的控制。\n  * G1 跟踪各个 Region 里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。保证了 G1 收集器在有限的时间内可以获取尽可能高的收集效率。\n  * 相比于CMS GC，G1未必能做到CMS在最好情况下的延时停顿，但是最差情况要好很多。\n\n　　**注：G1无论是为了垃圾收集产生的内存占用（Footprint）还是程序运行时的额外执行负载（Overload）都要比CMS要高。在小内存应用上CMS的表现大概率会优于G1，而G1在大内存应用上则发挥其优势。平衡点在6-8GB之间。**\n\n　　‍\n","slug":"java-JVM-垃圾回收和内存分配","published":1,"updated":"2025-04-22T07:27:29.941Z","_id":"cm9s3f40l0030bfg46bwnbb86","comments":1,"layout":"post","photos":[],"content":"<h1>垃圾回收和内存分配</h1>\n<h2 id=\"垃圾回收\">垃圾回收</h2>\n<h3 id=\"垃圾判别算法\">垃圾判别算法</h3>\n<h4 id=\"引用计数法\">引用计数法</h4>\n<blockquote>\n<p>一个对象A，只要有任何一个对象引用了A ，则A 的引用计数器就加1，当引用失效时，引用计数器就减1。只要对象A 的引用计数器的值为0，即表示对象A不可能再被使用，可进行回收。</p>\n</blockquote>\n<ul>\n<li>\n<p>优点</p>\n<ul>\n<li>实现简单，垃圾对象便于辨识；判定效率高，回收没有延迟性。</li>\n</ul>\n</li>\n<li>\n<p>缺点</p>\n<ul>\n<li>需要单独的字段存储计数器，增加了存储空间的开销。</li>\n<li>每次赋值伴随着计数器的增减，增加时间开销。</li>\n<li>无法处理循环依赖的问题</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"可达性分析\">可达性分析</h4>\n<blockquote>\n<p>将对象及其引用关系看作一个图，选定活动的对象作为 GC Roots，然后跟踪引用链条，如果一个对象和GC Roots之间不可达，也就是不存在引用链条，那么即可认为是可回收对象。</p>\n</blockquote>\n<p>基本思路：</p>\n<ul>\n<li>可达性分析算法是以根对象集合(GC Roots)为起始点，按照从上至下的方式搜索被根对象集合所连接的目标对象是否可达。</li>\n<li>使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索所走过的路径称为引用链(Reference Chain)</li>\n<li>如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象己经死亡，可以标记为垃圾对象。</li>\n<li>在可达性分析算法中，只有能够被根对象集合直接或者间接连接的对象才是存活对象。</li>\n</ul>\n<p>可作为&quot;GC Roots&quot;的对象</p>\n<ul>\n<li>虚拟机栈（栈帧中的本地变量表）中引用的对象，例如各个线程调用的方法堆中的参数，局部变量，临时变量。</li>\n<li>方法区中类静态属性引用的对象，例如java 类中的引用类型的静态变量</li>\n<li>方法区中常量引用的对象，例如字符串常量池中的引用</li>\n<li>本地方法栈中JNI（Native方法）引用的对象</li>\n<li>Java虚拟机内部的引用，例如基础类型对应的Class对象，一些常驻的异常对象，还有系统类加载器</li>\n<li>所有被同步锁持有的对象。</li>\n<li>反应java虚拟机内部情况的JMXBean，JVMTI中的注册的回调，本地代码缓存等（？？？）</li>\n</ul>\n<p>注：如果要使用可达性分析算法来判断内存是否可回收，那么分析工作必须在一个能保障<em>一致性的快照</em>中进行，这点也是导致GC进行时必须“Stop The World”的一个重要原因。</p>\n<h3 id=\"垃圾回收算法\">垃圾回收算法</h3>\n<h4 id=\"标记清除\">标记清除</h4>\n<blockquote>\n<p>标记：Collector从引用根节点开始遍历，标记所有被引用的对象。一般是在对象的Header中记录为可达对象。<br>\n清除：Collector对堆内存从头到尾进行线性的遍历，如果发现某个对象在其Header中没有标记为可达对象，则将其回收。</p>\n</blockquote>\n<ul>\n<li>效率比较低：递归与全堆对象遍历两次</li>\n<li>在进行GC的时候，需要停止整个应用程序，导致用户体验差</li>\n<li>这种方式清理出来的空闲内存是不连续的，产生内存碎片。</li>\n</ul>\n<h4 id=\"标记复制\">标记复制</h4>\n<blockquote>\n<p>将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收。</p>\n</blockquote>\n<ul>\n<li>\n<p>优点</p>\n<ul>\n<li>不会造成空间碎片。</li>\n</ul>\n</li>\n<li>\n<p>缺点</p>\n<ul>\n<li>需要两倍的内存空间</li>\n<li>对于G1这种分拆成为大量region的GC，复制而不是移动，意味着GC需要维护region之间对象引用关系，不管是内存占用或者时间开销也不小。</li>\n</ul>\n</li>\n</ul>\n<p>注：如果系统中的存活对象很多，复制算法不会很理想。因为复制算法需要复制的存活对象数量并不会太大,或者说非常低才行。</p>\n<h4 id=\"标记整理\">标记整理</h4>\n<blockquote>\n<p>从根节点开始标记所有被引用对象<br>\n将所有的存活对象压缩到内存的一端，按顺序排放，清理边界外所有的空间。</p>\n</blockquote>\n<ul>\n<li>\n<p>优点</p>\n<ul>\n<li>消除了标记/清除算法当中，内存区域分散的缺点，我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可。</li>\n<li>消除了复制算法当中，内存减半的高额代价。</li>\n</ul>\n</li>\n<li>\n<p>缺点</p>\n<ul>\n<li>效率不高，不仅要标记所有存活对象，还要整理所有存活对象的引用地址。</li>\n<li>对于老年代每次都有大量对象存活的区域来说，极为负重。</li>\n<li>移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址。</li>\n<li>移动过程中，需要全程暂停用户应用程序。即：STW</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"分代收集\">分代收集</h4>\n<blockquote>\n<p>基于这样一个事实：不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点使用不同的回收算法，以提高垃圾回收的效率。</p>\n</blockquote>\n<h4 id=\"增量回收\">增量回收</h4>\n<blockquote>\n<p>垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。</p>\n</blockquote>\n<p>注：线程上下文切换频繁，是的垃圾回收成本上升，导致吞吐量上升</p>\n<h4 id=\"分区算法\">分区算法</h4>\n<blockquote>\n<p>将按照对象的生命周期长短划分成两个部分，分区算法将整个堆空间划分成连续的不同小区间。每一个小区间都独立使用，独立回收。</p>\n</blockquote>\n<h3 id=\"JVM四种引用\">JVM四种引用</h3>\n<h4 id=\"强引用\">强引用</h4>\n<p>特点：GC时，永远不会被回收<br>\n使用场景</p>\n<blockquote>\n<p>new 对象</p>\n</blockquote>\n<h4 id=\"软引用SoftReference-Object-obj\">软引用SoftReference<Object>(obj);</h4>\n<p>特点：内存不足时（自动触发GC），会被回收<br>\n使用场景</p>\n<blockquote>\n<p>缓存</p>\n</blockquote>\n<h4 id=\"弱引用WeakReference-Object-obj\">弱引用WeakReference<Object>(obj)</h4>\n<p>特点：无论内存是否充足，只要进行GC，都会被回收<br>\n使用场景</p>\n<blockquote>\n<p>内部对象为弱引用 WeakReference为强引用</p>\n</blockquote>\n<h4 id=\"虚引用PhantomReference-new-Object-new-ReferenceQueue\">虚引用PhantomReference&lt;&gt;(new Object(),new ReferenceQueue&lt;&gt;())</h4>\n<p>特点：如同虚设，和没有引用没什么区别<br>\n使用场景</p>\n<blockquote>\n<ol>\n<li>管理堆外面的引用</li>\n</ol>\n</blockquote>\n<blockquote>\n<p>首先标记出所需要回收的对象，在标记完成后，统一回收掉所有被标记的对象</p>\n</blockquote>\n<blockquote>\n<p>将可用内存划分为两部分，每次只使用其中一块，当一块内存用完时，将还存活对象复制到另外一块上面，然后再把已使用的内存空间清理一遍</p>\n</blockquote>\n<blockquote>\n<p>标记出所需要回收的对象，将所有需要存活的对象都向内存空间的一端移动，然后直接清理掉边界以外的内存</p>\n</blockquote>\n<h2 id=\"JVM-GC-流程\">JVM GC 流程</h2>\n<blockquote>\n<p><a href=\"https://www.yuque.com/pride_yang/blog/qsgy0z#vfjXH\">JVM堆的内存分布</a></p>\n</blockquote>\n<blockquote>\n<p>Minor GC  新生代GC</p>\n</blockquote>\n<blockquote>\n<p>Major GC/Full GC</p>\n</blockquote>\n<ol>\n<li>开始时，对象会先分配到eden区</li>\n<li>引用运行，越来越多对象分配在eden区域</li>\n<li>当eden区域放不下时，就会发生minor GC(young GC),利用可达性分析标记出垃圾对象，然后将有用对象移动到survivor0区域，将标记出来的垃圾对象全部清除，此时eden区域就全部清理干净了。整个过程使用了 mark-sweep（标记整理）方法回收eden区，使用mark-copy（标记复制） 方法将可用对象移动到 survivor0区域。</li>\n<li>随着时间推移，eden如果又满了，再次触发minor GC，同样还是先做标记，这时eden和s0区可能都有垃圾对象了，注意：这时s1（即：to）区是空的，S0区和eden区的存活对象（S0 区域满了），将直接搬到s1区。然后将eden和S0区的垃圾清理掉，这一轮minor GC后，eden和S0区就变成了空的了。</li>\n<li>随着对象的不断分配，eden空可能又满了，这时会重复刚才的minor GC过程，不过要注意的是，这时候s0是空的，所以s0与s1的角色其实会互换，即：存活的对象，会从eden和s1区，向s0区移动。然后再把eden和s1区中的垃圾清除，这一轮完成后，eden与s1区变成空的</li>\n<li>对于那些比较“长寿”的对象一直在s0与s1中挪来挪去，一来很占地方，而且也会造成一定开销，降低gc效率，于是有了“代龄(age)”及“晋升”。对象在年青代的3个区(eden,s0,s1)之间，每次从1个区移到另1区，年龄+1，在young区达到一定的年龄阈值(-XX:MaxTenuringThreshold（默认15）)后，将晋升到老年代。</li>\n<li>如果老年代，最终也放满了，就会发生major GC（即Full GC），由于老年代的的对象通常会比较多，因为标记-清理-整理（压缩）的耗时通常会比较长，会让应用出现卡顿的现象，</li>\n</ol>\n<p>​<img src=\"/assets/net-img-1646740660775-762fcaa3-26b5-4d95-ac43-5cca58540969-20230330213439-sxz1b5i.png\" alt=\"\">​</p>\n<h2 id=\"垃圾收集器\">垃圾收集器</h2>\n<p>​<img src=\".//assets/image-20231126145713-0pou43f.png\" alt=\"图像\">​</p>\n<ol>\n<li>两个收集器间有连线，表明它们可以搭配使用：<br>\nSerial/Serial Old、Serial/CMS、ParNew/Serial Old、ParNew/CMS、Parallel Scavenge/Serial Old、Parallel Scavenge/Parallel Old、G1；</li>\n<li>其中Serial Old作为CMS出现&quot;Concurrent Mode Failure&quot;失败的后备预案。</li>\n<li>(红色虚线)由于维护和兼容性测试的成本，在JDK 8时将Serial+CMS、ParNew+Serial Old这两个组合声明为废弃（JEP 173），并在JDK 9中完全取消了这些组合的支持（JEP214），即：移除。</li>\n<li>(绿色虚线)JDK 14中：弃用Parallel Scavenge和SerialOld GC组合 （JEP 366）</li>\n<li>(青色虚线)JDK 14中：删除CMS垃圾回收器 （JEP 363）</li>\n</ol>\n<h3 id=\"经典垃圾收集器\">经典垃圾收集器</h3>\n<h4 id=\"Serial-收集器-Serial-Old-收集器\">Serial 收集器/Serial Old 收集器</h4>\n<blockquote>\n<p>简单高效，占用内存小 适合客户端</p>\n</blockquote>\n<p><img src=\"/assets/net-img-1629558034184-e1fe6601-777e-4a34-afe5-df37e5a9b720-20230330213445-e5uive7.png\" alt=\"image.png\" title=\"运行示意图\"></p>\n<h4 id=\"ParNew-收集器-Serial-Old-收集器\">ParNew 收集器/Serial Old 收集器</h4>\n<blockquote>\n<p>适合多核CPU 单核由于上下文切换，收集并不理想</p>\n</blockquote>\n<p><img src=\"/assets/net-img-1629559055065-5ad8d49f-81b6-45f3-87f8-c98716f799ed-20230330213451-7nkjlzc.png\" alt=\"image.png\" title=\"运行示意图\"></p>\n<h4 id=\"Parallel-Scavenge-Parallel-Old收集器\">Parallel Scavenge/Parallel Old收集器</h4>\n<blockquote>\n<p>吞吐量优先的垃圾收集器，有自适应调节策略 jdk8的默认垃圾收集器</p>\n</blockquote>\n<p><img src=\"/assets/net-img-1629559366006-0194df18-86f2-45fd-bd85-6f675b19bdb0-20230330213459-p7i5mm5.png\" alt=\"image.png\" title=\"运行示意图\"></p>\n<h4 id=\"CMS收集器（老年代）\">CMS收集器（老年代）</h4>\n<blockquote>\n<p>CMS是基于Mark-Sweep实现的，对于对象的回收效率很高。</p>\n<p>对于碎片问题，CMS采用基于Mark-Compact算法的Serial Old回收器作为补偿措施：当内存回收不佳（碎片导致的Concurrent Mode Failure时），将采用Serial Old执行Full GC以达到对老年代内存的整理</p>\n</blockquote>\n<p><img src=\"/assets/net-img-1629560137959-ab93eb78-c083-4c80-8283-4cfc470c8af0-20230330213504-cteixk9.png\" alt=\"image.png\" title=\"运行示意图\"></p>\n<ul>\n<li>初始标记（STW）：暂时时间非常短，标记与GC Roots直接关联的对象。</li>\n<li>并发标记（最耗时）：从GC Roots开始遍历整个对象图的过程。不会停顿用户线程</li>\n<li>重新标记：（STW）：修复并发标记环节，因为用户线程的执行，导致数据的不一致性问题</li>\n<li>并发清理（最耗时）：清理删除掉标记阶段判断的已经死亡的对象，释放内存空间。由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的。</li>\n</ul>\n<h4 id=\"G1-收集器\">G1 收集器</h4>\n<blockquote>\n<p>主要针对配备多核CPU及大容量内存的机器，以极高概率满足GC停顿时间的同时，还兼具高吞吐量，JDK9 以后的默认收集器</p>\n</blockquote>\n<p><img src=\"/assets/image-20231126155909-4zbslm1.png\" alt=\"图像\"></p>\n<h5 id=\"回收过程\">回收过程</h5>\n<ol>\n<li>\n<p>年轻代GC （Young GC）</p>\n<ol>\n<li>‍</li>\n</ol>\n</li>\n<li>\n<p>老年代并发标记过程 （Concurrent Marking）</p>\n</li>\n<li>\n<p>混合回收（Mixed GC）</p>\n</li>\n<li>\n<p>如果需要，单线程、独占式、高强度的Full GC还是继续存在的。它针对GC的评估失败提供了一种失败保护机制，即强力回收。</p>\n</li>\n</ol>\n<p><img src=\"/assets/image-20231126161709-b35di3t.png\" alt=\"图像 (2)\"></p>\n<p>顺时针，young gc -&gt; young gc + concurrent mark-&gt; Mixed GC顺序，进行垃圾回收。</p>\n<h5 id=\"特点\">特点</h5>\n<ul>\n<li></li>\n<li>\n<p>并发性：G1拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此，一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况</p>\n</li>\n</ul>\n<p><strong>并行与并发</strong></p>\n<ul>\n<li>\n<p>并行性：G1在回收期间，可以有多个GC线程同时工作，有效利用多核计算能力。此时用户线程STW</p>\n</li>\n<li>\n<p><strong>分代收集</strong></p>\n<ul>\n<li>从分代上看，G1依然属于分代型垃圾回收器，它会区分年轻代和老年代，年轻代依然有Eden区和Survivor区。但从堆的结构上看，它不要求整个Eden区、年轻代或者老年代都是连续的，也不再坚持固定大小和固定数量。</li>\n<li>将堆空间分为若干个区域（Region）,这些区域中包含了逻辑上的年轻代和老年代。</li>\n<li>和之前的各类回收器不同，它同时兼顾年轻代和老年代。对比其他回收器，或者工作在年轻代，或者工作在老年代；</li>\n</ul>\n</li>\n<li>\n<p>空间整合</p>\n<ul>\n<li>CMS：“标记-清除”算法、内存碎片、若干次GC后进行一次碎片整理</li>\n<li>G1将内存划分为一个个的region。内存的回收是以region作为基本单位的。Region之间是复制算法，但整体上实际可看作是标记-压缩（Mark-Compact）算法，两种算法都可以避免内存碎片。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次 GC。尤其是当Java堆非常大的时候，G1的优势更加明显。</li>\n</ul>\n</li>\n<li>\n<p>可预测的停顿时间模型</p>\n<ul>\n<li>由于分区的原因，G1可以只选取部分区域进行内存回收，这样缩小了回收的范围，因此对于全局停顿情况的发生也能得到较好的控制。</li>\n<li>G1 跟踪各个 Region 里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。保证了 G1 收集器在有限的时间内可以获取尽可能高的收集效率。</li>\n<li>相比于CMS GC，G1未必能做到CMS在最好情况下的延时停顿，但是最差情况要好很多。</li>\n</ul>\n</li>\n</ul>\n<p><strong>注：G1无论是为了垃圾收集产生的内存占用（Footprint）还是程序运行时的额外执行负载（Overload）都要比CMS要高。在小内存应用上CMS的表现大概率会优于G1，而G1在大内存应用上则发挥其优势。平衡点在6-8GB之间。</strong></p>\n<p>‍</p>\n","excerpt":"","more":"<h1>垃圾回收和内存分配</h1>\n<h2 id=\"垃圾回收\">垃圾回收</h2>\n<h3 id=\"垃圾判别算法\">垃圾判别算法</h3>\n<h4 id=\"引用计数法\">引用计数法</h4>\n<blockquote>\n<p>一个对象A，只要有任何一个对象引用了A ，则A 的引用计数器就加1，当引用失效时，引用计数器就减1。只要对象A 的引用计数器的值为0，即表示对象A不可能再被使用，可进行回收。</p>\n</blockquote>\n<ul>\n<li>\n<p>优点</p>\n<ul>\n<li>实现简单，垃圾对象便于辨识；判定效率高，回收没有延迟性。</li>\n</ul>\n</li>\n<li>\n<p>缺点</p>\n<ul>\n<li>需要单独的字段存储计数器，增加了存储空间的开销。</li>\n<li>每次赋值伴随着计数器的增减，增加时间开销。</li>\n<li>无法处理循环依赖的问题</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"可达性分析\">可达性分析</h4>\n<blockquote>\n<p>将对象及其引用关系看作一个图，选定活动的对象作为 GC Roots，然后跟踪引用链条，如果一个对象和GC Roots之间不可达，也就是不存在引用链条，那么即可认为是可回收对象。</p>\n</blockquote>\n<p>基本思路：</p>\n<ul>\n<li>可达性分析算法是以根对象集合(GC Roots)为起始点，按照从上至下的方式搜索被根对象集合所连接的目标对象是否可达。</li>\n<li>使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索所走过的路径称为引用链(Reference Chain)</li>\n<li>如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象己经死亡，可以标记为垃圾对象。</li>\n<li>在可达性分析算法中，只有能够被根对象集合直接或者间接连接的对象才是存活对象。</li>\n</ul>\n<p>可作为&quot;GC Roots&quot;的对象</p>\n<ul>\n<li>虚拟机栈（栈帧中的本地变量表）中引用的对象，例如各个线程调用的方法堆中的参数，局部变量，临时变量。</li>\n<li>方法区中类静态属性引用的对象，例如java 类中的引用类型的静态变量</li>\n<li>方法区中常量引用的对象，例如字符串常量池中的引用</li>\n<li>本地方法栈中JNI（Native方法）引用的对象</li>\n<li>Java虚拟机内部的引用，例如基础类型对应的Class对象，一些常驻的异常对象，还有系统类加载器</li>\n<li>所有被同步锁持有的对象。</li>\n<li>反应java虚拟机内部情况的JMXBean，JVMTI中的注册的回调，本地代码缓存等（？？？）</li>\n</ul>\n<p>注：如果要使用可达性分析算法来判断内存是否可回收，那么分析工作必须在一个能保障<em>一致性的快照</em>中进行，这点也是导致GC进行时必须“Stop The World”的一个重要原因。</p>\n<h3 id=\"垃圾回收算法\">垃圾回收算法</h3>\n<h4 id=\"标记清除\">标记清除</h4>\n<blockquote>\n<p>标记：Collector从引用根节点开始遍历，标记所有被引用的对象。一般是在对象的Header中记录为可达对象。<br>\n清除：Collector对堆内存从头到尾进行线性的遍历，如果发现某个对象在其Header中没有标记为可达对象，则将其回收。</p>\n</blockquote>\n<ul>\n<li>效率比较低：递归与全堆对象遍历两次</li>\n<li>在进行GC的时候，需要停止整个应用程序，导致用户体验差</li>\n<li>这种方式清理出来的空闲内存是不连续的，产生内存碎片。</li>\n</ul>\n<h4 id=\"标记复制\">标记复制</h4>\n<blockquote>\n<p>将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收。</p>\n</blockquote>\n<ul>\n<li>\n<p>优点</p>\n<ul>\n<li>不会造成空间碎片。</li>\n</ul>\n</li>\n<li>\n<p>缺点</p>\n<ul>\n<li>需要两倍的内存空间</li>\n<li>对于G1这种分拆成为大量region的GC，复制而不是移动，意味着GC需要维护region之间对象引用关系，不管是内存占用或者时间开销也不小。</li>\n</ul>\n</li>\n</ul>\n<p>注：如果系统中的存活对象很多，复制算法不会很理想。因为复制算法需要复制的存活对象数量并不会太大,或者说非常低才行。</p>\n<h4 id=\"标记整理\">标记整理</h4>\n<blockquote>\n<p>从根节点开始标记所有被引用对象<br>\n将所有的存活对象压缩到内存的一端，按顺序排放，清理边界外所有的空间。</p>\n</blockquote>\n<ul>\n<li>\n<p>优点</p>\n<ul>\n<li>消除了标记/清除算法当中，内存区域分散的缺点，我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可。</li>\n<li>消除了复制算法当中，内存减半的高额代价。</li>\n</ul>\n</li>\n<li>\n<p>缺点</p>\n<ul>\n<li>效率不高，不仅要标记所有存活对象，还要整理所有存活对象的引用地址。</li>\n<li>对于老年代每次都有大量对象存活的区域来说，极为负重。</li>\n<li>移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址。</li>\n<li>移动过程中，需要全程暂停用户应用程序。即：STW</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"分代收集\">分代收集</h4>\n<blockquote>\n<p>基于这样一个事实：不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点使用不同的回收算法，以提高垃圾回收的效率。</p>\n</blockquote>\n<h4 id=\"增量回收\">增量回收</h4>\n<blockquote>\n<p>垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。</p>\n</blockquote>\n<p>注：线程上下文切换频繁，是的垃圾回收成本上升，导致吞吐量上升</p>\n<h4 id=\"分区算法\">分区算法</h4>\n<blockquote>\n<p>将按照对象的生命周期长短划分成两个部分，分区算法将整个堆空间划分成连续的不同小区间。每一个小区间都独立使用，独立回收。</p>\n</blockquote>\n<h3 id=\"JVM四种引用\">JVM四种引用</h3>\n<h4 id=\"强引用\">强引用</h4>\n<p>特点：GC时，永远不会被回收<br>\n使用场景</p>\n<blockquote>\n<p>new 对象</p>\n</blockquote>\n<h4 id=\"软引用SoftReference-Object-obj\">软引用SoftReference<Object>(obj);</h4>\n<p>特点：内存不足时（自动触发GC），会被回收<br>\n使用场景</p>\n<blockquote>\n<p>缓存</p>\n</blockquote>\n<h4 id=\"弱引用WeakReference-Object-obj\">弱引用WeakReference<Object>(obj)</h4>\n<p>特点：无论内存是否充足，只要进行GC，都会被回收<br>\n使用场景</p>\n<blockquote>\n<p>内部对象为弱引用 WeakReference为强引用</p>\n</blockquote>\n<h4 id=\"虚引用PhantomReference-new-Object-new-ReferenceQueue\">虚引用PhantomReference&lt;&gt;(new Object(),new ReferenceQueue&lt;&gt;())</h4>\n<p>特点：如同虚设，和没有引用没什么区别<br>\n使用场景</p>\n<blockquote>\n<ol>\n<li>管理堆外面的引用</li>\n</ol>\n</blockquote>\n<blockquote>\n<p>首先标记出所需要回收的对象，在标记完成后，统一回收掉所有被标记的对象</p>\n</blockquote>\n<blockquote>\n<p>将可用内存划分为两部分，每次只使用其中一块，当一块内存用完时，将还存活对象复制到另外一块上面，然后再把已使用的内存空间清理一遍</p>\n</blockquote>\n<blockquote>\n<p>标记出所需要回收的对象，将所有需要存活的对象都向内存空间的一端移动，然后直接清理掉边界以外的内存</p>\n</blockquote>\n<h2 id=\"JVM-GC-流程\">JVM GC 流程</h2>\n<blockquote>\n<p><a href=\"https://www.yuque.com/pride_yang/blog/qsgy0z#vfjXH\">JVM堆的内存分布</a></p>\n</blockquote>\n<blockquote>\n<p>Minor GC  新生代GC</p>\n</blockquote>\n<blockquote>\n<p>Major GC/Full GC</p>\n</blockquote>\n<ol>\n<li>开始时，对象会先分配到eden区</li>\n<li>引用运行，越来越多对象分配在eden区域</li>\n<li>当eden区域放不下时，就会发生minor GC(young GC),利用可达性分析标记出垃圾对象，然后将有用对象移动到survivor0区域，将标记出来的垃圾对象全部清除，此时eden区域就全部清理干净了。整个过程使用了 mark-sweep（标记整理）方法回收eden区，使用mark-copy（标记复制） 方法将可用对象移动到 survivor0区域。</li>\n<li>随着时间推移，eden如果又满了，再次触发minor GC，同样还是先做标记，这时eden和s0区可能都有垃圾对象了，注意：这时s1（即：to）区是空的，S0区和eden区的存活对象（S0 区域满了），将直接搬到s1区。然后将eden和S0区的垃圾清理掉，这一轮minor GC后，eden和S0区就变成了空的了。</li>\n<li>随着对象的不断分配，eden空可能又满了，这时会重复刚才的minor GC过程，不过要注意的是，这时候s0是空的，所以s0与s1的角色其实会互换，即：存活的对象，会从eden和s1区，向s0区移动。然后再把eden和s1区中的垃圾清除，这一轮完成后，eden与s1区变成空的</li>\n<li>对于那些比较“长寿”的对象一直在s0与s1中挪来挪去，一来很占地方，而且也会造成一定开销，降低gc效率，于是有了“代龄(age)”及“晋升”。对象在年青代的3个区(eden,s0,s1)之间，每次从1个区移到另1区，年龄+1，在young区达到一定的年龄阈值(-XX:MaxTenuringThreshold（默认15）)后，将晋升到老年代。</li>\n<li>如果老年代，最终也放满了，就会发生major GC（即Full GC），由于老年代的的对象通常会比较多，因为标记-清理-整理（压缩）的耗时通常会比较长，会让应用出现卡顿的现象，</li>\n</ol>\n<p>​<img src=\"/assets/net-img-1646740660775-762fcaa3-26b5-4d95-ac43-5cca58540969-20230330213439-sxz1b5i.png\" alt=\"\">​</p>\n<h2 id=\"垃圾收集器\">垃圾收集器</h2>\n<p>​<img src=\".//assets/image-20231126145713-0pou43f.png\" alt=\"图像\">​</p>\n<ol>\n<li>两个收集器间有连线，表明它们可以搭配使用：<br>\nSerial/Serial Old、Serial/CMS、ParNew/Serial Old、ParNew/CMS、Parallel Scavenge/Serial Old、Parallel Scavenge/Parallel Old、G1；</li>\n<li>其中Serial Old作为CMS出现&quot;Concurrent Mode Failure&quot;失败的后备预案。</li>\n<li>(红色虚线)由于维护和兼容性测试的成本，在JDK 8时将Serial+CMS、ParNew+Serial Old这两个组合声明为废弃（JEP 173），并在JDK 9中完全取消了这些组合的支持（JEP214），即：移除。</li>\n<li>(绿色虚线)JDK 14中：弃用Parallel Scavenge和SerialOld GC组合 （JEP 366）</li>\n<li>(青色虚线)JDK 14中：删除CMS垃圾回收器 （JEP 363）</li>\n</ol>\n<h3 id=\"经典垃圾收集器\">经典垃圾收集器</h3>\n<h4 id=\"Serial-收集器-Serial-Old-收集器\">Serial 收集器/Serial Old 收集器</h4>\n<blockquote>\n<p>简单高效，占用内存小 适合客户端</p>\n</blockquote>\n<p><img src=\"/assets/net-img-1629558034184-e1fe6601-777e-4a34-afe5-df37e5a9b720-20230330213445-e5uive7.png\" alt=\"image.png\" title=\"运行示意图\"></p>\n<h4 id=\"ParNew-收集器-Serial-Old-收集器\">ParNew 收集器/Serial Old 收集器</h4>\n<blockquote>\n<p>适合多核CPU 单核由于上下文切换，收集并不理想</p>\n</blockquote>\n<p><img src=\"/assets/net-img-1629559055065-5ad8d49f-81b6-45f3-87f8-c98716f799ed-20230330213451-7nkjlzc.png\" alt=\"image.png\" title=\"运行示意图\"></p>\n<h4 id=\"Parallel-Scavenge-Parallel-Old收集器\">Parallel Scavenge/Parallel Old收集器</h4>\n<blockquote>\n<p>吞吐量优先的垃圾收集器，有自适应调节策略 jdk8的默认垃圾收集器</p>\n</blockquote>\n<p><img src=\"/assets/net-img-1629559366006-0194df18-86f2-45fd-bd85-6f675b19bdb0-20230330213459-p7i5mm5.png\" alt=\"image.png\" title=\"运行示意图\"></p>\n<h4 id=\"CMS收集器（老年代）\">CMS收集器（老年代）</h4>\n<blockquote>\n<p>CMS是基于Mark-Sweep实现的，对于对象的回收效率很高。</p>\n<p>对于碎片问题，CMS采用基于Mark-Compact算法的Serial Old回收器作为补偿措施：当内存回收不佳（碎片导致的Concurrent Mode Failure时），将采用Serial Old执行Full GC以达到对老年代内存的整理</p>\n</blockquote>\n<p><img src=\"/assets/net-img-1629560137959-ab93eb78-c083-4c80-8283-4cfc470c8af0-20230330213504-cteixk9.png\" alt=\"image.png\" title=\"运行示意图\"></p>\n<ul>\n<li>初始标记（STW）：暂时时间非常短，标记与GC Roots直接关联的对象。</li>\n<li>并发标记（最耗时）：从GC Roots开始遍历整个对象图的过程。不会停顿用户线程</li>\n<li>重新标记：（STW）：修复并发标记环节，因为用户线程的执行，导致数据的不一致性问题</li>\n<li>并发清理（最耗时）：清理删除掉标记阶段判断的已经死亡的对象，释放内存空间。由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的。</li>\n</ul>\n<h4 id=\"G1-收集器\">G1 收集器</h4>\n<blockquote>\n<p>主要针对配备多核CPU及大容量内存的机器，以极高概率满足GC停顿时间的同时，还兼具高吞吐量，JDK9 以后的默认收集器</p>\n</blockquote>\n<p><img src=\"/assets/image-20231126155909-4zbslm1.png\" alt=\"图像\"></p>\n<h5 id=\"回收过程\">回收过程</h5>\n<ol>\n<li>\n<p>年轻代GC （Young GC）</p>\n<ol>\n<li>‍</li>\n</ol>\n</li>\n<li>\n<p>老年代并发标记过程 （Concurrent Marking）</p>\n</li>\n<li>\n<p>混合回收（Mixed GC）</p>\n</li>\n<li>\n<p>如果需要，单线程、独占式、高强度的Full GC还是继续存在的。它针对GC的评估失败提供了一种失败保护机制，即强力回收。</p>\n</li>\n</ol>\n<p><img src=\"/assets/image-20231126161709-b35di3t.png\" alt=\"图像 (2)\"></p>\n<p>顺时针，young gc -&gt; young gc + concurrent mark-&gt; Mixed GC顺序，进行垃圾回收。</p>\n<h5 id=\"特点\">特点</h5>\n<ul>\n<li></li>\n<li>\n<p>并发性：G1拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此，一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况</p>\n</li>\n</ul>\n<p><strong>并行与并发</strong></p>\n<ul>\n<li>\n<p>并行性：G1在回收期间，可以有多个GC线程同时工作，有效利用多核计算能力。此时用户线程STW</p>\n</li>\n<li>\n<p><strong>分代收集</strong></p>\n<ul>\n<li>从分代上看，G1依然属于分代型垃圾回收器，它会区分年轻代和老年代，年轻代依然有Eden区和Survivor区。但从堆的结构上看，它不要求整个Eden区、年轻代或者老年代都是连续的，也不再坚持固定大小和固定数量。</li>\n<li>将堆空间分为若干个区域（Region）,这些区域中包含了逻辑上的年轻代和老年代。</li>\n<li>和之前的各类回收器不同，它同时兼顾年轻代和老年代。对比其他回收器，或者工作在年轻代，或者工作在老年代；</li>\n</ul>\n</li>\n<li>\n<p>空间整合</p>\n<ul>\n<li>CMS：“标记-清除”算法、内存碎片、若干次GC后进行一次碎片整理</li>\n<li>G1将内存划分为一个个的region。内存的回收是以region作为基本单位的。Region之间是复制算法，但整体上实际可看作是标记-压缩（Mark-Compact）算法，两种算法都可以避免内存碎片。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次 GC。尤其是当Java堆非常大的时候，G1的优势更加明显。</li>\n</ul>\n</li>\n<li>\n<p>可预测的停顿时间模型</p>\n<ul>\n<li>由于分区的原因，G1可以只选取部分区域进行内存回收，这样缩小了回收的范围，因此对于全局停顿情况的发生也能得到较好的控制。</li>\n<li>G1 跟踪各个 Region 里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。保证了 G1 收集器在有限的时间内可以获取尽可能高的收集效率。</li>\n<li>相比于CMS GC，G1未必能做到CMS在最好情况下的延时停顿，但是最差情况要好很多。</li>\n</ul>\n</li>\n</ul>\n<p><strong>注：G1无论是为了垃圾收集产生的内存占用（Footprint）还是程序运行时的额外执行负载（Overload）都要比CMS要高。在小内存应用上CMS的表现大概率会优于G1，而G1在大内存应用上则发挥其优势。平衡点在6-8GB之间。</strong></p>\n<p>‍</p>\n"},{"title":"虚拟机运行时数据区域","date":"2022-10-30T05:40:27.000Z","lastmod":"2023-11-25T05:15:42.000Z","_content":"\n# 虚拟机运行时数据区域\n\n## 运行时数据区域\n\n​![图像](/assets/image-20231119154230-3g5nidd.png)\n\n​​![图像](/assets/image-20231119154304-hwfdw8h.jpeg)​\n\n### 程序计数器\n\n> 通过改变这个计数器 的值来选取下一条需要执行的字节码指令\n\n　　java 虚拟机的多线程是通过线程轮流切换、分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器只会执行一条线程中的指令，为了线程切换后能恢复到正确的执行位置，每条线程都需要一个独立的程序计数器。\n每个线程都会有属于自己独立的线程计数器，各线程之间计数器不会相互影响，独立存储，这些区域成为线程私有。\n\n### Java虚拟机栈\n\n> Java方法执行的线程内存模型\n\n　　每个方法被执行，Java虚拟机栈会创建一个栈帧[(1)](https://www.yuque.com/pride_yang/blog/gngtxy)，用于存储局部变量表，操作数栈，方法出口，动态链接等信息。  \n一个方法的执行对应着一个栈帧的入栈与出栈过程。\n\n　　局部变量存储存放编译期间可知java虚拟机的基础类型（boolean，byte，char、short、int、float、dubbo、long）、对象引用（reference类型）、和returnAddress类型（指向一条字节码指令的地址）。\n\n　　局部变量表的存储单位是局部**变量槽（slot）**  其中64位长度的long和 double类型的数据会占用两个变量槽，其余的数据类型只占用一个 （一个变量槽的内存占用空间由虚拟机自行决定） 。\n\n　　当进入一个方法后，栈帧中需要分配多大的局部变量空间已经固定（变量槽数量）  \n《Java虚拟机规范》中  规定如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常，当栈扩展时无法申请到足够的内存会抛出OutOfMemoryError异常。  \n\n### 本地方法栈\n\n> 为虚拟机使用到的 Native 方法服务 （一个 Native Method 就是一个 java 调用非 java 代码的接口）\n\n　　**HotSpot栈内存不允许动态扩容**\n\n```bash\n-Xss 设置栈容量 jdk11 windows最小值 180k Linux最小值228k 否则启动时会出现提示\n```\n\n### Java堆\n\n> 被所有线程共享，在虚拟机启动时创建，用于存放对象实例。\n\n- java堆是垃圾收集器管理的内存区域，也被成为GC堆。G1收集器出现之前，垃圾收集器一般基于分代收集理论设计，但是之后出现了一些不采用分代设计的垃圾收集器。所以收集器不一定存在新生代，老年代，永久代，Eden区，From Survivor区，To Survivor区等。\n- 从内存角度看，所有线程共享的java堆可以划分为多个私有进程的分配缓存区（TLAB），以提升对象分配时的效率。\n\n```bash\n-Xmx 堆最大值\n-Xms 堆最小值\n-XX:+HeapDumpOnOutOfMemoryError 发生OOM时产生dump内存堆转储快照\n-XX:HeapDumpPath=./ 设置快照文件保存位置\n```\n\n#### jvm堆的默认分配方案\n\n　　![](/assets/net-img-1646742883104-4eef3a95-3655-44f4-8887-2f5f1628732e-20230330213506-2xv20ln.png)\n老年代 ： 三分之二的堆空间\n年轻代 ： 三分之一的堆空间\neden区： 8/10 的年轻代空间\nsurvivor0 : 1/10 的年轻代空间\nsurvivor1 : 1/10 的年轻代空间（from 区）\n\n　　**由于及时编译技术的进步，逃逸分析技术的日渐强大，栈上分配，标量替换等优化手段出现，对象实例也未必都全部分配在堆上。**\n\n　　  \n从 jdk 1.7 开始已经默认开启逃逸分析，如果某些方法中的对象引用没有被返回或者未被外面使用（也就是未逃逸出去），那么对象可以直接在栈上分配内存。\n\n　　JDK8 后方法区（永生代）移除，用元空间代替，元空间使用直接内存\n\n#### gc\n\n##### MinorGC触发机制\n\n* 当年轻代空间不足时，就会触发Minor GC。这里的年轻代满指的是Eden区满，Survivor满不会引发GC。（每次 Minor GC 会清理年轻代的内存。)\n* 因为 Java 对象大多都具备朝生夕灭的特性，所以 Minor GC 非常频繁，一般回收速度也比较快。这一定义既清晰又易于理解。\n* Minor GC会引发STW，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行。\n\n##### MajorGC触发机制\n\n* 指发生在老年代的GC，对象从老年代消失时，我们说“Major GC”或“Full GC”发生了。\n\n  * 出现了Major GC，经常会伴随至少一次的Minor GC（但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程）。\n  * 也就是在老年代空间不足时，会先尝试触发Minor GC。如果之后空间还不足，则触发Major GC\n\n* Major GC的速度一般会比Minor GC慢10倍以上，STW的时间更长。\n\n* 如果Major GC 后，内存还不足，就报OOM了。\n\n##### FullGC触发机制\n\n* 调用System.gc()时，系统建议执行Full GC，但是不必然执行\n* 老年代空间不足\n* 方法区空间不足\n* 通过Minor GC后进入老年代的平均大小大于老年代的可用内存\n* 由Eden区、survivor space0（From Space）区向survivor space1（To Space）区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小\n\n### 方法区（元空间）\n\n> 主要用于存储被虚拟机加载的类型信息、常量、静态变量、及时编译器编译后的代码缓存等数据\n\n#### 存储内容\n\n* 类型信息\n* 域信息\n\n  * 域名称，域类型，域修饰符（public, private, protected, static, final, volatile, transient的某个子集）\n* 方法信息\n\n  * 方法名称\n  * 方法的返回类型(或 void)\n  * 方法参数的数量和类型(按顺序)\n  * 方法的修饰符(public, private, protected, static, final, synchronized, native, abstract的一个子集)\n  * 方法的字节码(bytecodes)、操作数栈、局部变量表及大小 （abstract和native方法除外）\n  * 异常表（abstract和native方法除外）\n\n    * 每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引\n* non-final的类变量\n* 运行时常量池\n\n　　**在HotSpot中jdk1.8之前也被称为永久代 在jdk7后将永久代的功能转移到元空间**\n\n　　**元空间默认初始大小20m**\n\n```bash\n-XX:MaxMetaspaceSize 设置元空间最大值，默认为-1 不受限制或者说收本地内存限制\n-XX:MetaspaceSize 设置元空间初始空间大小 以字节为单位，达到该值会触发垃圾收集进行类型卸载，同事收集器会对该值进行调整，如果释放大量空间则适当降低该值，如果释放很少空间，那么在不超过最大值情况下适当提高。\n-MinMetaspaceFreeRatio：在垃圾收集后控制最小的元空间剩余容量的百分比，可减少因元空间不足导致垃圾收集的频率\n-MinMetaspaceFreeRatio：用于控制最大的元空间剩余容量的百分比\n```\n\n#### 运行时常量池\n\n> 方法区的一部分，用于存放编译期产生的各种字面量和符号引用  \n> **给基本类型变量赋值的方式就叫做字面量或者字面值**\n\n　　**注： 字符串常量池在堆中**\n\n### 直接内存(非本地内存)\n\n```bash\n-XX:MaxDirectMemorySize 设置字节内存大小 如果不进行设置则与java堆的最大值一致\n```\n\n##\n","source":"_posts/java/JVM/虚拟机运行时数据区域.md","raw":"---\ntitle: 虚拟机运行时数据区域\ndate: 2022-10-30T13:40:27Z\nlastmod: 2023-11-25T13:15:42Z\n---\n\n# 虚拟机运行时数据区域\n\n## 运行时数据区域\n\n​![图像](/assets/image-20231119154230-3g5nidd.png)\n\n​​![图像](/assets/image-20231119154304-hwfdw8h.jpeg)​\n\n### 程序计数器\n\n> 通过改变这个计数器 的值来选取下一条需要执行的字节码指令\n\n　　java 虚拟机的多线程是通过线程轮流切换、分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器只会执行一条线程中的指令，为了线程切换后能恢复到正确的执行位置，每条线程都需要一个独立的程序计数器。\n每个线程都会有属于自己独立的线程计数器，各线程之间计数器不会相互影响，独立存储，这些区域成为线程私有。\n\n### Java虚拟机栈\n\n> Java方法执行的线程内存模型\n\n　　每个方法被执行，Java虚拟机栈会创建一个栈帧[(1)](https://www.yuque.com/pride_yang/blog/gngtxy)，用于存储局部变量表，操作数栈，方法出口，动态链接等信息。  \n一个方法的执行对应着一个栈帧的入栈与出栈过程。\n\n　　局部变量存储存放编译期间可知java虚拟机的基础类型（boolean，byte，char、short、int、float、dubbo、long）、对象引用（reference类型）、和returnAddress类型（指向一条字节码指令的地址）。\n\n　　局部变量表的存储单位是局部**变量槽（slot）**  其中64位长度的long和 double类型的数据会占用两个变量槽，其余的数据类型只占用一个 （一个变量槽的内存占用空间由虚拟机自行决定） 。\n\n　　当进入一个方法后，栈帧中需要分配多大的局部变量空间已经固定（变量槽数量）  \n《Java虚拟机规范》中  规定如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常，当栈扩展时无法申请到足够的内存会抛出OutOfMemoryError异常。  \n\n### 本地方法栈\n\n> 为虚拟机使用到的 Native 方法服务 （一个 Native Method 就是一个 java 调用非 java 代码的接口）\n\n　　**HotSpot栈内存不允许动态扩容**\n\n```bash\n-Xss 设置栈容量 jdk11 windows最小值 180k Linux最小值228k 否则启动时会出现提示\n```\n\n### Java堆\n\n> 被所有线程共享，在虚拟机启动时创建，用于存放对象实例。\n\n- java堆是垃圾收集器管理的内存区域，也被成为GC堆。G1收集器出现之前，垃圾收集器一般基于分代收集理论设计，但是之后出现了一些不采用分代设计的垃圾收集器。所以收集器不一定存在新生代，老年代，永久代，Eden区，From Survivor区，To Survivor区等。\n- 从内存角度看，所有线程共享的java堆可以划分为多个私有进程的分配缓存区（TLAB），以提升对象分配时的效率。\n\n```bash\n-Xmx 堆最大值\n-Xms 堆最小值\n-XX:+HeapDumpOnOutOfMemoryError 发生OOM时产生dump内存堆转储快照\n-XX:HeapDumpPath=./ 设置快照文件保存位置\n```\n\n#### jvm堆的默认分配方案\n\n　　![](/assets/net-img-1646742883104-4eef3a95-3655-44f4-8887-2f5f1628732e-20230330213506-2xv20ln.png)\n老年代 ： 三分之二的堆空间\n年轻代 ： 三分之一的堆空间\neden区： 8/10 的年轻代空间\nsurvivor0 : 1/10 的年轻代空间\nsurvivor1 : 1/10 的年轻代空间（from 区）\n\n　　**由于及时编译技术的进步，逃逸分析技术的日渐强大，栈上分配，标量替换等优化手段出现，对象实例也未必都全部分配在堆上。**\n\n　　  \n从 jdk 1.7 开始已经默认开启逃逸分析，如果某些方法中的对象引用没有被返回或者未被外面使用（也就是未逃逸出去），那么对象可以直接在栈上分配内存。\n\n　　JDK8 后方法区（永生代）移除，用元空间代替，元空间使用直接内存\n\n#### gc\n\n##### MinorGC触发机制\n\n* 当年轻代空间不足时，就会触发Minor GC。这里的年轻代满指的是Eden区满，Survivor满不会引发GC。（每次 Minor GC 会清理年轻代的内存。)\n* 因为 Java 对象大多都具备朝生夕灭的特性，所以 Minor GC 非常频繁，一般回收速度也比较快。这一定义既清晰又易于理解。\n* Minor GC会引发STW，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行。\n\n##### MajorGC触发机制\n\n* 指发生在老年代的GC，对象从老年代消失时，我们说“Major GC”或“Full GC”发生了。\n\n  * 出现了Major GC，经常会伴随至少一次的Minor GC（但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程）。\n  * 也就是在老年代空间不足时，会先尝试触发Minor GC。如果之后空间还不足，则触发Major GC\n\n* Major GC的速度一般会比Minor GC慢10倍以上，STW的时间更长。\n\n* 如果Major GC 后，内存还不足，就报OOM了。\n\n##### FullGC触发机制\n\n* 调用System.gc()时，系统建议执行Full GC，但是不必然执行\n* 老年代空间不足\n* 方法区空间不足\n* 通过Minor GC后进入老年代的平均大小大于老年代的可用内存\n* 由Eden区、survivor space0（From Space）区向survivor space1（To Space）区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小\n\n### 方法区（元空间）\n\n> 主要用于存储被虚拟机加载的类型信息、常量、静态变量、及时编译器编译后的代码缓存等数据\n\n#### 存储内容\n\n* 类型信息\n* 域信息\n\n  * 域名称，域类型，域修饰符（public, private, protected, static, final, volatile, transient的某个子集）\n* 方法信息\n\n  * 方法名称\n  * 方法的返回类型(或 void)\n  * 方法参数的数量和类型(按顺序)\n  * 方法的修饰符(public, private, protected, static, final, synchronized, native, abstract的一个子集)\n  * 方法的字节码(bytecodes)、操作数栈、局部变量表及大小 （abstract和native方法除外）\n  * 异常表（abstract和native方法除外）\n\n    * 每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引\n* non-final的类变量\n* 运行时常量池\n\n　　**在HotSpot中jdk1.8之前也被称为永久代 在jdk7后将永久代的功能转移到元空间**\n\n　　**元空间默认初始大小20m**\n\n```bash\n-XX:MaxMetaspaceSize 设置元空间最大值，默认为-1 不受限制或者说收本地内存限制\n-XX:MetaspaceSize 设置元空间初始空间大小 以字节为单位，达到该值会触发垃圾收集进行类型卸载，同事收集器会对该值进行调整，如果释放大量空间则适当降低该值，如果释放很少空间，那么在不超过最大值情况下适当提高。\n-MinMetaspaceFreeRatio：在垃圾收集后控制最小的元空间剩余容量的百分比，可减少因元空间不足导致垃圾收集的频率\n-MinMetaspaceFreeRatio：用于控制最大的元空间剩余容量的百分比\n```\n\n#### 运行时常量池\n\n> 方法区的一部分，用于存放编译期产生的各种字面量和符号引用  \n> **给基本类型变量赋值的方式就叫做字面量或者字面值**\n\n　　**注： 字符串常量池在堆中**\n\n### 直接内存(非本地内存)\n\n```bash\n-XX:MaxDirectMemorySize 设置字节内存大小 如果不进行设置则与java堆的最大值一致\n```\n\n##\n","slug":"java-JVM-虚拟机运行时数据区域","published":1,"updated":"2025-04-22T07:27:29.941Z","_id":"cm9s3f40l0031bfg4az7cd8y2","comments":1,"layout":"post","photos":[],"content":"<h1>虚拟机运行时数据区域</h1>\n<h2 id=\"运行时数据区域\">运行时数据区域</h2>\n<p>​<img src=\"/assets/image-20231119154230-3g5nidd.png\" alt=\"图像\"></p>\n<p>​​<img src=\"/assets/image-20231119154304-hwfdw8h.jpeg\" alt=\"图像\">​</p>\n<h3 id=\"程序计数器\">程序计数器</h3>\n<blockquote>\n<p>通过改变这个计数器 的值来选取下一条需要执行的字节码指令</p>\n</blockquote>\n<p>java 虚拟机的多线程是通过线程轮流切换、分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器只会执行一条线程中的指令，为了线程切换后能恢复到正确的执行位置，每条线程都需要一个独立的程序计数器。<br>\n每个线程都会有属于自己独立的线程计数器，各线程之间计数器不会相互影响，独立存储，这些区域成为线程私有。</p>\n<h3 id=\"Java虚拟机栈\">Java虚拟机栈</h3>\n<blockquote>\n<p>Java方法执行的线程内存模型</p>\n</blockquote>\n<p>每个方法被执行，Java虚拟机栈会创建一个栈帧<a href=\"https://www.yuque.com/pride_yang/blog/gngtxy\">(1)</a>，用于存储局部变量表，操作数栈，方法出口，动态链接等信息。<br>\n一个方法的执行对应着一个栈帧的入栈与出栈过程。</p>\n<p>局部变量存储存放编译期间可知java虚拟机的基础类型（boolean，byte，char、short、int、float、dubbo、long）、对象引用（reference类型）、和returnAddress类型（指向一条字节码指令的地址）。</p>\n<p>局部变量表的存储单位是局部<strong>变量槽（slot）</strong>  其中64位长度的long和 double类型的数据会占用两个变量槽，其余的数据类型只占用一个 （一个变量槽的内存占用空间由虚拟机自行决定） 。</p>\n<p>当进入一个方法后，栈帧中需要分配多大的局部变量空间已经固定（变量槽数量）<br>\n《Java虚拟机规范》中  规定如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常，当栈扩展时无法申请到足够的内存会抛出OutOfMemoryError异常。</p>\n<h3 id=\"本地方法栈\">本地方法栈</h3>\n<blockquote>\n<p>为虚拟机使用到的 Native 方法服务 （一个 Native Method 就是一个 java 调用非 java 代码的接口）</p>\n</blockquote>\n<p><strong>HotSpot栈内存不允许动态扩容</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-Xss 设置栈容量 jdk11 windows最小值 180k Linux最小值228k 否则启动时会出现提示</span><br></pre></td></tr></table></figure>\n<h3 id=\"Java堆\">Java堆</h3>\n<blockquote>\n<p>被所有线程共享，在虚拟机启动时创建，用于存放对象实例。</p>\n</blockquote>\n<ul>\n<li>java堆是垃圾收集器管理的内存区域，也被成为GC堆。G1收集器出现之前，垃圾收集器一般基于分代收集理论设计，但是之后出现了一些不采用分代设计的垃圾收集器。所以收集器不一定存在新生代，老年代，永久代，Eden区，From Survivor区，To Survivor区等。</li>\n<li>从内存角度看，所有线程共享的java堆可以划分为多个私有进程的分配缓存区（TLAB），以提升对象分配时的效率。</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-Xmx 堆最大值</span><br><span class=\"line\">-Xms 堆最小值</span><br><span class=\"line\">-XX:+HeapDumpOnOutOfMemoryError 发生OOM时产生dump内存堆转储快照</span><br><span class=\"line\">-XX:HeapDumpPath=./ 设置快照文件保存位置</span><br></pre></td></tr></table></figure>\n<h4 id=\"jvm堆的默认分配方案\">jvm堆的默认分配方案</h4>\n<p><img src=\"/assets/net-img-1646742883104-4eef3a95-3655-44f4-8887-2f5f1628732e-20230330213506-2xv20ln.png\" alt=\"\"><br>\n老年代 ： 三分之二的堆空间<br>\n年轻代 ： 三分之一的堆空间<br>\neden区： 8/10 的年轻代空间<br>\nsurvivor0 : 1/10 的年轻代空间<br>\nsurvivor1 : 1/10 的年轻代空间（from 区）</p>\n<p><strong>由于及时编译技术的进步，逃逸分析技术的日渐强大，栈上分配，标量替换等优化手段出现，对象实例也未必都全部分配在堆上。</strong></p>\n<p>从 jdk 1.7 开始已经默认开启逃逸分析，如果某些方法中的对象引用没有被返回或者未被外面使用（也就是未逃逸出去），那么对象可以直接在栈上分配内存。</p>\n<p>JDK8 后方法区（永生代）移除，用元空间代替，元空间使用直接内存</p>\n<h4 id=\"gc\">gc</h4>\n<h5 id=\"MinorGC触发机制\">MinorGC触发机制</h5>\n<ul>\n<li>当年轻代空间不足时，就会触发Minor GC。这里的年轻代满指的是Eden区满，Survivor满不会引发GC。（每次 Minor GC 会清理年轻代的内存。)</li>\n<li>因为 Java 对象大多都具备朝生夕灭的特性，所以 Minor GC 非常频繁，一般回收速度也比较快。这一定义既清晰又易于理解。</li>\n<li>Minor GC会引发STW，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行。</li>\n</ul>\n<h5 id=\"MajorGC触发机制\">MajorGC触发机制</h5>\n<ul>\n<li>\n<p>指发生在老年代的GC，对象从老年代消失时，我们说“Major GC”或“Full GC”发生了。</p>\n<ul>\n<li>出现了Major GC，经常会伴随至少一次的Minor GC（但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程）。</li>\n<li>也就是在老年代空间不足时，会先尝试触发Minor GC。如果之后空间还不足，则触发Major GC</li>\n</ul>\n</li>\n<li>\n<p>Major GC的速度一般会比Minor GC慢10倍以上，STW的时间更长。</p>\n</li>\n<li>\n<p>如果Major GC 后，内存还不足，就报OOM了。</p>\n</li>\n</ul>\n<h5 id=\"FullGC触发机制\">FullGC触发机制</h5>\n<ul>\n<li>调用System.gc()时，系统建议执行Full GC，但是不必然执行</li>\n<li>老年代空间不足</li>\n<li>方法区空间不足</li>\n<li>通过Minor GC后进入老年代的平均大小大于老年代的可用内存</li>\n<li>由Eden区、survivor space0（From Space）区向survivor space1（To Space）区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小</li>\n</ul>\n<h3 id=\"方法区（元空间）\">方法区（元空间）</h3>\n<blockquote>\n<p>主要用于存储被虚拟机加载的类型信息、常量、静态变量、及时编译器编译后的代码缓存等数据</p>\n</blockquote>\n<h4 id=\"存储内容\">存储内容</h4>\n<ul>\n<li>\n<p>类型信息</p>\n</li>\n<li>\n<p>域信息</p>\n<ul>\n<li>域名称，域类型，域修饰符（public, private, protected, static, final, volatile, transient的某个子集）</li>\n</ul>\n</li>\n<li>\n<p>方法信息</p>\n<ul>\n<li>\n<p>方法名称</p>\n</li>\n<li>\n<p>方法的返回类型(或 void)</p>\n</li>\n<li>\n<p>方法参数的数量和类型(按顺序)</p>\n</li>\n<li>\n<p>方法的修饰符(public, private, protected, static, final, synchronized, native, abstract的一个子集)</p>\n</li>\n<li>\n<p>方法的字节码(bytecodes)、操作数栈、局部变量表及大小 （abstract和native方法除外）</p>\n</li>\n<li>\n<p>异常表（abstract和native方法除外）</p>\n<ul>\n<li>每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>non-final的类变量</p>\n</li>\n<li>\n<p>运行时常量池</p>\n</li>\n</ul>\n<p><strong>在HotSpot中jdk1.8之前也被称为永久代 在jdk7后将永久代的功能转移到元空间</strong></p>\n<p><strong>元空间默认初始大小20m</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-XX:MaxMetaspaceSize 设置元空间最大值，默认为-1 不受限制或者说收本地内存限制</span><br><span class=\"line\">-XX:MetaspaceSize 设置元空间初始空间大小 以字节为单位，达到该值会触发垃圾收集进行类型卸载，同事收集器会对该值进行调整，如果释放大量空间则适当降低该值，如果释放很少空间，那么在不超过最大值情况下适当提高。</span><br><span class=\"line\">-MinMetaspaceFreeRatio：在垃圾收集后控制最小的元空间剩余容量的百分比，可减少因元空间不足导致垃圾收集的频率</span><br><span class=\"line\">-MinMetaspaceFreeRatio：用于控制最大的元空间剩余容量的百分比</span><br></pre></td></tr></table></figure>\n<h4 id=\"运行时常量池\">运行时常量池</h4>\n<blockquote>\n<p>方法区的一部分，用于存放编译期产生的各种字面量和符号引用<br>\n<strong>给基本类型变量赋值的方式就叫做字面量或者字面值</strong></p>\n</blockquote>\n<p><strong>注： 字符串常量池在堆中</strong></p>\n<h3 id=\"直接内存-非本地内存\">直接内存(非本地内存)</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-XX:MaxDirectMemorySize 设置字节内存大小 如果不进行设置则与java堆的最大值一致</span><br></pre></td></tr></table></figure>\n<h2 id=\"\"></h2>\n","excerpt":"","more":"<h1>虚拟机运行时数据区域</h1>\n<h2 id=\"运行时数据区域\">运行时数据区域</h2>\n<p>​<img src=\"/assets/image-20231119154230-3g5nidd.png\" alt=\"图像\"></p>\n<p>​​<img src=\"/assets/image-20231119154304-hwfdw8h.jpeg\" alt=\"图像\">​</p>\n<h3 id=\"程序计数器\">程序计数器</h3>\n<blockquote>\n<p>通过改变这个计数器 的值来选取下一条需要执行的字节码指令</p>\n</blockquote>\n<p>java 虚拟机的多线程是通过线程轮流切换、分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器只会执行一条线程中的指令，为了线程切换后能恢复到正确的执行位置，每条线程都需要一个独立的程序计数器。<br>\n每个线程都会有属于自己独立的线程计数器，各线程之间计数器不会相互影响，独立存储，这些区域成为线程私有。</p>\n<h3 id=\"Java虚拟机栈\">Java虚拟机栈</h3>\n<blockquote>\n<p>Java方法执行的线程内存模型</p>\n</blockquote>\n<p>每个方法被执行，Java虚拟机栈会创建一个栈帧<a href=\"https://www.yuque.com/pride_yang/blog/gngtxy\">(1)</a>，用于存储局部变量表，操作数栈，方法出口，动态链接等信息。<br>\n一个方法的执行对应着一个栈帧的入栈与出栈过程。</p>\n<p>局部变量存储存放编译期间可知java虚拟机的基础类型（boolean，byte，char、short、int、float、dubbo、long）、对象引用（reference类型）、和returnAddress类型（指向一条字节码指令的地址）。</p>\n<p>局部变量表的存储单位是局部<strong>变量槽（slot）</strong>  其中64位长度的long和 double类型的数据会占用两个变量槽，其余的数据类型只占用一个 （一个变量槽的内存占用空间由虚拟机自行决定） 。</p>\n<p>当进入一个方法后，栈帧中需要分配多大的局部变量空间已经固定（变量槽数量）<br>\n《Java虚拟机规范》中  规定如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常，当栈扩展时无法申请到足够的内存会抛出OutOfMemoryError异常。</p>\n<h3 id=\"本地方法栈\">本地方法栈</h3>\n<blockquote>\n<p>为虚拟机使用到的 Native 方法服务 （一个 Native Method 就是一个 java 调用非 java 代码的接口）</p>\n</blockquote>\n<p><strong>HotSpot栈内存不允许动态扩容</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-Xss 设置栈容量 jdk11 windows最小值 180k Linux最小值228k 否则启动时会出现提示</span><br></pre></td></tr></table></figure>\n<h3 id=\"Java堆\">Java堆</h3>\n<blockquote>\n<p>被所有线程共享，在虚拟机启动时创建，用于存放对象实例。</p>\n</blockquote>\n<ul>\n<li>java堆是垃圾收集器管理的内存区域，也被成为GC堆。G1收集器出现之前，垃圾收集器一般基于分代收集理论设计，但是之后出现了一些不采用分代设计的垃圾收集器。所以收集器不一定存在新生代，老年代，永久代，Eden区，From Survivor区，To Survivor区等。</li>\n<li>从内存角度看，所有线程共享的java堆可以划分为多个私有进程的分配缓存区（TLAB），以提升对象分配时的效率。</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-Xmx 堆最大值</span><br><span class=\"line\">-Xms 堆最小值</span><br><span class=\"line\">-XX:+HeapDumpOnOutOfMemoryError 发生OOM时产生dump内存堆转储快照</span><br><span class=\"line\">-XX:HeapDumpPath=./ 设置快照文件保存位置</span><br></pre></td></tr></table></figure>\n<h4 id=\"jvm堆的默认分配方案\">jvm堆的默认分配方案</h4>\n<p><img src=\"/assets/net-img-1646742883104-4eef3a95-3655-44f4-8887-2f5f1628732e-20230330213506-2xv20ln.png\" alt=\"\"><br>\n老年代 ： 三分之二的堆空间<br>\n年轻代 ： 三分之一的堆空间<br>\neden区： 8/10 的年轻代空间<br>\nsurvivor0 : 1/10 的年轻代空间<br>\nsurvivor1 : 1/10 的年轻代空间（from 区）</p>\n<p><strong>由于及时编译技术的进步，逃逸分析技术的日渐强大，栈上分配，标量替换等优化手段出现，对象实例也未必都全部分配在堆上。</strong></p>\n<p>从 jdk 1.7 开始已经默认开启逃逸分析，如果某些方法中的对象引用没有被返回或者未被外面使用（也就是未逃逸出去），那么对象可以直接在栈上分配内存。</p>\n<p>JDK8 后方法区（永生代）移除，用元空间代替，元空间使用直接内存</p>\n<h4 id=\"gc\">gc</h4>\n<h5 id=\"MinorGC触发机制\">MinorGC触发机制</h5>\n<ul>\n<li>当年轻代空间不足时，就会触发Minor GC。这里的年轻代满指的是Eden区满，Survivor满不会引发GC。（每次 Minor GC 会清理年轻代的内存。)</li>\n<li>因为 Java 对象大多都具备朝生夕灭的特性，所以 Minor GC 非常频繁，一般回收速度也比较快。这一定义既清晰又易于理解。</li>\n<li>Minor GC会引发STW，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行。</li>\n</ul>\n<h5 id=\"MajorGC触发机制\">MajorGC触发机制</h5>\n<ul>\n<li>\n<p>指发生在老年代的GC，对象从老年代消失时，我们说“Major GC”或“Full GC”发生了。</p>\n<ul>\n<li>出现了Major GC，经常会伴随至少一次的Minor GC（但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程）。</li>\n<li>也就是在老年代空间不足时，会先尝试触发Minor GC。如果之后空间还不足，则触发Major GC</li>\n</ul>\n</li>\n<li>\n<p>Major GC的速度一般会比Minor GC慢10倍以上，STW的时间更长。</p>\n</li>\n<li>\n<p>如果Major GC 后，内存还不足，就报OOM了。</p>\n</li>\n</ul>\n<h5 id=\"FullGC触发机制\">FullGC触发机制</h5>\n<ul>\n<li>调用System.gc()时，系统建议执行Full GC，但是不必然执行</li>\n<li>老年代空间不足</li>\n<li>方法区空间不足</li>\n<li>通过Minor GC后进入老年代的平均大小大于老年代的可用内存</li>\n<li>由Eden区、survivor space0（From Space）区向survivor space1（To Space）区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小</li>\n</ul>\n<h3 id=\"方法区（元空间）\">方法区（元空间）</h3>\n<blockquote>\n<p>主要用于存储被虚拟机加载的类型信息、常量、静态变量、及时编译器编译后的代码缓存等数据</p>\n</blockquote>\n<h4 id=\"存储内容\">存储内容</h4>\n<ul>\n<li>\n<p>类型信息</p>\n</li>\n<li>\n<p>域信息</p>\n<ul>\n<li>域名称，域类型，域修饰符（public, private, protected, static, final, volatile, transient的某个子集）</li>\n</ul>\n</li>\n<li>\n<p>方法信息</p>\n<ul>\n<li>\n<p>方法名称</p>\n</li>\n<li>\n<p>方法的返回类型(或 void)</p>\n</li>\n<li>\n<p>方法参数的数量和类型(按顺序)</p>\n</li>\n<li>\n<p>方法的修饰符(public, private, protected, static, final, synchronized, native, abstract的一个子集)</p>\n</li>\n<li>\n<p>方法的字节码(bytecodes)、操作数栈、局部变量表及大小 （abstract和native方法除外）</p>\n</li>\n<li>\n<p>异常表（abstract和native方法除外）</p>\n<ul>\n<li>每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>non-final的类变量</p>\n</li>\n<li>\n<p>运行时常量池</p>\n</li>\n</ul>\n<p><strong>在HotSpot中jdk1.8之前也被称为永久代 在jdk7后将永久代的功能转移到元空间</strong></p>\n<p><strong>元空间默认初始大小20m</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-XX:MaxMetaspaceSize 设置元空间最大值，默认为-1 不受限制或者说收本地内存限制</span><br><span class=\"line\">-XX:MetaspaceSize 设置元空间初始空间大小 以字节为单位，达到该值会触发垃圾收集进行类型卸载，同事收集器会对该值进行调整，如果释放大量空间则适当降低该值，如果释放很少空间，那么在不超过最大值情况下适当提高。</span><br><span class=\"line\">-MinMetaspaceFreeRatio：在垃圾收集后控制最小的元空间剩余容量的百分比，可减少因元空间不足导致垃圾收集的频率</span><br><span class=\"line\">-MinMetaspaceFreeRatio：用于控制最大的元空间剩余容量的百分比</span><br></pre></td></tr></table></figure>\n<h4 id=\"运行时常量池\">运行时常量池</h4>\n<blockquote>\n<p>方法区的一部分，用于存放编译期产生的各种字面量和符号引用<br>\n<strong>给基本类型变量赋值的方式就叫做字面量或者字面值</strong></p>\n</blockquote>\n<p><strong>注： 字符串常量池在堆中</strong></p>\n<h3 id=\"直接内存-非本地内存\">直接内存(非本地内存)</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-XX:MaxDirectMemorySize 设置字节内存大小 如果不进行设置则与java堆的最大值一致</span><br></pre></td></tr></table></figure>\n<h2 id=\"\"></h2>\n"},{"title":"Filter拦截器","date":"2022-10-30T05:27:28.000Z","lastmod":"2022-10-30T05:27:28.000Z","_content":"\n# Filter拦截器\n\n### 如何实现拦截\n\n　　实现Filter接口，重写doFilter方法。\n\n#### doFilter方法有三个传入参数\n\n- ServletRequest：对于简单的过滤器，大多数过滤逻辑是基于这个对象的。如果处理HTTP请求，并且需要访问诸如getHeader或getCookies等在ServletRequest中无法得到的方法，就要把此对象构造成 HttpServletRequest。\n- ServletResponse：除了在两个情形下要使用它以外，通常忽略这个参数。\n  - 首先，如果希望完全阻塞对相关 servlet或JSP页面的访问。可调用response.getWriter并直接发送一个响应到客户机。\n  - 其次，如果希望修改相关的servlet或 JSP页面的输出，可把响应包含在一个收集所有发送到它的输出的对象中。然后，在调用serlvet或JSP页面后，过滤器可检查输出，如果合适就修改 它，之后发送到客户机。\n- FilterChain：对此对象调用doFilter以激活与servlet或JSP页面相关的下一个过滤器。如果没有另一个相关的过滤器，则对doFilter的调用激活servlet或JSP本身\n","source":"_posts/java/JavaWeb/Filter拦截器.md","raw":"---\ntitle: Filter拦截器\ndate: 2022-10-30T13:27:28Z\nlastmod: 2022-10-30T13:27:28Z\n---\n\n# Filter拦截器\n\n### 如何实现拦截\n\n　　实现Filter接口，重写doFilter方法。\n\n#### doFilter方法有三个传入参数\n\n- ServletRequest：对于简单的过滤器，大多数过滤逻辑是基于这个对象的。如果处理HTTP请求，并且需要访问诸如getHeader或getCookies等在ServletRequest中无法得到的方法，就要把此对象构造成 HttpServletRequest。\n- ServletResponse：除了在两个情形下要使用它以外，通常忽略这个参数。\n  - 首先，如果希望完全阻塞对相关 servlet或JSP页面的访问。可调用response.getWriter并直接发送一个响应到客户机。\n  - 其次，如果希望修改相关的servlet或 JSP页面的输出，可把响应包含在一个收集所有发送到它的输出的对象中。然后，在调用serlvet或JSP页面后，过滤器可检查输出，如果合适就修改 它，之后发送到客户机。\n- FilterChain：对此对象调用doFilter以激活与servlet或JSP页面相关的下一个过滤器。如果没有另一个相关的过滤器，则对doFilter的调用激活servlet或JSP本身\n","slug":"java-JavaWeb-Filter拦截器","published":1,"updated":"2025-04-22T02:21:59.463Z","comments":1,"layout":"post","photos":[],"_id":"cm9s3f40m0032bfg40x2w6zz5","content":"<h1>Filter拦截器</h1>\n<h3 id=\"如何实现拦截\">如何实现拦截</h3>\n<p>实现Filter接口，重写doFilter方法。</p>\n<h4 id=\"doFilter方法有三个传入参数\">doFilter方法有三个传入参数</h4>\n<ul>\n<li>ServletRequest：对于简单的过滤器，大多数过滤逻辑是基于这个对象的。如果处理HTTP请求，并且需要访问诸如getHeader或getCookies等在ServletRequest中无法得到的方法，就要把此对象构造成 HttpServletRequest。</li>\n<li>ServletResponse：除了在两个情形下要使用它以外，通常忽略这个参数。\n<ul>\n<li>首先，如果希望完全阻塞对相关 servlet或JSP页面的访问。可调用response.getWriter并直接发送一个响应到客户机。</li>\n<li>其次，如果希望修改相关的servlet或 JSP页面的输出，可把响应包含在一个收集所有发送到它的输出的对象中。然后，在调用serlvet或JSP页面后，过滤器可检查输出，如果合适就修改 它，之后发送到客户机。</li>\n</ul>\n</li>\n<li>FilterChain：对此对象调用doFilter以激活与servlet或JSP页面相关的下一个过滤器。如果没有另一个相关的过滤器，则对doFilter的调用激活servlet或JSP本身</li>\n</ul>\n","excerpt":"","more":"<h1>Filter拦截器</h1>\n<h3 id=\"如何实现拦截\">如何实现拦截</h3>\n<p>实现Filter接口，重写doFilter方法。</p>\n<h4 id=\"doFilter方法有三个传入参数\">doFilter方法有三个传入参数</h4>\n<ul>\n<li>ServletRequest：对于简单的过滤器，大多数过滤逻辑是基于这个对象的。如果处理HTTP请求，并且需要访问诸如getHeader或getCookies等在ServletRequest中无法得到的方法，就要把此对象构造成 HttpServletRequest。</li>\n<li>ServletResponse：除了在两个情形下要使用它以外，通常忽略这个参数。\n<ul>\n<li>首先，如果希望完全阻塞对相关 servlet或JSP页面的访问。可调用response.getWriter并直接发送一个响应到客户机。</li>\n<li>其次，如果希望修改相关的servlet或 JSP页面的输出，可把响应包含在一个收集所有发送到它的输出的对象中。然后，在调用serlvet或JSP页面后，过滤器可检查输出，如果合适就修改 它，之后发送到客户机。</li>\n</ul>\n</li>\n<li>FilterChain：对此对象调用doFilter以激活与servlet或JSP页面相关的下一个过滤器。如果没有另一个相关的过滤器，则对doFilter的调用激活servlet或JSP本身</li>\n</ul>\n"},{"title":"并发锁","date":"2023-05-14T14:53:28.000Z","lastmod":"2023-05-27T07:18:35.000Z","_content":"\n# 并发锁\n\n　　根据分类标准我们把锁分为以下 7 大类别，分别是：\n\n* 偏向锁/轻量级锁/重量级锁：这三种锁特指 synchronized 锁的状态，通过在对象头中的 mark word 来表明锁的状态。\n\n  * 偏向锁\n\n    * 如果自始至终，对于这把锁都不存在竞争，那么其实就没必要上锁，只需要打个标记就行了，这就是偏向锁的思想。一个对象被初始化后，还没有任何线程来获取它的锁时，那么它就是可偏向的，当有第一个线程来访问它并尝试获取锁的时候，它就将这个线程记录下来，以后如果尝试获取锁的线程正是偏向锁的拥有者，就可以直接获得锁，开销很小，性能最好。\n  * 重量级锁\n\n    * 重量级锁是互斥锁，它是利用操作系统的同步机制实现的，所以开销相对比较大。当多个线程直接有实际竞争，且锁竞争时间长的时候，轻量级锁不能满足需求，锁就会膨胀为重量级锁。重量级锁会让其他申请却拿不到锁的线程进入阻塞状态。\n  * 轻量级锁\n\n    * JVM 开发者发现在很多情况下，synchronized 中的代码是被多个线程交替执行的，而不是同时执行的，也就是说并不存在实际的竞争，或者是只有短时间的锁竞争，用 CAS 就可以解决，这种情况下，用完全互斥的重量级锁是没必要的。轻量级锁是指当锁原来是偏向锁的时候，被另一个线程访问，说明存在竞争，那么偏向锁就会升级为轻量级锁，线程会通过自旋的形式尝试获取锁，而不会陷入阻塞。\n* 可重入锁/非可重入锁；\n\n  * 不可重入锁：线程当前持有了这把锁，但是如果想再次获取这把锁，也必须要先释放锁后才能再次尝试获取。\n  * 可重入锁：线程当前已经持有这把锁了，能在不释放这把锁的情况下，再次获取这把锁。\n* 共享锁/独占锁；\n\n  * 共享锁：同一把锁可以被多个线程同时获得，\n  * 独占锁：锁只能同时被一个线程获得。\n* 公平锁/非公平锁；\n\n  * 公平锁的公平的含义在于如果线程现在拿不到这把锁，那么线程就都会进入等待，开始排队，在等待队列里等待时间长的线程会优先拿到这把锁，有先来先得的意思。\n  * 非公平锁就不那么“完美”了，它会在一定情况下，忽略掉已经在排队的线程，发生插队现象。\n* 悲观锁/乐观锁；\n\n  * 悲观锁的概念是在获取资源之前，必须先拿到锁，以便达到“独占”的状态，当前线程在操作资源的时候，其他线程由于不能拿到锁，所以其他线程不能来影响我。\n  * 乐观锁恰恰相反，它并不要求在获取资源前拿到锁，也不会锁住资源；相反，乐观锁利用 CAS 理念，在不独占资源的情况下，完成了对资源的修改。\n* 自旋锁/非自旋锁；\n\n  * 自旋锁的理念是如果线程现在拿不到锁，并不直接陷入阻塞或者释放 CPU 资源，而是开始利用循环，不停地尝试获取锁，这个循环过程被形象地比喻为“自旋”，就像是线程在“自我旋转”。\n  * 非自旋锁的理念就是没有自旋的过程，如果拿不到锁就直接放弃，或者进行其他的处理逻辑，例如去排队、陷入阻塞等。\n* 可中断锁/不可中断锁。\n\n  * 在 Java 中，synchronized 关键字修饰的锁代表的是不可中断锁，一旦线程申请了锁，就没有回头路了，只能等到拿到锁以后才能进行其他的逻辑处理。而我们的 ReentrantLock 是一种典型的可中断锁，例如使用 lockInterruptibly 方法在获取锁的过程中，突然不想获取了，那么也可以在中断之后去做其他的事情，不需要一直傻等到获取到锁才离开。\n\n## Synchronized\n\n### 原理:\n\n　　每个对象都有一个monitor锁，当一个monitor被线程持有后会处于锁定状态，使用的是monitorenter和monitorexit指令，其中monitorenter指令指向同步代码块的开始位置，monitorexit指令则指明同步代码块的结束位置。当执行monitorenter指令时，monitor计数器加一，取锁成功，当monitor的计数器为0时释放锁。\n\n　　Synchronized方法锁为该方法所在的对象本身，静态Synchronized方法从Class对象获取\n\n　　**Synchronized是可重入锁**\n\n　　当一个线程请求方法时，会去检查锁状态，如果锁状态是0，代表该锁没有被占用，直接进行CAS操作获取锁，将线程ID替换成自己的线程ID。如果锁状态不是0，代表有线程在访问该方法。此时，如果线程ID是自己的线程ID，如果是可重入锁，会将status自增1，然后获取到该锁，进而执行相应的方法。如果是非重入锁，就会进入阻塞队列等待。释放锁时，可重入锁，每一次退出方法，就会将status减1，直至status的值为0，最后释放该锁。释放锁时，非可重入锁，线程退出方法，直接就会释放该锁。\n\n### 对象的内存布局\n\n　　**jvm默认开启class pointer压缩 为4字节**  \n普通对象 markword 默认八个字节 instance data 若属性则为零 padding 补足被8整除  \n​![image.png](/assets/net-img-1615611389351-2cfaa4d5-b52c-4a2e-a170-c32ce97d17a6-20221030135532-u420fpk.png)  \n数组对象  \n​![image.png](/assets/net-img-1615611419969-14ba7126-9f92-482c-a851-9898cece7e8f-20221030135532-6itdbiz.png)​\n\n### 实现\n\n　　MONITORENTER 进入锁\nMONITOREXIT 退出锁\n在jvm执行过程中实现锁升级\n\n### 锁升级\n\n|锁状态||25位||31位|||1位|4bit|1bit（偏向锁位）|2bit锁标志||\n| --------------| -| -----------------------------| -| ----------------------| -| -----| ------| --------| ----------------| ----------| -|\n|无锁（new）||unused||　hashcode（如果调用）|||unused|分代年龄|0|0|1|\n|||||||||||||\n|锁状态||54位||||2位|1位|4bit|1bit（偏向锁位）|2bit锁标志||\n|偏向锁||当前线程指针||||Epoch|unused|分代年龄|1|0|1|\n|||||||||||||\n|锁状态||62位||||||||2bit锁标志||\n|轻量锁，自旋锁||指向线程栈中Lock Record的指针||||||||0|0|\n|重量级锁||指向互斥量（重量级锁）的指针||||||||1|0|\n|GC标记信息||CMS过程中用到的标记信息||||||||1|1|\n\n![image.png](/assets/net-img-1615614053644-2e45ea92-d426-42ca-a609-91b095ff7e83-20221030135532-iwc3p25.png)\n\n#### 锁升级流程(hashcode存储到Lock Record)\n\n1. 先new一个对象\n2. 若有一个线程进入，将线程id放入对象头中（偏向锁）\n3. 若再来一个线程，将使用CAS进行锁竞争，并这小偏向锁标识（自旋锁）（CAS等待自旋会消耗CPU）\n4. jdk1.6之前为自旋10次货自旋线程大于CPU核心的一半则进入重量锁 之后则为jvm自适应锁\n\n　　为何要升级到重量锁：升级重量锁后，其他线程进入等待状态，不消耗CPU，但是申请重量锁需要与内核打交道，会消耗资源。\n\n#### 锁粗化\n\n　　jvm检测到一连串操作都对同一对象加锁，此时jvm就会将锁范围加到一连串操作的外围（比如for循环append）\n\n#### 锁消除\n\n　　一个资源为非共享资源，jvm会自动把锁去除（比如只在一个方法内使用StringBuffer的append方法）\n\n## 显式锁\n\n​![1-12.png](/assets/net-img-1582875478351-18a69ed7-cb09-4a5a-a020-097490219718-20221030135517-0h9pq4n.png)​\n\n```\nLock和ReadWriteLock是两大锁的根接口\nLock 接口支持重入、公平等的锁规则：实现类 ReentrantLock、ReadLock和WriteLock。\nReadWriteLock 接口定义读取者共享而写入者独占的锁，实现类：ReentrantReadWriteLock。\n```\n\n### Lock 类\n\n#### ReentrantLock\n\n　　ReentrantLock方法：\n\n```java\n\t//传入boolean值,true时create一个公平锁，false为非公平锁\n        ReentrantLock(boolean fair) \n  \n\t//查看有多少线程等待锁\n\tint getQueueLength()\n\n\t//是否有线程等待抢锁\n\tboolean hasQueuedThreads()\n\n\t//是否有指定线程等待抢锁\n\tboolean hasQueuedThread(Thread thread)\n\n\t//当前线程是否抢到锁。返回0代表没有\n\tint getHoldCount()\n\n\t//查询此锁是否由任何线程持有\n\tboolean isLocked()\n\t \n\t //是否为公平锁\n\tboolean isFair() \n\n```\n\n　　Condition 方法：\n\n```java\npublic interface Condition {\n\t/**\n\t*Condition线程进入阻塞状态,调用signal()或者signalAll()再次唤醒，\n\t*允许中断如果在阻塞时锁持有线程中断，会抛出异常；\n\t*重要一点是：在当前持有Lock的线程中，当外部调用会await()后，ReentrantLock就允许其他线程来抢夺锁当前锁，\n\t*注意：通过创建Condition对象来使线程wait，必须先执行lock.lock方法获得锁\n\t*/\n    void await() throws InterruptedException;\n\n    //Condition线程进入阻塞状态,调用signal()或者signalAll()再次唤醒，不允许中断，如果在阻塞时锁持有线程中断，继续等待唤醒\n    void awaitUninterruptibly();\n\n    //设置阻塞时间，超时继续，超时时间单位为纳秒，其他同await()；返回时间大于零，表示是被唤醒，等待时间并且可以作为等待时间期望值，小于零表示超时\n    long awaitNanos(long nanosTimeout) throws InterruptedException;\n\n\t//类似awaitNanos(long nanosTimeout);返回值：被唤醒true，超时false\n    boolean await(long time, TimeUnit unit) throws InterruptedException;\n\n   //类似await(long time, TimeUnit unit) \n    boolean awaitUntil(Date deadline) throws InterruptedException;\n\n   //唤醒指定线程\n    void signal();\n\n    //唤醒全部线程\n    void signalAll();\n}\n\n```\n\n> Condition是Lock上的一个条件，可以多次newCondition()获得多个条件，Condition可用于线程间通信，通过Condition能够更加精细的控制多线程的休眠与唤醒\n\n> ReentrantLock.Condition线程通信注意点：  \n> \t1. 使用**ReentrantLock.Condition的signal()、await()、signalAll()方法使用之前必须要先进行lock()操作**[记得unlock()]，类似使用Object的notify()、wait()、notifyAll()之前必须要对Object对象进行synchronized操作；否则就会抛IllegalMonitorStateException；  \n> \t2. 注意在使用**ReentrantLock.Condition中使用signal()、await()、signalAll()方法，不能和Object的notify()、wait()、notifyAll()方法混用，否则抛出IllegalMonitorStateException`;\n\n#### ReentrantReadWriteLock\n\n##### 读写锁的实现分析\n\n　　读写锁因为也是维护一个整数状态(volatile修饰)，但是因为是一个整数，需要保证读写，两种状态，所以对32位整型进行了高16位和低16位的设计，其中高16为代表读锁，低16为代表写锁。\n\n* 写锁的获取与释放  \n          写锁是一个可重入的锁，允许同一个线程重复获取锁，所以在获取锁的逻辑中会进行是否当前线程以及是否有其他读线程的状态判断。如果当前线程在获取写锁时，读锁已经被获取(读状态不为0)，或者该线程不是已经获得了写锁的线程，则当前线程进入等待状态。  \n  写锁的释放和ReentrantLock的释放很像，当释放锁时，需要对状态递减一，并且前一次写线程修改对后续读线程可见。\n\n* 读锁的获取与释放  \n         读锁是一个可重入锁，在没有其他写线程时，读锁总是可以成功的获取，安全地进行状态加1。state这个值可以判断整个读锁被获得了多少次，而每个线程获取读锁的次数，是存储在ThreadLocal中的。  \n  读锁的每次释放均线程安全的减少读状态\n\n##### 锁降级\n\n　　锁降级指的是一个线程先拥有写锁，然后拥有读锁，在对数据处理完成后，释放写锁，此时该线程所持有的锁是读锁，从写锁降级为读锁。\n\n## 自旋锁\n\n### CAS （Compare and Swap（比较与交换））\n\n　　CAS是实现自旋锁的基础\n\n　　CAS的原理：\n\n　　\t线程从内存中取值i 赋值给k 对k进行运算，运算完毕后与内存中的i值进行比较，若相等证明无线程修改i ，结果正确，更新结果值。若不相等则证明有其他线程修改过该值，结果不正确进行重试。\n\n　　‍\n\n### 自旋锁\n\n> 自旋锁和非自旋锁的获取锁的过程。\n\n​![image](/assets/image-20230527140729-waan312.png)​\n\n　　自旋锁，它并不会放弃  CPU  时间片，而是通过自旋等待锁的释放，也就是说，它会不停地再次地尝试获取锁，如果失败就再次尝试，直到成功为止。\n\n　　非自旋锁，如果它发现此时获取不到锁，它就把自己的线程切换状态，让线程休眠，然后 CPU 就可以在这段时间去做很多其他的事情，直到之前持有这把锁的线程释放了锁，于是 CPU 再把之前的线程恢复回来，让这个线程再去尝试获取这把锁。如果再次失败，就再次让线程休眠，如果成功，一样可以成功获取到同步资源的锁。\n\n* 优点\n\n  * 自旋锁用循环去不停地尝试获取锁，让线程始终处于 Runnable 状态，节省了线程状态切换带来的开销。\n\n* 缺点\n\n  * 虽然避免了线程切换的开销，但是它在避免线程切换开销的同时也带来了新的开销，因为它需要不停得去尝试获取锁。如果这把锁一直不能被释放，那么这种尝试只是无用的尝试，会白白浪费处理器资源。也就是说，虽然一开始自旋锁的开销低于线程切换，但是随着时间的增加，这种开销也是水涨船高，后期甚至会超过线程切换的开销，得不偿失。\n\n### 注意事项\n\n　　‍\n\n　　**虽然避免了线程切换的开销，但是它在避免线程切换开销的同时也带来了新的开销，因为它需要不停得去尝试获取锁。如果这把锁一直不能被释放，那么这种尝试只是无用的尝试，会白白浪费处理器资源。**\n\n　　**ABA问题**\n\n### 适应场景\n\n　　适用于并发度不是特别高的场景，以及临界区比较短小的情况，这样我们可以利用避免线程切换来提高效率。如果临界区很大，线程一旦拿到锁，很久才会释放的话，那就不合适用自旋锁，因为自旋会一直占用 CPU 却无法拿到锁，白白消耗资源。\n\n　　‍\n\n　　‍\n\n　　‍\n\n　　‍\n\n　　‍\n\n　　‍\n\n　　‍\n\n　　‍\n\n　　‍\n\n## 问题\n\n### Synchronized 和 Lock 区别\n\n```\nsynchronized是java内置关键字，在jvm层面，Lock是个java类；\nsynchronized无法判断是否获取锁的状态，Lock可以判断是否获取到锁；\nsynchronized会自动释放锁(a 线程执行完同步代码会释放锁 ；b 线程执行过程中发生异常会释放锁)，Lock需在finally中手工释放锁（unlock()方法释放锁），否则容易造成线程死锁；\n用synchronized关键字的两个线程1和线程2，如果当前线程1获得锁，线程2线程等待。如果线程1阻塞，线程2则会一直等待下去，而Lock锁就不一定会等待下去，如果尝试获取不到锁，线程可以不用一直等待就结束了；\nsynchronized的锁可重入、不可中断、非公平，而Lock锁可重入、可判断、可公平（两者皆可）\nLock锁适合大量同步的代码的同步问题，synchronized锁适合代码少量的同步问题。\n```\n\n　　‍\n","source":"_posts/java/thread/并发锁.md","raw":"---\ntitle: 并发锁\ndate: 2023-05-14T22:53:28Z\nlastmod: 2023-05-27T15:18:35Z\n---\n\n# 并发锁\n\n　　根据分类标准我们把锁分为以下 7 大类别，分别是：\n\n* 偏向锁/轻量级锁/重量级锁：这三种锁特指 synchronized 锁的状态，通过在对象头中的 mark word 来表明锁的状态。\n\n  * 偏向锁\n\n    * 如果自始至终，对于这把锁都不存在竞争，那么其实就没必要上锁，只需要打个标记就行了，这就是偏向锁的思想。一个对象被初始化后，还没有任何线程来获取它的锁时，那么它就是可偏向的，当有第一个线程来访问它并尝试获取锁的时候，它就将这个线程记录下来，以后如果尝试获取锁的线程正是偏向锁的拥有者，就可以直接获得锁，开销很小，性能最好。\n  * 重量级锁\n\n    * 重量级锁是互斥锁，它是利用操作系统的同步机制实现的，所以开销相对比较大。当多个线程直接有实际竞争，且锁竞争时间长的时候，轻量级锁不能满足需求，锁就会膨胀为重量级锁。重量级锁会让其他申请却拿不到锁的线程进入阻塞状态。\n  * 轻量级锁\n\n    * JVM 开发者发现在很多情况下，synchronized 中的代码是被多个线程交替执行的，而不是同时执行的，也就是说并不存在实际的竞争，或者是只有短时间的锁竞争，用 CAS 就可以解决，这种情况下，用完全互斥的重量级锁是没必要的。轻量级锁是指当锁原来是偏向锁的时候，被另一个线程访问，说明存在竞争，那么偏向锁就会升级为轻量级锁，线程会通过自旋的形式尝试获取锁，而不会陷入阻塞。\n* 可重入锁/非可重入锁；\n\n  * 不可重入锁：线程当前持有了这把锁，但是如果想再次获取这把锁，也必须要先释放锁后才能再次尝试获取。\n  * 可重入锁：线程当前已经持有这把锁了，能在不释放这把锁的情况下，再次获取这把锁。\n* 共享锁/独占锁；\n\n  * 共享锁：同一把锁可以被多个线程同时获得，\n  * 独占锁：锁只能同时被一个线程获得。\n* 公平锁/非公平锁；\n\n  * 公平锁的公平的含义在于如果线程现在拿不到这把锁，那么线程就都会进入等待，开始排队，在等待队列里等待时间长的线程会优先拿到这把锁，有先来先得的意思。\n  * 非公平锁就不那么“完美”了，它会在一定情况下，忽略掉已经在排队的线程，发生插队现象。\n* 悲观锁/乐观锁；\n\n  * 悲观锁的概念是在获取资源之前，必须先拿到锁，以便达到“独占”的状态，当前线程在操作资源的时候，其他线程由于不能拿到锁，所以其他线程不能来影响我。\n  * 乐观锁恰恰相反，它并不要求在获取资源前拿到锁，也不会锁住资源；相反，乐观锁利用 CAS 理念，在不独占资源的情况下，完成了对资源的修改。\n* 自旋锁/非自旋锁；\n\n  * 自旋锁的理念是如果线程现在拿不到锁，并不直接陷入阻塞或者释放 CPU 资源，而是开始利用循环，不停地尝试获取锁，这个循环过程被形象地比喻为“自旋”，就像是线程在“自我旋转”。\n  * 非自旋锁的理念就是没有自旋的过程，如果拿不到锁就直接放弃，或者进行其他的处理逻辑，例如去排队、陷入阻塞等。\n* 可中断锁/不可中断锁。\n\n  * 在 Java 中，synchronized 关键字修饰的锁代表的是不可中断锁，一旦线程申请了锁，就没有回头路了，只能等到拿到锁以后才能进行其他的逻辑处理。而我们的 ReentrantLock 是一种典型的可中断锁，例如使用 lockInterruptibly 方法在获取锁的过程中，突然不想获取了，那么也可以在中断之后去做其他的事情，不需要一直傻等到获取到锁才离开。\n\n## Synchronized\n\n### 原理:\n\n　　每个对象都有一个monitor锁，当一个monitor被线程持有后会处于锁定状态，使用的是monitorenter和monitorexit指令，其中monitorenter指令指向同步代码块的开始位置，monitorexit指令则指明同步代码块的结束位置。当执行monitorenter指令时，monitor计数器加一，取锁成功，当monitor的计数器为0时释放锁。\n\n　　Synchronized方法锁为该方法所在的对象本身，静态Synchronized方法从Class对象获取\n\n　　**Synchronized是可重入锁**\n\n　　当一个线程请求方法时，会去检查锁状态，如果锁状态是0，代表该锁没有被占用，直接进行CAS操作获取锁，将线程ID替换成自己的线程ID。如果锁状态不是0，代表有线程在访问该方法。此时，如果线程ID是自己的线程ID，如果是可重入锁，会将status自增1，然后获取到该锁，进而执行相应的方法。如果是非重入锁，就会进入阻塞队列等待。释放锁时，可重入锁，每一次退出方法，就会将status减1，直至status的值为0，最后释放该锁。释放锁时，非可重入锁，线程退出方法，直接就会释放该锁。\n\n### 对象的内存布局\n\n　　**jvm默认开启class pointer压缩 为4字节**  \n普通对象 markword 默认八个字节 instance data 若属性则为零 padding 补足被8整除  \n​![image.png](/assets/net-img-1615611389351-2cfaa4d5-b52c-4a2e-a170-c32ce97d17a6-20221030135532-u420fpk.png)  \n数组对象  \n​![image.png](/assets/net-img-1615611419969-14ba7126-9f92-482c-a851-9898cece7e8f-20221030135532-6itdbiz.png)​\n\n### 实现\n\n　　MONITORENTER 进入锁\nMONITOREXIT 退出锁\n在jvm执行过程中实现锁升级\n\n### 锁升级\n\n|锁状态||25位||31位|||1位|4bit|1bit（偏向锁位）|2bit锁标志||\n| --------------| -| -----------------------------| -| ----------------------| -| -----| ------| --------| ----------------| ----------| -|\n|无锁（new）||unused||　hashcode（如果调用）|||unused|分代年龄|0|0|1|\n|||||||||||||\n|锁状态||54位||||2位|1位|4bit|1bit（偏向锁位）|2bit锁标志||\n|偏向锁||当前线程指针||||Epoch|unused|分代年龄|1|0|1|\n|||||||||||||\n|锁状态||62位||||||||2bit锁标志||\n|轻量锁，自旋锁||指向线程栈中Lock Record的指针||||||||0|0|\n|重量级锁||指向互斥量（重量级锁）的指针||||||||1|0|\n|GC标记信息||CMS过程中用到的标记信息||||||||1|1|\n\n![image.png](/assets/net-img-1615614053644-2e45ea92-d426-42ca-a609-91b095ff7e83-20221030135532-iwc3p25.png)\n\n#### 锁升级流程(hashcode存储到Lock Record)\n\n1. 先new一个对象\n2. 若有一个线程进入，将线程id放入对象头中（偏向锁）\n3. 若再来一个线程，将使用CAS进行锁竞争，并这小偏向锁标识（自旋锁）（CAS等待自旋会消耗CPU）\n4. jdk1.6之前为自旋10次货自旋线程大于CPU核心的一半则进入重量锁 之后则为jvm自适应锁\n\n　　为何要升级到重量锁：升级重量锁后，其他线程进入等待状态，不消耗CPU，但是申请重量锁需要与内核打交道，会消耗资源。\n\n#### 锁粗化\n\n　　jvm检测到一连串操作都对同一对象加锁，此时jvm就会将锁范围加到一连串操作的外围（比如for循环append）\n\n#### 锁消除\n\n　　一个资源为非共享资源，jvm会自动把锁去除（比如只在一个方法内使用StringBuffer的append方法）\n\n## 显式锁\n\n​![1-12.png](/assets/net-img-1582875478351-18a69ed7-cb09-4a5a-a020-097490219718-20221030135517-0h9pq4n.png)​\n\n```\nLock和ReadWriteLock是两大锁的根接口\nLock 接口支持重入、公平等的锁规则：实现类 ReentrantLock、ReadLock和WriteLock。\nReadWriteLock 接口定义读取者共享而写入者独占的锁，实现类：ReentrantReadWriteLock。\n```\n\n### Lock 类\n\n#### ReentrantLock\n\n　　ReentrantLock方法：\n\n```java\n\t//传入boolean值,true时create一个公平锁，false为非公平锁\n        ReentrantLock(boolean fair) \n  \n\t//查看有多少线程等待锁\n\tint getQueueLength()\n\n\t//是否有线程等待抢锁\n\tboolean hasQueuedThreads()\n\n\t//是否有指定线程等待抢锁\n\tboolean hasQueuedThread(Thread thread)\n\n\t//当前线程是否抢到锁。返回0代表没有\n\tint getHoldCount()\n\n\t//查询此锁是否由任何线程持有\n\tboolean isLocked()\n\t \n\t //是否为公平锁\n\tboolean isFair() \n\n```\n\n　　Condition 方法：\n\n```java\npublic interface Condition {\n\t/**\n\t*Condition线程进入阻塞状态,调用signal()或者signalAll()再次唤醒，\n\t*允许中断如果在阻塞时锁持有线程中断，会抛出异常；\n\t*重要一点是：在当前持有Lock的线程中，当外部调用会await()后，ReentrantLock就允许其他线程来抢夺锁当前锁，\n\t*注意：通过创建Condition对象来使线程wait，必须先执行lock.lock方法获得锁\n\t*/\n    void await() throws InterruptedException;\n\n    //Condition线程进入阻塞状态,调用signal()或者signalAll()再次唤醒，不允许中断，如果在阻塞时锁持有线程中断，继续等待唤醒\n    void awaitUninterruptibly();\n\n    //设置阻塞时间，超时继续，超时时间单位为纳秒，其他同await()；返回时间大于零，表示是被唤醒，等待时间并且可以作为等待时间期望值，小于零表示超时\n    long awaitNanos(long nanosTimeout) throws InterruptedException;\n\n\t//类似awaitNanos(long nanosTimeout);返回值：被唤醒true，超时false\n    boolean await(long time, TimeUnit unit) throws InterruptedException;\n\n   //类似await(long time, TimeUnit unit) \n    boolean awaitUntil(Date deadline) throws InterruptedException;\n\n   //唤醒指定线程\n    void signal();\n\n    //唤醒全部线程\n    void signalAll();\n}\n\n```\n\n> Condition是Lock上的一个条件，可以多次newCondition()获得多个条件，Condition可用于线程间通信，通过Condition能够更加精细的控制多线程的休眠与唤醒\n\n> ReentrantLock.Condition线程通信注意点：  \n> \t1. 使用**ReentrantLock.Condition的signal()、await()、signalAll()方法使用之前必须要先进行lock()操作**[记得unlock()]，类似使用Object的notify()、wait()、notifyAll()之前必须要对Object对象进行synchronized操作；否则就会抛IllegalMonitorStateException；  \n> \t2. 注意在使用**ReentrantLock.Condition中使用signal()、await()、signalAll()方法，不能和Object的notify()、wait()、notifyAll()方法混用，否则抛出IllegalMonitorStateException`;\n\n#### ReentrantReadWriteLock\n\n##### 读写锁的实现分析\n\n　　读写锁因为也是维护一个整数状态(volatile修饰)，但是因为是一个整数，需要保证读写，两种状态，所以对32位整型进行了高16位和低16位的设计，其中高16为代表读锁，低16为代表写锁。\n\n* 写锁的获取与释放  \n          写锁是一个可重入的锁，允许同一个线程重复获取锁，所以在获取锁的逻辑中会进行是否当前线程以及是否有其他读线程的状态判断。如果当前线程在获取写锁时，读锁已经被获取(读状态不为0)，或者该线程不是已经获得了写锁的线程，则当前线程进入等待状态。  \n  写锁的释放和ReentrantLock的释放很像，当释放锁时，需要对状态递减一，并且前一次写线程修改对后续读线程可见。\n\n* 读锁的获取与释放  \n         读锁是一个可重入锁，在没有其他写线程时，读锁总是可以成功的获取，安全地进行状态加1。state这个值可以判断整个读锁被获得了多少次，而每个线程获取读锁的次数，是存储在ThreadLocal中的。  \n  读锁的每次释放均线程安全的减少读状态\n\n##### 锁降级\n\n　　锁降级指的是一个线程先拥有写锁，然后拥有读锁，在对数据处理完成后，释放写锁，此时该线程所持有的锁是读锁，从写锁降级为读锁。\n\n## 自旋锁\n\n### CAS （Compare and Swap（比较与交换））\n\n　　CAS是实现自旋锁的基础\n\n　　CAS的原理：\n\n　　\t线程从内存中取值i 赋值给k 对k进行运算，运算完毕后与内存中的i值进行比较，若相等证明无线程修改i ，结果正确，更新结果值。若不相等则证明有其他线程修改过该值，结果不正确进行重试。\n\n　　‍\n\n### 自旋锁\n\n> 自旋锁和非自旋锁的获取锁的过程。\n\n​![image](/assets/image-20230527140729-waan312.png)​\n\n　　自旋锁，它并不会放弃  CPU  时间片，而是通过自旋等待锁的释放，也就是说，它会不停地再次地尝试获取锁，如果失败就再次尝试，直到成功为止。\n\n　　非自旋锁，如果它发现此时获取不到锁，它就把自己的线程切换状态，让线程休眠，然后 CPU 就可以在这段时间去做很多其他的事情，直到之前持有这把锁的线程释放了锁，于是 CPU 再把之前的线程恢复回来，让这个线程再去尝试获取这把锁。如果再次失败，就再次让线程休眠，如果成功，一样可以成功获取到同步资源的锁。\n\n* 优点\n\n  * 自旋锁用循环去不停地尝试获取锁，让线程始终处于 Runnable 状态，节省了线程状态切换带来的开销。\n\n* 缺点\n\n  * 虽然避免了线程切换的开销，但是它在避免线程切换开销的同时也带来了新的开销，因为它需要不停得去尝试获取锁。如果这把锁一直不能被释放，那么这种尝试只是无用的尝试，会白白浪费处理器资源。也就是说，虽然一开始自旋锁的开销低于线程切换，但是随着时间的增加，这种开销也是水涨船高，后期甚至会超过线程切换的开销，得不偿失。\n\n### 注意事项\n\n　　‍\n\n　　**虽然避免了线程切换的开销，但是它在避免线程切换开销的同时也带来了新的开销，因为它需要不停得去尝试获取锁。如果这把锁一直不能被释放，那么这种尝试只是无用的尝试，会白白浪费处理器资源。**\n\n　　**ABA问题**\n\n### 适应场景\n\n　　适用于并发度不是特别高的场景，以及临界区比较短小的情况，这样我们可以利用避免线程切换来提高效率。如果临界区很大，线程一旦拿到锁，很久才会释放的话，那就不合适用自旋锁，因为自旋会一直占用 CPU 却无法拿到锁，白白消耗资源。\n\n　　‍\n\n　　‍\n\n　　‍\n\n　　‍\n\n　　‍\n\n　　‍\n\n　　‍\n\n　　‍\n\n　　‍\n\n## 问题\n\n### Synchronized 和 Lock 区别\n\n```\nsynchronized是java内置关键字，在jvm层面，Lock是个java类；\nsynchronized无法判断是否获取锁的状态，Lock可以判断是否获取到锁；\nsynchronized会自动释放锁(a 线程执行完同步代码会释放锁 ；b 线程执行过程中发生异常会释放锁)，Lock需在finally中手工释放锁（unlock()方法释放锁），否则容易造成线程死锁；\n用synchronized关键字的两个线程1和线程2，如果当前线程1获得锁，线程2线程等待。如果线程1阻塞，线程2则会一直等待下去，而Lock锁就不一定会等待下去，如果尝试获取不到锁，线程可以不用一直等待就结束了；\nsynchronized的锁可重入、不可中断、非公平，而Lock锁可重入、可判断、可公平（两者皆可）\nLock锁适合大量同步的代码的同步问题，synchronized锁适合代码少量的同步问题。\n```\n\n　　‍\n","slug":"java-thread-并发锁","published":1,"updated":"2025-04-22T07:27:29.941Z","_id":"cm9s3f40n0033bfg4c8u83b89","comments":1,"layout":"post","photos":[],"content":"<h1>并发锁</h1>\n<p>根据分类标准我们把锁分为以下 7 大类别，分别是：</p>\n<ul>\n<li>\n<p>偏向锁/轻量级锁/重量级锁：这三种锁特指 synchronized 锁的状态，通过在对象头中的 mark word 来表明锁的状态。</p>\n<ul>\n<li>\n<p>偏向锁</p>\n<ul>\n<li>如果自始至终，对于这把锁都不存在竞争，那么其实就没必要上锁，只需要打个标记就行了，这就是偏向锁的思想。一个对象被初始化后，还没有任何线程来获取它的锁时，那么它就是可偏向的，当有第一个线程来访问它并尝试获取锁的时候，它就将这个线程记录下来，以后如果尝试获取锁的线程正是偏向锁的拥有者，就可以直接获得锁，开销很小，性能最好。</li>\n</ul>\n</li>\n<li>\n<p>重量级锁</p>\n<ul>\n<li>重量级锁是互斥锁，它是利用操作系统的同步机制实现的，所以开销相对比较大。当多个线程直接有实际竞争，且锁竞争时间长的时候，轻量级锁不能满足需求，锁就会膨胀为重量级锁。重量级锁会让其他申请却拿不到锁的线程进入阻塞状态。</li>\n</ul>\n</li>\n<li>\n<p>轻量级锁</p>\n<ul>\n<li>JVM 开发者发现在很多情况下，synchronized 中的代码是被多个线程交替执行的，而不是同时执行的，也就是说并不存在实际的竞争，或者是只有短时间的锁竞争，用 CAS 就可以解决，这种情况下，用完全互斥的重量级锁是没必要的。轻量级锁是指当锁原来是偏向锁的时候，被另一个线程访问，说明存在竞争，那么偏向锁就会升级为轻量级锁，线程会通过自旋的形式尝试获取锁，而不会陷入阻塞。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>可重入锁/非可重入锁；</p>\n<ul>\n<li>不可重入锁：线程当前持有了这把锁，但是如果想再次获取这把锁，也必须要先释放锁后才能再次尝试获取。</li>\n<li>可重入锁：线程当前已经持有这把锁了，能在不释放这把锁的情况下，再次获取这把锁。</li>\n</ul>\n</li>\n<li>\n<p>共享锁/独占锁；</p>\n<ul>\n<li>共享锁：同一把锁可以被多个线程同时获得，</li>\n<li>独占锁：锁只能同时被一个线程获得。</li>\n</ul>\n</li>\n<li>\n<p>公平锁/非公平锁；</p>\n<ul>\n<li>公平锁的公平的含义在于如果线程现在拿不到这把锁，那么线程就都会进入等待，开始排队，在等待队列里等待时间长的线程会优先拿到这把锁，有先来先得的意思。</li>\n<li>非公平锁就不那么“完美”了，它会在一定情况下，忽略掉已经在排队的线程，发生插队现象。</li>\n</ul>\n</li>\n<li>\n<p>悲观锁/乐观锁；</p>\n<ul>\n<li>悲观锁的概念是在获取资源之前，必须先拿到锁，以便达到“独占”的状态，当前线程在操作资源的时候，其他线程由于不能拿到锁，所以其他线程不能来影响我。</li>\n<li>乐观锁恰恰相反，它并不要求在获取资源前拿到锁，也不会锁住资源；相反，乐观锁利用 CAS 理念，在不独占资源的情况下，完成了对资源的修改。</li>\n</ul>\n</li>\n<li>\n<p>自旋锁/非自旋锁；</p>\n<ul>\n<li>自旋锁的理念是如果线程现在拿不到锁，并不直接陷入阻塞或者释放 CPU 资源，而是开始利用循环，不停地尝试获取锁，这个循环过程被形象地比喻为“自旋”，就像是线程在“自我旋转”。</li>\n<li>非自旋锁的理念就是没有自旋的过程，如果拿不到锁就直接放弃，或者进行其他的处理逻辑，例如去排队、陷入阻塞等。</li>\n</ul>\n</li>\n<li>\n<p>可中断锁/不可中断锁。</p>\n<ul>\n<li>在 Java 中，synchronized 关键字修饰的锁代表的是不可中断锁，一旦线程申请了锁，就没有回头路了，只能等到拿到锁以后才能进行其他的逻辑处理。而我们的 ReentrantLock 是一种典型的可中断锁，例如使用 lockInterruptibly 方法在获取锁的过程中，突然不想获取了，那么也可以在中断之后去做其他的事情，不需要一直傻等到获取到锁才离开。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Synchronized\">Synchronized</h2>\n<h3 id=\"原理\">原理:</h3>\n<p>每个对象都有一个monitor锁，当一个monitor被线程持有后会处于锁定状态，使用的是monitorenter和monitorexit指令，其中monitorenter指令指向同步代码块的开始位置，monitorexit指令则指明同步代码块的结束位置。当执行monitorenter指令时，monitor计数器加一，取锁成功，当monitor的计数器为0时释放锁。</p>\n<p>Synchronized方法锁为该方法所在的对象本身，静态Synchronized方法从Class对象获取</p>\n<p><strong>Synchronized是可重入锁</strong></p>\n<p>当一个线程请求方法时，会去检查锁状态，如果锁状态是0，代表该锁没有被占用，直接进行CAS操作获取锁，将线程ID替换成自己的线程ID。如果锁状态不是0，代表有线程在访问该方法。此时，如果线程ID是自己的线程ID，如果是可重入锁，会将status自增1，然后获取到该锁，进而执行相应的方法。如果是非重入锁，就会进入阻塞队列等待。释放锁时，可重入锁，每一次退出方法，就会将status减1，直至status的值为0，最后释放该锁。释放锁时，非可重入锁，线程退出方法，直接就会释放该锁。</p>\n<h3 id=\"对象的内存布局\">对象的内存布局</h3>\n<p><strong>jvm默认开启class pointer压缩 为4字节</strong><br>\n普通对象 markword 默认八个字节 instance data 若属性则为零 padding 补足被8整除<br>\n​<img src=\"/assets/net-img-1615611389351-2cfaa4d5-b52c-4a2e-a170-c32ce97d17a6-20221030135532-u420fpk.png\" alt=\"image.png\"><br>\n数组对象<br>\n​<img src=\"/assets/net-img-1615611419969-14ba7126-9f92-482c-a851-9898cece7e8f-20221030135532-6itdbiz.png\" alt=\"image.png\">​</p>\n<h3 id=\"实现\">实现</h3>\n<p>MONITORENTER 进入锁<br>\nMONITOREXIT 退出锁<br>\n在jvm执行过程中实现锁升级</p>\n<h3 id=\"锁升级\">锁升级</h3>\n<table>\n<thead>\n<tr>\n<th>锁状态</th>\n<th></th>\n<th>25位</th>\n<th></th>\n<th>31位</th>\n<th></th>\n<th></th>\n<th>1位</th>\n<th>4bit</th>\n<th>1bit（偏向锁位）</th>\n<th>2bit锁标志</th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>无锁（new）</td>\n<td></td>\n<td>unused</td>\n<td></td>\n<td>hashcode（如果调用）</td>\n<td></td>\n<td></td>\n<td>unused</td>\n<td>分代年龄</td>\n<td>0</td>\n<td>0</td>\n<td>1</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>锁状态</td>\n<td></td>\n<td>54位</td>\n<td></td>\n<td></td>\n<td></td>\n<td>2位</td>\n<td>1位</td>\n<td>4bit</td>\n<td>1bit（偏向锁位）</td>\n<td>2bit锁标志</td>\n<td></td>\n</tr>\n<tr>\n<td>偏向锁</td>\n<td></td>\n<td>当前线程指针</td>\n<td></td>\n<td></td>\n<td></td>\n<td>Epoch</td>\n<td>unused</td>\n<td>分代年龄</td>\n<td>1</td>\n<td>0</td>\n<td>1</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>锁状态</td>\n<td></td>\n<td>62位</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td>2bit锁标志</td>\n<td></td>\n</tr>\n<tr>\n<td>轻量锁，自旋锁</td>\n<td></td>\n<td>指向线程栈中Lock Record的指针</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td>0</td>\n<td>0</td>\n</tr>\n<tr>\n<td>重量级锁</td>\n<td></td>\n<td>指向互斥量（重量级锁）的指针</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td>1</td>\n<td>0</td>\n</tr>\n<tr>\n<td>GC标记信息</td>\n<td></td>\n<td>CMS过程中用到的标记信息</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>\n<p><img src=\"/assets/net-img-1615614053644-2e45ea92-d426-42ca-a609-91b095ff7e83-20221030135532-iwc3p25.png\" alt=\"image.png\"></p>\n<h4 id=\"锁升级流程-hashcode存储到Lock-Record\">锁升级流程(hashcode存储到Lock Record)</h4>\n<ol>\n<li>先new一个对象</li>\n<li>若有一个线程进入，将线程id放入对象头中（偏向锁）</li>\n<li>若再来一个线程，将使用CAS进行锁竞争，并这小偏向锁标识（自旋锁）（CAS等待自旋会消耗CPU）</li>\n<li>jdk1.6之前为自旋10次货自旋线程大于CPU核心的一半则进入重量锁 之后则为jvm自适应锁</li>\n</ol>\n<p>为何要升级到重量锁：升级重量锁后，其他线程进入等待状态，不消耗CPU，但是申请重量锁需要与内核打交道，会消耗资源。</p>\n<h4 id=\"锁粗化\">锁粗化</h4>\n<p>jvm检测到一连串操作都对同一对象加锁，此时jvm就会将锁范围加到一连串操作的外围（比如for循环append）</p>\n<h4 id=\"锁消除\">锁消除</h4>\n<p>一个资源为非共享资源，jvm会自动把锁去除（比如只在一个方法内使用StringBuffer的append方法）</p>\n<h2 id=\"显式锁\">显式锁</h2>\n<p>​<img src=\"/assets/net-img-1582875478351-18a69ed7-cb09-4a5a-a020-097490219718-20221030135517-0h9pq4n.png\" alt=\"1-12.png\">​</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Lock和ReadWriteLock是两大锁的根接口</span><br><span class=\"line\">Lock 接口支持重入、公平等的锁规则：实现类 ReentrantLock、ReadLock和WriteLock。</span><br><span class=\"line\">ReadWriteLock 接口定义读取者共享而写入者独占的锁，实现类：ReentrantReadWriteLock。</span><br></pre></td></tr></table></figure>\n<h3 id=\"Lock-类\">Lock 类</h3>\n<h4 id=\"ReentrantLock\">ReentrantLock</h4>\n<p>ReentrantLock方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//传入boolean值,true时create一个公平锁，false为非公平锁</span></span><br><span class=\"line\">       ReentrantLock(<span class=\"type\">boolean</span> fair) </span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">//查看有多少线程等待锁</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">getQueueLength</span><span class=\"params\">()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//是否有线程等待抢锁</span></span><br><span class=\"line\"><span class=\"type\">boolean</span> <span class=\"title function_\">hasQueuedThreads</span><span class=\"params\">()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//是否有指定线程等待抢锁</span></span><br><span class=\"line\"><span class=\"type\">boolean</span> <span class=\"title function_\">hasQueuedThread</span><span class=\"params\">(Thread thread)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//当前线程是否抢到锁。返回0代表没有</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">getHoldCount</span><span class=\"params\">()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//查询此锁是否由任何线程持有</span></span><br><span class=\"line\"><span class=\"type\">boolean</span> <span class=\"title function_\">isLocked</span><span class=\"params\">()</span></span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"comment\">//是否为公平锁</span></span><br><span class=\"line\"><span class=\"type\">boolean</span> <span class=\"title function_\">isFair</span><span class=\"params\">()</span> </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>Condition 方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Condition</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t*Condition线程进入阻塞状态,调用signal()或者signalAll()再次唤醒，</span></span><br><span class=\"line\"><span class=\"comment\">\t*允许中断如果在阻塞时锁持有线程中断，会抛出异常；</span></span><br><span class=\"line\"><span class=\"comment\">\t*重要一点是：在当前持有Lock的线程中，当外部调用会await()后，ReentrantLock就允许其他线程来抢夺锁当前锁，</span></span><br><span class=\"line\"><span class=\"comment\">\t*注意：通过创建Condition对象来使线程wait，必须先执行lock.lock方法获得锁</span></span><br><span class=\"line\"><span class=\"comment\">\t*/</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">await</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//Condition线程进入阻塞状态,调用signal()或者signalAll()再次唤醒，不允许中断，如果在阻塞时锁持有线程中断，继续等待唤醒</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">awaitUninterruptibly</span><span class=\"params\">()</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//设置阻塞时间，超时继续，超时时间单位为纳秒，其他同await()；返回时间大于零，表示是被唤醒，等待时间并且可以作为等待时间期望值，小于零表示超时</span></span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"title function_\">awaitNanos</span><span class=\"params\">(<span class=\"type\">long</span> nanosTimeout)</span> <span class=\"keyword\">throws</span> InterruptedException;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//类似awaitNanos(long nanosTimeout);返回值：被唤醒true，超时false</span></span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"title function_\">await</span><span class=\"params\">(<span class=\"type\">long</span> time, TimeUnit unit)</span> <span class=\"keyword\">throws</span> InterruptedException;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">//类似await(long time, TimeUnit unit) </span></span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"title function_\">awaitUntil</span><span class=\"params\">(Date deadline)</span> <span class=\"keyword\">throws</span> InterruptedException;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">//唤醒指定线程</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">signal</span><span class=\"params\">()</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//唤醒全部线程</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">signalAll</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>Condition是Lock上的一个条件，可以多次newCondition()获得多个条件，Condition可用于线程间通信，通过Condition能够更加精细的控制多线程的休眠与唤醒</p>\n</blockquote>\n<blockquote>\n<p>ReentrantLock.Condition线程通信注意点：</p>\n<ol>\n<li>使用<strong>ReentrantLock.Condition的signal()、await()、signalAll()方法使用之前必须要先进行lock()操作</strong>[记得unlock()]，类似使用Object的notify()、wait()、notifyAll()之前必须要对Object对象进行synchronized操作；否则就会抛IllegalMonitorStateException；</li>\n<li>注意在使用**ReentrantLock.Condition中使用signal()、await()、signalAll()方法，不能和Object的notify()、wait()、notifyAll()方法混用，否则抛出IllegalMonitorStateException`;</li>\n</ol>\n</blockquote>\n<h4 id=\"ReentrantReadWriteLock\">ReentrantReadWriteLock</h4>\n<h5 id=\"读写锁的实现分析\">读写锁的实现分析</h5>\n<p>读写锁因为也是维护一个整数状态(volatile修饰)，但是因为是一个整数，需要保证读写，两种状态，所以对32位整型进行了高16位和低16位的设计，其中高16为代表读锁，低16为代表写锁。</p>\n<ul>\n<li>\n<p>写锁的获取与释放<br>\n写锁是一个可重入的锁，允许同一个线程重复获取锁，所以在获取锁的逻辑中会进行是否当前线程以及是否有其他读线程的状态判断。如果当前线程在获取写锁时，读锁已经被获取(读状态不为0)，或者该线程不是已经获得了写锁的线程，则当前线程进入等待状态。<br>\n写锁的释放和ReentrantLock的释放很像，当释放锁时，需要对状态递减一，并且前一次写线程修改对后续读线程可见。</p>\n</li>\n<li>\n<p>读锁的获取与释放<br>\n读锁是一个可重入锁，在没有其他写线程时，读锁总是可以成功的获取，安全地进行状态加1。state这个值可以判断整个读锁被获得了多少次，而每个线程获取读锁的次数，是存储在ThreadLocal中的。<br>\n读锁的每次释放均线程安全的减少读状态</p>\n</li>\n</ul>\n<h5 id=\"锁降级\">锁降级</h5>\n<p>锁降级指的是一个线程先拥有写锁，然后拥有读锁，在对数据处理完成后，释放写锁，此时该线程所持有的锁是读锁，从写锁降级为读锁。</p>\n<h2 id=\"自旋锁\">自旋锁</h2>\n<h3 id=\"CAS-（Compare-and-Swap（比较与交换））\">CAS （Compare and Swap（比较与交换））</h3>\n<p>CAS是实现自旋锁的基础</p>\n<p>CAS的原理：</p>\n<p>线程从内存中取值i 赋值给k 对k进行运算，运算完毕后与内存中的i值进行比较，若相等证明无线程修改i ，结果正确，更新结果值。若不相等则证明有其他线程修改过该值，结果不正确进行重试。</p>\n<p>‍</p>\n<h3 id=\"自旋锁-2\">自旋锁</h3>\n<blockquote>\n<p>自旋锁和非自旋锁的获取锁的过程。</p>\n</blockquote>\n<p>​<img src=\"/assets/image-20230527140729-waan312.png\" alt=\"image\">​</p>\n<p>自旋锁，它并不会放弃  CPU  时间片，而是通过自旋等待锁的释放，也就是说，它会不停地再次地尝试获取锁，如果失败就再次尝试，直到成功为止。</p>\n<p>非自旋锁，如果它发现此时获取不到锁，它就把自己的线程切换状态，让线程休眠，然后 CPU 就可以在这段时间去做很多其他的事情，直到之前持有这把锁的线程释放了锁，于是 CPU 再把之前的线程恢复回来，让这个线程再去尝试获取这把锁。如果再次失败，就再次让线程休眠，如果成功，一样可以成功获取到同步资源的锁。</p>\n<ul>\n<li>\n<p>优点</p>\n<ul>\n<li>自旋锁用循环去不停地尝试获取锁，让线程始终处于 Runnable 状态，节省了线程状态切换带来的开销。</li>\n</ul>\n</li>\n<li>\n<p>缺点</p>\n<ul>\n<li>虽然避免了线程切换的开销，但是它在避免线程切换开销的同时也带来了新的开销，因为它需要不停得去尝试获取锁。如果这把锁一直不能被释放，那么这种尝试只是无用的尝试，会白白浪费处理器资源。也就是说，虽然一开始自旋锁的开销低于线程切换，但是随着时间的增加，这种开销也是水涨船高，后期甚至会超过线程切换的开销，得不偿失。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"注意事项\">注意事项</h3>\n<p>‍</p>\n<p><strong>虽然避免了线程切换的开销，但是它在避免线程切换开销的同时也带来了新的开销，因为它需要不停得去尝试获取锁。如果这把锁一直不能被释放，那么这种尝试只是无用的尝试，会白白浪费处理器资源。</strong></p>\n<p><strong>ABA问题</strong></p>\n<h3 id=\"适应场景\">适应场景</h3>\n<p>适用于并发度不是特别高的场景，以及临界区比较短小的情况，这样我们可以利用避免线程切换来提高效率。如果临界区很大，线程一旦拿到锁，很久才会释放的话，那就不合适用自旋锁，因为自旋会一直占用 CPU 却无法拿到锁，白白消耗资源。</p>\n<p>‍</p>\n<p>‍</p>\n<p>‍</p>\n<p>‍</p>\n<p>‍</p>\n<p>‍</p>\n<p>‍</p>\n<p>‍</p>\n<p>‍</p>\n<h2 id=\"问题\">问题</h2>\n<h3 id=\"Synchronized-和-Lock-区别\">Synchronized 和 Lock 区别</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">synchronized是java内置关键字，在jvm层面，Lock是个java类；</span><br><span class=\"line\">synchronized无法判断是否获取锁的状态，Lock可以判断是否获取到锁；</span><br><span class=\"line\">synchronized会自动释放锁(a 线程执行完同步代码会释放锁 ；b 线程执行过程中发生异常会释放锁)，Lock需在finally中手工释放锁（unlock()方法释放锁），否则容易造成线程死锁；</span><br><span class=\"line\">用synchronized关键字的两个线程1和线程2，如果当前线程1获得锁，线程2线程等待。如果线程1阻塞，线程2则会一直等待下去，而Lock锁就不一定会等待下去，如果尝试获取不到锁，线程可以不用一直等待就结束了；</span><br><span class=\"line\">synchronized的锁可重入、不可中断、非公平，而Lock锁可重入、可判断、可公平（两者皆可）</span><br><span class=\"line\">Lock锁适合大量同步的代码的同步问题，synchronized锁适合代码少量的同步问题。</span><br></pre></td></tr></table></figure>\n<p>‍</p>\n","excerpt":"","more":"<h1>并发锁</h1>\n<p>根据分类标准我们把锁分为以下 7 大类别，分别是：</p>\n<ul>\n<li>\n<p>偏向锁/轻量级锁/重量级锁：这三种锁特指 synchronized 锁的状态，通过在对象头中的 mark word 来表明锁的状态。</p>\n<ul>\n<li>\n<p>偏向锁</p>\n<ul>\n<li>如果自始至终，对于这把锁都不存在竞争，那么其实就没必要上锁，只需要打个标记就行了，这就是偏向锁的思想。一个对象被初始化后，还没有任何线程来获取它的锁时，那么它就是可偏向的，当有第一个线程来访问它并尝试获取锁的时候，它就将这个线程记录下来，以后如果尝试获取锁的线程正是偏向锁的拥有者，就可以直接获得锁，开销很小，性能最好。</li>\n</ul>\n</li>\n<li>\n<p>重量级锁</p>\n<ul>\n<li>重量级锁是互斥锁，它是利用操作系统的同步机制实现的，所以开销相对比较大。当多个线程直接有实际竞争，且锁竞争时间长的时候，轻量级锁不能满足需求，锁就会膨胀为重量级锁。重量级锁会让其他申请却拿不到锁的线程进入阻塞状态。</li>\n</ul>\n</li>\n<li>\n<p>轻量级锁</p>\n<ul>\n<li>JVM 开发者发现在很多情况下，synchronized 中的代码是被多个线程交替执行的，而不是同时执行的，也就是说并不存在实际的竞争，或者是只有短时间的锁竞争，用 CAS 就可以解决，这种情况下，用完全互斥的重量级锁是没必要的。轻量级锁是指当锁原来是偏向锁的时候，被另一个线程访问，说明存在竞争，那么偏向锁就会升级为轻量级锁，线程会通过自旋的形式尝试获取锁，而不会陷入阻塞。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>可重入锁/非可重入锁；</p>\n<ul>\n<li>不可重入锁：线程当前持有了这把锁，但是如果想再次获取这把锁，也必须要先释放锁后才能再次尝试获取。</li>\n<li>可重入锁：线程当前已经持有这把锁了，能在不释放这把锁的情况下，再次获取这把锁。</li>\n</ul>\n</li>\n<li>\n<p>共享锁/独占锁；</p>\n<ul>\n<li>共享锁：同一把锁可以被多个线程同时获得，</li>\n<li>独占锁：锁只能同时被一个线程获得。</li>\n</ul>\n</li>\n<li>\n<p>公平锁/非公平锁；</p>\n<ul>\n<li>公平锁的公平的含义在于如果线程现在拿不到这把锁，那么线程就都会进入等待，开始排队，在等待队列里等待时间长的线程会优先拿到这把锁，有先来先得的意思。</li>\n<li>非公平锁就不那么“完美”了，它会在一定情况下，忽略掉已经在排队的线程，发生插队现象。</li>\n</ul>\n</li>\n<li>\n<p>悲观锁/乐观锁；</p>\n<ul>\n<li>悲观锁的概念是在获取资源之前，必须先拿到锁，以便达到“独占”的状态，当前线程在操作资源的时候，其他线程由于不能拿到锁，所以其他线程不能来影响我。</li>\n<li>乐观锁恰恰相反，它并不要求在获取资源前拿到锁，也不会锁住资源；相反，乐观锁利用 CAS 理念，在不独占资源的情况下，完成了对资源的修改。</li>\n</ul>\n</li>\n<li>\n<p>自旋锁/非自旋锁；</p>\n<ul>\n<li>自旋锁的理念是如果线程现在拿不到锁，并不直接陷入阻塞或者释放 CPU 资源，而是开始利用循环，不停地尝试获取锁，这个循环过程被形象地比喻为“自旋”，就像是线程在“自我旋转”。</li>\n<li>非自旋锁的理念就是没有自旋的过程，如果拿不到锁就直接放弃，或者进行其他的处理逻辑，例如去排队、陷入阻塞等。</li>\n</ul>\n</li>\n<li>\n<p>可中断锁/不可中断锁。</p>\n<ul>\n<li>在 Java 中，synchronized 关键字修饰的锁代表的是不可中断锁，一旦线程申请了锁，就没有回头路了，只能等到拿到锁以后才能进行其他的逻辑处理。而我们的 ReentrantLock 是一种典型的可中断锁，例如使用 lockInterruptibly 方法在获取锁的过程中，突然不想获取了，那么也可以在中断之后去做其他的事情，不需要一直傻等到获取到锁才离开。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Synchronized\">Synchronized</h2>\n<h3 id=\"原理\">原理:</h3>\n<p>每个对象都有一个monitor锁，当一个monitor被线程持有后会处于锁定状态，使用的是monitorenter和monitorexit指令，其中monitorenter指令指向同步代码块的开始位置，monitorexit指令则指明同步代码块的结束位置。当执行monitorenter指令时，monitor计数器加一，取锁成功，当monitor的计数器为0时释放锁。</p>\n<p>Synchronized方法锁为该方法所在的对象本身，静态Synchronized方法从Class对象获取</p>\n<p><strong>Synchronized是可重入锁</strong></p>\n<p>当一个线程请求方法时，会去检查锁状态，如果锁状态是0，代表该锁没有被占用，直接进行CAS操作获取锁，将线程ID替换成自己的线程ID。如果锁状态不是0，代表有线程在访问该方法。此时，如果线程ID是自己的线程ID，如果是可重入锁，会将status自增1，然后获取到该锁，进而执行相应的方法。如果是非重入锁，就会进入阻塞队列等待。释放锁时，可重入锁，每一次退出方法，就会将status减1，直至status的值为0，最后释放该锁。释放锁时，非可重入锁，线程退出方法，直接就会释放该锁。</p>\n<h3 id=\"对象的内存布局\">对象的内存布局</h3>\n<p><strong>jvm默认开启class pointer压缩 为4字节</strong><br>\n普通对象 markword 默认八个字节 instance data 若属性则为零 padding 补足被8整除<br>\n​<img src=\"/assets/net-img-1615611389351-2cfaa4d5-b52c-4a2e-a170-c32ce97d17a6-20221030135532-u420fpk.png\" alt=\"image.png\"><br>\n数组对象<br>\n​<img src=\"/assets/net-img-1615611419969-14ba7126-9f92-482c-a851-9898cece7e8f-20221030135532-6itdbiz.png\" alt=\"image.png\">​</p>\n<h3 id=\"实现\">实现</h3>\n<p>MONITORENTER 进入锁<br>\nMONITOREXIT 退出锁<br>\n在jvm执行过程中实现锁升级</p>\n<h3 id=\"锁升级\">锁升级</h3>\n<table>\n<thead>\n<tr>\n<th>锁状态</th>\n<th></th>\n<th>25位</th>\n<th></th>\n<th>31位</th>\n<th></th>\n<th></th>\n<th>1位</th>\n<th>4bit</th>\n<th>1bit（偏向锁位）</th>\n<th>2bit锁标志</th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>无锁（new）</td>\n<td></td>\n<td>unused</td>\n<td></td>\n<td>hashcode（如果调用）</td>\n<td></td>\n<td></td>\n<td>unused</td>\n<td>分代年龄</td>\n<td>0</td>\n<td>0</td>\n<td>1</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>锁状态</td>\n<td></td>\n<td>54位</td>\n<td></td>\n<td></td>\n<td></td>\n<td>2位</td>\n<td>1位</td>\n<td>4bit</td>\n<td>1bit（偏向锁位）</td>\n<td>2bit锁标志</td>\n<td></td>\n</tr>\n<tr>\n<td>偏向锁</td>\n<td></td>\n<td>当前线程指针</td>\n<td></td>\n<td></td>\n<td></td>\n<td>Epoch</td>\n<td>unused</td>\n<td>分代年龄</td>\n<td>1</td>\n<td>0</td>\n<td>1</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>锁状态</td>\n<td></td>\n<td>62位</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td>2bit锁标志</td>\n<td></td>\n</tr>\n<tr>\n<td>轻量锁，自旋锁</td>\n<td></td>\n<td>指向线程栈中Lock Record的指针</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td>0</td>\n<td>0</td>\n</tr>\n<tr>\n<td>重量级锁</td>\n<td></td>\n<td>指向互斥量（重量级锁）的指针</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td>1</td>\n<td>0</td>\n</tr>\n<tr>\n<td>GC标记信息</td>\n<td></td>\n<td>CMS过程中用到的标记信息</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>\n<p><img src=\"/assets/net-img-1615614053644-2e45ea92-d426-42ca-a609-91b095ff7e83-20221030135532-iwc3p25.png\" alt=\"image.png\"></p>\n<h4 id=\"锁升级流程-hashcode存储到Lock-Record\">锁升级流程(hashcode存储到Lock Record)</h4>\n<ol>\n<li>先new一个对象</li>\n<li>若有一个线程进入，将线程id放入对象头中（偏向锁）</li>\n<li>若再来一个线程，将使用CAS进行锁竞争，并这小偏向锁标识（自旋锁）（CAS等待自旋会消耗CPU）</li>\n<li>jdk1.6之前为自旋10次货自旋线程大于CPU核心的一半则进入重量锁 之后则为jvm自适应锁</li>\n</ol>\n<p>为何要升级到重量锁：升级重量锁后，其他线程进入等待状态，不消耗CPU，但是申请重量锁需要与内核打交道，会消耗资源。</p>\n<h4 id=\"锁粗化\">锁粗化</h4>\n<p>jvm检测到一连串操作都对同一对象加锁，此时jvm就会将锁范围加到一连串操作的外围（比如for循环append）</p>\n<h4 id=\"锁消除\">锁消除</h4>\n<p>一个资源为非共享资源，jvm会自动把锁去除（比如只在一个方法内使用StringBuffer的append方法）</p>\n<h2 id=\"显式锁\">显式锁</h2>\n<p>​<img src=\"/assets/net-img-1582875478351-18a69ed7-cb09-4a5a-a020-097490219718-20221030135517-0h9pq4n.png\" alt=\"1-12.png\">​</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Lock和ReadWriteLock是两大锁的根接口</span><br><span class=\"line\">Lock 接口支持重入、公平等的锁规则：实现类 ReentrantLock、ReadLock和WriteLock。</span><br><span class=\"line\">ReadWriteLock 接口定义读取者共享而写入者独占的锁，实现类：ReentrantReadWriteLock。</span><br></pre></td></tr></table></figure>\n<h3 id=\"Lock-类\">Lock 类</h3>\n<h4 id=\"ReentrantLock\">ReentrantLock</h4>\n<p>ReentrantLock方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//传入boolean值,true时create一个公平锁，false为非公平锁</span></span><br><span class=\"line\">       ReentrantLock(<span class=\"type\">boolean</span> fair) </span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">//查看有多少线程等待锁</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">getQueueLength</span><span class=\"params\">()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//是否有线程等待抢锁</span></span><br><span class=\"line\"><span class=\"type\">boolean</span> <span class=\"title function_\">hasQueuedThreads</span><span class=\"params\">()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//是否有指定线程等待抢锁</span></span><br><span class=\"line\"><span class=\"type\">boolean</span> <span class=\"title function_\">hasQueuedThread</span><span class=\"params\">(Thread thread)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//当前线程是否抢到锁。返回0代表没有</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">getHoldCount</span><span class=\"params\">()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//查询此锁是否由任何线程持有</span></span><br><span class=\"line\"><span class=\"type\">boolean</span> <span class=\"title function_\">isLocked</span><span class=\"params\">()</span></span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"comment\">//是否为公平锁</span></span><br><span class=\"line\"><span class=\"type\">boolean</span> <span class=\"title function_\">isFair</span><span class=\"params\">()</span> </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>Condition 方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Condition</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t*Condition线程进入阻塞状态,调用signal()或者signalAll()再次唤醒，</span></span><br><span class=\"line\"><span class=\"comment\">\t*允许中断如果在阻塞时锁持有线程中断，会抛出异常；</span></span><br><span class=\"line\"><span class=\"comment\">\t*重要一点是：在当前持有Lock的线程中，当外部调用会await()后，ReentrantLock就允许其他线程来抢夺锁当前锁，</span></span><br><span class=\"line\"><span class=\"comment\">\t*注意：通过创建Condition对象来使线程wait，必须先执行lock.lock方法获得锁</span></span><br><span class=\"line\"><span class=\"comment\">\t*/</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">await</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//Condition线程进入阻塞状态,调用signal()或者signalAll()再次唤醒，不允许中断，如果在阻塞时锁持有线程中断，继续等待唤醒</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">awaitUninterruptibly</span><span class=\"params\">()</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//设置阻塞时间，超时继续，超时时间单位为纳秒，其他同await()；返回时间大于零，表示是被唤醒，等待时间并且可以作为等待时间期望值，小于零表示超时</span></span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"title function_\">awaitNanos</span><span class=\"params\">(<span class=\"type\">long</span> nanosTimeout)</span> <span class=\"keyword\">throws</span> InterruptedException;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//类似awaitNanos(long nanosTimeout);返回值：被唤醒true，超时false</span></span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"title function_\">await</span><span class=\"params\">(<span class=\"type\">long</span> time, TimeUnit unit)</span> <span class=\"keyword\">throws</span> InterruptedException;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">//类似await(long time, TimeUnit unit) </span></span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"title function_\">awaitUntil</span><span class=\"params\">(Date deadline)</span> <span class=\"keyword\">throws</span> InterruptedException;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">//唤醒指定线程</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">signal</span><span class=\"params\">()</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//唤醒全部线程</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">signalAll</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>Condition是Lock上的一个条件，可以多次newCondition()获得多个条件，Condition可用于线程间通信，通过Condition能够更加精细的控制多线程的休眠与唤醒</p>\n</blockquote>\n<blockquote>\n<p>ReentrantLock.Condition线程通信注意点：</p>\n<ol>\n<li>使用<strong>ReentrantLock.Condition的signal()、await()、signalAll()方法使用之前必须要先进行lock()操作</strong>[记得unlock()]，类似使用Object的notify()、wait()、notifyAll()之前必须要对Object对象进行synchronized操作；否则就会抛IllegalMonitorStateException；</li>\n<li>注意在使用**ReentrantLock.Condition中使用signal()、await()、signalAll()方法，不能和Object的notify()、wait()、notifyAll()方法混用，否则抛出IllegalMonitorStateException`;</li>\n</ol>\n</blockquote>\n<h4 id=\"ReentrantReadWriteLock\">ReentrantReadWriteLock</h4>\n<h5 id=\"读写锁的实现分析\">读写锁的实现分析</h5>\n<p>读写锁因为也是维护一个整数状态(volatile修饰)，但是因为是一个整数，需要保证读写，两种状态，所以对32位整型进行了高16位和低16位的设计，其中高16为代表读锁，低16为代表写锁。</p>\n<ul>\n<li>\n<p>写锁的获取与释放<br>\n写锁是一个可重入的锁，允许同一个线程重复获取锁，所以在获取锁的逻辑中会进行是否当前线程以及是否有其他读线程的状态判断。如果当前线程在获取写锁时，读锁已经被获取(读状态不为0)，或者该线程不是已经获得了写锁的线程，则当前线程进入等待状态。<br>\n写锁的释放和ReentrantLock的释放很像，当释放锁时，需要对状态递减一，并且前一次写线程修改对后续读线程可见。</p>\n</li>\n<li>\n<p>读锁的获取与释放<br>\n读锁是一个可重入锁，在没有其他写线程时，读锁总是可以成功的获取，安全地进行状态加1。state这个值可以判断整个读锁被获得了多少次，而每个线程获取读锁的次数，是存储在ThreadLocal中的。<br>\n读锁的每次释放均线程安全的减少读状态</p>\n</li>\n</ul>\n<h5 id=\"锁降级\">锁降级</h5>\n<p>锁降级指的是一个线程先拥有写锁，然后拥有读锁，在对数据处理完成后，释放写锁，此时该线程所持有的锁是读锁，从写锁降级为读锁。</p>\n<h2 id=\"自旋锁\">自旋锁</h2>\n<h3 id=\"CAS-（Compare-and-Swap（比较与交换））\">CAS （Compare and Swap（比较与交换））</h3>\n<p>CAS是实现自旋锁的基础</p>\n<p>CAS的原理：</p>\n<p>线程从内存中取值i 赋值给k 对k进行运算，运算完毕后与内存中的i值进行比较，若相等证明无线程修改i ，结果正确，更新结果值。若不相等则证明有其他线程修改过该值，结果不正确进行重试。</p>\n<p>‍</p>\n<h3 id=\"自旋锁-2\">自旋锁</h3>\n<blockquote>\n<p>自旋锁和非自旋锁的获取锁的过程。</p>\n</blockquote>\n<p>​<img src=\"/assets/image-20230527140729-waan312.png\" alt=\"image\">​</p>\n<p>自旋锁，它并不会放弃  CPU  时间片，而是通过自旋等待锁的释放，也就是说，它会不停地再次地尝试获取锁，如果失败就再次尝试，直到成功为止。</p>\n<p>非自旋锁，如果它发现此时获取不到锁，它就把自己的线程切换状态，让线程休眠，然后 CPU 就可以在这段时间去做很多其他的事情，直到之前持有这把锁的线程释放了锁，于是 CPU 再把之前的线程恢复回来，让这个线程再去尝试获取这把锁。如果再次失败，就再次让线程休眠，如果成功，一样可以成功获取到同步资源的锁。</p>\n<ul>\n<li>\n<p>优点</p>\n<ul>\n<li>自旋锁用循环去不停地尝试获取锁，让线程始终处于 Runnable 状态，节省了线程状态切换带来的开销。</li>\n</ul>\n</li>\n<li>\n<p>缺点</p>\n<ul>\n<li>虽然避免了线程切换的开销，但是它在避免线程切换开销的同时也带来了新的开销，因为它需要不停得去尝试获取锁。如果这把锁一直不能被释放，那么这种尝试只是无用的尝试，会白白浪费处理器资源。也就是说，虽然一开始自旋锁的开销低于线程切换，但是随着时间的增加，这种开销也是水涨船高，后期甚至会超过线程切换的开销，得不偿失。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"注意事项\">注意事项</h3>\n<p>‍</p>\n<p><strong>虽然避免了线程切换的开销，但是它在避免线程切换开销的同时也带来了新的开销，因为它需要不停得去尝试获取锁。如果这把锁一直不能被释放，那么这种尝试只是无用的尝试，会白白浪费处理器资源。</strong></p>\n<p><strong>ABA问题</strong></p>\n<h3 id=\"适应场景\">适应场景</h3>\n<p>适用于并发度不是特别高的场景，以及临界区比较短小的情况，这样我们可以利用避免线程切换来提高效率。如果临界区很大，线程一旦拿到锁，很久才会释放的话，那就不合适用自旋锁，因为自旋会一直占用 CPU 却无法拿到锁，白白消耗资源。</p>\n<p>‍</p>\n<p>‍</p>\n<p>‍</p>\n<p>‍</p>\n<p>‍</p>\n<p>‍</p>\n<p>‍</p>\n<p>‍</p>\n<p>‍</p>\n<h2 id=\"问题\">问题</h2>\n<h3 id=\"Synchronized-和-Lock-区别\">Synchronized 和 Lock 区别</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">synchronized是java内置关键字，在jvm层面，Lock是个java类；</span><br><span class=\"line\">synchronized无法判断是否获取锁的状态，Lock可以判断是否获取到锁；</span><br><span class=\"line\">synchronized会自动释放锁(a 线程执行完同步代码会释放锁 ；b 线程执行过程中发生异常会释放锁)，Lock需在finally中手工释放锁（unlock()方法释放锁），否则容易造成线程死锁；</span><br><span class=\"line\">用synchronized关键字的两个线程1和线程2，如果当前线程1获得锁，线程2线程等待。如果线程1阻塞，线程2则会一直等待下去，而Lock锁就不一定会等待下去，如果尝试获取不到锁，线程可以不用一直等待就结束了；</span><br><span class=\"line\">synchronized的锁可重入、不可中断、非公平，而Lock锁可重入、可判断、可公平（两者皆可）</span><br><span class=\"line\">Lock锁适合大量同步的代码的同步问题，synchronized锁适合代码少量的同步问题。</span><br></pre></td></tr></table></figure>\n<p>‍</p>\n"},{"title":"线程池","date":"2023-05-14T14:53:28.000Z","lastmod":"2023-05-14T14:53:28.000Z","_content":"\n# 线程池 \n\n## 线程池\n\n1. Executor 接口：\n   声明了 execute(Runnable runnable)方法，执行任务代码\n2. ExecutorService 接口：\n   继承 Executor 接口，声明方法：submit、invokeAll、invokeAny 以及 shutDown 等\n3. AbstractExecutorService 抽象类：\n   实现 ExecutorService 接口，基本实现 ExecutorService 中声明的所有方法\n4. ScheduledExecutorService 接口：\n   继承 ExecutorService 接口，声明定时执行任务方法\n5. ThreadPoolExecutor 类：\n   继承类 AbstractExecutorService，实现 execute、submit、shutdown、shutdownNow 方法\n6. ScheduledThreadPoolExecutor 类：\n   继承 ThreadPoolExecutor 类，实现 ScheduledExecutorService 接口并实现其中的方法\n7. Executors 类：\n   提供快速创建线程池的方法\n\n## Executor 框架与线程池\n\n　　Executor 框架包括：线程池，Executor，Executors，ExecutorService，CompletionService，Future，Callable 等\n\n　　Executor 接口中之定义了一个方法 execute（Runnable command），该方法接收一个 Runable 实例，它用来执行一个任务\n\n　　ExecutorService 接口继承自 Executor 接口，它提供了更丰富的实现多线程的方法，比如\n\n1. submit()方法可以返回Future对象，可以调用isDone()方法查询Future是否已完成，当任务完成时，它具有一个结果，可以通过get()方法获取到该结果，Future提供了cancel()方法用来取消执行pending中的任务。\n2. shutdown()方法允许之前已经提交的任务执行完毕之后再挂起关闭，shutdownNow()方法则阻止正在等待的任务启动，并尝试停止之前正在执行的任务。\n\n　　**多线程的缺点：**\n\n- 处理任务的线程创建和销毁都非常耗时并消耗资源。\n- 多线程之间的切换也会非常耗时并消耗资源。\n  **解决方法：采用线程池**\n- 使用时线程已存在，消除了线程创建的时耗\n- 通过设置线程数目，防止资源不足\n\n### ThreadPoolExecutor 的全参构造函数参数\n\n　　在 Java 中创建线程池常用的类是 ThreadPoolExecutor，该类的全参构造函数如下：\n\n```java\npublic ThreadPoolExecutor(int corePoolSize,\n                          int maximumPoolSize,\n                          long keepAliveTime,\n                          TimeUnit unit,\n                          BlockingQueue<Runnable> workQueue,\n                          ThreadFactory threadFactory,\n                          RejectedExecutionHandler handler) {\n```\n\n　　参数介绍：\n\n* ​`corePoolSize`​：线程池中核心线程数的最大值\n* ​`maximumPoolSize`​：线程池中能拥有最多线程数\n* ​`workQueue`​：用于缓存任务的阻塞队列，对于不同的应用场景我们可能会采取不同的排队策略，这就需要不同类型的阻塞队列，在线程池中常用的阻塞队列有以下 2 种：\n\n  * ​`SynchronousQueue<Runnable>`​：此队列中不缓存任何一个任务。向线程池提交任务时，如果没有空闲线程来运行任务，则入列操作会阻塞。当有线程来获取任务时，出列操作会唤醒执行入列操作的线程。从这个特性来看，`SynchronousQueue`​ 是一个无界队列，因此当使用 `SynchronousQueue`​ 作为线程池的阻塞队列时，参数 `maximumPoolSizes`​ 没有任何作用。\n  * ​`LinkedBlockingQueue<Runnable>`​：顾名思义是用链表实现的队列，可以是有界的，也可以是无界的，但在 `Executors`​ 中默认使用无界的。\n* ​`keepAliveTime`​：表示空闲线程的存活时间。\n* ​`unit`​：表示 `keepAliveTime`​ 的单位。\n* ​`handler`​：表示当 `workQueue`​ 已满，且池中的线程数达到 `maximumPoolSize`​ 时，线程池拒绝添加新任务时采取的策略。一般可以采取以下四种取值。\n\n  1. 如果没有空闲的线程执行该任务且当前运行的线程数少于 `corePoolSize`​，则添加新的线程执行该任务。\n  2. 如果没有空闲的线程执行该任务且当前的线程数等于 `corePoolSize`​ 同时**阻塞队列未满**，则将任务入队列，而不添加新的线程。\n  3. 如果没有空闲的线程执行该任务且阻塞队列已满同时池中的线程数小于 `maximumPoolSize`​，则创建新的线程执行任务。\n  4. 如果没有空闲的线程执行该任务且阻塞队列已满同时池中的线程数等于 `maximumPoolSize`​，则根据构造函数中的 `handler`​ 指定的拒绝策略来拒绝新的任务。\n* ​`threadFactory`​：指定创建线程的工厂\n\n### 四种线程池拒绝策略\n\n#### `ThreadPoolExecutor.AbortPolicy()`​\n\n　　抛出 `RejectedExecutionException`​\n\n#### `ThreadPoolExecutor.CallerRunsPolicy()`​\n\n　　由向线程池提交任务的线程来执行该任务\n\n#### `ThreadPoolExecutor.DiscardOldestPolicy()`​\n\n　　抛弃最旧的任务（最先提交而没有得到执行的任务）\n\n#### `ThreadPoolExecutor.DiscardPolicy()`​\n\n　　抛弃当前的任务\n\n### 阻塞队列\n\n* ​`ArrayBlockingQueue`​：基于数组的阻塞队列实现，在ArrayBlockingQueue内部，维护了一个定长的数组，以便缓存队列中的数据对象，其内部没实现读写分离，也就意味着生产和消费者不能完全并行。长度是需要定义的，可以指定先进先出或者先进后出，因为长度是需要定义的，所以也叫有界队列，在很多场合非常适合使用。\n* ​`LinkedBlockingQueue`​：基于链表的阻塞队列，同ArrayBlockingQueue类似，其内部也维持着一个数据缓冲队列（该队列由一个链表构成），LinkedBlockingQueue之所以能够高效地处理并发数据，是因为其内部实现采用分离锁（读写分离两个锁），从而实现生产者和消费者操作完全并行运行。需要注意一下，它是一个无界队列。\n* ​`SynchronousQueue`​：一种没有缓冲的队列，生产者产生的数据直接会被消费者获取并且立刻消费。\n* ​`PriorityBlockingQueue`​：基于优先级别的阻塞队列（优先级的判断通过构造函数传入的Compator对象来决定，也就是说传入队列的对象必须实现Comparable接口），在实现PriorityBlockingQueue时，内部控制线程同步的锁采用的是公平锁，需要注意的是它也是一个无界的队列。\n* ​`DelayQueue`​：带有延迟时间的Queue，其中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素。DelayQueue中的元素必须先实现Delayed接口，DelayQueue是一个没有大小限制的队列，应用场景很多，比如对缓存超时的数据进行移除、任务超时处理、空闲连接的关闭等等\n\n​![image](/assets/image-20230519215732-zz9jpqo.png)​\n\n### 四种常用线程池（ExecutorService的实现类）\n\n　　ThreadPoolExecutor 构造函数的参数很多，使用起来很麻烦，为了方便的创建线程池，JavaSE 中又定义了 Executors 类，Eexcutors 类提供了四个创建线程池的方法，分别如下\n\n#### newCachedThreadPool\n\n　　该方法创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。\n此类型线程池特点是：\n\n1. .工作线程的创建数量几乎没有限制(其实也有限制的,数目为 Interger. MAX_VALUE)\n2. 空闲的工作线程会自动销毁，有新任务会重新创建\n3. 在使用 CachedThreadPool 时，一定要注意控制任务的数量，否则，由于大量线程同时运行，很有会造成系统瘫痪。\n\n#### newFixedThreadPool\n\n　　该方法创建一个指定工作线程数量的线程池。每当提交一个任务就创建一个工作线程，如果工作线程数量达到线程池初始的最大数，则将提交的任务存入到池队列中。\n优点：具有线程池提高程序效率和节省创建线程时所耗的开销。\n缺点：在线程池空闲时，即线程池中没有可运行任务时，它不会释放工作线程，还会占用一定的系统资源。\n\n#### newSingleThreadExecutor\n\n　　该方法创建一个单线程化的 Executor，即只创建唯一的工作者线程来执行任务，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO,优先级)执行。如果这个线程异常结束，会有另一个取代它，保证顺序执行。\n单工作线程最大的特点是可保证顺序地执行各个任务，并且在任意给定的时间不会有多个线程是活动的。\n\n#### newScheduleThreadPool\n\n　　该方法创建一个定长的线程池，而且支持定时的以及周期性的任务执行，支持定时及周期性任务执行。\n\n> FixedThreadPool、SingleThreadPool：使用的是无界队列（LinkedBlockingQueue），当任务堆积很多时，会占用大量内存，最终导致OOM。ChachedTheadPool：可以无限创建线程（Integer.MAX_VALUE），任务过多时会导致创建线程达到操作系统上线或者发生OOM。ScheduledThreadPool、SingleThreadScheduledPool：使用的是DelayedWorkQueue队列，实质上也是一种无界队列，会导致OOM。\n\n## 问题\n\n### 为什么java的线程池当核心线程满了以后,先往blockingQueue中存任务,queue满了以后\n\n　　起到一个缓冲的作用。最大线程数这个参数更像是无奈之举，在最坏的情况下做最后的努力，去新建线程去帮助消化任务。但是这种情况可能存在丢任务的情况。\n","source":"_posts/java/thread/线程池.md","raw":"---\ntitle: 线程池 \ndate: 2023-05-14T22:53:28Z\nlastmod: 2023-05-14T22:53:28Z\n---\n\n# 线程池 \n\n## 线程池\n\n1. Executor 接口：\n   声明了 execute(Runnable runnable)方法，执行任务代码\n2. ExecutorService 接口：\n   继承 Executor 接口，声明方法：submit、invokeAll、invokeAny 以及 shutDown 等\n3. AbstractExecutorService 抽象类：\n   实现 ExecutorService 接口，基本实现 ExecutorService 中声明的所有方法\n4. ScheduledExecutorService 接口：\n   继承 ExecutorService 接口，声明定时执行任务方法\n5. ThreadPoolExecutor 类：\n   继承类 AbstractExecutorService，实现 execute、submit、shutdown、shutdownNow 方法\n6. ScheduledThreadPoolExecutor 类：\n   继承 ThreadPoolExecutor 类，实现 ScheduledExecutorService 接口并实现其中的方法\n7. Executors 类：\n   提供快速创建线程池的方法\n\n## Executor 框架与线程池\n\n　　Executor 框架包括：线程池，Executor，Executors，ExecutorService，CompletionService，Future，Callable 等\n\n　　Executor 接口中之定义了一个方法 execute（Runnable command），该方法接收一个 Runable 实例，它用来执行一个任务\n\n　　ExecutorService 接口继承自 Executor 接口，它提供了更丰富的实现多线程的方法，比如\n\n1. submit()方法可以返回Future对象，可以调用isDone()方法查询Future是否已完成，当任务完成时，它具有一个结果，可以通过get()方法获取到该结果，Future提供了cancel()方法用来取消执行pending中的任务。\n2. shutdown()方法允许之前已经提交的任务执行完毕之后再挂起关闭，shutdownNow()方法则阻止正在等待的任务启动，并尝试停止之前正在执行的任务。\n\n　　**多线程的缺点：**\n\n- 处理任务的线程创建和销毁都非常耗时并消耗资源。\n- 多线程之间的切换也会非常耗时并消耗资源。\n  **解决方法：采用线程池**\n- 使用时线程已存在，消除了线程创建的时耗\n- 通过设置线程数目，防止资源不足\n\n### ThreadPoolExecutor 的全参构造函数参数\n\n　　在 Java 中创建线程池常用的类是 ThreadPoolExecutor，该类的全参构造函数如下：\n\n```java\npublic ThreadPoolExecutor(int corePoolSize,\n                          int maximumPoolSize,\n                          long keepAliveTime,\n                          TimeUnit unit,\n                          BlockingQueue<Runnable> workQueue,\n                          ThreadFactory threadFactory,\n                          RejectedExecutionHandler handler) {\n```\n\n　　参数介绍：\n\n* ​`corePoolSize`​：线程池中核心线程数的最大值\n* ​`maximumPoolSize`​：线程池中能拥有最多线程数\n* ​`workQueue`​：用于缓存任务的阻塞队列，对于不同的应用场景我们可能会采取不同的排队策略，这就需要不同类型的阻塞队列，在线程池中常用的阻塞队列有以下 2 种：\n\n  * ​`SynchronousQueue<Runnable>`​：此队列中不缓存任何一个任务。向线程池提交任务时，如果没有空闲线程来运行任务，则入列操作会阻塞。当有线程来获取任务时，出列操作会唤醒执行入列操作的线程。从这个特性来看，`SynchronousQueue`​ 是一个无界队列，因此当使用 `SynchronousQueue`​ 作为线程池的阻塞队列时，参数 `maximumPoolSizes`​ 没有任何作用。\n  * ​`LinkedBlockingQueue<Runnable>`​：顾名思义是用链表实现的队列，可以是有界的，也可以是无界的，但在 `Executors`​ 中默认使用无界的。\n* ​`keepAliveTime`​：表示空闲线程的存活时间。\n* ​`unit`​：表示 `keepAliveTime`​ 的单位。\n* ​`handler`​：表示当 `workQueue`​ 已满，且池中的线程数达到 `maximumPoolSize`​ 时，线程池拒绝添加新任务时采取的策略。一般可以采取以下四种取值。\n\n  1. 如果没有空闲的线程执行该任务且当前运行的线程数少于 `corePoolSize`​，则添加新的线程执行该任务。\n  2. 如果没有空闲的线程执行该任务且当前的线程数等于 `corePoolSize`​ 同时**阻塞队列未满**，则将任务入队列，而不添加新的线程。\n  3. 如果没有空闲的线程执行该任务且阻塞队列已满同时池中的线程数小于 `maximumPoolSize`​，则创建新的线程执行任务。\n  4. 如果没有空闲的线程执行该任务且阻塞队列已满同时池中的线程数等于 `maximumPoolSize`​，则根据构造函数中的 `handler`​ 指定的拒绝策略来拒绝新的任务。\n* ​`threadFactory`​：指定创建线程的工厂\n\n### 四种线程池拒绝策略\n\n#### `ThreadPoolExecutor.AbortPolicy()`​\n\n　　抛出 `RejectedExecutionException`​\n\n#### `ThreadPoolExecutor.CallerRunsPolicy()`​\n\n　　由向线程池提交任务的线程来执行该任务\n\n#### `ThreadPoolExecutor.DiscardOldestPolicy()`​\n\n　　抛弃最旧的任务（最先提交而没有得到执行的任务）\n\n#### `ThreadPoolExecutor.DiscardPolicy()`​\n\n　　抛弃当前的任务\n\n### 阻塞队列\n\n* ​`ArrayBlockingQueue`​：基于数组的阻塞队列实现，在ArrayBlockingQueue内部，维护了一个定长的数组，以便缓存队列中的数据对象，其内部没实现读写分离，也就意味着生产和消费者不能完全并行。长度是需要定义的，可以指定先进先出或者先进后出，因为长度是需要定义的，所以也叫有界队列，在很多场合非常适合使用。\n* ​`LinkedBlockingQueue`​：基于链表的阻塞队列，同ArrayBlockingQueue类似，其内部也维持着一个数据缓冲队列（该队列由一个链表构成），LinkedBlockingQueue之所以能够高效地处理并发数据，是因为其内部实现采用分离锁（读写分离两个锁），从而实现生产者和消费者操作完全并行运行。需要注意一下，它是一个无界队列。\n* ​`SynchronousQueue`​：一种没有缓冲的队列，生产者产生的数据直接会被消费者获取并且立刻消费。\n* ​`PriorityBlockingQueue`​：基于优先级别的阻塞队列（优先级的判断通过构造函数传入的Compator对象来决定，也就是说传入队列的对象必须实现Comparable接口），在实现PriorityBlockingQueue时，内部控制线程同步的锁采用的是公平锁，需要注意的是它也是一个无界的队列。\n* ​`DelayQueue`​：带有延迟时间的Queue，其中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素。DelayQueue中的元素必须先实现Delayed接口，DelayQueue是一个没有大小限制的队列，应用场景很多，比如对缓存超时的数据进行移除、任务超时处理、空闲连接的关闭等等\n\n​![image](/assets/image-20230519215732-zz9jpqo.png)​\n\n### 四种常用线程池（ExecutorService的实现类）\n\n　　ThreadPoolExecutor 构造函数的参数很多，使用起来很麻烦，为了方便的创建线程池，JavaSE 中又定义了 Executors 类，Eexcutors 类提供了四个创建线程池的方法，分别如下\n\n#### newCachedThreadPool\n\n　　该方法创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。\n此类型线程池特点是：\n\n1. .工作线程的创建数量几乎没有限制(其实也有限制的,数目为 Interger. MAX_VALUE)\n2. 空闲的工作线程会自动销毁，有新任务会重新创建\n3. 在使用 CachedThreadPool 时，一定要注意控制任务的数量，否则，由于大量线程同时运行，很有会造成系统瘫痪。\n\n#### newFixedThreadPool\n\n　　该方法创建一个指定工作线程数量的线程池。每当提交一个任务就创建一个工作线程，如果工作线程数量达到线程池初始的最大数，则将提交的任务存入到池队列中。\n优点：具有线程池提高程序效率和节省创建线程时所耗的开销。\n缺点：在线程池空闲时，即线程池中没有可运行任务时，它不会释放工作线程，还会占用一定的系统资源。\n\n#### newSingleThreadExecutor\n\n　　该方法创建一个单线程化的 Executor，即只创建唯一的工作者线程来执行任务，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO,优先级)执行。如果这个线程异常结束，会有另一个取代它，保证顺序执行。\n单工作线程最大的特点是可保证顺序地执行各个任务，并且在任意给定的时间不会有多个线程是活动的。\n\n#### newScheduleThreadPool\n\n　　该方法创建一个定长的线程池，而且支持定时的以及周期性的任务执行，支持定时及周期性任务执行。\n\n> FixedThreadPool、SingleThreadPool：使用的是无界队列（LinkedBlockingQueue），当任务堆积很多时，会占用大量内存，最终导致OOM。ChachedTheadPool：可以无限创建线程（Integer.MAX_VALUE），任务过多时会导致创建线程达到操作系统上线或者发生OOM。ScheduledThreadPool、SingleThreadScheduledPool：使用的是DelayedWorkQueue队列，实质上也是一种无界队列，会导致OOM。\n\n## 问题\n\n### 为什么java的线程池当核心线程满了以后,先往blockingQueue中存任务,queue满了以后\n\n　　起到一个缓冲的作用。最大线程数这个参数更像是无奈之举，在最坏的情况下做最后的努力，去新建线程去帮助消化任务。但是这种情况可能存在丢任务的情况。\n","slug":"java-thread-线程池","published":1,"updated":"2025-04-22T07:27:29.941Z","_id":"cm9s3f40n0034bfg42z1u6wyi","comments":1,"layout":"post","photos":[],"content":"<h1>线程池</h1>\n<h2 id=\"线程池\">线程池</h2>\n<ol>\n<li>Executor 接口：<br>\n声明了 execute(Runnable runnable)方法，执行任务代码</li>\n<li>ExecutorService 接口：<br>\n继承 Executor 接口，声明方法：submit、invokeAll、invokeAny 以及 shutDown 等</li>\n<li>AbstractExecutorService 抽象类：<br>\n实现 ExecutorService 接口，基本实现 ExecutorService 中声明的所有方法</li>\n<li>ScheduledExecutorService 接口：<br>\n继承 ExecutorService 接口，声明定时执行任务方法</li>\n<li>ThreadPoolExecutor 类：<br>\n继承类 AbstractExecutorService，实现 execute、submit、shutdown、shutdownNow 方法</li>\n<li>ScheduledThreadPoolExecutor 类：<br>\n继承 ThreadPoolExecutor 类，实现 ScheduledExecutorService 接口并实现其中的方法</li>\n<li>Executors 类：<br>\n提供快速创建线程池的方法</li>\n</ol>\n<h2 id=\"Executor-框架与线程池\">Executor 框架与线程池</h2>\n<p>Executor 框架包括：线程池，Executor，Executors，ExecutorService，CompletionService，Future，Callable 等</p>\n<p>Executor 接口中之定义了一个方法 execute（Runnable command），该方法接收一个 Runable 实例，它用来执行一个任务</p>\n<p>ExecutorService 接口继承自 Executor 接口，它提供了更丰富的实现多线程的方法，比如</p>\n<ol>\n<li>submit()方法可以返回Future对象，可以调用isDone()方法查询Future是否已完成，当任务完成时，它具有一个结果，可以通过get()方法获取到该结果，Future提供了cancel()方法用来取消执行pending中的任务。</li>\n<li>shutdown()方法允许之前已经提交的任务执行完毕之后再挂起关闭，shutdownNow()方法则阻止正在等待的任务启动，并尝试停止之前正在执行的任务。</li>\n</ol>\n<p><strong>多线程的缺点：</strong></p>\n<ul>\n<li>处理任务的线程创建和销毁都非常耗时并消耗资源。</li>\n<li>多线程之间的切换也会非常耗时并消耗资源。<br>\n<strong>解决方法：采用线程池</strong></li>\n<li>使用时线程已存在，消除了线程创建的时耗</li>\n<li>通过设置线程数目，防止资源不足</li>\n</ul>\n<h3 id=\"ThreadPoolExecutor-的全参构造函数参数\">ThreadPoolExecutor 的全参构造函数参数</h3>\n<p>在 Java 中创建线程池常用的类是 ThreadPoolExecutor，该类的全参构造函数如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">ThreadPoolExecutor</span><span class=\"params\">(<span class=\"type\">int</span> corePoolSize,</span></span><br><span class=\"line\"><span class=\"params\">                          <span class=\"type\">int</span> maximumPoolSize,</span></span><br><span class=\"line\"><span class=\"params\">                          <span class=\"type\">long</span> keepAliveTime,</span></span><br><span class=\"line\"><span class=\"params\">                          TimeUnit unit,</span></span><br><span class=\"line\"><span class=\"params\">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class=\"line\"><span class=\"params\">                          ThreadFactory threadFactory,</span></span><br><span class=\"line\"><span class=\"params\">                          RejectedExecutionHandler handler)</span> &#123;</span><br></pre></td></tr></table></figure>\n<p>参数介绍：</p>\n<ul>\n<li>\n<p>​<code>corePoolSize</code>​：线程池中核心线程数的最大值</p>\n</li>\n<li>\n<p>​<code>maximumPoolSize</code>​：线程池中能拥有最多线程数</p>\n</li>\n<li>\n<p>​<code>workQueue</code>​：用于缓存任务的阻塞队列，对于不同的应用场景我们可能会采取不同的排队策略，这就需要不同类型的阻塞队列，在线程池中常用的阻塞队列有以下 2 种：</p>\n<ul>\n<li>​<code>SynchronousQueue&lt;Runnable&gt;</code>​：此队列中不缓存任何一个任务。向线程池提交任务时，如果没有空闲线程来运行任务，则入列操作会阻塞。当有线程来获取任务时，出列操作会唤醒执行入列操作的线程。从这个特性来看，<code>SynchronousQueue</code>​ 是一个无界队列，因此当使用 <code>SynchronousQueue</code>​ 作为线程池的阻塞队列时，参数 <code>maximumPoolSizes</code>​ 没有任何作用。</li>\n<li>​<code>LinkedBlockingQueue&lt;Runnable&gt;</code>​：顾名思义是用链表实现的队列，可以是有界的，也可以是无界的，但在 <code>Executors</code>​ 中默认使用无界的。</li>\n</ul>\n</li>\n<li>\n<p>​<code>keepAliveTime</code>​：表示空闲线程的存活时间。</p>\n</li>\n<li>\n<p>​<code>unit</code>​：表示 <code>keepAliveTime</code>​ 的单位。</p>\n</li>\n<li>\n<p>​<code>handler</code>​：表示当 <code>workQueue</code>​ 已满，且池中的线程数达到 <code>maximumPoolSize</code>​ 时，线程池拒绝添加新任务时采取的策略。一般可以采取以下四种取值。</p>\n<ol>\n<li>如果没有空闲的线程执行该任务且当前运行的线程数少于 <code>corePoolSize</code>​，则添加新的线程执行该任务。</li>\n<li>如果没有空闲的线程执行该任务且当前的线程数等于 <code>corePoolSize</code>​ 同时<strong>阻塞队列未满</strong>，则将任务入队列，而不添加新的线程。</li>\n<li>如果没有空闲的线程执行该任务且阻塞队列已满同时池中的线程数小于 <code>maximumPoolSize</code>​，则创建新的线程执行任务。</li>\n<li>如果没有空闲的线程执行该任务且阻塞队列已满同时池中的线程数等于 <code>maximumPoolSize</code>​，则根据构造函数中的 <code>handler</code>​ 指定的拒绝策略来拒绝新的任务。</li>\n</ol>\n</li>\n<li>\n<p>​<code>threadFactory</code>​：指定创建线程的工厂</p>\n</li>\n</ul>\n<h3 id=\"四种线程池拒绝策略\">四种线程池拒绝策略</h3>\n<h4 id=\"ThreadPoolExecutor-AbortPolicy-​\"><code>ThreadPoolExecutor.AbortPolicy()</code>​</h4>\n<p>抛出 <code>RejectedExecutionException</code>​</p>\n<h4 id=\"ThreadPoolExecutor-CallerRunsPolicy-​\"><code>ThreadPoolExecutor.CallerRunsPolicy()</code>​</h4>\n<p>由向线程池提交任务的线程来执行该任务</p>\n<h4 id=\"ThreadPoolExecutor-DiscardOldestPolicy-​\"><code>ThreadPoolExecutor.DiscardOldestPolicy()</code>​</h4>\n<p>抛弃最旧的任务（最先提交而没有得到执行的任务）</p>\n<h4 id=\"ThreadPoolExecutor-DiscardPolicy-​\"><code>ThreadPoolExecutor.DiscardPolicy()</code>​</h4>\n<p>抛弃当前的任务</p>\n<h3 id=\"阻塞队列\">阻塞队列</h3>\n<ul>\n<li>​<code>ArrayBlockingQueue</code>​：基于数组的阻塞队列实现，在ArrayBlockingQueue内部，维护了一个定长的数组，以便缓存队列中的数据对象，其内部没实现读写分离，也就意味着生产和消费者不能完全并行。长度是需要定义的，可以指定先进先出或者先进后出，因为长度是需要定义的，所以也叫有界队列，在很多场合非常适合使用。</li>\n<li>​<code>LinkedBlockingQueue</code>​：基于链表的阻塞队列，同ArrayBlockingQueue类似，其内部也维持着一个数据缓冲队列（该队列由一个链表构成），LinkedBlockingQueue之所以能够高效地处理并发数据，是因为其内部实现采用分离锁（读写分离两个锁），从而实现生产者和消费者操作完全并行运行。需要注意一下，它是一个无界队列。</li>\n<li>​<code>SynchronousQueue</code>​：一种没有缓冲的队列，生产者产生的数据直接会被消费者获取并且立刻消费。</li>\n<li>​<code>PriorityBlockingQueue</code>​：基于优先级别的阻塞队列（优先级的判断通过构造函数传入的Compator对象来决定，也就是说传入队列的对象必须实现Comparable接口），在实现PriorityBlockingQueue时，内部控制线程同步的锁采用的是公平锁，需要注意的是它也是一个无界的队列。</li>\n<li>​<code>DelayQueue</code>​：带有延迟时间的Queue，其中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素。DelayQueue中的元素必须先实现Delayed接口，DelayQueue是一个没有大小限制的队列，应用场景很多，比如对缓存超时的数据进行移除、任务超时处理、空闲连接的关闭等等</li>\n</ul>\n<p>​<img src=\"/assets/image-20230519215732-zz9jpqo.png\" alt=\"image\">​</p>\n<h3 id=\"四种常用线程池（ExecutorService的实现类）\">四种常用线程池（ExecutorService的实现类）</h3>\n<p>ThreadPoolExecutor 构造函数的参数很多，使用起来很麻烦，为了方便的创建线程池，JavaSE 中又定义了 Executors 类，Eexcutors 类提供了四个创建线程池的方法，分别如下</p>\n<h4 id=\"newCachedThreadPool\">newCachedThreadPool</h4>\n<p>该方法创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。<br>\n此类型线程池特点是：</p>\n<ol>\n<li>.工作线程的创建数量几乎没有限制(其实也有限制的,数目为 Interger. MAX_VALUE)</li>\n<li>空闲的工作线程会自动销毁，有新任务会重新创建</li>\n<li>在使用 CachedThreadPool 时，一定要注意控制任务的数量，否则，由于大量线程同时运行，很有会造成系统瘫痪。</li>\n</ol>\n<h4 id=\"newFixedThreadPool\">newFixedThreadPool</h4>\n<p>该方法创建一个指定工作线程数量的线程池。每当提交一个任务就创建一个工作线程，如果工作线程数量达到线程池初始的最大数，则将提交的任务存入到池队列中。<br>\n优点：具有线程池提高程序效率和节省创建线程时所耗的开销。<br>\n缺点：在线程池空闲时，即线程池中没有可运行任务时，它不会释放工作线程，还会占用一定的系统资源。</p>\n<h4 id=\"newSingleThreadExecutor\">newSingleThreadExecutor</h4>\n<p>该方法创建一个单线程化的 Executor，即只创建唯一的工作者线程来执行任务，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO,优先级)执行。如果这个线程异常结束，会有另一个取代它，保证顺序执行。<br>\n单工作线程最大的特点是可保证顺序地执行各个任务，并且在任意给定的时间不会有多个线程是活动的。</p>\n<h4 id=\"newScheduleThreadPool\">newScheduleThreadPool</h4>\n<p>该方法创建一个定长的线程池，而且支持定时的以及周期性的任务执行，支持定时及周期性任务执行。</p>\n<blockquote>\n<p>FixedThreadPool、SingleThreadPool：使用的是无界队列（LinkedBlockingQueue），当任务堆积很多时，会占用大量内存，最终导致OOM。ChachedTheadPool：可以无限创建线程（Integer.MAX_VALUE），任务过多时会导致创建线程达到操作系统上线或者发生OOM。ScheduledThreadPool、SingleThreadScheduledPool：使用的是DelayedWorkQueue队列，实质上也是一种无界队列，会导致OOM。</p>\n</blockquote>\n<h2 id=\"问题\">问题</h2>\n<h3 id=\"为什么java的线程池当核心线程满了以后-先往blockingQueue中存任务-queue满了以后\">为什么java的线程池当核心线程满了以后,先往blockingQueue中存任务,queue满了以后</h3>\n<p>起到一个缓冲的作用。最大线程数这个参数更像是无奈之举，在最坏的情况下做最后的努力，去新建线程去帮助消化任务。但是这种情况可能存在丢任务的情况。</p>\n","excerpt":"","more":"<h1>线程池</h1>\n<h2 id=\"线程池\">线程池</h2>\n<ol>\n<li>Executor 接口：<br>\n声明了 execute(Runnable runnable)方法，执行任务代码</li>\n<li>ExecutorService 接口：<br>\n继承 Executor 接口，声明方法：submit、invokeAll、invokeAny 以及 shutDown 等</li>\n<li>AbstractExecutorService 抽象类：<br>\n实现 ExecutorService 接口，基本实现 ExecutorService 中声明的所有方法</li>\n<li>ScheduledExecutorService 接口：<br>\n继承 ExecutorService 接口，声明定时执行任务方法</li>\n<li>ThreadPoolExecutor 类：<br>\n继承类 AbstractExecutorService，实现 execute、submit、shutdown、shutdownNow 方法</li>\n<li>ScheduledThreadPoolExecutor 类：<br>\n继承 ThreadPoolExecutor 类，实现 ScheduledExecutorService 接口并实现其中的方法</li>\n<li>Executors 类：<br>\n提供快速创建线程池的方法</li>\n</ol>\n<h2 id=\"Executor-框架与线程池\">Executor 框架与线程池</h2>\n<p>Executor 框架包括：线程池，Executor，Executors，ExecutorService，CompletionService，Future，Callable 等</p>\n<p>Executor 接口中之定义了一个方法 execute（Runnable command），该方法接收一个 Runable 实例，它用来执行一个任务</p>\n<p>ExecutorService 接口继承自 Executor 接口，它提供了更丰富的实现多线程的方法，比如</p>\n<ol>\n<li>submit()方法可以返回Future对象，可以调用isDone()方法查询Future是否已完成，当任务完成时，它具有一个结果，可以通过get()方法获取到该结果，Future提供了cancel()方法用来取消执行pending中的任务。</li>\n<li>shutdown()方法允许之前已经提交的任务执行完毕之后再挂起关闭，shutdownNow()方法则阻止正在等待的任务启动，并尝试停止之前正在执行的任务。</li>\n</ol>\n<p><strong>多线程的缺点：</strong></p>\n<ul>\n<li>处理任务的线程创建和销毁都非常耗时并消耗资源。</li>\n<li>多线程之间的切换也会非常耗时并消耗资源。<br>\n<strong>解决方法：采用线程池</strong></li>\n<li>使用时线程已存在，消除了线程创建的时耗</li>\n<li>通过设置线程数目，防止资源不足</li>\n</ul>\n<h3 id=\"ThreadPoolExecutor-的全参构造函数参数\">ThreadPoolExecutor 的全参构造函数参数</h3>\n<p>在 Java 中创建线程池常用的类是 ThreadPoolExecutor，该类的全参构造函数如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">ThreadPoolExecutor</span><span class=\"params\">(<span class=\"type\">int</span> corePoolSize,</span></span><br><span class=\"line\"><span class=\"params\">                          <span class=\"type\">int</span> maximumPoolSize,</span></span><br><span class=\"line\"><span class=\"params\">                          <span class=\"type\">long</span> keepAliveTime,</span></span><br><span class=\"line\"><span class=\"params\">                          TimeUnit unit,</span></span><br><span class=\"line\"><span class=\"params\">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class=\"line\"><span class=\"params\">                          ThreadFactory threadFactory,</span></span><br><span class=\"line\"><span class=\"params\">                          RejectedExecutionHandler handler)</span> &#123;</span><br></pre></td></tr></table></figure>\n<p>参数介绍：</p>\n<ul>\n<li>\n<p>​<code>corePoolSize</code>​：线程池中核心线程数的最大值</p>\n</li>\n<li>\n<p>​<code>maximumPoolSize</code>​：线程池中能拥有最多线程数</p>\n</li>\n<li>\n<p>​<code>workQueue</code>​：用于缓存任务的阻塞队列，对于不同的应用场景我们可能会采取不同的排队策略，这就需要不同类型的阻塞队列，在线程池中常用的阻塞队列有以下 2 种：</p>\n<ul>\n<li>​<code>SynchronousQueue&lt;Runnable&gt;</code>​：此队列中不缓存任何一个任务。向线程池提交任务时，如果没有空闲线程来运行任务，则入列操作会阻塞。当有线程来获取任务时，出列操作会唤醒执行入列操作的线程。从这个特性来看，<code>SynchronousQueue</code>​ 是一个无界队列，因此当使用 <code>SynchronousQueue</code>​ 作为线程池的阻塞队列时，参数 <code>maximumPoolSizes</code>​ 没有任何作用。</li>\n<li>​<code>LinkedBlockingQueue&lt;Runnable&gt;</code>​：顾名思义是用链表实现的队列，可以是有界的，也可以是无界的，但在 <code>Executors</code>​ 中默认使用无界的。</li>\n</ul>\n</li>\n<li>\n<p>​<code>keepAliveTime</code>​：表示空闲线程的存活时间。</p>\n</li>\n<li>\n<p>​<code>unit</code>​：表示 <code>keepAliveTime</code>​ 的单位。</p>\n</li>\n<li>\n<p>​<code>handler</code>​：表示当 <code>workQueue</code>​ 已满，且池中的线程数达到 <code>maximumPoolSize</code>​ 时，线程池拒绝添加新任务时采取的策略。一般可以采取以下四种取值。</p>\n<ol>\n<li>如果没有空闲的线程执行该任务且当前运行的线程数少于 <code>corePoolSize</code>​，则添加新的线程执行该任务。</li>\n<li>如果没有空闲的线程执行该任务且当前的线程数等于 <code>corePoolSize</code>​ 同时<strong>阻塞队列未满</strong>，则将任务入队列，而不添加新的线程。</li>\n<li>如果没有空闲的线程执行该任务且阻塞队列已满同时池中的线程数小于 <code>maximumPoolSize</code>​，则创建新的线程执行任务。</li>\n<li>如果没有空闲的线程执行该任务且阻塞队列已满同时池中的线程数等于 <code>maximumPoolSize</code>​，则根据构造函数中的 <code>handler</code>​ 指定的拒绝策略来拒绝新的任务。</li>\n</ol>\n</li>\n<li>\n<p>​<code>threadFactory</code>​：指定创建线程的工厂</p>\n</li>\n</ul>\n<h3 id=\"四种线程池拒绝策略\">四种线程池拒绝策略</h3>\n<h4 id=\"ThreadPoolExecutor-AbortPolicy-​\"><code>ThreadPoolExecutor.AbortPolicy()</code>​</h4>\n<p>抛出 <code>RejectedExecutionException</code>​</p>\n<h4 id=\"ThreadPoolExecutor-CallerRunsPolicy-​\"><code>ThreadPoolExecutor.CallerRunsPolicy()</code>​</h4>\n<p>由向线程池提交任务的线程来执行该任务</p>\n<h4 id=\"ThreadPoolExecutor-DiscardOldestPolicy-​\"><code>ThreadPoolExecutor.DiscardOldestPolicy()</code>​</h4>\n<p>抛弃最旧的任务（最先提交而没有得到执行的任务）</p>\n<h4 id=\"ThreadPoolExecutor-DiscardPolicy-​\"><code>ThreadPoolExecutor.DiscardPolicy()</code>​</h4>\n<p>抛弃当前的任务</p>\n<h3 id=\"阻塞队列\">阻塞队列</h3>\n<ul>\n<li>​<code>ArrayBlockingQueue</code>​：基于数组的阻塞队列实现，在ArrayBlockingQueue内部，维护了一个定长的数组，以便缓存队列中的数据对象，其内部没实现读写分离，也就意味着生产和消费者不能完全并行。长度是需要定义的，可以指定先进先出或者先进后出，因为长度是需要定义的，所以也叫有界队列，在很多场合非常适合使用。</li>\n<li>​<code>LinkedBlockingQueue</code>​：基于链表的阻塞队列，同ArrayBlockingQueue类似，其内部也维持着一个数据缓冲队列（该队列由一个链表构成），LinkedBlockingQueue之所以能够高效地处理并发数据，是因为其内部实现采用分离锁（读写分离两个锁），从而实现生产者和消费者操作完全并行运行。需要注意一下，它是一个无界队列。</li>\n<li>​<code>SynchronousQueue</code>​：一种没有缓冲的队列，生产者产生的数据直接会被消费者获取并且立刻消费。</li>\n<li>​<code>PriorityBlockingQueue</code>​：基于优先级别的阻塞队列（优先级的判断通过构造函数传入的Compator对象来决定，也就是说传入队列的对象必须实现Comparable接口），在实现PriorityBlockingQueue时，内部控制线程同步的锁采用的是公平锁，需要注意的是它也是一个无界的队列。</li>\n<li>​<code>DelayQueue</code>​：带有延迟时间的Queue，其中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素。DelayQueue中的元素必须先实现Delayed接口，DelayQueue是一个没有大小限制的队列，应用场景很多，比如对缓存超时的数据进行移除、任务超时处理、空闲连接的关闭等等</li>\n</ul>\n<p>​<img src=\"/assets/image-20230519215732-zz9jpqo.png\" alt=\"image\">​</p>\n<h3 id=\"四种常用线程池（ExecutorService的实现类）\">四种常用线程池（ExecutorService的实现类）</h3>\n<p>ThreadPoolExecutor 构造函数的参数很多，使用起来很麻烦，为了方便的创建线程池，JavaSE 中又定义了 Executors 类，Eexcutors 类提供了四个创建线程池的方法，分别如下</p>\n<h4 id=\"newCachedThreadPool\">newCachedThreadPool</h4>\n<p>该方法创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。<br>\n此类型线程池特点是：</p>\n<ol>\n<li>.工作线程的创建数量几乎没有限制(其实也有限制的,数目为 Interger. MAX_VALUE)</li>\n<li>空闲的工作线程会自动销毁，有新任务会重新创建</li>\n<li>在使用 CachedThreadPool 时，一定要注意控制任务的数量，否则，由于大量线程同时运行，很有会造成系统瘫痪。</li>\n</ol>\n<h4 id=\"newFixedThreadPool\">newFixedThreadPool</h4>\n<p>该方法创建一个指定工作线程数量的线程池。每当提交一个任务就创建一个工作线程，如果工作线程数量达到线程池初始的最大数，则将提交的任务存入到池队列中。<br>\n优点：具有线程池提高程序效率和节省创建线程时所耗的开销。<br>\n缺点：在线程池空闲时，即线程池中没有可运行任务时，它不会释放工作线程，还会占用一定的系统资源。</p>\n<h4 id=\"newSingleThreadExecutor\">newSingleThreadExecutor</h4>\n<p>该方法创建一个单线程化的 Executor，即只创建唯一的工作者线程来执行任务，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO,优先级)执行。如果这个线程异常结束，会有另一个取代它，保证顺序执行。<br>\n单工作线程最大的特点是可保证顺序地执行各个任务，并且在任意给定的时间不会有多个线程是活动的。</p>\n<h4 id=\"newScheduleThreadPool\">newScheduleThreadPool</h4>\n<p>该方法创建一个定长的线程池，而且支持定时的以及周期性的任务执行，支持定时及周期性任务执行。</p>\n<blockquote>\n<p>FixedThreadPool、SingleThreadPool：使用的是无界队列（LinkedBlockingQueue），当任务堆积很多时，会占用大量内存，最终导致OOM。ChachedTheadPool：可以无限创建线程（Integer.MAX_VALUE），任务过多时会导致创建线程达到操作系统上线或者发生OOM。ScheduledThreadPool、SingleThreadScheduledPool：使用的是DelayedWorkQueue队列，实质上也是一种无界队列，会导致OOM。</p>\n</blockquote>\n<h2 id=\"问题\">问题</h2>\n<h3 id=\"为什么java的线程池当核心线程满了以后-先往blockingQueue中存任务-queue满了以后\">为什么java的线程池当核心线程满了以后,先往blockingQueue中存任务,queue满了以后</h3>\n<p>起到一个缓冲的作用。最大线程数这个参数更像是无奈之举，在最坏的情况下做最后的努力，去新建线程去帮助消化任务。但是这种情况可能存在丢任务的情况。</p>\n"},{"title":"并发处理","date":"2023-05-14T14:53:28.000Z","lastmod":"2023-05-14T14:33:08.000Z","_content":"\n# 并发处理 \n\n---\n\n## 多线程特性\n\n- 原子性\n  - 一个或多个操作要么全部执行并且执行过程中不会被任何因素打断，要么就不执行。\n- 可见性\n  - 当多个线程同时访问一个变量时，一个线程修改了这个变量，其他线程能够立即看见修改的值。单线程不存在可见性问题。\n- 有序型\n  - 程序的执行按照代码的先后顺序执行\n\n## 对象的发布和逸出\n\n### 发布\n\n> \"发布( Publish)\"一个对象的意思是指,使对象能够在当前作用域之外的代码中使用\n\n1. 一个指向该对象的引用保存到其他代码可以访问的地方\n\n```java\npublic class Person(){\n    private String name;\n    private int age;\n}\n\npublic class Record{\n    Person p;\n}\n\n```\n\n2. 在某一个非私有的方法中返回该引用\n\n```java\npublic class Person(){\n    private String name;\n    private int age;\n\n    public Person get(){\n        return new Person();\n    }\n}\n```\n\n3. 将引用传递到其他类的方法中\n\n```java\npublic class Person(){\n    private String name;\n    private int age;\n}\n\npublic class Record{\n    private void getPersonMessage(Person p){\n        .....\n    }\n}\n```\n\n### 逸出\n\n> 当某个不应该发布的对象被发布时,这种情况就被称为逸出( Escape).\n\n1. 内部的可变状态逸出\n\n```java\nclass UnsafeStates{\n    private String[] states = {\"AK\",\"AL\",...};\n    public String[] getStates(){\n        return states;\n    }\n}\n//数组states本事私有的变量，但是以public公有的方式发布出去，导致states已经逸出了它所在的作用域，任何调用者都能修改这个数组的内容\n```\n\n2. 隐式地使用this引用导致逸出\n\n```java\npublic class ThisEscape{\n    public ThisEscape(EventSource source){\n        source.registerListener(\n            new EventListener(){\n                public void onEvent(Event e){\n                    dosomething(e);\n                }\n            })\n        //在这里count初始化为1\n        count = 1;\n    }\n}\n//当ThisEscape发布EventListener时，也隐含地发布了ThisEscape实例本身。因为在这个内部类的实例中包含了对ThisEscape实例的隐含引用。\n//this逸出会导致ThisEscape也发布出去，也就是ThisEscape还没有构建完成就发布出去，也就是count=1;这一句还没执行就发布了ThisEscape对象，如果要使用count时,很有可能会出现对象不一致的状态\n```\n\n　　**使用工厂方法来防止this引用在构造函数过程中逸出**\n\n```java\npublic class SafeListener{\n    private final EventListener listener;\n    private SafeListener(){\n        listener = new EventListener(){\n            public void onEvent(Event e){\n                dosomething(e);\n            }\n        };\n    }\n    public static SafeListener newInstance(EventSource source){\n        SafeListener safe = new SafeListener();\n        source.registerListener(safe.listener);\n        return safe;\n    }\n}\n//保证在对象为构造完成之前，是不会发布该对象\n```\n\n## 线程封闭\n\n1. Ad-hoc线程封闭。\n\n> 维护线程封闭性的职责完全由程序实现承担，可用性不高。\n\n　　Ad-hoc 线程封闭下的一个特例适用于 volatile 变量。 只要确保 volatile 变量仅从单个线程写入，就可以安全地对共享 volatile 变量执读 - 改 - 写操作。\n\n2. 栈封闭。\n\n　　局部变量，无并发问题，在项目中使用最多，简单说就是局部变量，方法的变量都拷贝到线程的堆栈中，只有这个线程能访问到。尽量少使用全局变量（变量不是常量）\n\n3. ThreadLocal类。\n\n## 原子类\n\n　　Java 的 java.util.concurrent.atomic 包里面提供了很多可以进行原子操作的类，分为以下四类：\n\n- 原子更新基本类型：AtomicInteger、AtomicBoolean、AtomicLong\n- 原子更新数组：AtomicIntegerArray、AtomicLongArray\n- 原子更新引用：AtomicReference、AtomicStampedReference 等\n- 原子更新属性：AtomicIntegerFieldUpdater、AtomicLongFieldUpdater\n\n　　提供这些原子类的目的就是为了解决基本类型操作的非原子性导致在多线程并发情况下引发的问题。\n\n### 非原子问题演示\n\n　　i++并不是原子操作\n\n```java\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class AtomicClass {\n    static int n = 0;\n    public static void main(String[] args) throws InterruptedException {\n        int j = 0;\n        while(j<100){\n            n = 0;\n            Thread t1 = new Thread(){\n                public void run(){\n                    for(int i=0; i<1000; i++){\n                        n++;\n                    }\n                }\n            };\n            Thread t2 = new Thread(){\n                public void run(){\n                    for(int i=0; i<1000; i++){\n                        n++;\n                    }\n                }\n            };\n            t1.start();\n            t2.start();\n            t1.join();\n            t2.join();\n            System.out.println(\"n的最终值是：\"+n);\n            j++;\n        }\n\n    }\n}\n```\n\n　　结果不一定全是 2000\n\n### 非原子问题的原子解决\n\n```java\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class AtomicClass {\n    static AtomicInteger n;\n    public static void main(String[] args) throws InterruptedException {\n        int j = 0;\n        while(j<100){\n            n = new AtomicInteger(0);\n            Thread t1 = new Thread(){\n                public void run(){\n                    for(int i=0; i<1000; i++){\n                        n.getAndIncrement();\n                    }\n                }\n            };\n            Thread t2 = new Thread(){\n                public void run(){\n                    for(int i=0; i<1000; i++){\n                        n.getAndIncrement();\n                    }\n                }\n            };\n            t1.start();\n            t2.start();\n            t1.join();\n            t2.join();\n            System.out.println(\"n的最终值是：\"+n);\n            j++;\n        }\n\n    }\n}\n```\n\n　　**原理**\n\n![1-10.png](/assets/net-img-1582875462202-61de3608-d606-44f6-b8d0-c82da3a7acd8-20221030135541-a1152vd.png)\n\n### CAS 的 ABA 问题\n\n　　当前内存的值一开始是 A，被另外一个线程先改为 B 然后再改为 A，那么当前线程访问的时候发现是 A，则认为它没有被其他线程访问过。在某些场景下这样是存在错误风险的。如下图：\n\n![1-11.png](/assets/net-img-1582875470139-ea71ffbe-3cbd-44d8-8560-1e72b3a4bab4-20221030135541-hkuw6hs.png)\n\n### AtomicStampedReference 解决 ABA 问题\n\n```\nAtomicStampedReference(初始值，时间戳)：构造函数设置初始值和时间戳\ngetStamp：获取时间戳\ngetReference：获取预期值\ncompareAndSet(预期值，更新值，预期时间戳，更新时间戳)：实现CAS时间戳和预期值对比\n```\n\n```java\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.atomic.AtomicStampedReference;\n\npublic class AtomicClass {\n    static AtomicStampedReference<Integer> n;\n    public static void main(String[] args) throws InterruptedException {\n        int j = 0;\n        while(j<100){\n            n = new AtomicStampedReference<Integer>(0,0);\n            Thread t1 = new Thread(){\n                public void run(){\n                    for(int i=0; i<1000; i++){\n                        int stamp;\n                        Integer reference;\n                        do{\n                            stamp = n.getStamp();\n                            reference = n.getReference();\n                        } while(!n.compareAndSet(reference, reference+1, stamp, stamp+1));\n                    }\n                }\n            };\n            Thread t2 = new Thread(){\n                public void run(){\n                    for(int i=0; i<1000; i++){\n                        int stamp;\n                        Integer reference;\n                        do{\n                            stamp = n.getStamp();\n                            reference = n.getReference();\n\n                        } while(!n.compareAndSet(reference, reference+1, stamp, stamp+1));\n                    }\n                }\n            };\n            t1.start();\n            t2.start();\n            t1.join();\n            t2.join();\n            System.out.println(\"n的最终值是：\"+n.getReference());\n            j++;\n        }\n\n    }\n}\n```\n\n　　**注意：采用 AtomicStampedReference 会降低性能，慎用。**\n\n　　‍\n","source":"_posts/java/thread/并发处理.md","raw":"---\ntitle: 并发处理 \ndate: 2023-05-14T22:53:28Z\nlastmod: 2023-05-14T22:33:08Z\n---\n\n# 并发处理 \n\n---\n\n## 多线程特性\n\n- 原子性\n  - 一个或多个操作要么全部执行并且执行过程中不会被任何因素打断，要么就不执行。\n- 可见性\n  - 当多个线程同时访问一个变量时，一个线程修改了这个变量，其他线程能够立即看见修改的值。单线程不存在可见性问题。\n- 有序型\n  - 程序的执行按照代码的先后顺序执行\n\n## 对象的发布和逸出\n\n### 发布\n\n> \"发布( Publish)\"一个对象的意思是指,使对象能够在当前作用域之外的代码中使用\n\n1. 一个指向该对象的引用保存到其他代码可以访问的地方\n\n```java\npublic class Person(){\n    private String name;\n    private int age;\n}\n\npublic class Record{\n    Person p;\n}\n\n```\n\n2. 在某一个非私有的方法中返回该引用\n\n```java\npublic class Person(){\n    private String name;\n    private int age;\n\n    public Person get(){\n        return new Person();\n    }\n}\n```\n\n3. 将引用传递到其他类的方法中\n\n```java\npublic class Person(){\n    private String name;\n    private int age;\n}\n\npublic class Record{\n    private void getPersonMessage(Person p){\n        .....\n    }\n}\n```\n\n### 逸出\n\n> 当某个不应该发布的对象被发布时,这种情况就被称为逸出( Escape).\n\n1. 内部的可变状态逸出\n\n```java\nclass UnsafeStates{\n    private String[] states = {\"AK\",\"AL\",...};\n    public String[] getStates(){\n        return states;\n    }\n}\n//数组states本事私有的变量，但是以public公有的方式发布出去，导致states已经逸出了它所在的作用域，任何调用者都能修改这个数组的内容\n```\n\n2. 隐式地使用this引用导致逸出\n\n```java\npublic class ThisEscape{\n    public ThisEscape(EventSource source){\n        source.registerListener(\n            new EventListener(){\n                public void onEvent(Event e){\n                    dosomething(e);\n                }\n            })\n        //在这里count初始化为1\n        count = 1;\n    }\n}\n//当ThisEscape发布EventListener时，也隐含地发布了ThisEscape实例本身。因为在这个内部类的实例中包含了对ThisEscape实例的隐含引用。\n//this逸出会导致ThisEscape也发布出去，也就是ThisEscape还没有构建完成就发布出去，也就是count=1;这一句还没执行就发布了ThisEscape对象，如果要使用count时,很有可能会出现对象不一致的状态\n```\n\n　　**使用工厂方法来防止this引用在构造函数过程中逸出**\n\n```java\npublic class SafeListener{\n    private final EventListener listener;\n    private SafeListener(){\n        listener = new EventListener(){\n            public void onEvent(Event e){\n                dosomething(e);\n            }\n        };\n    }\n    public static SafeListener newInstance(EventSource source){\n        SafeListener safe = new SafeListener();\n        source.registerListener(safe.listener);\n        return safe;\n    }\n}\n//保证在对象为构造完成之前，是不会发布该对象\n```\n\n## 线程封闭\n\n1. Ad-hoc线程封闭。\n\n> 维护线程封闭性的职责完全由程序实现承担，可用性不高。\n\n　　Ad-hoc 线程封闭下的一个特例适用于 volatile 变量。 只要确保 volatile 变量仅从单个线程写入，就可以安全地对共享 volatile 变量执读 - 改 - 写操作。\n\n2. 栈封闭。\n\n　　局部变量，无并发问题，在项目中使用最多，简单说就是局部变量，方法的变量都拷贝到线程的堆栈中，只有这个线程能访问到。尽量少使用全局变量（变量不是常量）\n\n3. ThreadLocal类。\n\n## 原子类\n\n　　Java 的 java.util.concurrent.atomic 包里面提供了很多可以进行原子操作的类，分为以下四类：\n\n- 原子更新基本类型：AtomicInteger、AtomicBoolean、AtomicLong\n- 原子更新数组：AtomicIntegerArray、AtomicLongArray\n- 原子更新引用：AtomicReference、AtomicStampedReference 等\n- 原子更新属性：AtomicIntegerFieldUpdater、AtomicLongFieldUpdater\n\n　　提供这些原子类的目的就是为了解决基本类型操作的非原子性导致在多线程并发情况下引发的问题。\n\n### 非原子问题演示\n\n　　i++并不是原子操作\n\n```java\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class AtomicClass {\n    static int n = 0;\n    public static void main(String[] args) throws InterruptedException {\n        int j = 0;\n        while(j<100){\n            n = 0;\n            Thread t1 = new Thread(){\n                public void run(){\n                    for(int i=0; i<1000; i++){\n                        n++;\n                    }\n                }\n            };\n            Thread t2 = new Thread(){\n                public void run(){\n                    for(int i=0; i<1000; i++){\n                        n++;\n                    }\n                }\n            };\n            t1.start();\n            t2.start();\n            t1.join();\n            t2.join();\n            System.out.println(\"n的最终值是：\"+n);\n            j++;\n        }\n\n    }\n}\n```\n\n　　结果不一定全是 2000\n\n### 非原子问题的原子解决\n\n```java\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class AtomicClass {\n    static AtomicInteger n;\n    public static void main(String[] args) throws InterruptedException {\n        int j = 0;\n        while(j<100){\n            n = new AtomicInteger(0);\n            Thread t1 = new Thread(){\n                public void run(){\n                    for(int i=0; i<1000; i++){\n                        n.getAndIncrement();\n                    }\n                }\n            };\n            Thread t2 = new Thread(){\n                public void run(){\n                    for(int i=0; i<1000; i++){\n                        n.getAndIncrement();\n                    }\n                }\n            };\n            t1.start();\n            t2.start();\n            t1.join();\n            t2.join();\n            System.out.println(\"n的最终值是：\"+n);\n            j++;\n        }\n\n    }\n}\n```\n\n　　**原理**\n\n![1-10.png](/assets/net-img-1582875462202-61de3608-d606-44f6-b8d0-c82da3a7acd8-20221030135541-a1152vd.png)\n\n### CAS 的 ABA 问题\n\n　　当前内存的值一开始是 A，被另外一个线程先改为 B 然后再改为 A，那么当前线程访问的时候发现是 A，则认为它没有被其他线程访问过。在某些场景下这样是存在错误风险的。如下图：\n\n![1-11.png](/assets/net-img-1582875470139-ea71ffbe-3cbd-44d8-8560-1e72b3a4bab4-20221030135541-hkuw6hs.png)\n\n### AtomicStampedReference 解决 ABA 问题\n\n```\nAtomicStampedReference(初始值，时间戳)：构造函数设置初始值和时间戳\ngetStamp：获取时间戳\ngetReference：获取预期值\ncompareAndSet(预期值，更新值，预期时间戳，更新时间戳)：实现CAS时间戳和预期值对比\n```\n\n```java\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.atomic.AtomicStampedReference;\n\npublic class AtomicClass {\n    static AtomicStampedReference<Integer> n;\n    public static void main(String[] args) throws InterruptedException {\n        int j = 0;\n        while(j<100){\n            n = new AtomicStampedReference<Integer>(0,0);\n            Thread t1 = new Thread(){\n                public void run(){\n                    for(int i=0; i<1000; i++){\n                        int stamp;\n                        Integer reference;\n                        do{\n                            stamp = n.getStamp();\n                            reference = n.getReference();\n                        } while(!n.compareAndSet(reference, reference+1, stamp, stamp+1));\n                    }\n                }\n            };\n            Thread t2 = new Thread(){\n                public void run(){\n                    for(int i=0; i<1000; i++){\n                        int stamp;\n                        Integer reference;\n                        do{\n                            stamp = n.getStamp();\n                            reference = n.getReference();\n\n                        } while(!n.compareAndSet(reference, reference+1, stamp, stamp+1));\n                    }\n                }\n            };\n            t1.start();\n            t2.start();\n            t1.join();\n            t2.join();\n            System.out.println(\"n的最终值是：\"+n.getReference());\n            j++;\n        }\n\n    }\n}\n```\n\n　　**注意：采用 AtomicStampedReference 会降低性能，慎用。**\n\n　　‍\n","slug":"java-thread-并发处理","published":1,"updated":"2025-04-22T07:27:29.941Z","_id":"cm9s3f40o0035bfg4bcv4fem0","comments":1,"layout":"post","photos":[],"content":"<h1>并发处理</h1>\n<hr>\n<h2 id=\"多线程特性\">多线程特性</h2>\n<ul>\n<li>原子性\n<ul>\n<li>一个或多个操作要么全部执行并且执行过程中不会被任何因素打断，要么就不执行。</li>\n</ul>\n</li>\n<li>可见性\n<ul>\n<li>当多个线程同时访问一个变量时，一个线程修改了这个变量，其他线程能够立即看见修改的值。单线程不存在可见性问题。</li>\n</ul>\n</li>\n<li>有序型\n<ul>\n<li>程序的执行按照代码的先后顺序执行</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"对象的发布和逸出\">对象的发布和逸出</h2>\n<h3 id=\"发布\">发布</h3>\n<blockquote>\n<p>&quot;发布( Publish)&quot;一个对象的意思是指,使对象能够在当前作用域之外的代码中使用</p>\n</blockquote>\n<ol>\n<li>一个指向该对象的引用保存到其他代码可以访问的地方</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Person</span>()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> age;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Record</span>&#123;</span><br><span class=\"line\">    Person p;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>在某一个非私有的方法中返回该引用</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Person</span>()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> age;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Person <span class=\"title function_\">get</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Person</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>将引用传递到其他类的方法中</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Person</span>()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> age;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Record</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">getPersonMessage</span><span class=\"params\">(Person p)</span>&#123;</span><br><span class=\"line\">        .....</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"逸出\">逸出</h3>\n<blockquote>\n<p>当某个不应该发布的对象被发布时,这种情况就被称为逸出( Escape).</p>\n</blockquote>\n<ol>\n<li>内部的可变状态逸出</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">UnsafeStates</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String[] states = &#123;<span class=\"string\">&quot;AK&quot;</span>,<span class=\"string\">&quot;AL&quot;</span>,...&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String[] getStates()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> states;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//数组states本事私有的变量，但是以public公有的方式发布出去，导致states已经逸出了它所在的作用域，任何调用者都能修改这个数组的内容</span></span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>隐式地使用this引用导致逸出</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ThisEscape</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">ThisEscape</span><span class=\"params\">(EventSource source)</span>&#123;</span><br><span class=\"line\">        source.registerListener(</span><br><span class=\"line\">            <span class=\"keyword\">new</span> <span class=\"title class_\">EventListener</span>()&#123;</span><br><span class=\"line\">                <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onEvent</span><span class=\"params\">(Event e)</span>&#123;</span><br><span class=\"line\">                    dosomething(e);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        <span class=\"comment\">//在这里count初始化为1</span></span><br><span class=\"line\">        count = <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//当ThisEscape发布EventListener时，也隐含地发布了ThisEscape实例本身。因为在这个内部类的实例中包含了对ThisEscape实例的隐含引用。</span></span><br><span class=\"line\"><span class=\"comment\">//this逸出会导致ThisEscape也发布出去，也就是ThisEscape还没有构建完成就发布出去，也就是count=1;这一句还没执行就发布了ThisEscape对象，如果要使用count时,很有可能会出现对象不一致的状态</span></span><br></pre></td></tr></table></figure>\n<p><strong>使用工厂方法来防止this引用在构造函数过程中逸出</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SafeListener</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> EventListener listener;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">SafeListener</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        listener = <span class=\"keyword\">new</span> <span class=\"title class_\">EventListener</span>()&#123;</span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onEvent</span><span class=\"params\">(Event e)</span>&#123;</span><br><span class=\"line\">                dosomething(e);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> SafeListener <span class=\"title function_\">newInstance</span><span class=\"params\">(EventSource source)</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">SafeListener</span> <span class=\"variable\">safe</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SafeListener</span>();</span><br><span class=\"line\">        source.registerListener(safe.listener);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> safe;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//保证在对象为构造完成之前，是不会发布该对象</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"线程封闭\">线程封闭</h2>\n<ol>\n<li>Ad-hoc线程封闭。</li>\n</ol>\n<blockquote>\n<p>维护线程封闭性的职责完全由程序实现承担，可用性不高。</p>\n</blockquote>\n<p>Ad-hoc 线程封闭下的一个特例适用于 volatile 变量。 只要确保 volatile 变量仅从单个线程写入，就可以安全地对共享 volatile 变量执读 - 改 - 写操作。</p>\n<ol start=\"2\">\n<li>栈封闭。</li>\n</ol>\n<p>局部变量，无并发问题，在项目中使用最多，简单说就是局部变量，方法的变量都拷贝到线程的堆栈中，只有这个线程能访问到。尽量少使用全局变量（变量不是常量）</p>\n<ol start=\"3\">\n<li>ThreadLocal类。</li>\n</ol>\n<h2 id=\"原子类\">原子类</h2>\n<p>Java 的 java.util.concurrent.atomic 包里面提供了很多可以进行原子操作的类，分为以下四类：</p>\n<ul>\n<li>原子更新基本类型：AtomicInteger、AtomicBoolean、AtomicLong</li>\n<li>原子更新数组：AtomicIntegerArray、AtomicLongArray</li>\n<li>原子更新引用：AtomicReference、AtomicStampedReference 等</li>\n<li>原子更新属性：AtomicIntegerFieldUpdater、AtomicLongFieldUpdater</li>\n</ul>\n<p>提供这些原子类的目的就是为了解决基本类型操作的非原子性导致在多线程并发情况下引发的问题。</p>\n<h3 id=\"非原子问题演示\">非原子问题演示</h3>\n<p>i++并不是原子操作</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AtomicClass</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(j&lt;<span class=\"number\">100</span>)&#123;</span><br><span class=\"line\">            n = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"type\">Thread</span> <span class=\"variable\">t1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>()&#123;</span><br><span class=\"line\">                <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">1000</span>; i++)&#123;</span><br><span class=\"line\">                        n++;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">            <span class=\"type\">Thread</span> <span class=\"variable\">t2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>()&#123;</span><br><span class=\"line\">                <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">1000</span>; i++)&#123;</span><br><span class=\"line\">                        n++;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">            t1.start();</span><br><span class=\"line\">            t2.start();</span><br><span class=\"line\">            t1.join();</span><br><span class=\"line\">            t2.join();</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;n的最终值是：&quot;</span>+n);</span><br><span class=\"line\">            j++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>结果不一定全是 2000</p>\n<h3 id=\"非原子问题的原子解决\">非原子问题的原子解决</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AtomicClass</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> AtomicInteger n;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(j&lt;<span class=\"number\">100</span>)&#123;</span><br><span class=\"line\">            n = <span class=\"keyword\">new</span> <span class=\"title class_\">AtomicInteger</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">            <span class=\"type\">Thread</span> <span class=\"variable\">t1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>()&#123;</span><br><span class=\"line\">                <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">1000</span>; i++)&#123;</span><br><span class=\"line\">                        n.getAndIncrement();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">            <span class=\"type\">Thread</span> <span class=\"variable\">t2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>()&#123;</span><br><span class=\"line\">                <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">1000</span>; i++)&#123;</span><br><span class=\"line\">                        n.getAndIncrement();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">            t1.start();</span><br><span class=\"line\">            t2.start();</span><br><span class=\"line\">            t1.join();</span><br><span class=\"line\">            t2.join();</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;n的最终值是：&quot;</span>+n);</span><br><span class=\"line\">            j++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>原理</strong></p>\n<p><img src=\"/assets/net-img-1582875462202-61de3608-d606-44f6-b8d0-c82da3a7acd8-20221030135541-a1152vd.png\" alt=\"1-10.png\"></p>\n<h3 id=\"CAS-的-ABA-问题\">CAS 的 ABA 问题</h3>\n<p>当前内存的值一开始是 A，被另外一个线程先改为 B 然后再改为 A，那么当前线程访问的时候发现是 A，则认为它没有被其他线程访问过。在某些场景下这样是存在错误风险的。如下图：</p>\n<p><img src=\"/assets/net-img-1582875470139-ea71ffbe-3cbd-44d8-8560-1e72b3a4bab4-20221030135541-hkuw6hs.png\" alt=\"1-11.png\"></p>\n<h3 id=\"AtomicStampedReference-解决-ABA-问题\">AtomicStampedReference 解决 ABA 问题</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AtomicStampedReference(初始值，时间戳)：构造函数设置初始值和时间戳</span><br><span class=\"line\">getStamp：获取时间戳</span><br><span class=\"line\">getReference：获取预期值</span><br><span class=\"line\">compareAndSet(预期值，更新值，预期时间戳，更新时间戳)：实现CAS时间戳和预期值对比</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.atomic.AtomicStampedReference;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AtomicClass</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> AtomicStampedReference&lt;Integer&gt; n;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(j&lt;<span class=\"number\">100</span>)&#123;</span><br><span class=\"line\">            n = <span class=\"keyword\">new</span> <span class=\"title class_\">AtomicStampedReference</span>&lt;Integer&gt;(<span class=\"number\">0</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\">            <span class=\"type\">Thread</span> <span class=\"variable\">t1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>()&#123;</span><br><span class=\"line\">                <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">1000</span>; i++)&#123;</span><br><span class=\"line\">                        <span class=\"type\">int</span> stamp;</span><br><span class=\"line\">                        Integer reference;</span><br><span class=\"line\">                        <span class=\"keyword\">do</span>&#123;</span><br><span class=\"line\">                            stamp = n.getStamp();</span><br><span class=\"line\">                            reference = n.getReference();</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">while</span>(!n.compareAndSet(reference, reference+<span class=\"number\">1</span>, stamp, stamp+<span class=\"number\">1</span>));</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">            <span class=\"type\">Thread</span> <span class=\"variable\">t2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>()&#123;</span><br><span class=\"line\">                <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">1000</span>; i++)&#123;</span><br><span class=\"line\">                        <span class=\"type\">int</span> stamp;</span><br><span class=\"line\">                        Integer reference;</span><br><span class=\"line\">                        <span class=\"keyword\">do</span>&#123;</span><br><span class=\"line\">                            stamp = n.getStamp();</span><br><span class=\"line\">                            reference = n.getReference();</span><br><span class=\"line\"></span><br><span class=\"line\">                        &#125; <span class=\"keyword\">while</span>(!n.compareAndSet(reference, reference+<span class=\"number\">1</span>, stamp, stamp+<span class=\"number\">1</span>));</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">            t1.start();</span><br><span class=\"line\">            t2.start();</span><br><span class=\"line\">            t1.join();</span><br><span class=\"line\">            t2.join();</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;n的最终值是：&quot;</span>+n.getReference());</span><br><span class=\"line\">            j++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>注意：采用 AtomicStampedReference 会降低性能，慎用。</strong></p>\n<p>‍</p>\n","excerpt":"","more":"<h1>并发处理</h1>\n<hr>\n<h2 id=\"多线程特性\">多线程特性</h2>\n<ul>\n<li>原子性\n<ul>\n<li>一个或多个操作要么全部执行并且执行过程中不会被任何因素打断，要么就不执行。</li>\n</ul>\n</li>\n<li>可见性\n<ul>\n<li>当多个线程同时访问一个变量时，一个线程修改了这个变量，其他线程能够立即看见修改的值。单线程不存在可见性问题。</li>\n</ul>\n</li>\n<li>有序型\n<ul>\n<li>程序的执行按照代码的先后顺序执行</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"对象的发布和逸出\">对象的发布和逸出</h2>\n<h3 id=\"发布\">发布</h3>\n<blockquote>\n<p>&quot;发布( Publish)&quot;一个对象的意思是指,使对象能够在当前作用域之外的代码中使用</p>\n</blockquote>\n<ol>\n<li>一个指向该对象的引用保存到其他代码可以访问的地方</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Person</span>()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> age;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Record</span>&#123;</span><br><span class=\"line\">    Person p;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>在某一个非私有的方法中返回该引用</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Person</span>()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> age;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Person <span class=\"title function_\">get</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Person</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>将引用传递到其他类的方法中</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Person</span>()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> age;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Record</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">getPersonMessage</span><span class=\"params\">(Person p)</span>&#123;</span><br><span class=\"line\">        .....</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"逸出\">逸出</h3>\n<blockquote>\n<p>当某个不应该发布的对象被发布时,这种情况就被称为逸出( Escape).</p>\n</blockquote>\n<ol>\n<li>内部的可变状态逸出</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">UnsafeStates</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String[] states = &#123;<span class=\"string\">&quot;AK&quot;</span>,<span class=\"string\">&quot;AL&quot;</span>,...&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String[] getStates()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> states;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//数组states本事私有的变量，但是以public公有的方式发布出去，导致states已经逸出了它所在的作用域，任何调用者都能修改这个数组的内容</span></span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>隐式地使用this引用导致逸出</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ThisEscape</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">ThisEscape</span><span class=\"params\">(EventSource source)</span>&#123;</span><br><span class=\"line\">        source.registerListener(</span><br><span class=\"line\">            <span class=\"keyword\">new</span> <span class=\"title class_\">EventListener</span>()&#123;</span><br><span class=\"line\">                <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onEvent</span><span class=\"params\">(Event e)</span>&#123;</span><br><span class=\"line\">                    dosomething(e);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        <span class=\"comment\">//在这里count初始化为1</span></span><br><span class=\"line\">        count = <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//当ThisEscape发布EventListener时，也隐含地发布了ThisEscape实例本身。因为在这个内部类的实例中包含了对ThisEscape实例的隐含引用。</span></span><br><span class=\"line\"><span class=\"comment\">//this逸出会导致ThisEscape也发布出去，也就是ThisEscape还没有构建完成就发布出去，也就是count=1;这一句还没执行就发布了ThisEscape对象，如果要使用count时,很有可能会出现对象不一致的状态</span></span><br></pre></td></tr></table></figure>\n<p><strong>使用工厂方法来防止this引用在构造函数过程中逸出</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SafeListener</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> EventListener listener;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">SafeListener</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        listener = <span class=\"keyword\">new</span> <span class=\"title class_\">EventListener</span>()&#123;</span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">onEvent</span><span class=\"params\">(Event e)</span>&#123;</span><br><span class=\"line\">                dosomething(e);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> SafeListener <span class=\"title function_\">newInstance</span><span class=\"params\">(EventSource source)</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">SafeListener</span> <span class=\"variable\">safe</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SafeListener</span>();</span><br><span class=\"line\">        source.registerListener(safe.listener);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> safe;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//保证在对象为构造完成之前，是不会发布该对象</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"线程封闭\">线程封闭</h2>\n<ol>\n<li>Ad-hoc线程封闭。</li>\n</ol>\n<blockquote>\n<p>维护线程封闭性的职责完全由程序实现承担，可用性不高。</p>\n</blockquote>\n<p>Ad-hoc 线程封闭下的一个特例适用于 volatile 变量。 只要确保 volatile 变量仅从单个线程写入，就可以安全地对共享 volatile 变量执读 - 改 - 写操作。</p>\n<ol start=\"2\">\n<li>栈封闭。</li>\n</ol>\n<p>局部变量，无并发问题，在项目中使用最多，简单说就是局部变量，方法的变量都拷贝到线程的堆栈中，只有这个线程能访问到。尽量少使用全局变量（变量不是常量）</p>\n<ol start=\"3\">\n<li>ThreadLocal类。</li>\n</ol>\n<h2 id=\"原子类\">原子类</h2>\n<p>Java 的 java.util.concurrent.atomic 包里面提供了很多可以进行原子操作的类，分为以下四类：</p>\n<ul>\n<li>原子更新基本类型：AtomicInteger、AtomicBoolean、AtomicLong</li>\n<li>原子更新数组：AtomicIntegerArray、AtomicLongArray</li>\n<li>原子更新引用：AtomicReference、AtomicStampedReference 等</li>\n<li>原子更新属性：AtomicIntegerFieldUpdater、AtomicLongFieldUpdater</li>\n</ul>\n<p>提供这些原子类的目的就是为了解决基本类型操作的非原子性导致在多线程并发情况下引发的问题。</p>\n<h3 id=\"非原子问题演示\">非原子问题演示</h3>\n<p>i++并不是原子操作</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AtomicClass</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(j&lt;<span class=\"number\">100</span>)&#123;</span><br><span class=\"line\">            n = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"type\">Thread</span> <span class=\"variable\">t1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>()&#123;</span><br><span class=\"line\">                <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">1000</span>; i++)&#123;</span><br><span class=\"line\">                        n++;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">            <span class=\"type\">Thread</span> <span class=\"variable\">t2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>()&#123;</span><br><span class=\"line\">                <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">1000</span>; i++)&#123;</span><br><span class=\"line\">                        n++;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">            t1.start();</span><br><span class=\"line\">            t2.start();</span><br><span class=\"line\">            t1.join();</span><br><span class=\"line\">            t2.join();</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;n的最终值是：&quot;</span>+n);</span><br><span class=\"line\">            j++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>结果不一定全是 2000</p>\n<h3 id=\"非原子问题的原子解决\">非原子问题的原子解决</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AtomicClass</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> AtomicInteger n;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(j&lt;<span class=\"number\">100</span>)&#123;</span><br><span class=\"line\">            n = <span class=\"keyword\">new</span> <span class=\"title class_\">AtomicInteger</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">            <span class=\"type\">Thread</span> <span class=\"variable\">t1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>()&#123;</span><br><span class=\"line\">                <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">1000</span>; i++)&#123;</span><br><span class=\"line\">                        n.getAndIncrement();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">            <span class=\"type\">Thread</span> <span class=\"variable\">t2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>()&#123;</span><br><span class=\"line\">                <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">1000</span>; i++)&#123;</span><br><span class=\"line\">                        n.getAndIncrement();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">            t1.start();</span><br><span class=\"line\">            t2.start();</span><br><span class=\"line\">            t1.join();</span><br><span class=\"line\">            t2.join();</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;n的最终值是：&quot;</span>+n);</span><br><span class=\"line\">            j++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>原理</strong></p>\n<p><img src=\"/assets/net-img-1582875462202-61de3608-d606-44f6-b8d0-c82da3a7acd8-20221030135541-a1152vd.png\" alt=\"1-10.png\"></p>\n<h3 id=\"CAS-的-ABA-问题\">CAS 的 ABA 问题</h3>\n<p>当前内存的值一开始是 A，被另外一个线程先改为 B 然后再改为 A，那么当前线程访问的时候发现是 A，则认为它没有被其他线程访问过。在某些场景下这样是存在错误风险的。如下图：</p>\n<p><img src=\"/assets/net-img-1582875470139-ea71ffbe-3cbd-44d8-8560-1e72b3a4bab4-20221030135541-hkuw6hs.png\" alt=\"1-11.png\"></p>\n<h3 id=\"AtomicStampedReference-解决-ABA-问题\">AtomicStampedReference 解决 ABA 问题</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AtomicStampedReference(初始值，时间戳)：构造函数设置初始值和时间戳</span><br><span class=\"line\">getStamp：获取时间戳</span><br><span class=\"line\">getReference：获取预期值</span><br><span class=\"line\">compareAndSet(预期值，更新值，预期时间戳，更新时间戳)：实现CAS时间戳和预期值对比</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.atomic.AtomicStampedReference;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AtomicClass</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> AtomicStampedReference&lt;Integer&gt; n;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(j&lt;<span class=\"number\">100</span>)&#123;</span><br><span class=\"line\">            n = <span class=\"keyword\">new</span> <span class=\"title class_\">AtomicStampedReference</span>&lt;Integer&gt;(<span class=\"number\">0</span>,<span class=\"number\">0</span>);</span><br><span class=\"line\">            <span class=\"type\">Thread</span> <span class=\"variable\">t1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>()&#123;</span><br><span class=\"line\">                <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">1000</span>; i++)&#123;</span><br><span class=\"line\">                        <span class=\"type\">int</span> stamp;</span><br><span class=\"line\">                        Integer reference;</span><br><span class=\"line\">                        <span class=\"keyword\">do</span>&#123;</span><br><span class=\"line\">                            stamp = n.getStamp();</span><br><span class=\"line\">                            reference = n.getReference();</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">while</span>(!n.compareAndSet(reference, reference+<span class=\"number\">1</span>, stamp, stamp+<span class=\"number\">1</span>));</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">            <span class=\"type\">Thread</span> <span class=\"variable\">t2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>()&#123;</span><br><span class=\"line\">                <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">1000</span>; i++)&#123;</span><br><span class=\"line\">                        <span class=\"type\">int</span> stamp;</span><br><span class=\"line\">                        Integer reference;</span><br><span class=\"line\">                        <span class=\"keyword\">do</span>&#123;</span><br><span class=\"line\">                            stamp = n.getStamp();</span><br><span class=\"line\">                            reference = n.getReference();</span><br><span class=\"line\"></span><br><span class=\"line\">                        &#125; <span class=\"keyword\">while</span>(!n.compareAndSet(reference, reference+<span class=\"number\">1</span>, stamp, stamp+<span class=\"number\">1</span>));</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">            t1.start();</span><br><span class=\"line\">            t2.start();</span><br><span class=\"line\">            t1.join();</span><br><span class=\"line\">            t2.join();</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;n的最终值是：&quot;</span>+n.getReference());</span><br><span class=\"line\">            j++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>注意：采用 AtomicStampedReference 会降低性能，慎用。</strong></p>\n<p>‍</p>\n"},{"title":"线程间通讯","date":"2023-05-14T14:53:28.000Z","lastmod":"2023-05-14T14:41:00.000Z","_content":"\n# 线程间通讯\n\n## 线程通信\n\n### 线程间通信常用方式\n\n1. 休眠唤醒\n   1. object 的 wait，notify，notifyAll\n   2. Condition 的 await，signal，signalAll\n2. CountDownLatch：用于某个线程 A 等待若干个其他线程执行完之后，它才执行\n   - CountDownLatch 这个类能够使一个线程等待其他线程完成各自的工作后再执行。\n   - CountDownLatch 是通过一个计数器来实现的，计数器的初始值为线程的数量。  \n  ![1-8.png](/assets/net-img-1582875399701-d03e5b25-a1c9-498e-85d6-18f86f41e38f-20221030135517-a6hu6sv.png)\n\n　　每当一个线程完成了自己的任务后，计数器的值就会减 1。当计数器值到达 0 时，它表示所有的线程已经完成了任务，然后在闭锁上等待的线程就可以恢复执行任务。\n1. CyclicBarrier：一组线程等待至某个状态之后再全部同时执行\n\n- CyclicBarrier 实现让一组线程等待至某个状态之后再全部同时执行。\n- CyclicBarrier 底层是 ReentrantLock 和 Condition 实现\n\n4. Semaphore：用于控制对某组资源的访问权限\n\n　　**Object 和 Condition 休眠唤醒区别**\n\n1. object wait()必须在 synchronized（同步锁）下使用，\n2. object wait()必须要通过 Nodify()方法进行唤醒\n3. condition await() 必须和 Lock（互斥锁/共享锁）配合使用\n4. condition await() 必须通过 signal() 方法进行唤醒\n\n　　**sleep 和 wait 区别**\n\n||wait|sleep|\n| ----------| -----------------------------------------------------------------------------| ----------------------------------------------------|\n|同步|只能在同步上下文中调用 wait 方法，否则会抛出 llegalMonitorstateException 异常|不需要在同步方法或同步代码块调用|\n|作用对象|wait 方法定义在 Object 类中，作用于对象本身|sleep 方法定义在 java.lang.thread 中，作用于当前线程|\n|释放锁资源|是|否|\n|唤醒条件|其他线程调用对象的 notify()或者 notifyAll()方法|超时或调用 Interrupt()方法体|\n|方法属性|wait 是实例方法|sleep 是静态方法|\n\n　　**wait 和 notify 区别**\n\n* wait 和 notify 都是 Object 中的方法\n* wait 和 notify 执行前线程都必须获得对象锁\n* wait 的作用是使当前线程进行等待\n* notify 的作用是通知其他等待当前线程的对象锁的线程\n\n## Volatile 关键字\n\n### 非原子性的64位操作\n\n　　非Volatile修饰的64位变量（double和long类型），JVM允许将64位的读操作和写操作分为两个32位的操作，如果这两个操作在不同线程执行，可能就会导致数据丢失。在多线程中使用共享且可变的long和double类型变量，必须使用Volatile修饰或加锁，否则会有线程安全问题。\n\n### 原理\n\n　　Java把处理器多级抽象化为JMM，及线程私有化的工作内存和线程共有的主内存，每个线程从主内村拷贝所需数据到自己的工作内存处理，在重新写回主内存。volatile原理就是当线程修改volatile修饰的变量时，要立即写入内存，当线程读取被volatile修饰的变量时，要立即到主存中读取，保证可见性。\n\n### 作用\n\n> 一个共享变量（类的成员变量、类的静态成员变量）被 volatile 修饰之后，那么就具备了两层语义：\n\n* 保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。（注意：不保证原子性）\n* 禁止进行指令重排序。（保证变量所在行的有序性）\n\n  * 当程序执行到 volatile 变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；\n  * 在进行指令优化时，不能将在对 volatile 变量访问的语句放在其后面执行，也不能把 volatile 变量后面的语句放到其前面执行\n\n### 内存屏障\n\n　　**MESI CPU缓存一致性协议**  \n屏障两边的指令不可重排  \n​![image.png](//assets/net-img-1615619423077-dea312ee-787e-4a28-b723-199f76a214f7-20221030135542-mx20k3e.png)  \n​![image.png](//assets/net-img-1615619453470-bdab6e23-1385-4538-9c91-ceefcd05aa27-20221030135542-vyoxljv.png)**应用场景**\n\n　　基于 volatile 的作用，使用 volatile 必须满足以下两个条件：\n\n* 对变量的写操作不依赖于当前值\n* 该变量没有包含在具有其他变量的不变式中\n* 在访问变量时不需要加锁  \n  **常见应用场景如下：**   \n  状态量标记：\n\n```java\nvolatile boolean flag = false;\n \nwhile(!flag){\n    doSomething();\n}\n \npublic void setFlag() {\n    flag = true;\n}\n\n\nvolatile boolean inited = false;\n//线程1:\ncontext = loadContext(); \ninited = true;           \n \n//线程2:\nwhile(!inited ){\nsleep()\n}\ndoSomethingwithconfig(context);\n```\n\n　　双重校验：\n\n```java\nclass Singleton{\n    private volatile static Singleton instance = null;\n \n    private Singleton() {\n \n    }\n \n    public static Singleton getInstance() {\n        if(instance==null) {\n            synchronized (Singleton.class) {\n                if(instance==null)\n                    instance = new Singleton();\n            }\n        }\n        return instance;\n    }\n}\n```\n\n### 局限\n\n　　Volatile修饰变量只能保证可见性，不能保证原子性\n\n　　‍\n","source":"_posts/java/thread/线程间通讯.md","raw":"---\ntitle: 线程间通讯\ndate: 2023-05-14T22:53:28Z\nlastmod: 2023-05-14T22:41:00Z\n---\n\n# 线程间通讯\n\n## 线程通信\n\n### 线程间通信常用方式\n\n1. 休眠唤醒\n   1. object 的 wait，notify，notifyAll\n   2. Condition 的 await，signal，signalAll\n2. CountDownLatch：用于某个线程 A 等待若干个其他线程执行完之后，它才执行\n   - CountDownLatch 这个类能够使一个线程等待其他线程完成各自的工作后再执行。\n   - CountDownLatch 是通过一个计数器来实现的，计数器的初始值为线程的数量。  \n  ![1-8.png](/assets/net-img-1582875399701-d03e5b25-a1c9-498e-85d6-18f86f41e38f-20221030135517-a6hu6sv.png)\n\n　　每当一个线程完成了自己的任务后，计数器的值就会减 1。当计数器值到达 0 时，它表示所有的线程已经完成了任务，然后在闭锁上等待的线程就可以恢复执行任务。\n1. CyclicBarrier：一组线程等待至某个状态之后再全部同时执行\n\n- CyclicBarrier 实现让一组线程等待至某个状态之后再全部同时执行。\n- CyclicBarrier 底层是 ReentrantLock 和 Condition 实现\n\n4. Semaphore：用于控制对某组资源的访问权限\n\n　　**Object 和 Condition 休眠唤醒区别**\n\n1. object wait()必须在 synchronized（同步锁）下使用，\n2. object wait()必须要通过 Nodify()方法进行唤醒\n3. condition await() 必须和 Lock（互斥锁/共享锁）配合使用\n4. condition await() 必须通过 signal() 方法进行唤醒\n\n　　**sleep 和 wait 区别**\n\n||wait|sleep|\n| ----------| -----------------------------------------------------------------------------| ----------------------------------------------------|\n|同步|只能在同步上下文中调用 wait 方法，否则会抛出 llegalMonitorstateException 异常|不需要在同步方法或同步代码块调用|\n|作用对象|wait 方法定义在 Object 类中，作用于对象本身|sleep 方法定义在 java.lang.thread 中，作用于当前线程|\n|释放锁资源|是|否|\n|唤醒条件|其他线程调用对象的 notify()或者 notifyAll()方法|超时或调用 Interrupt()方法体|\n|方法属性|wait 是实例方法|sleep 是静态方法|\n\n　　**wait 和 notify 区别**\n\n* wait 和 notify 都是 Object 中的方法\n* wait 和 notify 执行前线程都必须获得对象锁\n* wait 的作用是使当前线程进行等待\n* notify 的作用是通知其他等待当前线程的对象锁的线程\n\n## Volatile 关键字\n\n### 非原子性的64位操作\n\n　　非Volatile修饰的64位变量（double和long类型），JVM允许将64位的读操作和写操作分为两个32位的操作，如果这两个操作在不同线程执行，可能就会导致数据丢失。在多线程中使用共享且可变的long和double类型变量，必须使用Volatile修饰或加锁，否则会有线程安全问题。\n\n### 原理\n\n　　Java把处理器多级抽象化为JMM，及线程私有化的工作内存和线程共有的主内存，每个线程从主内村拷贝所需数据到自己的工作内存处理，在重新写回主内存。volatile原理就是当线程修改volatile修饰的变量时，要立即写入内存，当线程读取被volatile修饰的变量时，要立即到主存中读取，保证可见性。\n\n### 作用\n\n> 一个共享变量（类的成员变量、类的静态成员变量）被 volatile 修饰之后，那么就具备了两层语义：\n\n* 保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。（注意：不保证原子性）\n* 禁止进行指令重排序。（保证变量所在行的有序性）\n\n  * 当程序执行到 volatile 变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；\n  * 在进行指令优化时，不能将在对 volatile 变量访问的语句放在其后面执行，也不能把 volatile 变量后面的语句放到其前面执行\n\n### 内存屏障\n\n　　**MESI CPU缓存一致性协议**  \n屏障两边的指令不可重排  \n​![image.png](//assets/net-img-1615619423077-dea312ee-787e-4a28-b723-199f76a214f7-20221030135542-mx20k3e.png)  \n​![image.png](//assets/net-img-1615619453470-bdab6e23-1385-4538-9c91-ceefcd05aa27-20221030135542-vyoxljv.png)**应用场景**\n\n　　基于 volatile 的作用，使用 volatile 必须满足以下两个条件：\n\n* 对变量的写操作不依赖于当前值\n* 该变量没有包含在具有其他变量的不变式中\n* 在访问变量时不需要加锁  \n  **常见应用场景如下：**   \n  状态量标记：\n\n```java\nvolatile boolean flag = false;\n \nwhile(!flag){\n    doSomething();\n}\n \npublic void setFlag() {\n    flag = true;\n}\n\n\nvolatile boolean inited = false;\n//线程1:\ncontext = loadContext(); \ninited = true;           \n \n//线程2:\nwhile(!inited ){\nsleep()\n}\ndoSomethingwithconfig(context);\n```\n\n　　双重校验：\n\n```java\nclass Singleton{\n    private volatile static Singleton instance = null;\n \n    private Singleton() {\n \n    }\n \n    public static Singleton getInstance() {\n        if(instance==null) {\n            synchronized (Singleton.class) {\n                if(instance==null)\n                    instance = new Singleton();\n            }\n        }\n        return instance;\n    }\n}\n```\n\n### 局限\n\n　　Volatile修饰变量只能保证可见性，不能保证原子性\n\n　　‍\n","slug":"java-thread-线程间通讯","published":1,"updated":"2025-04-22T07:28:38.969Z","_id":"cm9s3f40p0036bfg4eao7bjij","comments":1,"layout":"post","photos":[],"content":"<h1>线程间通讯</h1>\n<h2 id=\"线程通信\">线程通信</h2>\n<h3 id=\"线程间通信常用方式\">线程间通信常用方式</h3>\n<ol>\n<li>休眠唤醒\n<ol>\n<li>object 的 wait，notify，notifyAll</li>\n<li>Condition 的 await，signal，signalAll</li>\n</ol>\n</li>\n<li>CountDownLatch：用于某个线程 A 等待若干个其他线程执行完之后，它才执行\n<ul>\n<li>CountDownLatch 这个类能够使一个线程等待其他线程完成各自的工作后再执行。</li>\n<li>CountDownLatch 是通过一个计数器来实现的，计数器的初始值为线程的数量。<br>\n<img src=\"/assets/net-img-1582875399701-d03e5b25-a1c9-498e-85d6-18f86f41e38f-20221030135517-a6hu6sv.png\" alt=\"1-8.png\"></li>\n</ul>\n</li>\n</ol>\n<p>每当一个线程完成了自己的任务后，计数器的值就会减 1。当计数器值到达 0 时，它表示所有的线程已经完成了任务，然后在闭锁上等待的线程就可以恢复执行任务。</p>\n<ol>\n<li>CyclicBarrier：一组线程等待至某个状态之后再全部同时执行</li>\n</ol>\n<ul>\n<li>CyclicBarrier 实现让一组线程等待至某个状态之后再全部同时执行。</li>\n<li>CyclicBarrier 底层是 ReentrantLock 和 Condition 实现</li>\n</ul>\n<ol start=\"4\">\n<li>Semaphore：用于控制对某组资源的访问权限</li>\n</ol>\n<p><strong>Object 和 Condition 休眠唤醒区别</strong></p>\n<ol>\n<li>object wait()必须在 synchronized（同步锁）下使用，</li>\n<li>object wait()必须要通过 Nodify()方法进行唤醒</li>\n<li>condition await() 必须和 Lock（互斥锁/共享锁）配合使用</li>\n<li>condition await() 必须通过 signal() 方法进行唤醒</li>\n</ol>\n<p><strong>sleep 和 wait 区别</strong></p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>wait</th>\n<th>sleep</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>同步</td>\n<td>只能在同步上下文中调用 wait 方法，否则会抛出 llegalMonitorstateException 异常</td>\n<td>不需要在同步方法或同步代码块调用</td>\n</tr>\n<tr>\n<td>作用对象</td>\n<td>wait 方法定义在 Object 类中，作用于对象本身</td>\n<td>sleep 方法定义在 java.lang.thread 中，作用于当前线程</td>\n</tr>\n<tr>\n<td>释放锁资源</td>\n<td>是</td>\n<td>否</td>\n</tr>\n<tr>\n<td>唤醒条件</td>\n<td>其他线程调用对象的 notify()或者 notifyAll()方法</td>\n<td>超时或调用 Interrupt()方法体</td>\n</tr>\n<tr>\n<td>方法属性</td>\n<td>wait 是实例方法</td>\n<td>sleep 是静态方法</td>\n</tr>\n</tbody>\n</table>\n<p><strong>wait 和 notify 区别</strong></p>\n<ul>\n<li>wait 和 notify 都是 Object 中的方法</li>\n<li>wait 和 notify 执行前线程都必须获得对象锁</li>\n<li>wait 的作用是使当前线程进行等待</li>\n<li>notify 的作用是通知其他等待当前线程的对象锁的线程</li>\n</ul>\n<h2 id=\"Volatile-关键字\">Volatile 关键字</h2>\n<h3 id=\"非原子性的64位操作\">非原子性的64位操作</h3>\n<p>非Volatile修饰的64位变量（double和long类型），JVM允许将64位的读操作和写操作分为两个32位的操作，如果这两个操作在不同线程执行，可能就会导致数据丢失。在多线程中使用共享且可变的long和double类型变量，必须使用Volatile修饰或加锁，否则会有线程安全问题。</p>\n<h3 id=\"原理\">原理</h3>\n<p>Java把处理器多级抽象化为JMM，及线程私有化的工作内存和线程共有的主内存，每个线程从主内村拷贝所需数据到自己的工作内存处理，在重新写回主内存。volatile原理就是当线程修改volatile修饰的变量时，要立即写入内存，当线程读取被volatile修饰的变量时，要立即到主存中读取，保证可见性。</p>\n<h3 id=\"作用\">作用</h3>\n<blockquote>\n<p>一个共享变量（类的成员变量、类的静态成员变量）被 volatile 修饰之后，那么就具备了两层语义：</p>\n</blockquote>\n<ul>\n<li>\n<p>保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。（注意：不保证原子性）</p>\n</li>\n<li>\n<p>禁止进行指令重排序。（保证变量所在行的有序性）</p>\n<ul>\n<li>当程序执行到 volatile 变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；</li>\n<li>在进行指令优化时，不能将在对 volatile 变量访问的语句放在其后面执行，也不能把 volatile 变量后面的语句放到其前面执行</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"内存屏障\">内存屏障</h3>\n<p><strong>MESI CPU缓存一致性协议</strong><br>\n屏障两边的指令不可重排<br>\n​<img src=\"//assets/net-img-1615619423077-dea312ee-787e-4a28-b723-199f76a214f7-20221030135542-mx20k3e.png\" alt=\"image.png\"><br>\n​<img src=\"//assets/net-img-1615619453470-bdab6e23-1385-4538-9c91-ceefcd05aa27-20221030135542-vyoxljv.png\" alt=\"image.png\"><strong>应用场景</strong></p>\n<p>基于 volatile 的作用，使用 volatile 必须满足以下两个条件：</p>\n<ul>\n<li>对变量的写操作不依赖于当前值</li>\n<li>该变量没有包含在具有其他变量的不变式中</li>\n<li>在访问变量时不需要加锁<br>\n<strong>常见应用场景如下：</strong><br>\n状态量标记：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">volatile</span> <span class=\"type\">boolean</span> <span class=\"variable\">flag</span> <span class=\"operator\">=</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">while</span>(!flag)&#123;</span><br><span class=\"line\">    doSomething();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setFlag</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    flag = <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">volatile</span> <span class=\"type\">boolean</span> <span class=\"variable\">inited</span> <span class=\"operator\">=</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"><span class=\"comment\">//线程1:</span></span><br><span class=\"line\">context = loadContext(); </span><br><span class=\"line\">inited = <span class=\"literal\">true</span>;           </span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">//线程2:</span></span><br><span class=\"line\"><span class=\"keyword\">while</span>(!inited )&#123;</span><br><span class=\"line\">sleep()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">doSomethingwithconfig(context);</span><br></pre></td></tr></table></figure>\n<p>双重校验：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">static</span> <span class=\"type\">Singleton</span> <span class=\"variable\">instance</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">Singleton</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(instance==<span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (Singleton.class) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(instance==<span class=\"literal\">null</span>)</span><br><span class=\"line\">                    instance = <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"局限\">局限</h3>\n<p>Volatile修饰变量只能保证可见性，不能保证原子性</p>\n<p>‍</p>\n","excerpt":"","more":"<h1>线程间通讯</h1>\n<h2 id=\"线程通信\">线程通信</h2>\n<h3 id=\"线程间通信常用方式\">线程间通信常用方式</h3>\n<ol>\n<li>休眠唤醒\n<ol>\n<li>object 的 wait，notify，notifyAll</li>\n<li>Condition 的 await，signal，signalAll</li>\n</ol>\n</li>\n<li>CountDownLatch：用于某个线程 A 等待若干个其他线程执行完之后，它才执行\n<ul>\n<li>CountDownLatch 这个类能够使一个线程等待其他线程完成各自的工作后再执行。</li>\n<li>CountDownLatch 是通过一个计数器来实现的，计数器的初始值为线程的数量。<br>\n<img src=\"/assets/net-img-1582875399701-d03e5b25-a1c9-498e-85d6-18f86f41e38f-20221030135517-a6hu6sv.png\" alt=\"1-8.png\"></li>\n</ul>\n</li>\n</ol>\n<p>每当一个线程完成了自己的任务后，计数器的值就会减 1。当计数器值到达 0 时，它表示所有的线程已经完成了任务，然后在闭锁上等待的线程就可以恢复执行任务。</p>\n<ol>\n<li>CyclicBarrier：一组线程等待至某个状态之后再全部同时执行</li>\n</ol>\n<ul>\n<li>CyclicBarrier 实现让一组线程等待至某个状态之后再全部同时执行。</li>\n<li>CyclicBarrier 底层是 ReentrantLock 和 Condition 实现</li>\n</ul>\n<ol start=\"4\">\n<li>Semaphore：用于控制对某组资源的访问权限</li>\n</ol>\n<p><strong>Object 和 Condition 休眠唤醒区别</strong></p>\n<ol>\n<li>object wait()必须在 synchronized（同步锁）下使用，</li>\n<li>object wait()必须要通过 Nodify()方法进行唤醒</li>\n<li>condition await() 必须和 Lock（互斥锁/共享锁）配合使用</li>\n<li>condition await() 必须通过 signal() 方法进行唤醒</li>\n</ol>\n<p><strong>sleep 和 wait 区别</strong></p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>wait</th>\n<th>sleep</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>同步</td>\n<td>只能在同步上下文中调用 wait 方法，否则会抛出 llegalMonitorstateException 异常</td>\n<td>不需要在同步方法或同步代码块调用</td>\n</tr>\n<tr>\n<td>作用对象</td>\n<td>wait 方法定义在 Object 类中，作用于对象本身</td>\n<td>sleep 方法定义在 java.lang.thread 中，作用于当前线程</td>\n</tr>\n<tr>\n<td>释放锁资源</td>\n<td>是</td>\n<td>否</td>\n</tr>\n<tr>\n<td>唤醒条件</td>\n<td>其他线程调用对象的 notify()或者 notifyAll()方法</td>\n<td>超时或调用 Interrupt()方法体</td>\n</tr>\n<tr>\n<td>方法属性</td>\n<td>wait 是实例方法</td>\n<td>sleep 是静态方法</td>\n</tr>\n</tbody>\n</table>\n<p><strong>wait 和 notify 区别</strong></p>\n<ul>\n<li>wait 和 notify 都是 Object 中的方法</li>\n<li>wait 和 notify 执行前线程都必须获得对象锁</li>\n<li>wait 的作用是使当前线程进行等待</li>\n<li>notify 的作用是通知其他等待当前线程的对象锁的线程</li>\n</ul>\n<h2 id=\"Volatile-关键字\">Volatile 关键字</h2>\n<h3 id=\"非原子性的64位操作\">非原子性的64位操作</h3>\n<p>非Volatile修饰的64位变量（double和long类型），JVM允许将64位的读操作和写操作分为两个32位的操作，如果这两个操作在不同线程执行，可能就会导致数据丢失。在多线程中使用共享且可变的long和double类型变量，必须使用Volatile修饰或加锁，否则会有线程安全问题。</p>\n<h3 id=\"原理\">原理</h3>\n<p>Java把处理器多级抽象化为JMM，及线程私有化的工作内存和线程共有的主内存，每个线程从主内村拷贝所需数据到自己的工作内存处理，在重新写回主内存。volatile原理就是当线程修改volatile修饰的变量时，要立即写入内存，当线程读取被volatile修饰的变量时，要立即到主存中读取，保证可见性。</p>\n<h3 id=\"作用\">作用</h3>\n<blockquote>\n<p>一个共享变量（类的成员变量、类的静态成员变量）被 volatile 修饰之后，那么就具备了两层语义：</p>\n</blockquote>\n<ul>\n<li>\n<p>保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。（注意：不保证原子性）</p>\n</li>\n<li>\n<p>禁止进行指令重排序。（保证变量所在行的有序性）</p>\n<ul>\n<li>当程序执行到 volatile 变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；</li>\n<li>在进行指令优化时，不能将在对 volatile 变量访问的语句放在其后面执行，也不能把 volatile 变量后面的语句放到其前面执行</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"内存屏障\">内存屏障</h3>\n<p><strong>MESI CPU缓存一致性协议</strong><br>\n屏障两边的指令不可重排<br>\n​<img src=\"//assets/net-img-1615619423077-dea312ee-787e-4a28-b723-199f76a214f7-20221030135542-mx20k3e.png\" alt=\"image.png\"><br>\n​<img src=\"//assets/net-img-1615619453470-bdab6e23-1385-4538-9c91-ceefcd05aa27-20221030135542-vyoxljv.png\" alt=\"image.png\"><strong>应用场景</strong></p>\n<p>基于 volatile 的作用，使用 volatile 必须满足以下两个条件：</p>\n<ul>\n<li>对变量的写操作不依赖于当前值</li>\n<li>该变量没有包含在具有其他变量的不变式中</li>\n<li>在访问变量时不需要加锁<br>\n<strong>常见应用场景如下：</strong><br>\n状态量标记：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">volatile</span> <span class=\"type\">boolean</span> <span class=\"variable\">flag</span> <span class=\"operator\">=</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">while</span>(!flag)&#123;</span><br><span class=\"line\">    doSomething();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setFlag</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    flag = <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">volatile</span> <span class=\"type\">boolean</span> <span class=\"variable\">inited</span> <span class=\"operator\">=</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"><span class=\"comment\">//线程1:</span></span><br><span class=\"line\">context = loadContext(); </span><br><span class=\"line\">inited = <span class=\"literal\">true</span>;           </span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">//线程2:</span></span><br><span class=\"line\"><span class=\"keyword\">while</span>(!inited )&#123;</span><br><span class=\"line\">sleep()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">doSomethingwithconfig(context);</span><br></pre></td></tr></table></figure>\n<p>双重校验：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">static</span> <span class=\"type\">Singleton</span> <span class=\"variable\">instance</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">Singleton</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(instance==<span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (Singleton.class) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(instance==<span class=\"literal\">null</span>)</span><br><span class=\"line\">                    instance = <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"局限\">局限</h3>\n<p>Volatile修饰变量只能保证可见性，不能保证原子性</p>\n<p>‍</p>\n"}],"PostAsset":[{"_id":"source/_posts/java/Base/JavaStream.md","post":"cm9s3f3yo0001bfg4gji44ji6","slug":"JavaStream.md","modified":1,"renderable":1},{"_id":"source/_posts/java/Base/ThreadLocal.md","post":"cm9s3f3yo0001bfg4gji44ji6","slug":"ThreadLocal.md","modified":1,"renderable":1},{"_id":"source/_posts/java/Base/Volatile.md","post":"cm9s3f3yo0001bfg4gji44ji6","slug":"Volatile.md","modified":1,"renderable":1},{"_id":"source/_posts/java/Collection/List.md","post":"cm9s3f3yv0005bfg49hwx0b2y","slug":"List.md","modified":1,"renderable":1},{"_id":"source/_posts/java/Collection/Map.md","post":"cm9s3f3yv0005bfg49hwx0b2y","slug":"Map.md","modified":1,"renderable":1},{"_id":"source/_posts/java/Collection/Queue.md","post":"cm9s3f3yv0005bfg49hwx0b2y","slug":"Queue.md","modified":1,"renderable":1},{"_id":"source/_posts/java/Collection/Set.md","post":"cm9s3f3yv0005bfg49hwx0b2y","slug":"Set.md","modified":1,"renderable":1},{"_id":"source/_posts/java/JVM/Java虚拟机栈栈帧.md","post":"cm9s3f3yv0006bfg45rn42dzz","slug":"Java虚拟机栈栈帧.md","modified":1,"renderable":1},{"_id":"source/_posts/java/JVM/垃圾回收和内存分配.md","post":"cm9s3f3yv0006bfg45rn42dzz","slug":"垃圾回收和内存分配.md","modified":1,"renderable":1},{"_id":"source/_posts/java/JVM/虚拟机中的对象.md","post":"cm9s3f3yv0006bfg45rn42dzz","slug":"虚拟机中的对象.md","modified":1,"renderable":1},{"_id":"source/_posts/java/JVM/虚拟机运行时数据区域.md","post":"cm9s3f3yv0006bfg45rn42dzz","slug":"虚拟机运行时数据区域.md","modified":1,"renderable":1},{"_id":"source/_posts/java/JavaWeb/Filter拦截器.md","post":"cm9s3f3yx0007bfg47uroaeyi","slug":"Filter拦截器.md","modified":1,"renderable":1},{"_id":"source/_posts/java/thread/并发处理.md","post":"cm9s3f3yx0008bfg4d2n5e8hf","slug":"并发处理.md","modified":1,"renderable":1},{"_id":"source/_posts/java/thread/并发锁.md","post":"cm9s3f3yx0008bfg4d2n5e8hf","slug":"并发锁.md","modified":1,"renderable":1},{"_id":"source/_posts/java/thread/线程池.md","post":"cm9s3f3yx0008bfg4d2n5e8hf","slug":"线程池.md","modified":1,"renderable":1},{"_id":"source/_posts/java/thread/线程间通讯.md","post":"cm9s3f3yx0008bfg4d2n5e8hf","slug":"线程间通讯.md","modified":1,"renderable":1}],"PostCategory":[],"PostTag":[],"Tag":[]}}