---
title: 工厂模式
date: 2022-10-30T11:20:59Z
lastmod: 2022-10-30T11:20:59Z
---

# 工厂模式

## 工厂模式

> 在基类中定义创建对象的一个接口，让子类决定实例化哪个类。工厂方法让一个类的实例化延迟到子类中进行。

　　**好处**

- 解耦
- 降低代码重复率
- 降低维护成本

### 简单工厂（静态工厂方法模式）

　　根据传入参数判断创建的工厂类

#### 适用场景

- 需要创建的对象较少
- 客户不关心对象的创建过程

#### 角色分配

- 工厂（Factory）角色：负责实现创建所有实例的内部逻辑，工厂类合可以被外界直接调用，创建所需的产品对象
- 抽象产品（Product）角色：简单工厂模式所创建的所有对象的父类，负责描述所有实例所共有的公共接口
- 具体产品（Concrete Product）角色：简单工厂模式的创建目标，所有创建的对象都是充当这个角色的某个具体类的实例。

#### 例子

```java

创建 Shape 接口
public interface Shape {
    void draw();
}
```

```java
（2）创建实现该接口的具体图形类
圆形
public class Circle implements Shape {
    public Circle() {
        System.out.println("Circle");
    }
    @Override
    public void draw() {
        System.out.println("Draw Circle");
    }
}
```

```java
长方形
public class Rectangle implements Shape {
    public Rectangle() {
        System.out.println("Rectangle");
    }
    @Override
    public void draw() {
        System.out.println("Draw Rectangle");
    }
}
```

```java
正方形
public class Square implements Shape {
    public Square() {
        System.out.println("Square");
}
    @Override
    public void draw() {
        System.out.println("Draw Square");
    }
}
```

```java
（3）创建工厂类：
public class ShapeFactory {
    // 使用 getShape 方法获取形状类型的对象
    public static Shape getShape(String shapeType) {
        if (shapeType == null) {
            return null;
        }
        if (shapeType.equalsIgnoreCase("CIRCLE")) {
            return new Circle();
        } else if (shapeType.equalsIgnoreCase("RECTANGLE")) {
            return new Rectangle();
        } else if (shapeType.equalsIgnoreCase("SQUARE")) {
            return new Square();
        }
        return null;
    }
}
```

　　**缺点**
一旦需要修改产品，工厂中的类就需要修改，不符合开放-封闭原则

```java
/**
 * 利用反射解决简单工厂每次增加新了产品类都要修改产品工厂的弊端
 *
 * @author Administrator
 *
 */
public class ShapeFactory2 {
    public static Object getClass(Class<? extends Shape> clazz) {
        Object obj = null;

        try {
            obj = Class.forName(clazz.getName()).newInstance();
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        } catch (InstantiationException e) {
            e.printStackTrace();
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        }

        return obj;
    }
}
```

### 工厂方法

> 每个对象都有一个与之对应的工厂

#### 适用场景

- 一个类不知道他所需要的对象的类
- 一个类通过其子类来指定创建哪个对象
- 将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无需关心是哪一个工厂子类创建产品子类，需要时再动态指定，可将具体工厂类的类名存储在配置文件或数据库中

#### 分配角色

- 抽象工厂(Abstract Factory)角色：是工厂方法模式的核心。任何在模式中创建的对象的工厂类必须实现这个接口。
- 具体工厂(Concrete Factory)角色 ：实现抽象工厂接口的具体工厂类。
- 抽象产品(AbstractProduct)角色 ：工厂方法模式所创建的对象的超类型，也就是产品对象的共同父类或共同拥有的接口。
- 具体产品(Concrete Product)角色 ：实现了抽象产品角色所定义的接口。

#### **例子**

　　**接口和图像实现类不变**

```java
(1)增加一个工厂接口：
public interface Factory {
    public Shape getShape();
}
(2)增加相关工厂类:
圆形工厂类
public class CircleFactory implements Factory {
    @Override
    public Shape getShape() {
        // TODO Auto-generated method stub
        return new Circle();
    }
}
长方形工厂类
public class RectangleFactory implements Factory{
    @Override
    public Shape getShape() {
        // TODO Auto-generated method stub
        return new Rectangle();
    }
}
圆形工厂类
public class SquareFactory implements Factory{
    @Override
    public Shape getShape() {
        // TODO Auto-generated method stub
        return new Square();
    }
}
```

### 抽象工厂

> 将产品进一步模糊，改为可创建一类 ####适用场景

- 不需要知道它所创建的对象的类。
- 需要一组对象共同完成某种功能时，并且可能存在多组对象完成不同功能的情况。
- 系统结构稳定，不会频繁的增加对象

#### 角色分配：

　　抽象工厂（AbstractFactory）角色 ：是工厂方法模式的核心，与应用程序无关。任何在模式中创建的对象的工厂类必须实现这个接口。
具体工厂类（ConreteFactory）角色 ：实现抽象工厂接口的具体工厂类，
抽象产品（Abstract Product）角色 ：工厂方法模式所创建的对象的超类型，也就是产品对象的共同父类或共同拥有的接口。
具体产品（Concrete Product）角色 ：抽象工厂模式所创建的任何产品对象都是某一个具体产品类的实例。在抽象工厂中创建的产品属于同一产品族（配套产品），这不同于工厂模式中的工厂只创建单一产品，

　　
**
