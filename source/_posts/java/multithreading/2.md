---
title: "Volatile"
description:
date: 2022-09-24T19:09:58+08:00
image:
math: true
license:
categories:
    - java
tags:
    - thread
    - 原理
    - Volatile
hidden: false
comments: false
draft: false
---

## Volatile 关键字

### 非原子性的64位操作
非Volatile修饰的64位变量（double和long类型），JVM允许将64位的读操作和写操作分为两个32位的操作，如果这两个操作在不同线程执行，可能就会导致数据丢失。在多线程中使用共享且可变的long和double类型变量，必须使用Volatile修饰或加锁，否则会有线程安全问题。

### 原理
Java把处理器多级抽象化为JMM，及线程私有化的工作内存和线程共有的主内存，每个线程从主内村拷贝所需数据到自己的工作内存处理，在重新写回主内存。volatile原理就是当线程修改volatile修饰的变量时，要立即写入内存，当线程读取被volatile修饰的变量时，要立即到主存中读取，保证可见性。
### 作用

> 一个共享变量（类的成员变量、类的静态成员变量）被 volatile 修饰之后，那么就具备了两层语义：


- 保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。（注意：不保证原子性）
- 禁止进行指令重排序。（保证变量所在行的有序性）
   - 当程序执行到 volatile 变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；
   - 在进行指令优化时，不能将在对 volatile 变量访问的语句放在其后面执行，也不能把 volatile 变量后面的语句放到其前面执行
### 内存屏障
**MESI CPU缓存一致性协议**
屏障两边的指令不可重排
![image.png](https://cdn.nlark.com/yuque/0/2021/png/381674/1615619423077-dea312ee-787e-4a28-b723-199f76a214f7.png#crop=0&crop=0&crop=1&crop=1&height=354&id=Ofz2q&margin=%5Bobject%20Object%5D&name=image.png&originHeight=354&originWidth=863&originalType=binary&ratio=1&rotation=0&showTitle=false&size=354799&status=done&style=none&title=&width=863)
![image.png](https://cdn.nlark.com/yuque/0/2021/png/381674/1615619453470-bdab6e23-1385-4538-9c91-ceefcd05aa27.png#crop=0&crop=0&crop=1&crop=1&height=283&id=jLumj&margin=%5Bobject%20Object%5D&name=image.png&originHeight=283&originWidth=880&originalType=binary&ratio=1&rotation=0&showTitle=false&size=255651&status=done&style=none&title=&width=880)
**应用场景**

基于 volatile 的作用，使用 volatile 必须满足以下两个条件：

- 对变量的写操作不依赖于当前值
- 该变量没有包含在具有其他变量的不变式中
- 在访问变量时不需要加锁
**常见应用场景如下：**
状态量标记：

```java
volatile boolean flag = false;
 
while(!flag){
    doSomething();
}
 
public void setFlag() {
    flag = true;
}


volatile boolean inited = false;
//线程1:
context = loadContext(); 
inited = true;           
 
//线程2:
while(!inited ){
sleep()
}
doSomethingwithconfig(context);
```

双重校验：

```java
class Singleton{
    private volatile static Singleton instance = null;
 
    private Singleton() {
 
    }
 
    public static Singleton getInstance() {
        if(instance==null) {
            synchronized (Singleton.class) {
                if(instance==null)
                    instance = new Singleton();
            }
        }
        return instance;
    }
}
```

### 局限
Volatile修饰变量只能保证可见性，不能保证原子性