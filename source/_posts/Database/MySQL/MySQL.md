---
title: MySQL
date: 2022-11-12T16:00:24Z
lastmod: 2023-02-28T12:47:48Z
---

# MySQL

　　**MDL (Metadata lock)  ​**元数据锁: 常见由create、 alter、 drop和truncate四个关键字完成的SQL语句

　　**DDL（Data Definition Languages）语句：**数据定义语言，这些语句定义了不同的数据段、数据库、表、列、索引等数据库对象的定义。常用的语句关键字主要包括 create、drop、alter等。

　　**DML（Data Manipulation Language）语句：**数据操纵语句，用于添加、删除、更新和查询数据库记录，并检查数据完整性，常用的语句关键字主要包括 insert、delete、udpate 和select 等。(增添改查）

　　**DCL（Data Control Language）语句：**数据控制语句，用于控制不同数据段直接的许可和访问级别的语句。这些语句定义了数据库、表、字段、用户的访问权限和安全级别。主要的语句关键字包括 grant、revoke 等。

## 事务

### 隔离性（ACID）

* 原子性（最小单位）
* 一致性 （数据的正确性，）
* 隔离性（不同事务之间的更改不可见）
* 持久性（落入磁盘）

### 产生问题

* 脏读（dirty read）

  * 在不同事务下，当前事务可以读到另外事务未提交的数据
* 不可重复读（non-repeatable read）

  * 同一个事务多次读取相同的数据，结果不一致，强调数据的修改。
* 幻读（phantom read）

  * 在一个事务中，两次读取，其中一次读取到其他事务插入的数据，强调数据的增删。

### 隔离级别（SQL标准规定）

* 读未提交是指，一个事务还没提交时，它做的变更就能被别的事务看到。

  * 会产生脏读，幻读，不可重复读
* 读提交是指，一个事务提交之后，它做的变更才会被其他事务看到。

  * 会产生幻读，不可重复读
* 可重复读是指，（mysql默认隔离级别）一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。

  * 会产生幻读，**但是mysql采用MVCC（多版本控制）和间隙锁避免了幻读。**
* 串行化，顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。

　　MYSQL事务和锁详解见[^1]

　　‍

[^1]: # MySQL事务和锁

    ## 锁

    ### InnoDB 中的锁类型

    * 标准行级锁

      * 排他锁（X Lock），允许事务删除或更新一行数据
      * 共享锁（S Lock），允许事务读一行数据
    * 表级意向锁

      * 意向排他锁（IX Lock），事务想要获取一张表中某几行的排他锁
      * 意向共享锁（IS Lock），事务想要获取一张表中某几行的共享锁

    ‍

    锁的兼容性

    ||IS|IX|S|X|
    | ----| --------| --------| --------| :------: |
    |IS|兼容|兼容|兼容|不兼容|
    |IX|兼容|兼容|不兼容|不兼容|
    |S|兼容|不兼容|兼容|不兼容|
    |X|不兼容|不兼容|不兼容|不兼容|

    兼容：指对同一个记录（row）锁的兼容性情况

    InnoDB支持的行级锁，所以意向锁不会阻塞除全表扫描以外的任何请求

    ### 一致性非锁定读

    > InnoDB通过MVCC（多版本控制）的方法读取当前值行时间数据库中行的数据
    >

    ‍

    ### 锁的算法

    #### 行锁三种算法

    * Record Lock：单个行记录上的锁
    * Gap Lock：间隙锁，锁定一个范围，但不包含记录本身（前开后闭）
    * Next-Key Lock（Record Lock + Gap Lock）：锁定一个范围，并且锁定记录本身

    #### 加锁规则

    > 两个“原则”、两个“优化”和一个“bug”：
    >

    * 原则 1：加锁的基本单位是 next-key lock。希望你还记得，next-key lock 是前开后闭区间。
    * 原则 2：查找过程中访问到的对象才会加锁。
    * 优化 1：索引上的等值查询，给唯一索引加锁的时候，next-key lock 退化为行锁（Record Lock）。
    * 优化 2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock 退化为间隙锁。
    * 一个 bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止。

    加锁规则案例[^2]

    **Read** **Committed 隔离级别下只使用Record Lock**

    **RepeaTable Read 隔离级别下使用Next-Key Lock**

    ### Phantom Problem （Next-Key Lock解决）

    > 同一个事务下，连续执行两次同样的SQL语句可能导致不同的结果，第二次的SQL语句可能返回之前不存在的行
    >

    根据加锁范围，MySQl里面的锁大致可以分为**全局锁**、**表级锁**和**行锁**

    ### 全局锁

    > 对整个数据实例加锁
    >

    * MySQL 提供了一个加全局读锁的方法，命令是 Flush tables with read lock (FTWRL)。当你需要让整个库处于只读状态的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。
    * 使用场景：全库逻辑备份
    * 官方自带的逻辑备份工具是 mysqldump。当 mysqldump 使用参数–single-transaction 的时候，导数据之前就会启动一个事务，来确保拿到一致性视图。而由于 MVCC 的支持，这个过程中数据是可以正常更新的。**single-transaction 方法只适用于所有的表使用事务引擎的库。**如果有的表使用了不支持事务的引擎，那么备份就只能通过 FTWRL 方法

    ### 表级锁

    > MySQL 里面表级别的锁有两种：一种是表锁，一种是元数据锁（meta data lock，MDL)。
    >

    #### 表锁的语法是 lock tables … read/write

    * 例子: 如果在某个线程 A 中执行 lock tables t1 read, t2 write; 这个语句，则其他线程写 t1、读写 t2 的语句都会被阻塞。同时，线程 A 在执行 unlock tables 之前，也只能执行读 t1、读写 t2 的操作。连写 t1 都不允许，自然也不能访问其他表。

    #### 类表级的锁是 MDL（metadata lock)

    * MDL 不需要显式使用，在访问一个表的时候会被自动加上。MDL 的作用是，保证读写的正确性。你可以想象一下，如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个表结构做变更，删了一列，那么查询线程拿到的结果跟表结构对不上，肯定是不行的。
    * 因此，在 MySQL 5.5 版本中引入了 MDL，当对一个表做增删改查操作的时候，加 MDL 读锁；当要对表做结构变更操作的时候，加 MDL 写锁。

    ## 事务

    ### 事务的实现

    * 锁实现事务的隔离性
    * 重做日志保证事务的持久性和原子性
    * 回滚日志保证事务的一致性

    #### Redo log（重做日志）

            InnoDB通过 Force Log as Commit 机制实现事务的持久性，即当事务提交（Commit）时，必须先将该事务的所有日志写入文件中进行持久化，待事务的Commit操作完成时才算完成 。使用 `Write-Ahead Logging(预写日志技术)`​

            Redo日志会把事务在执行过程 中对数据库所做的所有修改都记录下来，在之后系统奔溃重启后可以把事务所做的任何修改都恢复出来

       ![](assets/net-img-640-20230330194058-16epkoj.png)​

    ‍

    #### Undo log（回滚日志）

            事务的原子性是通过 undo log 实现的。在事务没提交之前，MySQL 会先记录更新前的数据到 undo log 日志文件里面，当事务回滚时，可以利用 undo log 来进行回滚。如下图：

    ![](assets/net-img-640-20230330193532-4safylx.png)

    ### 隐式提交的SQL语句

    ‍

    ‍

    ‍

    ## 相关问题

    * 快照是如何在MVCC 里是怎么工作的[^3]
    * 事务的可重复读的能力是怎么实现的[^4]
    * 全库只读，为什么不使用 set global readonly=true 的方式呢[^5]
    * Write-Ahead Logging[^6]
    * InnoDB 刷脏页的时机[^7]

    ‍


[^2]: # 加锁规则案例

    # 案例一：等值查询间隙锁

    第一个例子是关于等值条件操作间隙：

    ​![](assets/image-20230218230318-i0g5orx.png)​

    [图 1](siyuan://blocks/20230218230318-y5vi64g) 等值查询的间隙锁由于表 t 中没有 id=7 的记录，所以用我们上面提到的加锁规则判断一下的话：

    1. 根据原则 1，加锁单位是 next-key lock，session A 加锁范围就是 (5,10]；
    2. 同时根据优化 2，这是一个等值查询 (id=7)，而 id=10 不满足查询条件，next-key lock 退化成间隙锁，因此最终加锁的范围是 (5,10)。

    所以，session B 要往这个间隙里面插入 id=8 的记录会被锁住，但是 session C 修改 id=10 这行是可以的。

    # 案例二：非唯一索引等值锁

    第二个例子是关于覆盖索引上的锁：

    ​![](assets/image-20230218230318-ypt4n3t.png)​

    [图 2](siyuan://blocks/20230218230318-ba5oxwz) 只加在非唯一索引上的锁看到这个例子，你是不是有一种“该锁的不锁，不该锁的乱锁”的感觉？我们来分析一下吧。

    这里 session A 要给索引 c 上 c=5 的这一行加上读锁。

    1. 根据原则 1，加锁单位是 next-key lock，因此会给 (0,5] 加上 next-key lock。
    2. 要注意 c 是普通索引，因此仅访问 c=5 这一条记录是不能马上停下来的，需要向右遍历，查到 c=10 才放弃。根据原则 2，访问到的都要加锁，因此要给 (5,10] 加 next-key lock。
    3. 但是同时这个符合优化 2：等值判断，向右遍历，最后一个值不满足 c=5 这个等值条件，因此退化成间隙锁 (5,10)。
    4. 根据原则 2 ，**只有访问到的对象才会加锁**，这个查询使用覆盖索引，并不需要访问主键索引，所以主键索引上没有加任何锁，这就是为什么 session B 的 update 语句可以执行完成。

    但 session C 要插入一个 (7,7,7) 的记录，就会被 session A 的间隙锁 (5,10) 锁住。

    需要注意，在这个例子中，lock in share mode 只锁覆盖索引，但是如果是 for update 就不一样了。 执行 for update 时，系统会认为你接下来要更新数据，因此会顺便给主键索引上满足条件的行加上行锁。

    这个例子说明，锁是加在索引上的；同时，它给我们的指导是，如果你要用 lock in share mode 来给行加读锁避免数据被更新的话，就必须得绕过覆盖索引的优化，在查询字段中加入索引中不存在的字段。比如，将 session A 的查询语句改成 select d from t where c=5 lock in share mode。你可以自己验证一下效果。

    # 案例三：主键索引范围锁

    第三个例子是关于范围查询的。

    举例之前，你可以先思考一下这个问题：对于我们这个表 t，下面这两条查询语句，加锁范围相同吗？

    ```
    mysql> select * from t where id=10 for update;mysql> select * from t where id>=10 and id<11 for update;
    ```
    你可能会想，id 定义为 int 类型，这两个语句就是等价的吧？其实，它们并不完全等价。

    在逻辑上，这两条查语句肯定是等价的，但是它们的加锁规则不太一样。现在，我们就让 session A 执行第二个查询语句，来看看加锁效果。

    ​![](assets/image-20230218230318-t4i4y3l.png)​

    [图 3](siyuan://blocks/20230218230318-05n9zby) 主键索引上范围查询的锁现在我们就用前面提到的加锁规则，来分析一下 session A 会加什么锁呢？

    1. 开始执行的时候，要找到第一个 id=10 的行，因此本该是 next-key lock(5,10]。 根据优化 1， 主键 id 上的等值条件，退化成行锁，只加了 id=10 这一行的行锁。
    2. 范围查找就往后继续找，找到 id=15 这一行停下来，因此需要加 next-key lock(10,15]。

    所以，session A 这时候锁的范围就是主键索引上，行锁 id=10 和 next-key lock(10,15]。这样，session B 和 session C 的结果你就能理解了。

    这里你需要注意一点，首次 session A 定位查找 id=10 的行的时候，是当做等值查询来判断的，而向右扫描到 id=15 的时候，用的是范围查询判断。

    # 案例四：非唯一索引范围锁

    接下来，我们再看两个范围查询加锁的例子，你可以对照着案例三来看。

    需要注意的是，与案例三不同的是，案例四中查询语句的 where 部分用的是字段 c。

    ​![](assets/image-20230218230318-31t0a0v.png)​

    [图 4](siyuan://blocks/20230218230318-3ula5j1) 非唯一索引范围锁这次 session A 用字段 c 来判断，加锁规则跟案例三唯一的不同是：在第一次用 c=10 定位记录的时候，索引 c 上加了 (5,10] 这个 next-key lock 后，由于索引 c 是非唯一索引，没有优化规则，也就是说不会蜕变为行锁，因此最终 sesion A 加的锁是，索引 c 上的 (5,10] 和 (10,15] 这两个 next-key lock。

    所以从结果上来看，sesson B 要插入（8,8,8) 的这个 insert 语句时就被堵住了。

    这里需要扫描到 c=15 才停止扫描，是合理的，因为 InnoDB 要扫到 c=15，才知道不需要继续往后找了。

    # 案例五：唯一索引范围锁 bug

    前面的四个案例，我们已经用到了加锁规则中的两个原则和两个优化，接下来再看一个关于加锁规则中 bug 的案例。

    ​![](assets/image-20230218230318-t9tvsgp.png)​

    [图 5](siyuan://blocks/20230218230318-bk7nnpe) 唯一索引范围锁的 bugsession A 是一个范围查询，按照原则 1 的话，应该是索引 id 上只加 (10,15] 这个 next-key lock，并且因为 id 是唯一键，所以循环判断到 id=15 这一行就应该停止了。

    但是实现上，InnoDB 会往前扫描到第一个不满足条件的行为止，也就是 id=20。而且由于这是个范围扫描，因此索引 id 上的 (15,20] 这个 next-key lock 也会被锁上。

    所以你看到了，session B 要更新 id=20 这一行，是会被锁住的。同样地，session C 要插入 id=16 的一行，也会被锁住。

    照理说，这里锁住 id=20 这一行的行为，其实是没有必要的。因为扫描到 id=15，就可以确定不用往后再找了。但实现上还是这么做了，因此我认为这是个 bug。

    我也曾找社区的专家讨论过，官方 bug 系统上也有提到，但是并未被 verified。所以，认为这是 bug 这个事儿，也只能算我的一家之言，如果你有其他见解的话，也欢迎你提出来。

    # 案例六：非唯一索引上存在"等值"的例子

    接下来的例子，是为了更好地说明“间隙”这个概念。这里，我给表 t 插入一条新记录。

    ```
    mysql> insert into t values(30,10,30);
    ```
    新插入的这一行 c=10，也就是说现在表里有两个 c=10 的行。那么，这时候索引 c 上的间隙是什么状态了呢？你要知道，由于非唯一索引上包含主键的值，所以是不可能存在“相同”的两行的。

    ​![](assets/image-20230218230318-ybffha3.png)​

    [图 6](siyuan://blocks/20230218230318-yruadpb) 非唯一索引等值的例子可以看到，虽然有两个 c=10，但是它们的主键值 id 是不同的（分别是 10 和 30），因此这两个 c=10 的记录之间，也是有间隙的。

    图中我画出了索引 c 上的主键 id。为了跟间隙锁的开区间形式进行区别，我用 (c=10,id=30) 这样的形式，来表示索引上的一行。

    现在，我们来看一下案例六。

    这次我们用 delete 语句来验证。注意，delete 语句加锁的逻辑，其实跟 select ... for update 是类似的，也就是我在文章开始总结的两个“原则”、两个“优化”和一个“bug”。

    ​![](assets/image-20230218230318-cknlz85.png)​

    [图 7](siyuan://blocks/20230218230318-d4r2c4q) delete 示例这时，session A 在遍历的时候，先访问第一个 c=10 的记录。同样地，根据原则 1，这里加的是 (c=5,id=5) 到 (c=10,id=10) 这个 next-key lock。

    然后，session A 向右查找，直到碰到 (c=15,id=15) 这一行，循环才结束。根据优化 2，这是一个等值查询，向右查找到了不满足条件的行，所以会退化成 (c=10,id=10) 到 (c=15,id=15) 的间隙锁。

    也就是说，这个 delete 语句在索引 c 上的加锁范围，就是下图中蓝色区域覆盖的部分。  
    ​![](assets/image-20230218230318-w95qpr6.png)​

    [图 8](siyuan://blocks/20230218230318-9ezoh9l) delete 加锁效果示例这个蓝色区域左右两边都是虚线，表示开区间，即 (c=5,id=5) 和 (c=15,id=15) 这两行上都没有锁。

    # 案例七：limit 语句加锁

    例子 6 也有一个对照案例，场景如下所示：

    ​![](assets/image-20230218230318-0kn4aj5.png)​

    [图 9](siyuan://blocks/20230218230318-0g71n9s) limit 语句加锁这个例子里，session A 的 delete 语句加了 limit 2。你知道表 t 里 c=10 的记录其实只有两条，因此加不加 limit 2，删除的效果都是一样的，但是加锁的效果却不同。可以看到，session B 的 insert 语句执行通过了，跟案例六的结果不同。

    这是因为，案例七里的 delete 语句明确加了 limit 2 的限制，因此在遍历到 (c=10, id=30) 这一行之后，满足条件的语句已经有两条，循环就结束了。

    因此，索引 c 上的加锁范围就变成了从（c=5,id=5) 到（c=10,id=30) 这个前开后闭区间，如下图所示：  
    ​![](assets/image-20230218230318-ye9g47h.png)​

    [图 10](siyuan://blocks/20230218230318-emxelha) 带 limit 2 的加锁效果可以看到，(c=10,id=30）之后的这个间隙并没有在加锁范围里，因此 insert 语句插入 c=12 是可以执行成功的。

    这个例子对我们实践的指导意义就是，**在删除数据的时候尽量加 limit**。这样不仅可以控制删除数据的条数，让操作更安全，还可以减小加锁的范围。

    # 案例八：一个死锁的例子

    前面的例子中，我们在分析的时候，是按照 next-key lock 的逻辑来分析的，因为这样分析比较方便。最后我们再看一个案例，目的是说明：next-key lock 实际上是间隙锁和行锁加起来的结果。

    你一定会疑惑，这个概念不是一开始就说了吗？不要着急，我们先来看下面这个例子：

    ​![](assets/image-20230218230318-nedvesv.png)​

    [图 11](siyuan://blocks/20230218230318-rsa35uv) 案例八的操作序列现在，我们按时间顺序来分析一下为什么是这样的结果。

    1. session A 启动事务后执行查询语句加 lock in share mode，在索引 c 上加了 next-key lock(5,10] 和间隙锁 (10,15)；
    2. session B 的 update 语句也要在索引 c 上加 next-key lock(5,10] ，进入锁等待；
    3. 然后 session A 要再插入 (8,8,8) 这一行，被 session B 的间隙锁锁住。由于出现了死锁，InnoDB 让 session B 回滚。

    你可能会问，session B 的 next-key lock 不是还没申请成功吗？

    其实是这样的，session B 的“加 next-key lock(5,10] ”操作，实际上分成了两步，先是加 (5,10) 的间隙锁，加锁成功；然后加 c=10 的行锁，这时候才被锁住的。

    也就是说，我们在分析加锁规则的时候可以用 next-key lock 来分析。但是要知道，具体执行的时候，是要分成间隙锁和行锁两段来执行的。

    ‍


[^3]: ## 快照是如何在MVCC 里是怎么工作的

    * InnoDB 里面每个事务有一个唯一的事务 ID，叫作 transaction id。它是在事务开始的时候向 InnoDB 的事务系统申请的，是按申请顺序严格递增的。
    * 而每行数据也都是有多个版本的。每次事务更新数据的时候，都会生成一个新的数据版本，并且把 transaction id 赋值给这个数据版本的事务 ID，记为 row trx_id。同时，旧的数据版本要保留，并且在新的数据版本中，能够有信息可以直接拿到它。
    * 也就是说，数据表中的一行记录，其实可能有多个版本 (row)，每个版本有自己的 row trx_id。

    一个记录被多个事务连续更新后的状态。如下图  
    ​![下载.png](assets/net-img-1628905841173-c32bdb25-8b61-4f16-b08e-96898d7aeefc-20221031123444-2pva1h4.png)​

    * 图中虚线框里是同一行数据的 4 个版本，当前最新版本是 V4，k 的值是 22，它是被 transaction id 为 25 的事务更新的，因此它的 row trx_id 也是 25。图中的三个虚线箭头，就是 undo log；而 V1、V2、V3 并不是物理上真实存在的，而是每次需要的时候根据当前版本和 undo log 计算出来的。


[^4]: ## 事务的可重复读的能力是怎么实现的

    * 可重复读的核心就是一致性读（consistent read）；而事务更新数据的时候，只能用当前读。如果当前的记录的行锁被其他事务占用的话，就需要进入锁等待。
    * 而读提交的逻辑和可重复读的逻辑类似，它们最主要的区别是：

      * 在可重复读隔离级别下，只需要在事务开始的时候创建一致性视图，之后事务里的其他查询都共用这个一致性视图；
      * 在读提交隔离级别下，每一个语句执行前都会重新算出一个新的视图。

    > “start transaction with consistent snapshot; ”的意思是从这个语句开始，创建一个持续整个事务的一致性快照。所以，在读提交隔离级别下，这个用法就没意义了，等效于普通的 start transaction。
    >


[^5]: ## 全库只读，为什么不使用 set global readonly=true 的方式呢

    * 一是，在有些系统中，readonly 的值会被用来做其他逻辑，比如用来判断一个库是主库还是备库。因此，修改 global 变量的方式影响面更大，我不建议你使用。
    * 二是，在异常处理机制上有差异。如果执行 FTWRL 命令之后由于客户端发生异常断开，那么 MySQL 会自动释放这个全局锁，整个库回到可以正常更新的状态。而将整个库设置为 readonly 之后，如果客户端发生异常，则数据库就会一直保持 readonly 状态，这样会导致整个库长时间处于不可写状态，风险较高。


[^6]: ## Write-Ahead Logging

    我们修改某条记录，其实该记录并不是马上刷入磁盘的，而是将 Innodb 的 Buffer Pool  标记为脏页，等待后续的异步刷盘。

    Buffer Pool 是提高了读写效率没错，但是问题来了，Buffer Pool 是基于内存的，而内存总是不可靠，万一断电重启，还没来得及落盘的脏页数据就会丢失。

    为了防止断电导致数据丢失的问题，当有一条记录需要更新的时候，InnoDB 引擎就会先更新内存（同时标记为脏页），然后将本次对这个页的修改以 redo log 的形式记录下来，**这个时候更新就算完成了**。

    **MySQL 的写操作并不是立刻写到磁盘上，而是先写日志，然后在合适的时间再写到磁盘上**


[^7]: ## InnoDB 刷脏页的时机
